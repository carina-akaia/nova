var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/.pnpm/dexie@4.0.8/node_modules/dexie/dist/dexie.js
var require_dexie = __commonJS({
  "node_modules/.pnpm/dexie@4.0.8/node_modules/dexie/dist/dexie.js"(exports, module) {
    "use strict";
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Dexie = factory());
    })(exports, function() {
      "use strict";
      var extendStatics2 = function(d, b) {
        extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d2[p2] = b2[p2];
        };
        return extendStatics2(d, b);
      };
      function __extends2(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics2(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      }
      var __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s = arguments[i2];
            for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2)) t[p2] = s[p2];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      function __spreadArray2(to, from2, pack) {
        if (pack || arguments.length === 2) for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
        return to.concat(ar || Array.prototype.slice.call(from2));
      }
      var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
      var keys = Object.keys;
      var isArray3 = Array.isArray;
      if (typeof Promise !== "undefined" && !_global.Promise) {
        _global.Promise = Promise;
      }
      function extend(obj, extension) {
        if (typeof extension !== "object")
          return obj;
        keys(extension).forEach(function(key) {
          obj[key] = extension[key];
        });
        return obj;
      }
      var getProto = Object.getPrototypeOf;
      var _hasOwn = {}.hasOwnProperty;
      function hasOwn(obj, prop2) {
        return _hasOwn.call(obj, prop2);
      }
      function props(proto, extension) {
        if (typeof extension === "function")
          extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function(key) {
          setProp(proto, key, extension[key]);
        });
      }
      var defineProperty = Object.defineProperty;
      function setProp(obj, prop2, functionOrGetSet, options) {
        defineProperty(obj, prop2, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
      }
      function derive(Child) {
        return {
          from: function(Parent) {
            Child.prototype = Object.create(Parent.prototype);
            setProp(Child.prototype, "constructor", Child);
            return {
              extend: props.bind(null, Child.prototype)
            };
          }
        };
      }
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      function getPropertyDescriptor(obj, prop2) {
        var pd = getOwnPropertyDescriptor(obj, prop2);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop2);
      }
      var _slice = [].slice;
      function slice(args, start, end) {
        return _slice.call(args, start, end);
      }
      function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
      }
      function assert2(b) {
        if (!b)
          throw new Error("Assertion Failed");
      }
      function asap$1(fn) {
        if (_global.setImmediate)
          setImmediate(fn);
        else
          setTimeout(fn, 0);
      }
      function arrayToObject(array, extractor) {
        return array.reduce(function(result, item, i2) {
          var nameAndValue = extractor(item, i2);
          if (nameAndValue)
            result[nameAndValue[0]] = nameAndValue[1];
          return result;
        }, {});
      }
      function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string" && hasOwn(obj, keyPath))
          return obj[keyPath];
        if (!keyPath)
          return obj;
        if (typeof keyPath !== "string") {
          var rv = [];
          for (var i2 = 0, l = keyPath.length; i2 < l; ++i2) {
            var val = getByKeyPath(obj, keyPath[i2]);
            rv.push(val);
          }
          return rv;
        }
        var period = keyPath.indexOf(".");
        if (period !== -1) {
          var innerObj = obj[keyPath.substr(0, period)];
          return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return void 0;
      }
      function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === void 0)
          return;
        if ("isFrozen" in Object && Object.isFrozen(obj))
          return;
        if (typeof keyPath !== "string" && "length" in keyPath) {
          assert2(typeof value !== "string" && "length" in value);
          for (var i2 = 0, l = keyPath.length; i2 < l; ++i2) {
            setByKeyPath(obj, keyPath[i2], value[i2]);
          }
        } else {
          var period = keyPath.indexOf(".");
          if (period !== -1) {
            var currentKeyPath = keyPath.substr(0, period);
            var remainingKeyPath = keyPath.substr(period + 1);
            if (remainingKeyPath === "")
              if (value === void 0) {
                if (isArray3(obj) && !isNaN(parseInt(currentKeyPath)))
                  obj.splice(currentKeyPath, 1);
                else
                  delete obj[currentKeyPath];
              } else
                obj[currentKeyPath] = value;
            else {
              var innerObj = obj[currentKeyPath];
              if (!innerObj || !hasOwn(obj, currentKeyPath))
                innerObj = obj[currentKeyPath] = {};
              setByKeyPath(innerObj, remainingKeyPath, value);
            }
          } else {
            if (value === void 0) {
              if (isArray3(obj) && !isNaN(parseInt(keyPath)))
                obj.splice(keyPath, 1);
              else
                delete obj[keyPath];
            } else
              obj[keyPath] = value;
          }
        }
      }
      function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === "string")
          setByKeyPath(obj, keyPath, void 0);
        else if ("length" in keyPath)
          [].map.call(keyPath, function(kp) {
            setByKeyPath(obj, kp, void 0);
          });
      }
      function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
          if (hasOwn(obj, m))
            rv[m] = obj[m];
        }
        return rv;
      }
      var concat2 = [].concat;
      function flatten2(a2) {
        return concat2.apply([], a2);
      }
      var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten2([8, 16, 32, 64].map(function(num) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + num + "Array";
        });
      }))).filter(function(t) {
        return _global[t];
      });
      var intrinsicTypes = new Set(intrinsicTypeNames.map(function(t) {
        return _global[t];
      }));
      function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
          if (hasOwn(o, k)) {
            var v = o[k];
            rv[k] = !v || typeof v !== "object" || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
          }
        return rv;
      }
      function objectIsEmpty(o) {
        for (var k in o)
          if (hasOwn(o, k))
            return false;
        return true;
      }
      var circularRefs = null;
      function deepClone2(any) {
        circularRefs = /* @__PURE__ */ new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
      }
      function innerDeepClone(x2) {
        if (!x2 || typeof x2 !== "object")
          return x2;
        var rv = circularRefs.get(x2);
        if (rv)
          return rv;
        if (isArray3(x2)) {
          rv = [];
          circularRefs.set(x2, rv);
          for (var i2 = 0, l = x2.length; i2 < l; ++i2) {
            rv.push(innerDeepClone(x2[i2]));
          }
        } else if (intrinsicTypes.has(x2.constructor)) {
          rv = x2;
        } else {
          var proto = getProto(x2);
          rv = proto === Object.prototype ? {} : Object.create(proto);
          circularRefs.set(x2, rv);
          for (var prop2 in x2) {
            if (hasOwn(x2, prop2)) {
              rv[prop2] = innerDeepClone(x2[prop2]);
            }
          }
        }
        return rv;
      }
      var toString2 = {}.toString;
      function toStringTag(o) {
        return toString2.call(o).slice(8, -1);
      }
      var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
      var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x2) {
        var i2;
        return x2 != null && (i2 = x2[iteratorSymbol]) && i2.apply(x2);
      } : function() {
        return null;
      };
      function delArrayItem(a2, x2) {
        var i2 = a2.indexOf(x2);
        if (i2 >= 0)
          a2.splice(i2, 1);
        return i2 >= 0;
      }
      var NO_CHAR_ARRAY = {};
      function getArrayOf(arrayLike) {
        var i2, a2, x2, it;
        if (arguments.length === 1) {
          if (isArray3(arrayLike))
            return arrayLike.slice();
          if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
            return [arrayLike];
          if (it = getIteratorOf(arrayLike)) {
            a2 = [];
            while (x2 = it.next(), !x2.done)
              a2.push(x2.value);
            return a2;
          }
          if (arrayLike == null)
            return [arrayLike];
          i2 = arrayLike.length;
          if (typeof i2 === "number") {
            a2 = new Array(i2);
            while (i2--)
              a2[i2] = arrayLike[i2];
            return a2;
          }
          return [arrayLike];
        }
        i2 = arguments.length;
        a2 = new Array(i2);
        while (i2--)
          a2[i2] = arguments[i2];
        return a2;
      }
      var isAsyncFunction = typeof Symbol !== "undefined" ? function(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return false;
      };
      var dexieErrorNames = [
        "Modify",
        "Bulk",
        "OpenFailed",
        "VersionChange",
        "Schema",
        "Upgrade",
        "InvalidTable",
        "MissingAPI",
        "NoSuchDatabase",
        "InvalidArgument",
        "SubTransaction",
        "Unsupported",
        "Internal",
        "DatabaseClosed",
        "PrematureCommit",
        "ForeignAwait"
      ];
      var idbDomErrorNames = [
        "Unknown",
        "Constraint",
        "Data",
        "TransactionInactive",
        "ReadOnly",
        "Version",
        "NotFound",
        "InvalidState",
        "InvalidAccess",
        "Abort",
        "Timeout",
        "QuotaExceeded",
        "Syntax",
        "DataClone"
      ];
      var errorList = dexieErrorNames.concat(idbDomErrorNames);
      var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
      };
      function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
      }
      derive(DexieError).from(Error).extend({
        toString: function() {
          return this.name + ": " + this.message;
        }
      });
      function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures).map(function(key) {
          return failures[key].toString();
        }).filter(function(v, i2, s) {
          return s.indexOf(v) === i2;
        }).join("\n");
      }
      function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
      }
      derive(ModifyError).from(DexieError);
      function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function(pos) {
          return failures[pos];
        });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
      }
      derive(BulkError).from(DexieError);
      var errnames = errorList.reduce(function(obj, name) {
        return obj[name] = name + "Error", obj;
      }, {});
      var BaseException = DexieError;
      var exceptions = errorList.reduce(function(obj, name) {
        var fullName = name + "Error";
        function DexieError2(msgOrInner, inner) {
          this.name = fullName;
          if (!msgOrInner) {
            this.message = defaultTexts[name] || fullName;
            this.inner = null;
          } else if (typeof msgOrInner === "string") {
            this.message = "".concat(msgOrInner).concat(!inner ? "" : "\n " + inner);
            this.inner = inner || null;
          } else if (typeof msgOrInner === "object") {
            this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
            this.inner = msgOrInner;
          }
        }
        derive(DexieError2).from(BaseException);
        obj[name] = DexieError2;
        return obj;
      }, {});
      exceptions.Syntax = SyntaxError;
      exceptions.Type = TypeError;
      exceptions.Range = RangeError;
      var exceptionMap = idbDomErrorNames.reduce(function(obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
          return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
          setProp(rv, "stack", { get: function() {
            return this.inner.stack;
          } });
        }
        return rv;
      }
      var fullNameExceptions = errorList.reduce(function(obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
          obj[name + "Error"] = exceptions[name];
        return obj;
      }, {});
      fullNameExceptions.ModifyError = ModifyError;
      fullNameExceptions.DexieError = DexieError;
      fullNameExceptions.BulkError = BulkError;
      function nop() {
      }
      function mirror(val) {
        return val;
      }
      function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
          return f2;
        return function(val) {
          return f2(f1(val));
        };
      }
      function callBoth(on1, on2) {
        return function() {
          on1.apply(this, arguments);
          on2.apply(this, arguments);
        };
      }
      function hookCreatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res !== void 0)
            arguments[0] = res;
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res2 !== void 0 ? res2 : res;
        };
      }
      function hookDeletingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          f1.apply(this, arguments);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = this.onerror = null;
          f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
      }
      function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function(modifications) {
          var res = f1.apply(this, arguments);
          extend(modifications, res);
          var onsuccess = this.onsuccess, onerror = this.onerror;
          this.onsuccess = null;
          this.onerror = null;
          var res2 = f2.apply(this, arguments);
          if (onsuccess)
            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
          if (onerror)
            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
          return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
        };
      }
      function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          if (f2.apply(this, arguments) === false)
            return false;
          return f1.apply(this, arguments);
        };
      }
      function promisableChain(f1, f2) {
        if (f1 === nop)
          return f2;
        return function() {
          var res = f1.apply(this, arguments);
          if (res && typeof res.then === "function") {
            var thiz = this, i2 = arguments.length, args = new Array(i2);
            while (i2--)
              args[i2] = arguments[i2];
            return res.then(function() {
              return f2.apply(thiz, args);
            });
          }
          return f2.apply(this, arguments);
        };
      }
      var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function setDebug(value, filter2) {
        debug = value;
      }
      var INTERNAL = {};
      var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === "undefined" ? [] : function() {
        var globalP = Promise.resolve();
        if (typeof crypto === "undefined" || !crypto.subtle)
          return [globalP, getProto(globalP), globalP];
        var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [
          nativeP,
          getProto(nativeP),
          globalP
        ];
      }(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
      var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
      var patchGlobalPromise = !!resolvedGlobalPromise;
      function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
      }
      var asap = function(callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
          schedulePhysicalTick();
          needsNewPhysicalTick = false;
        }
      };
      var isOutsideMicroTick = true, needsNewPhysicalTick = true, unhandledErrors = [], rejectingErrors = [], rejectionMapper = mirror;
      var globalPSD = {
        id: "global",
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
      };
      var PSD = globalPSD;
      var microtickQueue = [];
      var numScheduledCalls = 0;
      var tickFinalizers = [];
      function DexiePromise(fn) {
        if (typeof this !== "object")
          throw new TypeError("Promises must be constructed via new");
        this._listeners = [];
        this._lib = false;
        var psd = this._PSD = PSD;
        if (typeof fn !== "function") {
          if (fn !== INTERNAL)
            throw new TypeError("Not a function");
          this._state = arguments[1];
          this._value = arguments[2];
          if (this._state === false)
            handleRejection(this, this._value);
          return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
      }
      var thenProp = {
        get: function() {
          var psd = PSD, microTaskId = totalEchoes;
          function then(onFulfilled, onRejected) {
            var _this = this;
            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
            var cleanup = possibleAwait && !decrementExpectedAwaits();
            var rv = new DexiePromise(function(resolve2, reject) {
              propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve2, reject, psd));
            });
            if (this._consoleTask)
              rv._consoleTask = this._consoleTask;
            return rv;
          }
          then.prototype = INTERNAL;
          return then;
        },
        set: function(value) {
          setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
            get: function() {
              return value;
            },
            set: thenProp.set
          });
        }
      };
      props(DexiePromise.prototype, {
        then: thenProp,
        _then: function(onFulfilled, onRejected) {
          propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function(onRejected) {
          if (arguments.length === 1)
            return this.then(null, onRejected);
          var type6 = arguments[0], handler = arguments[1];
          return typeof type6 === "function" ? this.then(null, function(err) {
            return err instanceof type6 ? handler(err) : PromiseReject(err);
          }) : this.then(null, function(err) {
            return err && err.name === type6 ? handler(err) : PromiseReject(err);
          });
        },
        finally: function(onFinally) {
          return this.then(function(value) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return value;
            });
          }, function(err) {
            return DexiePromise.resolve(onFinally()).then(function() {
              return PromiseReject(err);
            });
          });
        },
        timeout: function(ms, msg) {
          var _this = this;
          return ms < Infinity ? new DexiePromise(function(resolve2, reject) {
            var handle = setTimeout(function() {
              return reject(new exceptions.Timeout(msg));
            }, ms);
            _this.then(resolve2, reject).finally(clearTimeout.bind(null, handle));
          }) : this;
        }
      });
      if (typeof Symbol !== "undefined" && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
      globalPSD.env = snapShot();
      function Listener(onFulfilled, onRejected, resolve2, reject, zone) {
        this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
        this.onRejected = typeof onRejected === "function" ? onRejected : null;
        this.resolve = resolve2;
        this.reject = reject;
        this.psd = zone;
      }
      props(DexiePromise, {
        all: function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve2, reject) {
            if (values.length === 0)
              resolve2([]);
            var remaining = values.length;
            values.forEach(function(a2, i2) {
              return DexiePromise.resolve(a2).then(function(x2) {
                values[i2] = x2;
                if (!--remaining)
                  resolve2(values);
              }, reject);
            });
          });
        },
        resolve: function(value) {
          if (value instanceof DexiePromise)
            return value;
          if (value && typeof value.then === "function")
            return new DexiePromise(function(resolve2, reject) {
              value.then(resolve2, reject);
            });
          var rv = new DexiePromise(INTERNAL, true, value);
          return rv;
        },
        reject: PromiseReject,
        race: function() {
          var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
          return new DexiePromise(function(resolve2, reject) {
            values.map(function(value) {
              return DexiePromise.resolve(value).then(resolve2, reject);
            });
          });
        },
        PSD: {
          get: function() {
            return PSD;
          },
          set: function(value) {
            return PSD = value;
          }
        },
        totalEchoes: { get: function() {
          return totalEchoes;
        } },
        newPSD: newScope,
        usePSD,
        scheduler: {
          get: function() {
            return asap;
          },
          set: function(value) {
            asap = value;
          }
        },
        rejectionMapper: {
          get: function() {
            return rejectionMapper;
          },
          set: function(value) {
            rejectionMapper = value;
          }
        },
        follow: function(fn, zoneProps) {
          return new DexiePromise(function(resolve2, reject) {
            return newScope(function(resolve3, reject2) {
              var psd = PSD;
              psd.unhandleds = [];
              psd.onunhandled = reject2;
              psd.finalize = callBoth(function() {
                var _this = this;
                run_at_end_of_this_or_next_physical_tick(function() {
                  _this.unhandleds.length === 0 ? resolve3() : reject2(_this.unhandleds[0]);
                });
              }, psd.finalize);
              fn();
            }, zoneProps, resolve2, reject);
          });
        }
      });
      if (NativePromise) {
        if (NativePromise.allSettled)
          setProp(DexiePromise, "allSettled", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve2) {
              if (possiblePromises.length === 0)
                resolve2([]);
              var remaining = possiblePromises.length;
              var results = new Array(remaining);
              possiblePromises.forEach(function(p2, i2) {
                return DexiePromise.resolve(p2).then(function(value) {
                  return results[i2] = { status: "fulfilled", value };
                }, function(reason) {
                  return results[i2] = { status: "rejected", reason };
                }).then(function() {
                  return --remaining || resolve2(results);
                });
              });
            });
          });
        if (NativePromise.any && typeof AggregateError !== "undefined")
          setProp(DexiePromise, "any", function() {
            var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function(resolve2, reject) {
              if (possiblePromises.length === 0)
                reject(new AggregateError([]));
              var remaining = possiblePromises.length;
              var failures = new Array(remaining);
              possiblePromises.forEach(function(p2, i2) {
                return DexiePromise.resolve(p2).then(function(value) {
                  return resolve2(value);
                }, function(failure) {
                  failures[i2] = failure;
                  if (!--remaining)
                    reject(new AggregateError(failures));
                });
              });
            });
          });
      }
      function executePromiseTask(promise, fn) {
        try {
          fn(function(value) {
            if (promise._state !== null)
              return;
            if (value === promise)
              throw new TypeError("A promise cannot be resolved with itself.");
            var shouldExecuteTick = promise._lib && beginMicroTickScope();
            if (value && typeof value.then === "function") {
              executePromiseTask(promise, function(resolve2, reject) {
                value instanceof DexiePromise ? value._then(resolve2, reject) : value.then(resolve2, reject);
              });
            } else {
              promise._state = true;
              promise._value = value;
              propagateAllListeners(promise);
            }
            if (shouldExecuteTick)
              endMicroTickScope();
          }, handleRejection.bind(null, promise));
        } catch (ex) {
          handleRejection(promise, ex);
        }
      }
      function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
          return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
          endMicroTickScope();
      }
      function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i2 = 0, len = listeners.length; i2 < len; ++i2) {
          propagateToListener(promise, listeners[i2]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
          ++numScheduledCalls;
          asap(function() {
            if (--numScheduledCalls === 0)
              finalizePhysicalTick();
          }, []);
        }
      }
      function propagateToListener(promise, listener) {
        if (promise._state === null) {
          promise._listeners.push(listener);
          return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
          return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
      }
      function callListener(cb, promise, listener) {
        try {
          var ret, value = promise._value;
          if (!promise._state && rejectingErrors.length)
            rejectingErrors = [];
          ret = debug && promise._consoleTask ? promise._consoleTask.run(function() {
            return cb(value);
          }) : cb(value);
          if (!promise._state && rejectingErrors.indexOf(value) === -1) {
            markErrorAsHandled(promise);
          }
          listener.resolve(ret);
        } catch (e) {
          listener.reject(e);
        } finally {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
          --listener.psd.ref || listener.psd.finalize();
        }
      }
      function physicalTick() {
        usePSD(globalPSD, function() {
          beginMicroTickScope() && endMicroTickScope();
        });
      }
      function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
      }
      function endMicroTickScope() {
        var callbacks, i2, l;
        do {
          while (microtickQueue.length > 0) {
            callbacks = microtickQueue;
            microtickQueue = [];
            l = callbacks.length;
            for (i2 = 0; i2 < l; ++i2) {
              var item = callbacks[i2];
              item[0].apply(null, item[1]);
            }
          }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
      }
      function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function(p2) {
          p2._PSD.onunhandled.call(null, p2._value, p2);
        });
        var finalizers = tickFinalizers.slice(0);
        var i2 = finalizers.length;
        while (i2)
          finalizers[--i2]();
      }
      function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
          fn();
          tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(function() {
          if (--numScheduledCalls === 0)
            finalizePhysicalTick();
        }, []);
      }
      function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function(p2) {
          return p2._value === promise._value;
        }))
          unhandledErrors.push(promise);
      }
      function markErrorAsHandled(promise) {
        var i2 = unhandledErrors.length;
        while (i2)
          if (unhandledErrors[--i2]._value === promise._value) {
            unhandledErrors.splice(i2, 1);
            return;
          }
      }
      function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
      }
      function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function() {
          var wasRootExec = beginMicroTickScope(), outerScope = PSD;
          try {
            switchToZone(psd, true);
            return fn.apply(this, arguments);
          } catch (e) {
            errorCatcher && errorCatcher(e);
          } finally {
            switchToZone(outerScope, false);
            if (wasRootExec)
              endMicroTickScope();
          }
        };
      }
      var task = { awaits: 0, echoes: 0, id: 0 };
      var taskCounter = 0;
      var zoneStack = [];
      var zoneEchoes = 0;
      var totalEchoes = 0;
      var zone_id_counter = 0;
      function newScope(fn, props2, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
          Promise: DexiePromise,
          PromiseProp: { value: DexiePromise, configurable: true, writable: true },
          all: DexiePromise.all,
          race: DexiePromise.race,
          allSettled: DexiePromise.allSettled,
          any: DexiePromise.any,
          resolve: DexiePromise.resolve,
          reject: DexiePromise.reject
        } : {};
        if (props2)
          extend(psd, props2);
        ++parent.ref;
        psd.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
          psd.finalize();
        return rv;
      }
      function incrementExpectedAwaits() {
        if (!task.id)
          task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
      }
      function decrementExpectedAwaits() {
        if (!task.awaits)
          return false;
        if (--task.awaits === 0)
          task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
      }
      if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
      }
      function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
          incrementExpectedAwaits();
          return possiblePromise.then(function(x2) {
            decrementExpectedAwaits();
            return x2;
          }, function(e) {
            decrementExpectedAwaits();
            return rejection(e);
          });
        }
        return possiblePromise;
      }
      function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
          task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
      }
      function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
      }
      function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
          queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
          return;
        PSD = targetZone;
        if (currentZone === globalPSD)
          globalPSD.env = snapShot();
        if (patchGlobalPromise) {
          var GlobalPromise = globalPSD.env.Promise;
          var targetEnv = targetZone.env;
          if (currentZone.global || targetZone.global) {
            Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
            GlobalPromise.all = targetEnv.all;
            GlobalPromise.race = targetEnv.race;
            GlobalPromise.resolve = targetEnv.resolve;
            GlobalPromise.reject = targetEnv.reject;
            if (targetEnv.allSettled)
              GlobalPromise.allSettled = targetEnv.allSettled;
            if (targetEnv.any)
              GlobalPromise.any = targetEnv.any;
          }
        }
      }
      function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
          Promise: GlobalPromise,
          PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
          all: GlobalPromise.all,
          race: GlobalPromise.race,
          allSettled: GlobalPromise.allSettled,
          any: GlobalPromise.any,
          resolve: GlobalPromise.resolve,
          reject: GlobalPromise.reject
        } : {};
      }
      function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
          switchToZone(psd, true);
          return fn(a1, a2, a3);
        } finally {
          switchToZone(outerScope, false);
        }
      }
      function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== "function" ? fn : function() {
          var outerZone = PSD;
          if (possibleAwait)
            incrementExpectedAwaits();
          switchToZone(zone, true);
          try {
            return fn.apply(this, arguments);
          } finally {
            switchToZone(outerZone, false);
            if (cleanup)
              queueMicrotask(decrementExpectedAwaits);
          }
        };
      }
      function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
          if (zoneEchoes === 0) {
            cb();
          } else {
            enqueueNativeMicroTask(cb);
          }
        } else {
          setTimeout(cb, 0);
        }
      }
      var rejection = DexiePromise.reject;
      function tempTransaction(db2, mode, storeNames, fn) {
        if (!db2.idbdb || !db2._state.openComplete && (!PSD.letThrough && !db2._vip)) {
          if (db2._state.openComplete) {
            return rejection(new exceptions.DatabaseClosed(db2._state.dbOpenError));
          }
          if (!db2._state.isBeingOpened) {
            if (!db2._state.autoOpen)
              return rejection(new exceptions.DatabaseClosed());
            db2.open().catch(nop);
          }
          return db2._state.dbReadyPromise.then(function() {
            return tempTransaction(db2, mode, storeNames, fn);
          });
        } else {
          var trans = db2._createTransaction(mode, storeNames, db2._dbSchema);
          try {
            trans.create();
            db2._state.PR1398_maxLoop = 3;
          } catch (ex) {
            if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
              console.warn("Dexie: Need to reopen db");
              db2.close({ disableAutoOpen: false });
              return db2.open().then(function() {
                return tempTransaction(db2, mode, storeNames, fn);
              });
            }
            return rejection(ex);
          }
          return trans._promise(mode, function(resolve2, reject) {
            return newScope(function() {
              PSD.trans = trans;
              return fn(resolve2, reject, trans);
            });
          }).then(function(result) {
            if (mode === "readwrite")
              try {
                trans.idbtrans.commit();
              } catch (_a2) {
              }
            return mode === "readonly" ? result : trans._completion.then(function() {
              return result;
            });
          });
        }
      }
      var DEXIE_VERSION = "4.0.8";
      var maxString = String.fromCharCode(65535);
      var minKey = -Infinity;
      var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
      var STRING_EXPECTED = "String expected.";
      var connections = [];
      var DBNAMES_DB = "__dbnames";
      var READONLY = "readonly";
      var READWRITE = "readwrite";
      function combine(filter1, filter2) {
        return filter1 ? filter2 ? function() {
          return filter1.apply(this, arguments) && filter2.apply(this, arguments);
        } : filter1 : filter2;
      }
      var AnyRange = {
        type: 3,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
      };
      function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath) ? function(obj) {
          if (obj[keyPath] === void 0 && keyPath in obj) {
            obj = deepClone2(obj);
            delete obj[keyPath];
          }
          return obj;
        } : function(obj) {
          return obj;
        };
      }
      function Entity2() {
        throw exceptions.Type();
      }
      function cmp2(a2, b) {
        try {
          var ta = type5(a2);
          var tb = type5(b);
          if (ta !== tb) {
            if (ta === "Array")
              return 1;
            if (tb === "Array")
              return -1;
            if (ta === "binary")
              return 1;
            if (tb === "binary")
              return -1;
            if (ta === "string")
              return 1;
            if (tb === "string")
              return -1;
            if (ta === "Date")
              return 1;
            if (tb !== "Date")
              return NaN;
            return -1;
          }
          switch (ta) {
            case "number":
            case "Date":
            case "string":
              return a2 > b ? 1 : a2 < b ? -1 : 0;
            case "binary": {
              return compareUint8Arrays(getUint8Array(a2), getUint8Array(b));
            }
            case "Array":
              return compareArrays(a2, b);
          }
        } catch (_a2) {
        }
        return NaN;
      }
      function compareArrays(a2, b) {
        var al = a2.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i2 = 0; i2 < l; ++i2) {
          var res = cmp2(a2[i2], b[i2]);
          if (res !== 0)
            return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      function compareUint8Arrays(a2, b) {
        var al = a2.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i2 = 0; i2 < l; ++i2) {
          if (a2[i2] !== b[i2])
            return a2[i2] < b[i2] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
      }
      function type5(x2) {
        var t = typeof x2;
        if (t !== "object")
          return t;
        if (ArrayBuffer.isView(x2))
          return "binary";
        var tsTag = toStringTag(x2);
        return tsTag === "ArrayBuffer" ? "binary" : tsTag;
      }
      function getUint8Array(a2) {
        if (a2 instanceof Uint8Array)
          return a2;
        if (ArrayBuffer.isView(a2))
          return new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
        return new Uint8Array(a2);
      }
      var Table = function() {
        function Table2() {
        }
        Table2.prototype._trans = function(mode, fn, writeLocked) {
          var trans = this._tx || PSD.trans;
          var tableName = this.name;
          var task2 = debug && typeof console !== "undefined" && console.createTask && console.createTask("Dexie: ".concat(mode === "readonly" ? "read" : "write", " ").concat(this.name));
          function checkTableInTransaction(resolve2, reject, trans2) {
            if (!trans2.schema[tableName])
              throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            return fn(trans2.idbtrans, trans2);
          }
          var wasRootExec = beginMicroTickScope();
          try {
            var p2 = trans && trans.db._novip === this.db._novip ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(function() {
              return trans._promise(mode, checkTableInTransaction, writeLocked);
            }, { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
            if (task2) {
              p2._consoleTask = task2;
              p2 = p2.catch(function(err) {
                console.trace(err);
                return rejection(err);
              });
            }
            return p2;
          } finally {
            if (wasRootExec)
              endMicroTickScope();
          }
        };
        Table2.prototype.get = function(keyOrCrit, cb) {
          var _this = this;
          if (keyOrCrit && keyOrCrit.constructor === Object)
            return this.where(keyOrCrit).first(cb);
          if (keyOrCrit == null)
            return rejection(new exceptions.Type("Invalid argument to Table.get()"));
          return this._trans("readonly", function(trans) {
            return _this.core.get({ trans, key: keyOrCrit }).then(function(res) {
              return _this.hook.reading.fire(res);
            });
          }).then(cb);
        };
        Table2.prototype.where = function(indexOrCrit) {
          if (typeof indexOrCrit === "string")
            return new this.db.WhereClause(this, indexOrCrit);
          if (isArray3(indexOrCrit))
            return new this.db.WhereClause(this, "[".concat(indexOrCrit.join("+"), "]"));
          var keyPaths = keys(indexOrCrit);
          if (keyPaths.length === 1)
            return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
          var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function(ix) {
            if (ix.compound && keyPaths.every(function(keyPath) {
              return ix.keyPath.indexOf(keyPath) >= 0;
            })) {
              for (var i2 = 0; i2 < keyPaths.length; ++i2) {
                if (keyPaths.indexOf(ix.keyPath[i2]) === -1)
                  return false;
              }
              return true;
            }
            return false;
          }).sort(function(a2, b) {
            return a2.keyPath.length - b.keyPath.length;
          })[0];
          if (compoundIndex && this.db._maxKey !== maxString) {
            var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
            return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map(function(kp) {
              return indexOrCrit[kp];
            }));
          }
          if (!compoundIndex && debug)
            console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(keyPaths.join("+"), "]"));
          var idxByName = this.schema.idxByName;
          var idb = this.db._deps.indexedDB;
          function equals3(a2, b) {
            return idb.cmp(a2, b) === 0;
          }
          var _a2 = keyPaths.reduce(function(_a3, keyPath) {
            var prevIndex = _a3[0], prevFilterFn = _a3[1];
            var index2 = idxByName[keyPath];
            var value = indexOrCrit[keyPath];
            return [
              prevIndex || index2,
              prevIndex || !index2 ? combine(prevFilterFn, index2 && index2.multi ? function(x2) {
                var prop2 = getByKeyPath(x2, keyPath);
                return isArray3(prop2) && prop2.some(function(item) {
                  return equals3(value, item);
                });
              } : function(x2) {
                return equals3(value, getByKeyPath(x2, keyPath));
              }) : prevFilterFn
            ];
          }, [null, null]), idx = _a2[0], filterFunction = _a2[1];
          return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
        };
        Table2.prototype.filter = function(filterFunction) {
          return this.toCollection().and(filterFunction);
        };
        Table2.prototype.count = function(thenShortcut) {
          return this.toCollection().count(thenShortcut);
        };
        Table2.prototype.offset = function(offset) {
          return this.toCollection().offset(offset);
        };
        Table2.prototype.limit = function(numRows) {
          return this.toCollection().limit(numRows);
        };
        Table2.prototype.each = function(callback) {
          return this.toCollection().each(callback);
        };
        Table2.prototype.toArray = function(thenShortcut) {
          return this.toCollection().toArray(thenShortcut);
        };
        Table2.prototype.toCollection = function() {
          return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table2.prototype.orderBy = function(index2) {
          return new this.db.Collection(new this.db.WhereClause(this, isArray3(index2) ? "[".concat(index2.join("+"), "]") : index2));
        };
        Table2.prototype.reverse = function() {
          return this.toCollection().reverse();
        };
        Table2.prototype.mapToClass = function(constructor) {
          var _a2 = this, db2 = _a2.db, tableName = _a2.name;
          this.schema.mappedClass = constructor;
          if (constructor.prototype instanceof Entity2) {
            constructor = function(_super) {
              __extends2(class_1, _super);
              function class_1() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              Object.defineProperty(class_1.prototype, "db", {
                get: function() {
                  return db2;
                },
                enumerable: false,
                configurable: true
              });
              class_1.prototype.table = function() {
                return tableName;
              };
              return class_1;
            }(constructor);
          }
          var inheritedProps = /* @__PURE__ */ new Set();
          for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
            Object.getOwnPropertyNames(proto).forEach(function(propName) {
              return inheritedProps.add(propName);
            });
          }
          var readHook = function(obj) {
            if (!obj)
              return obj;
            var res = Object.create(constructor.prototype);
            for (var m in obj)
              if (!inheritedProps.has(m))
                try {
                  res[m] = obj[m];
                } catch (_) {
                }
            return res;
          };
          if (this.schema.readHook) {
            this.hook.reading.unsubscribe(this.schema.readHook);
          }
          this.schema.readHook = readHook;
          this.hook("reading", readHook);
          return constructor;
        };
        Table2.prototype.defineClass = function() {
          function Class(content) {
            extend(this, content);
          }
          return this.mapToClass(Class);
        };
        Table2.prototype.add = function(obj, key) {
          var _this = this;
          var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.update = function(keyOrObject, modifications) {
          if (typeof keyOrObject === "object" && !isArray3(keyOrObject)) {
            var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
            if (key === void 0)
              return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
            return this.where(":id").equals(key).modify(modifications);
          } else {
            return this.where(":id").equals(keyOrObject).modify(modifications);
          }
        };
        Table2.prototype.put = function(obj, key) {
          var _this = this;
          var _a2 = this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
          var objToAdd = obj;
          if (keyPath && auto) {
            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
          }
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult;
          }).then(function(lastResult) {
            if (keyPath) {
              try {
                setByKeyPath(obj, keyPath, lastResult);
              } catch (_) {
              }
            }
            return lastResult;
          });
        };
        Table2.prototype.delete = function(key) {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: [key] });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.clear = function() {
          var _this = this;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "deleteRange", range: AnyRange });
          }).then(function(res) {
            return res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0;
          });
        };
        Table2.prototype.bulkGet = function(keys2) {
          var _this = this;
          return this._trans("readonly", function(trans) {
            return _this.core.getMany({
              keys: keys2,
              trans
            }).then(function(result) {
              return result.map(function(res) {
                return _this.hook.reading.fire(res);
              });
            });
          });
        };
        Table2.prototype.bulkAdd = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys2 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            if (keyPath && keys2)
              throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
            if (keys2 && keys2.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "add", keys: keys2, values: objectsToAdd, wantResults }).then(function(_a3) {
              var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkPut = function(objects, keysOrOptions, options) {
          var _this = this;
          var keys2 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
          options = options || (keys2 ? void 0 : keysOrOptions);
          var wantResults = options ? options.allKeys : void 0;
          return this._trans("readwrite", function(trans) {
            var _a2 = _this.schema.primKey, auto = _a2.auto, keyPath = _a2.keyPath;
            if (keyPath && keys2)
              throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
            if (keys2 && keys2.length !== objects.length)
              throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
            var numObjects = objects.length;
            var objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
            return _this.core.mutate({ trans, type: "put", keys: keys2, values: objectsToPut, wantResults }).then(function(_a3) {
              var numFailures = _a3.numFailures, results = _a3.results, lastResult = _a3.lastResult, failures = _a3.failures;
              var result = wantResults ? results : lastResult;
              if (numFailures === 0)
                return result;
              throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
            });
          });
        };
        Table2.prototype.bulkUpdate = function(keysAndChanges) {
          var _this = this;
          var coreTable = this.core;
          var keys2 = keysAndChanges.map(function(entry) {
            return entry.key;
          });
          var changeSpecs = keysAndChanges.map(function(entry) {
            return entry.changes;
          });
          var offsetMap = [];
          return this._trans("readwrite", function(trans) {
            return coreTable.getMany({ trans, keys: keys2, cache: "clone" }).then(function(objs) {
              var resultKeys = [];
              var resultObjs = [];
              keysAndChanges.forEach(function(_a2, idx) {
                var key = _a2.key, changes = _a2.changes;
                var obj = objs[idx];
                if (obj) {
                  for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                    var keyPath = _b[_i];
                    var value = changes[keyPath];
                    if (keyPath === _this.schema.primKey.keyPath) {
                      if (cmp2(value, key) !== 0) {
                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                      }
                    } else {
                      setByKeyPath(obj, keyPath, value);
                    }
                  }
                  offsetMap.push(idx);
                  resultKeys.push(key);
                  resultObjs.push(obj);
                }
              });
              var numEntries = resultKeys.length;
              return coreTable.mutate({
                trans,
                type: "put",
                keys: resultKeys,
                values: resultObjs,
                updates: {
                  keys: keys2,
                  changeSpecs
                }
              }).then(function(_a2) {
                var numFailures = _a2.numFailures, failures = _a2.failures;
                if (numFailures === 0)
                  return numEntries;
                for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                  var offset = _b[_i];
                  var mappedOffset = offsetMap[Number(offset)];
                  if (mappedOffset != null) {
                    var failure = failures[offset];
                    delete failures[offset];
                    failures[mappedOffset] = failure;
                  }
                }
                throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
              });
            });
          });
        };
        Table2.prototype.bulkDelete = function(keys2) {
          var _this = this;
          var numKeys = keys2.length;
          return this._trans("readwrite", function(trans) {
            return _this.core.mutate({ trans, type: "delete", keys: keys2 });
          }).then(function(_a2) {
            var numFailures = _a2.numFailures, lastResult = _a2.lastResult, failures = _a2.failures;
            if (numFailures === 0)
              return lastResult;
            throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
          });
        };
        return Table2;
      }();
      function Events(ctx) {
        var evs = {};
        var rv = function(eventName, subscriber) {
          if (subscriber) {
            var i3 = arguments.length, args = new Array(i3 - 1);
            while (--i3)
              args[i3 - 1] = arguments[i3];
            evs[eventName].subscribe.apply(null, args);
            return ctx;
          } else if (typeof eventName === "string") {
            return evs[eventName];
          }
        };
        rv.addEventType = add3;
        for (var i2 = 1, l = arguments.length; i2 < l; ++i2) {
          add3(arguments[i2]);
        }
        return rv;
        function add3(eventName, chainFunction, defaultFunction) {
          if (typeof eventName === "object")
            return addConfiguredEvents(eventName);
          if (!chainFunction)
            chainFunction = reverseStoppableEventChain;
          if (!defaultFunction)
            defaultFunction = nop;
          var context2 = {
            subscribers: [],
            fire: defaultFunction,
            subscribe: function(cb) {
              if (context2.subscribers.indexOf(cb) === -1) {
                context2.subscribers.push(cb);
                context2.fire = chainFunction(context2.fire, cb);
              }
            },
            unsubscribe: function(cb) {
              context2.subscribers = context2.subscribers.filter(function(fn) {
                return fn !== cb;
              });
              context2.fire = context2.subscribers.reduce(chainFunction, defaultFunction);
            }
          };
          evs[eventName] = rv[eventName] = context2;
          return context2;
        }
        function addConfiguredEvents(cfg) {
          keys(cfg).forEach(function(eventName) {
            var args = cfg[eventName];
            if (isArray3(args)) {
              add3(eventName, cfg[eventName][0], cfg[eventName][1]);
            } else if (args === "asap") {
              var context2 = add3(eventName, mirror, function fire() {
                var i3 = arguments.length, args2 = new Array(i3);
                while (i3--)
                  args2[i3] = arguments[i3];
                context2.subscribers.forEach(function(fn) {
                  asap$1(function fireEvent() {
                    fn.apply(null, args2);
                  });
                });
              });
            } else
              throw new exceptions.InvalidArgument("Invalid event config");
          });
        }
      }
      function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype });
        return constructor;
      }
      function createTableConstructor(db2) {
        return makeClassConstructor(Table.prototype, function Table2(name, tableSchema, trans) {
          this.db = db2;
          this._tx = trans;
          this.name = name;
          this.schema = tableSchema;
          this.hook = db2._allTables[name] ? db2._allTables[name].hook : Events(null, {
            "creating": [hookCreatingChain, nop],
            "reading": [pureFunctionChain, mirror],
            "updating": [hookUpdatingChain, nop],
            "deleting": [hookDeletingChain, nop]
          });
        });
      }
      function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
      }
      function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
      }
      function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function() {
          return combine(curr(), factory());
        } : factory;
        ctx.justLimit = isLimitFilter && !curr;
      }
      function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
      }
      function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
          return coreSchema.primaryKey;
        var index2 = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index2)
          throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index2;
      }
      function openCursor(ctx, coreTable, trans) {
        var index2 = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
          trans,
          values: !ctx.keysOnly,
          reverse: ctx.dir === "prev",
          unique: !!ctx.unique,
          query: {
            index: index2,
            range: ctx.range
          }
        });
      }
      function iter(ctx, fn, coreTrans, coreTable) {
        var filter2 = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
          return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter2), fn, !ctx.keysOnly && ctx.valueMapper);
        } else {
          var set_1 = {};
          var union = function(item, cursor, advance) {
            if (!filter2 || filter2(cursor, advance, function(result) {
              return cursor.stop(result);
            }, function(err) {
              return cursor.fail(err);
            })) {
              var primaryKey = cursor.primaryKey;
              var key = "" + primaryKey;
              if (key === "[object ArrayBuffer]")
                key = "" + new Uint8Array(primaryKey);
              if (!hasOwn(set_1, key)) {
                set_1[key] = true;
                fn(item, cursor, advance);
              }
            }
          };
          return Promise.all([
            ctx.or._iterate(union, coreTrans),
            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
          ]);
        }
      }
      function iterate(cursorPromise, filter2, fn, valueMapper) {
        var mappedFn = valueMapper ? function(x2, c, a2) {
          return fn(valueMapper(x2), c, a2);
        } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function(cursor) {
          if (cursor) {
            return cursor.start(function() {
              var c = function() {
                return cursor.continue();
              };
              if (!filter2 || filter2(cursor, function(advancer) {
                return c = advancer;
              }, function(val) {
                cursor.stop(val);
                c = nop;
              }, function(e) {
                cursor.fail(e);
                c = nop;
              }))
                wrappedFn(cursor.value, cursor, function(advancer) {
                  return c = advancer;
                });
              c();
            });
          }
        });
      }
      var PropModSymbol2 = Symbol();
      var PropModification2 = function() {
        function PropModification3(spec) {
          Object.assign(this, spec);
        }
        PropModification3.prototype.execute = function(value) {
          var _a2;
          if (this.add !== void 0) {
            var term = this.add;
            if (isArray3(term)) {
              return __spreadArray2(__spreadArray2([], isArray3(value) ? value : [], true), term, true).sort();
            }
            if (typeof term === "number")
              return (Number(value) || 0) + term;
            if (typeof term === "bigint") {
              try {
                return BigInt(value) + term;
              } catch (_b) {
                return BigInt(0) + term;
              }
            }
            throw new TypeError("Invalid term ".concat(term));
          }
          if (this.remove !== void 0) {
            var subtrahend_1 = this.remove;
            if (isArray3(subtrahend_1)) {
              return isArray3(value) ? value.filter(function(item) {
                return !subtrahend_1.includes(item);
              }).sort() : [];
            }
            if (typeof subtrahend_1 === "number")
              return Number(value) - subtrahend_1;
            if (typeof subtrahend_1 === "bigint") {
              try {
                return BigInt(value) - subtrahend_1;
              } catch (_c) {
                return BigInt(0) - subtrahend_1;
              }
            }
            throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
          }
          var prefixToReplace = (_a2 = this.replacePrefix) === null || _a2 === void 0 ? void 0 : _a2[0];
          if (prefixToReplace && typeof value === "string" && value.startsWith(prefixToReplace)) {
            return this.replacePrefix[1] + value.substring(prefixToReplace.length);
          }
          return value;
        };
        return PropModification3;
      }();
      var Collection = function() {
        function Collection2() {
        }
        Collection2.prototype._read = function(fn, cb) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
        };
        Collection2.prototype._write = function(fn) {
          var ctx = this._ctx;
          return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
        };
        Collection2.prototype._addAlgorithm = function(fn) {
          var ctx = this._ctx;
          ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection2.prototype._iterate = function(fn, coreTrans) {
          return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection2.prototype.clone = function(props2) {
          var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
          if (props2)
            extend(ctx, props2);
          rv._ctx = ctx;
          return rv;
        };
        Collection2.prototype.raw = function() {
          this._ctx.valueMapper = null;
          return this;
        };
        Collection2.prototype.each = function(fn) {
          var ctx = this._ctx;
          return this._read(function(trans) {
            return iter(ctx, fn, trans, ctx.table.core);
          });
        };
        Collection2.prototype.count = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            var coreTable = ctx.table.core;
            if (isPlainKeyRange(ctx, true)) {
              return coreTable.count({
                trans,
                query: {
                  index: getIndexOrStore(ctx, coreTable.schema),
                  range: ctx.range
                }
              }).then(function(count2) {
                return Math.min(count2, ctx.limit);
              });
            } else {
              var count = 0;
              return iter(ctx, function() {
                ++count;
                return false;
              }, trans, coreTable).then(function() {
                return count;
              });
            }
          }).then(cb);
        };
        Collection2.prototype.sortBy = function(keyPath, cb) {
          var parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
          function getval(obj, i2) {
            if (i2)
              return getval(obj[parts[i2]], i2 - 1);
            return obj[lastPart];
          }
          var order = this._ctx.dir === "next" ? 1 : -1;
          function sorter(a2, b) {
            var aVal = getval(a2, lastIndex), bVal = getval(b, lastIndex);
            return aVal < bVal ? -order : aVal > bVal ? order : 0;
          }
          return this.toArray(function(a2) {
            return a2.sort(sorter);
          }).then(cb);
        };
        Collection2.prototype.toArray = function(cb) {
          var _this = this;
          return this._read(function(trans) {
            var ctx = _this._ctx;
            if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
              var valueMapper_1 = ctx.valueMapper;
              var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                limit: ctx.limit,
                values: true,
                query: {
                  index: index2,
                  range: ctx.range
                }
              }).then(function(_a2) {
                var result = _a2.result;
                return valueMapper_1 ? result.map(valueMapper_1) : result;
              });
            } else {
              var a_1 = [];
              return iter(ctx, function(item) {
                return a_1.push(item);
              }, trans, ctx.table.core).then(function() {
                return a_1;
              });
            }
          }, cb);
        };
        Collection2.prototype.offset = function(offset) {
          var ctx = this._ctx;
          if (offset <= 0)
            return this;
          ctx.offset += offset;
          if (isPlainKeyRange(ctx)) {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function(cursor, advance) {
                if (offsetLeft === 0)
                  return true;
                if (offsetLeft === 1) {
                  --offsetLeft;
                  return false;
                }
                advance(function() {
                  cursor.advance(offsetLeft);
                  offsetLeft = 0;
                });
                return false;
              };
            });
          } else {
            addReplayFilter(ctx, function() {
              var offsetLeft = offset;
              return function() {
                return --offsetLeft < 0;
              };
            });
          }
          return this;
        };
        Collection2.prototype.limit = function(numRows) {
          this._ctx.limit = Math.min(this._ctx.limit, numRows);
          addReplayFilter(this._ctx, function() {
            var rowsLeft = numRows;
            return function(cursor, advance, resolve2) {
              if (--rowsLeft <= 0)
                advance(resolve2);
              return rowsLeft >= 0;
            };
          }, true);
          return this;
        };
        Collection2.prototype.until = function(filterFunction, bIncludeStopEntry) {
          addFilter(this._ctx, function(cursor, advance, resolve2) {
            if (filterFunction(cursor.value)) {
              advance(resolve2);
              return bIncludeStopEntry;
            } else {
              return true;
            }
          });
          return this;
        };
        Collection2.prototype.first = function(cb) {
          return this.limit(1).toArray(function(a2) {
            return a2[0];
          }).then(cb);
        };
        Collection2.prototype.last = function(cb) {
          return this.reverse().first(cb);
        };
        Collection2.prototype.filter = function(filterFunction) {
          addFilter(this._ctx, function(cursor) {
            return filterFunction(cursor.value);
          });
          addMatchFilter(this._ctx, filterFunction);
          return this;
        };
        Collection2.prototype.and = function(filter2) {
          return this.filter(filter2);
        };
        Collection2.prototype.or = function(indexName) {
          return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection2.prototype.reverse = function() {
          this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
          if (this._ondirectionchange)
            this._ondirectionchange(this._ctx.dir);
          return this;
        };
        Collection2.prototype.desc = function() {
          return this.reverse();
        };
        Collection2.prototype.eachKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.key, cursor);
          });
        };
        Collection2.prototype.eachUniqueKey = function(cb) {
          this._ctx.unique = "unique";
          return this.eachKey(cb);
        };
        Collection2.prototype.eachPrimaryKey = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          return this.each(function(val, cursor) {
            cb(cursor.primaryKey, cursor);
          });
        };
        Collection2.prototype.keys = function(cb) {
          var ctx = this._ctx;
          ctx.keysOnly = !ctx.isMatch;
          var a2 = [];
          return this.each(function(item, cursor) {
            a2.push(cursor.key);
          }).then(function() {
            return a2;
          }).then(cb);
        };
        Collection2.prototype.primaryKeys = function(cb) {
          var ctx = this._ctx;
          if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
            return this._read(function(trans) {
              var index2 = getIndexOrStore(ctx, ctx.table.core.schema);
              return ctx.table.core.query({
                trans,
                values: false,
                limit: ctx.limit,
                query: {
                  index: index2,
                  range: ctx.range
                }
              });
            }).then(function(_a2) {
              var result = _a2.result;
              return result;
            }).then(cb);
          }
          ctx.keysOnly = !ctx.isMatch;
          var a2 = [];
          return this.each(function(item, cursor) {
            a2.push(cursor.primaryKey);
          }).then(function() {
            return a2;
          }).then(cb);
        };
        Collection2.prototype.uniqueKeys = function(cb) {
          this._ctx.unique = "unique";
          return this.keys(cb);
        };
        Collection2.prototype.firstKey = function(cb) {
          return this.limit(1).keys(function(a2) {
            return a2[0];
          }).then(cb);
        };
        Collection2.prototype.lastKey = function(cb) {
          return this.reverse().firstKey(cb);
        };
        Collection2.prototype.distinct = function() {
          var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
          if (!idx || !idx.multi)
            return this;
          var set2 = {};
          addFilter(this._ctx, function(cursor) {
            var strKey = cursor.primaryKey.toString();
            var found = hasOwn(set2, strKey);
            set2[strKey] = true;
            return !found;
          });
          return this;
        };
        Collection2.prototype.modify = function(changes) {
          var _this = this;
          var ctx = this._ctx;
          return this._write(function(trans) {
            var modifyer;
            if (typeof changes === "function") {
              modifyer = changes;
            } else {
              var keyPaths = keys(changes);
              var numKeys = keyPaths.length;
              modifyer = function(item) {
                var anythingModified = false;
                for (var i2 = 0; i2 < numKeys; ++i2) {
                  var keyPath = keyPaths[i2];
                  var val = changes[keyPath];
                  var origVal = getByKeyPath(item, keyPath);
                  if (val instanceof PropModification2) {
                    setByKeyPath(item, keyPath, val.execute(origVal));
                    anythingModified = true;
                  } else if (origVal !== val) {
                    setByKeyPath(item, keyPath, val);
                    anythingModified = true;
                  }
                }
                return anythingModified;
              };
            }
            var coreTable = ctx.table.core;
            var _a2 = coreTable.schema.primaryKey, outbound = _a2.outbound, extractKey = _a2.extractKey;
            var limit = _this.db._options.modifyChunkSize || 200;
            var totalFailures = [];
            var successCount = 0;
            var failedKeys = [];
            var applyMutateResult = function(expectedCount, res) {
              var failures = res.failures, numFailures = res.numFailures;
              successCount += expectedCount - numFailures;
              for (var _i = 0, _a3 = keys(failures); _i < _a3.length; _i++) {
                var pos = _a3[_i];
                totalFailures.push(failures[pos]);
              }
            };
            return _this.clone().primaryKeys().then(function(keys2) {
              var criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
                index: ctx.index,
                range: ctx.range
              };
              var nextChunk = function(offset) {
                var count = Math.min(limit, keys2.length - offset);
                return coreTable.getMany({
                  trans,
                  keys: keys2.slice(offset, offset + count),
                  cache: "immutable"
                }).then(function(values) {
                  var addValues = [];
                  var putValues = [];
                  var putKeys = outbound ? [] : null;
                  var deleteKeys = [];
                  for (var i2 = 0; i2 < count; ++i2) {
                    var origValue = values[i2];
                    var ctx_1 = {
                      value: deepClone2(origValue),
                      primKey: keys2[offset + i2]
                    };
                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                      if (ctx_1.value == null) {
                        deleteKeys.push(keys2[offset + i2]);
                      } else if (!outbound && cmp2(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                        deleteKeys.push(keys2[offset + i2]);
                        addValues.push(ctx_1.value);
                      } else {
                        putValues.push(ctx_1.value);
                        if (outbound)
                          putKeys.push(keys2[offset + i2]);
                      }
                    }
                  }
                  return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then(function(res) {
                    for (var pos in res.failures) {
                      deleteKeys.splice(parseInt(pos), 1);
                    }
                    applyMutateResult(addValues.length, res);
                  })).then(function() {
                    return (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
                      trans,
                      type: "put",
                      keys: putKeys,
                      values: putValues,
                      criteria,
                      changeSpec: typeof changes !== "function" && changes,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(putValues.length, res);
                    });
                  }).then(function() {
                    return (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
                      trans,
                      type: "delete",
                      keys: deleteKeys,
                      criteria,
                      isAdditionalChunk: offset > 0
                    }).then(function(res) {
                      return applyMutateResult(deleteKeys.length, res);
                    });
                  }).then(function() {
                    return keys2.length > offset + count && nextChunk(offset + limit);
                  });
                });
              };
              return nextChunk(0).then(function() {
                if (totalFailures.length > 0)
                  throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                return keys2.length;
              });
            });
          });
        };
        Collection2.prototype.delete = function() {
          var ctx = this._ctx, range = ctx.range;
          if (isPlainKeyRange(ctx) && (ctx.isPrimKey || range.type === 3)) {
            return this._write(function(trans) {
              var primaryKey = ctx.table.core.schema.primaryKey;
              var coreRange = range;
              return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(function(count) {
                return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(function(_a2) {
                  var failures = _a2.failures;
                  _a2.lastResult;
                  _a2.results;
                  var numFailures = _a2.numFailures;
                  if (numFailures)
                    throw new ModifyError("Could not delete some values", Object.keys(failures).map(function(pos) {
                      return failures[pos];
                    }), count - numFailures);
                  return count - numFailures;
                });
              });
            });
          }
          return this.modify(deleteCallback);
        };
        return Collection2;
      }();
      var deleteCallback = function(value, ctx) {
        return ctx.value = null;
      };
      function createCollectionConstructor(db2) {
        return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
          this.db = db2;
          var keyRange = AnyRange, error = null;
          if (keyRangeGenerator)
            try {
              keyRange = keyRangeGenerator();
            } catch (ex) {
              error = ex;
            }
          var whereCtx = whereClause._ctx;
          var table = whereCtx.table;
          var readingHook = table.hook.reading.fire;
          this._ctx = {
            table,
            index: whereCtx.index,
            isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
            range: keyRange,
            keysOnly: false,
            dir: "next",
            unique: "",
            algorithm: null,
            filter: null,
            replayFilter: null,
            justLimit: true,
            isMatch: null,
            offset: 0,
            limit: Infinity,
            error,
            or: whereCtx.or,
            valueMapper: readingHook !== mirror ? readingHook : null
          };
        });
      }
      function simpleCompare(a2, b) {
        return a2 < b ? -1 : a2 === b ? 0 : 1;
      }
      function simpleCompareReverse(a2, b) {
        return a2 > b ? -1 : a2 === b ? 0 : 1;
      }
      function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
      }
      function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function() {
          return rangeEqual("");
        }).limit(0);
      }
      function upperFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toUpperCase();
        } : function(s) {
          return s.toLowerCase();
        };
      }
      function lowerFactory(dir) {
        return dir === "next" ? function(s) {
          return s.toLowerCase();
        } : function(s) {
          return s.toUpperCase();
        };
      }
      function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp3, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i2 = 0; i2 < length; ++i2) {
          var lwrKeyChar = lowerKey[i2];
          if (lwrKeyChar !== lowerNeedle[i2]) {
            if (cmp3(key[i2], upperNeedle[i2]) < 0)
              return key.substr(0, i2) + upperNeedle[i2] + upperNeedle.substr(i2 + 1);
            if (cmp3(key[i2], lowerNeedle[i2]) < 0)
              return key.substr(0, i2) + lowerNeedle[i2] + upperNeedle.substr(i2 + 1);
            if (llp >= 0)
              return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
            return null;
          }
          if (cmp3(key[i2], lwrKeyChar) < 0)
            llp = i2;
        }
        if (length < lowerNeedle.length && dir === "next")
          return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
          return key.substr(0, upperNeedle.length);
        return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
      }
      function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare3, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function(s) {
          return typeof s === "string";
        })) {
          return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
          upper = upperFactory(dir);
          lower = lowerFactory(dir);
          compare3 = dir === "next" ? simpleCompare : simpleCompareReverse;
          var needleBounds = needles.map(function(needle) {
            return { lower: lower(needle), upper: upper(needle) };
          }).sort(function(a2, b) {
            return compare3(a2.lower, b.lower);
          });
          upperNeedles = needleBounds.map(function(nb) {
            return nb.upper;
          });
          lowerNeedles = needleBounds.map(function(nb) {
            return nb.lower;
          });
          direction = dir;
          nextKeySuffix = dir === "next" ? "" : suffix;
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function() {
          return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix);
        });
        c._ondirectionchange = function(direction2) {
          initDirection(direction2);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function(cursor, advance, resolve2) {
          var key = cursor.key;
          if (typeof key !== "string")
            return false;
          var lowerKey = lower(key);
          if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
            return true;
          } else {
            var lowestPossibleCasing = null;
            for (var i2 = firstPossibleNeedle; i2 < needlesLen; ++i2) {
              var casing = nextCasing(key, lowerKey, upperNeedles[i2], lowerNeedles[i2], compare3, direction);
              if (casing === null && lowestPossibleCasing === null)
                firstPossibleNeedle = i2 + 1;
              else if (lowestPossibleCasing === null || compare3(lowestPossibleCasing, casing) > 0) {
                lowestPossibleCasing = casing;
              }
            }
            if (lowestPossibleCasing !== null) {
              advance(function() {
                cursor.continue(lowestPossibleCasing + nextKeySuffix);
              });
            } else {
              advance(resolve2);
            }
            return false;
          }
        });
        return c;
      }
      function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
          type: 2,
          lower,
          upper,
          lowerOpen,
          upperOpen
        };
      }
      function rangeEqual(value) {
        return {
          type: 1,
          lower: value,
          upper: value
        };
      }
      var WhereClause = function() {
        function WhereClause2() {
        }
        Object.defineProperty(WhereClause2.prototype, "Collection", {
          get: function() {
            return this._ctx.table.db.Collection;
          },
          enumerable: false,
          configurable: true
        });
        WhereClause2.prototype.between = function(lower, upper, includeLower, includeUpper) {
          includeLower = includeLower !== false;
          includeUpper = includeUpper === true;
          try {
            if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
              return emptyCollection(this);
            return new this.Collection(this, function() {
              return createRange(lower, upper, !includeLower, !includeUpper);
            });
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
        };
        WhereClause2.prototype.equals = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return rangeEqual(value);
          });
        };
        WhereClause2.prototype.above = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, true);
          });
        };
        WhereClause2.prototype.aboveOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(value, void 0, false);
          });
        };
        WhereClause2.prototype.below = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value, false, true);
          });
        };
        WhereClause2.prototype.belowOrEqual = function(value) {
          if (value == null)
            return fail(this, INVALID_KEY_ARGUMENT);
          return new this.Collection(this, function() {
            return createRange(void 0, value);
          });
        };
        WhereClause2.prototype.startsWith = function(str) {
          if (typeof str !== "string")
            return fail(this, STRING_EXPECTED);
          return this.between(str, str + maxString, true, true);
        };
        WhereClause2.prototype.startsWithIgnoreCase = function(str) {
          if (str === "")
            return this.startsWith(str);
          return addIgnoreCaseAlgorithm(this, function(x2, a2) {
            return x2.indexOf(a2[0]) === 0;
          }, [str], maxString);
        };
        WhereClause2.prototype.equalsIgnoreCase = function(str) {
          return addIgnoreCaseAlgorithm(this, function(x2, a2) {
            return x2 === a2[0];
          }, [str], "");
        };
        WhereClause2.prototype.anyOfIgnoreCase = function() {
          var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set2.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x2, a2) {
            return a2.indexOf(x2) !== -1;
          }, set2, "");
        };
        WhereClause2.prototype.startsWithAnyOfIgnoreCase = function() {
          var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set2.length === 0)
            return emptyCollection(this);
          return addIgnoreCaseAlgorithm(this, function(x2, a2) {
            return a2.some(function(n2) {
              return x2.indexOf(n2) === 0;
            });
          }, set2, maxString);
        };
        WhereClause2.prototype.anyOf = function() {
          var _this = this;
          var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          var compare3 = this._cmp;
          try {
            set2.sort(compare3);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          if (set2.length === 0)
            return emptyCollection(this);
          var c = new this.Collection(this, function() {
            return createRange(set2[0], set2[set2.length - 1]);
          });
          c._ondirectionchange = function(direction) {
            compare3 = direction === "next" ? _this._ascending : _this._descending;
            set2.sort(compare3);
          };
          var i2 = 0;
          c._addAlgorithm(function(cursor, advance, resolve2) {
            var key = cursor.key;
            while (compare3(key, set2[i2]) > 0) {
              ++i2;
              if (i2 === set2.length) {
                advance(resolve2);
                return false;
              }
            }
            if (compare3(key, set2[i2]) === 0) {
              return true;
            } else {
              advance(function() {
                cursor.continue(set2[i2]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.notEqual = function(value) {
          return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.noneOf = function() {
          var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (set2.length === 0)
            return new this.Collection(this);
          try {
            set2.sort(this._ascending);
          } catch (e) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var ranges = set2.reduce(function(res, val) {
            return res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]];
          }, null);
          ranges.push([set2[set2.length - 1], this.db._maxKey]);
          return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause2.prototype.inAnyRange = function(ranges, options) {
          var _this = this;
          var cmp3 = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
          if (ranges.length === 0)
            return emptyCollection(this);
          if (!ranges.every(function(range) {
            return range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0;
          })) {
            return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
          }
          var includeLowers = !options || options.includeLowers !== false;
          var includeUppers = options && options.includeUppers === true;
          function addRange2(ranges2, newRange) {
            var i2 = 0, l = ranges2.length;
            for (; i2 < l; ++i2) {
              var range = ranges2[i2];
              if (cmp3(newRange[0], range[1]) < 0 && cmp3(newRange[1], range[0]) > 0) {
                range[0] = min(range[0], newRange[0]);
                range[1] = max(range[1], newRange[1]);
                break;
              }
            }
            if (i2 === l)
              ranges2.push(newRange);
            return ranges2;
          }
          var sortDirection = ascending;
          function rangeSorter(a2, b) {
            return sortDirection(a2[0], b[0]);
          }
          var set2;
          try {
            set2 = ranges.reduce(addRange2, []);
            set2.sort(rangeSorter);
          } catch (ex) {
            return fail(this, INVALID_KEY_ARGUMENT);
          }
          var rangePos = 0;
          var keyIsBeyondCurrentEntry = includeUppers ? function(key) {
            return ascending(key, set2[rangePos][1]) > 0;
          } : function(key) {
            return ascending(key, set2[rangePos][1]) >= 0;
          };
          var keyIsBeforeCurrentEntry = includeLowers ? function(key) {
            return descending(key, set2[rangePos][0]) > 0;
          } : function(key) {
            return descending(key, set2[rangePos][0]) >= 0;
          };
          function keyWithinCurrentRange(key) {
            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
          }
          var checkKey = keyIsBeyondCurrentEntry;
          var c = new this.Collection(this, function() {
            return createRange(set2[0][0], set2[set2.length - 1][1], !includeLowers, !includeUppers);
          });
          c._ondirectionchange = function(direction) {
            if (direction === "next") {
              checkKey = keyIsBeyondCurrentEntry;
              sortDirection = ascending;
            } else {
              checkKey = keyIsBeforeCurrentEntry;
              sortDirection = descending;
            }
            set2.sort(rangeSorter);
          };
          c._addAlgorithm(function(cursor, advance, resolve2) {
            var key = cursor.key;
            while (checkKey(key)) {
              ++rangePos;
              if (rangePos === set2.length) {
                advance(resolve2);
                return false;
              }
            }
            if (keyWithinCurrentRange(key)) {
              return true;
            } else if (_this._cmp(key, set2[rangePos][1]) === 0 || _this._cmp(key, set2[rangePos][0]) === 0) {
              return false;
            } else {
              advance(function() {
                if (sortDirection === ascending)
                  cursor.continue(set2[rangePos][0]);
                else
                  cursor.continue(set2[rangePos][1]);
              });
              return false;
            }
          });
          return c;
        };
        WhereClause2.prototype.startsWithAnyOf = function() {
          var set2 = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
          if (!set2.every(function(s) {
            return typeof s === "string";
          })) {
            return fail(this, "startsWithAnyOf() only works with strings");
          }
          if (set2.length === 0)
            return emptyCollection(this);
          return this.inAnyRange(set2.map(function(str) {
            return [str, str + maxString];
          }));
        };
        return WhereClause2;
      }();
      function createWhereClauseConstructor(db2) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index2, orCollection) {
          this.db = db2;
          this._ctx = {
            table,
            index: index2 === ":id" ? null : index2,
            or: orCollection
          };
          this._cmp = this._ascending = cmp2;
          this._descending = function(a2, b) {
            return cmp2(b, a2);
          };
          this._max = function(a2, b) {
            return cmp2(a2, b) > 0 ? a2 : b;
          };
          this._min = function(a2, b) {
            return cmp2(a2, b) < 0 ? a2 : b;
          };
          this._IDBKeyRange = db2._deps.IDBKeyRange;
          if (!this._IDBKeyRange)
            throw new exceptions.MissingAPI();
        });
      }
      function eventRejectHandler(reject) {
        return wrap(function(event2) {
          preventDefault2(event2);
          reject(event2.target.error);
          return false;
        });
      }
      function preventDefault2(event2) {
        if (event2.stopPropagation)
          event2.stopPropagation();
        if (event2.preventDefault)
          event2.preventDefault();
      }
      var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
      var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
      var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
      var Transaction = function() {
        function Transaction2() {
        }
        Transaction2.prototype._lock = function() {
          assert2(!PSD.global);
          ++this._reculock;
          if (this._reculock === 1 && !PSD.global)
            PSD.lockOwnerFor = this;
          return this;
        };
        Transaction2.prototype._unlock = function() {
          assert2(!PSD.global);
          if (--this._reculock === 0) {
            if (!PSD.global)
              PSD.lockOwnerFor = null;
            while (this._blockedFuncs.length > 0 && !this._locked()) {
              var fnAndPSD = this._blockedFuncs.shift();
              try {
                usePSD(fnAndPSD[1], fnAndPSD[0]);
              } catch (e) {
              }
            }
          }
          return this;
        };
        Transaction2.prototype._locked = function() {
          return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction2.prototype.create = function(idbtrans) {
          var _this = this;
          if (!this.mode)
            return this;
          var idbdb = this.db.idbdb;
          var dbOpenError = this.db._state.dbOpenError;
          assert2(!this.idbtrans);
          if (!idbtrans && !idbdb) {
            switch (dbOpenError && dbOpenError.name) {
              case "DatabaseClosedError":
                throw new exceptions.DatabaseClosed(dbOpenError);
              case "MissingAPIError":
                throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
              default:
                throw new exceptions.OpenFailed(dbOpenError);
            }
          }
          if (!this.active)
            throw new exceptions.TransactionInactive();
          assert2(this._completion._state === null);
          idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
          idbtrans.onerror = wrap(function(ev) {
            preventDefault2(ev);
            _this._reject(idbtrans.error);
          });
          idbtrans.onabort = wrap(function(ev) {
            preventDefault2(ev);
            _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
            _this.active = false;
            _this.on("abort").fire(ev);
          });
          idbtrans.oncomplete = wrap(function() {
            _this.active = false;
            _this._resolve();
            if ("mutatedParts" in idbtrans) {
              globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
            }
          });
          return this;
        };
        Transaction2.prototype._promise = function(mode, fn, bWriteLock) {
          var _this = this;
          if (mode === "readwrite" && this.mode !== "readwrite")
            return rejection(new exceptions.ReadOnly("Transaction is readonly"));
          if (!this.active)
            return rejection(new exceptions.TransactionInactive());
          if (this._locked()) {
            return new DexiePromise(function(resolve2, reject) {
              _this._blockedFuncs.push([function() {
                _this._promise(mode, fn, bWriteLock).then(resolve2, reject);
              }, PSD]);
            });
          } else if (bWriteLock) {
            return newScope(function() {
              var p3 = new DexiePromise(function(resolve2, reject) {
                _this._lock();
                var rv = fn(resolve2, reject, _this);
                if (rv && rv.then)
                  rv.then(resolve2, reject);
              });
              p3.finally(function() {
                return _this._unlock();
              });
              p3._lib = true;
              return p3;
            });
          } else {
            var p2 = new DexiePromise(function(resolve2, reject) {
              var rv = fn(resolve2, reject, _this);
              if (rv && rv.then)
                rv.then(resolve2, reject);
            });
            p2._lib = true;
            return p2;
          }
        };
        Transaction2.prototype._root = function() {
          return this.parent ? this.parent._root() : this;
        };
        Transaction2.prototype.waitFor = function(promiseLike) {
          var root = this._root();
          var promise = DexiePromise.resolve(promiseLike);
          if (root._waitingFor) {
            root._waitingFor = root._waitingFor.then(function() {
              return promise;
            });
          } else {
            root._waitingFor = promise;
            root._waitingQueue = [];
            var store = root.idbtrans.objectStore(root.storeNames[0]);
            (function spin() {
              ++root._spinCount;
              while (root._waitingQueue.length)
                root._waitingQueue.shift()();
              if (root._waitingFor)
                store.get(-Infinity).onsuccess = spin;
            })();
          }
          var currentWaitPromise = root._waitingFor;
          return new DexiePromise(function(resolve2, reject) {
            promise.then(function(res) {
              return root._waitingQueue.push(wrap(resolve2.bind(null, res)));
            }, function(err) {
              return root._waitingQueue.push(wrap(reject.bind(null, err)));
            }).finally(function() {
              if (root._waitingFor === currentWaitPromise) {
                root._waitingFor = null;
              }
            });
          });
        };
        Transaction2.prototype.abort = function() {
          if (this.active) {
            this.active = false;
            if (this.idbtrans)
              this.idbtrans.abort();
            this._reject(new exceptions.Abort());
          }
        };
        Transaction2.prototype.table = function(tableName) {
          var memoizedTables = this._memoizedTables || (this._memoizedTables = {});
          if (hasOwn(memoizedTables, tableName))
            return memoizedTables[tableName];
          var tableSchema = this.schema[tableName];
          if (!tableSchema) {
            throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
          }
          var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
          transactionBoundTable.core = this.db.core.table(tableName);
          memoizedTables[tableName] = transactionBoundTable;
          return transactionBoundTable;
        };
        return Transaction2;
      }();
      function createTransactionConstructor(db2) {
        return makeClassConstructor(Transaction.prototype, function Transaction2(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
          var _this = this;
          this.db = db2;
          this.mode = mode;
          this.storeNames = storeNames;
          this.schema = dbschema;
          this.chromeTransactionDurability = chromeTransactionDurability;
          this.idbtrans = null;
          this.on = Events(this, "complete", "error", "abort");
          this.parent = parent || null;
          this.active = true;
          this._reculock = 0;
          this._blockedFuncs = [];
          this._resolve = null;
          this._reject = null;
          this._waitingFor = null;
          this._waitingQueue = null;
          this._spinCount = 0;
          this._completion = new DexiePromise(function(resolve2, reject) {
            _this._resolve = resolve2;
            _this._reject = reject;
          });
          this._completion.then(function() {
            _this.active = false;
            _this.on.complete.fire();
          }, function(e) {
            var wasActive = _this.active;
            _this.active = false;
            _this.on.error.fire(e);
            _this.parent ? _this.parent._reject(e) : wasActive && _this.idbtrans && _this.idbtrans.abort();
            return rejection(e);
          });
        });
      }
      function createIndexSpec(name, keyPath, unique2, multi, auto, compound, isPrimKey) {
        return {
          name,
          keyPath,
          unique: unique2,
          multi,
          auto,
          compound,
          src: (unique2 && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
        };
      }
      function nameFromKeyPath(keyPath) {
        return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
      }
      function createTableSchema(name, primKey, indexes) {
        return {
          name,
          primKey,
          indexes,
          mappedClass: null,
          idxByName: arrayToObject(indexes, function(index2) {
            return [index2.name, index2];
          })
        };
      }
      function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
      }
      var getMaxKey = function(IdbKeyRange) {
        try {
          IdbKeyRange.only([[]]);
          getMaxKey = function() {
            return [[]];
          };
          return [[]];
        } catch (e) {
          getMaxKey = function() {
            return maxString;
          };
          return maxString;
        }
      };
      function getKeyExtractor(keyPath) {
        if (keyPath == null) {
          return function() {
            return void 0;
          };
        } else if (typeof keyPath === "string") {
          return getSinglePathKeyExtractor(keyPath);
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split(".");
        if (split.length === 1) {
          return function(obj) {
            return obj[keyPath];
          };
        } else {
          return function(obj) {
            return getByKeyPath(obj, keyPath);
          };
        }
      }
      function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
      }
      var _id_counter = 0;
      function getKeyPathAlias(keyPath) {
        return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : "[".concat(keyPath.join("+"), "]");
      }
      function createDBCore(db2, IdbKeyRange, tmpTrans) {
        function extractSchema(db3, trans) {
          var tables2 = arrayify(db3.objectStoreNames);
          return {
            schema: {
              name: db3.name,
              tables: tables2.map(function(table) {
                return trans.objectStore(table);
              }).map(function(store) {
                var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                var compound = isArray3(keyPath);
                var outbound = keyPath == null;
                var indexByKeyPath = {};
                var result = {
                  name: store.name,
                  primaryKey: {
                    name: null,
                    isPrimaryKey: true,
                    outbound,
                    compound,
                    keyPath,
                    autoIncrement,
                    unique: true,
                    extractKey: getKeyExtractor(keyPath)
                  },
                  indexes: arrayify(store.indexNames).map(function(indexName) {
                    return store.index(indexName);
                  }).map(function(index2) {
                    var name = index2.name, unique2 = index2.unique, multiEntry = index2.multiEntry, keyPath2 = index2.keyPath;
                    var compound2 = isArray3(keyPath2);
                    var result2 = {
                      name,
                      compound: compound2,
                      keyPath: keyPath2,
                      unique: unique2,
                      multiEntry,
                      extractKey: getKeyExtractor(keyPath2)
                    };
                    indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
                    return result2;
                  }),
                  getIndexByKeyPath: function(keyPath2) {
                    return indexByKeyPath[getKeyPathAlias(keyPath2)];
                  }
                };
                indexByKeyPath[":id"] = result.primaryKey;
                if (keyPath != null) {
                  indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                }
                return result;
              })
            },
            hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
          };
        }
        function makeIDBKeyRange(range) {
          if (range.type === 3)
            return null;
          if (range.type === 4)
            throw new Error("Cannot convert never type to IDBKeyRange");
          var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
          var idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
          return idbRange;
        }
        function createDbCoreTable(tableSchema) {
          var tableName = tableSchema.name;
          function mutate2(_a3) {
            var trans = _a3.trans, type6 = _a3.type, keys2 = _a3.keys, values = _a3.values, range = _a3.range;
            return new Promise(function(resolve2, reject) {
              resolve2 = wrap(resolve2);
              var store = trans.objectStore(tableName);
              var outbound = store.keyPath == null;
              var isAddOrPut = type6 === "put" || type6 === "add";
              if (!isAddOrPut && type6 !== "delete" && type6 !== "deleteRange")
                throw new Error("Invalid operation type: " + type6);
              var length = (keys2 || values || { length: 1 }).length;
              if (keys2 && values && keys2.length !== values.length) {
                throw new Error("Given keys array must have same length as given values array.");
              }
              if (length === 0)
                return resolve2({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              var req;
              var reqs = [];
              var failures = [];
              var numFailures = 0;
              var errorHandler = function(event2) {
                ++numFailures;
                preventDefault2(event2);
              };
              if (type6 === "deleteRange") {
                if (range.type === 4)
                  return resolve2({ numFailures, failures, results: [], lastResult: void 0 });
                if (range.type === 3)
                  reqs.push(req = store.clear());
                else
                  reqs.push(req = store.delete(makeIDBKeyRange(range)));
              } else {
                var _a4 = isAddOrPut ? outbound ? [values, keys2] : [values, null] : [keys2, null], args1 = _a4[0], args2 = _a4[1];
                if (isAddOrPut) {
                  for (var i2 = 0; i2 < length; ++i2) {
                    reqs.push(req = args2 && args2[i2] !== void 0 ? store[type6](args1[i2], args2[i2]) : store[type6](args1[i2]));
                    req.onerror = errorHandler;
                  }
                } else {
                  for (var i2 = 0; i2 < length; ++i2) {
                    reqs.push(req = store[type6](args1[i2]));
                    req.onerror = errorHandler;
                  }
                }
              }
              var done = function(event2) {
                var lastResult = event2.target.result;
                reqs.forEach(function(req2, i3) {
                  return req2.error != null && (failures[i3] = req2.error);
                });
                resolve2({
                  numFailures,
                  failures,
                  results: type6 === "delete" ? keys2 : reqs.map(function(req2) {
                    return req2.result;
                  }),
                  lastResult
                });
              };
              req.onerror = function(event2) {
                errorHandler(event2);
                done(event2);
              };
              req.onsuccess = done;
            });
          }
          function openCursor2(_a3) {
            var trans = _a3.trans, values = _a3.values, query2 = _a3.query, reverse = _a3.reverse, unique2 = _a3.unique;
            return new Promise(function(resolve2, reject) {
              resolve2 = wrap(resolve2);
              var index2 = query2.index, range = query2.range;
              var store = trans.objectStore(tableName);
              var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
              var direction = reverse ? unique2 ? "prevunique" : "prev" : unique2 ? "nextunique" : "next";
              var req = values || !("openKeyCursor" in source2) ? source2.openCursor(makeIDBKeyRange(range), direction) : source2.openKeyCursor(makeIDBKeyRange(range), direction);
              req.onerror = eventRejectHandler(reject);
              req.onsuccess = wrap(function(ev) {
                var cursor = req.result;
                if (!cursor) {
                  resolve2(null);
                  return;
                }
                cursor.___id = ++_id_counter;
                cursor.done = false;
                var _cursorContinue = cursor.continue.bind(cursor);
                var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                if (_cursorContinuePrimaryKey)
                  _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                var _cursorAdvance = cursor.advance.bind(cursor);
                var doThrowCursorIsNotStarted = function() {
                  throw new Error("Cursor not started");
                };
                var doThrowCursorIsStopped = function() {
                  throw new Error("Cursor not stopped");
                };
                cursor.trans = trans;
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                cursor.fail = wrap(reject);
                cursor.next = function() {
                  var _this = this;
                  var gotOne = 1;
                  return this.start(function() {
                    return gotOne-- ? _this.continue() : _this.stop();
                  }).then(function() {
                    return _this;
                  });
                };
                cursor.start = function(callback) {
                  var iterationPromise = new Promise(function(resolveIteration, rejectIteration) {
                    resolveIteration = wrap(resolveIteration);
                    req.onerror = eventRejectHandler(rejectIteration);
                    cursor.fail = rejectIteration;
                    cursor.stop = function(value) {
                      cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                      resolveIteration(value);
                    };
                  });
                  var guardedCallback = function() {
                    if (req.result) {
                      try {
                        callback();
                      } catch (err) {
                        cursor.fail(err);
                      }
                    } else {
                      cursor.done = true;
                      cursor.start = function() {
                        throw new Error("Cursor behind last entry");
                      };
                      cursor.stop();
                    }
                  };
                  req.onsuccess = wrap(function(ev2) {
                    req.onsuccess = guardedCallback;
                    guardedCallback();
                  });
                  cursor.continue = _cursorContinue;
                  cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                  cursor.advance = _cursorAdvance;
                  guardedCallback();
                  return iterationPromise;
                };
                resolve2(cursor);
              }, reject);
            });
          }
          function query(hasGetAll2) {
            return function(request) {
              return new Promise(function(resolve2, reject) {
                resolve2 = wrap(resolve2);
                var trans = request.trans, values = request.values, limit = request.limit, query2 = request.query;
                var nonInfinitLimit = limit === Infinity ? void 0 : limit;
                var index2 = query2.index, range = query2.range;
                var store = trans.objectStore(tableName);
                var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
                var idbKeyRange = makeIDBKeyRange(range);
                if (limit === 0)
                  return resolve2({ result: [] });
                if (hasGetAll2) {
                  var req = values ? source2.getAll(idbKeyRange, nonInfinitLimit) : source2.getAllKeys(idbKeyRange, nonInfinitLimit);
                  req.onsuccess = function(event2) {
                    return resolve2({ result: event2.target.result });
                  };
                  req.onerror = eventRejectHandler(reject);
                } else {
                  var count_1 = 0;
                  var req_1 = values || !("openKeyCursor" in source2) ? source2.openCursor(idbKeyRange) : source2.openKeyCursor(idbKeyRange);
                  var result_1 = [];
                  req_1.onsuccess = function(event2) {
                    var cursor = req_1.result;
                    if (!cursor)
                      return resolve2({ result: result_1 });
                    result_1.push(values ? cursor.value : cursor.primaryKey);
                    if (++count_1 === limit)
                      return resolve2({ result: result_1 });
                    cursor.continue();
                  };
                  req_1.onerror = eventRejectHandler(reject);
                }
              });
            };
          }
          return {
            name: tableName,
            schema: tableSchema,
            mutate: mutate2,
            getMany: function(_a3) {
              var trans = _a3.trans, keys2 = _a3.keys;
              return new Promise(function(resolve2, reject) {
                resolve2 = wrap(resolve2);
                var store = trans.objectStore(tableName);
                var length = keys2.length;
                var result = new Array(length);
                var keyCount = 0;
                var callbackCount = 0;
                var req;
                var successHandler = function(event2) {
                  var req2 = event2.target;
                  if ((result[req2._pos] = req2.result) != null)
                    ;
                  if (++callbackCount === keyCount)
                    resolve2(result);
                };
                var errorHandler = eventRejectHandler(reject);
                for (var i2 = 0; i2 < length; ++i2) {
                  var key = keys2[i2];
                  if (key != null) {
                    req = store.get(keys2[i2]);
                    req._pos = i2;
                    req.onsuccess = successHandler;
                    req.onerror = errorHandler;
                    ++keyCount;
                  }
                }
                if (keyCount === 0)
                  resolve2(result);
              });
            },
            get: function(_a3) {
              var trans = _a3.trans, key = _a3.key;
              return new Promise(function(resolve2, reject) {
                resolve2 = wrap(resolve2);
                var store = trans.objectStore(tableName);
                var req = store.get(key);
                req.onsuccess = function(event2) {
                  return resolve2(event2.target.result);
                };
                req.onerror = eventRejectHandler(reject);
              });
            },
            query: query(hasGetAll),
            openCursor: openCursor2,
            count: function(_a3) {
              var query2 = _a3.query, trans = _a3.trans;
              var index2 = query2.index, range = query2.range;
              return new Promise(function(resolve2, reject) {
                var store = trans.objectStore(tableName);
                var source2 = index2.isPrimaryKey ? store : store.index(index2.name);
                var idbKeyRange = makeIDBKeyRange(range);
                var req = idbKeyRange ? source2.count(idbKeyRange) : source2.count();
                req.onsuccess = wrap(function(ev) {
                  return resolve2(ev.target.result);
                });
                req.onerror = eventRejectHandler(reject);
              });
            }
          };
        }
        var _a2 = extractSchema(db2, tmpTrans), schema = _a2.schema, hasGetAll = _a2.hasGetAll;
        var tables = schema.tables.map(function(tableSchema) {
          return createDbCoreTable(tableSchema);
        });
        var tableMap = {};
        tables.forEach(function(table) {
          return tableMap[table.name] = table;
        });
        return {
          stack: "dbcore",
          transaction: db2.transaction.bind(db2),
          table: function(name) {
            var result = tableMap[name];
            if (!result)
              throw new Error("Table '".concat(name, "' not found"));
            return tableMap[name];
          },
          MIN_KEY: -Infinity,
          MAX_KEY: getMaxKey(IdbKeyRange),
          schema
        };
      }
      function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function(down, _a2) {
          var create5 = _a2.create;
          return __assign(__assign({}, down), create5(down));
        }, stackImpl);
      }
      function createMiddlewareStacks(middlewares, idbdb, _a2, tmpTrans) {
        var IDBKeyRange2 = _a2.IDBKeyRange;
        _a2.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
        return {
          dbcore
        };
      }
      function generateMiddlewareStacks(db2, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db2._middlewares, idbdb, db2._deps, tmpTrans);
        db2.core = stacks.dbcore;
        db2.tables.forEach(function(table) {
          var tableName = table.name;
          if (db2.core.schema.tables.some(function(tbl) {
            return tbl.name === tableName;
          })) {
            table.core = db2.core.table(tableName);
            if (db2[tableName] instanceof db2.Table) {
              db2[tableName].core = table.core;
            }
          }
        });
      }
      function setApiOnPlace(db2, objs, tableNames, dbschema) {
        tableNames.forEach(function(tableName) {
          var schema = dbschema[tableName];
          objs.forEach(function(obj) {
            var propDesc = getPropertyDescriptor(obj, tableName);
            if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
              if (obj === db2.Transaction.prototype || obj instanceof db2.Transaction) {
                setProp(obj, tableName, {
                  get: function() {
                    return this.table(tableName);
                  },
                  set: function(value) {
                    defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
                  }
                });
              } else {
                obj[tableName] = new db2.Table(tableName, schema);
              }
            }
          });
        });
      }
      function removeTablesApi(db2, objs) {
        objs.forEach(function(obj) {
          for (var key in obj) {
            if (obj[key] instanceof db2.Table)
              delete obj[key];
          }
        });
      }
      function lowerVersionFirst(a2, b) {
        return a2._cfg.version - b._cfg.version;
      }
      function runUpgraders(db2, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db2._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains("$meta") && !globalSchema.$meta) {
          globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
          db2._storeNames.push("$meta");
        }
        var trans = db2._createTransaction("readwrite", db2._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function() {
          PSD.trans = trans;
          PSD.transless = transless;
          if (oldVersion === 0) {
            keys(globalSchema).forEach(function(tableName) {
              createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
            });
            generateMiddlewareStacks(db2, idbUpgradeTrans);
            DexiePromise.follow(function() {
              return db2.on.populate.fire(trans);
            }).catch(rejectTransaction);
          } else {
            generateMiddlewareStacks(db2, idbUpgradeTrans);
            return getExistingVersion(db2, trans, oldVersion).then(function(oldVersion2) {
              return updateTablesAndIndexes(db2, oldVersion2, trans, idbUpgradeTrans);
            }).catch(rejectTransaction);
          }
        });
      }
      function patchCurrentVersion(db2, idbUpgradeTrans) {
        createMissingTables(db2._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains("$meta")) {
          idbUpgradeTrans.db.createObjectStore("$meta").add(Math.ceil(idbUpgradeTrans.db.version / 10 - 1), "version");
        }
        var globalSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db2, db2._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db2._dbSchema);
        var _loop_1 = function(tableChange2) {
          if (tableChange2.change.length || tableChange2.recreate) {
            console.warn("Unable to patch indexes of table ".concat(tableChange2.name, " because it has changes on the type of index or primary key."));
            return { value: void 0 };
          }
          var store = idbUpgradeTrans.objectStore(tableChange2.name);
          tableChange2.add.forEach(function(idx) {
            if (debug)
              console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange2.name, ".").concat(idx.src));
            addIndex(store, idx);
          });
        };
        for (var _i = 0, _a2 = diff.change; _i < _a2.length; _i++) {
          var tableChange = _a2[_i];
          var state_1 = _loop_1(tableChange);
          if (typeof state_1 === "object")
            return state_1.value;
        }
      }
      function getExistingVersion(db2, trans, oldVersion) {
        if (trans.storeNames.includes("$meta")) {
          return trans.table("$meta").get("version").then(function(metaVersion) {
            return metaVersion != null ? metaVersion : oldVersion;
          });
        } else {
          return DexiePromise.resolve(oldVersion);
        }
      }
      function updateTablesAndIndexes(db2, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db2._versions;
        var globalSchema = db2._dbSchema = buildGlobalSchema(db2, db2.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function(v) {
          return v._cfg.version >= oldVersion;
        });
        if (versToRun.length === 0) {
          return DexiePromise.resolve();
        }
        versToRun.forEach(function(version) {
          queue.push(function() {
            var oldSchema = globalSchema;
            var newSchema = version._cfg.dbschema;
            adjustToExistingIndexNames(db2, oldSchema, idbUpgradeTrans);
            adjustToExistingIndexNames(db2, newSchema, idbUpgradeTrans);
            globalSchema = db2._dbSchema = newSchema;
            var diff = getSchemaDiff(oldSchema, newSchema);
            diff.add.forEach(function(tuple) {
              createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
            });
            diff.change.forEach(function(change) {
              if (change.recreate) {
                throw new exceptions.Upgrade("Not yet support for changing primary key");
              } else {
                var store_1 = idbUpgradeTrans.objectStore(change.name);
                change.add.forEach(function(idx) {
                  return addIndex(store_1, idx);
                });
                change.change.forEach(function(idx) {
                  store_1.deleteIndex(idx.name);
                  addIndex(store_1, idx);
                });
                change.del.forEach(function(idxName) {
                  return store_1.deleteIndex(idxName);
                });
              }
            });
            var contentUpgrade = version._cfg.contentUpgrade;
            if (contentUpgrade && version._cfg.version > oldVersion) {
              generateMiddlewareStacks(db2, idbUpgradeTrans);
              trans._memoizedTables = {};
              var upgradeSchema_1 = shallowClone(newSchema);
              diff.del.forEach(function(table) {
                upgradeSchema_1[table] = oldSchema[table];
              });
              removeTablesApi(db2, [db2.Transaction.prototype]);
              setApiOnPlace(db2, [db2.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
              trans.schema = upgradeSchema_1;
              var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
              if (contentUpgradeIsAsync_1) {
                incrementExpectedAwaits();
              }
              var returnValue_1;
              var promiseFollowed = DexiePromise.follow(function() {
                returnValue_1 = contentUpgrade(trans);
                if (returnValue_1) {
                  if (contentUpgradeIsAsync_1) {
                    var decrementor = decrementExpectedAwaits.bind(null, null);
                    returnValue_1.then(decrementor, decrementor);
                  }
                }
              });
              return returnValue_1 && typeof returnValue_1.then === "function" ? DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function() {
                return returnValue_1;
              });
            }
          });
          queue.push(function(idbtrans) {
            var newSchema = version._cfg.dbschema;
            deleteRemovedTables(newSchema, idbtrans);
            removeTablesApi(db2, [db2.Transaction.prototype]);
            setApiOnPlace(db2, [db2.Transaction.prototype], db2._storeNames, db2._dbSchema);
            trans.schema = db2._dbSchema;
          });
          queue.push(function(idbtrans) {
            if (db2.idbdb.objectStoreNames.contains("$meta")) {
              if (Math.ceil(db2.idbdb.version / 10) === version._cfg.version) {
                db2.idbdb.deleteObjectStore("$meta");
                delete db2._dbSchema.$meta;
                db2._storeNames = db2._storeNames.filter(function(name) {
                  return name !== "$meta";
                });
              } else {
                idbtrans.objectStore("$meta").put(version._cfg.version, "version");
              }
            }
          });
        });
        function runQueue() {
          return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
        }
        return runQueue().then(function() {
          createMissingTables(globalSchema, idbUpgradeTrans);
        });
      }
      function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
          del: [],
          add: [],
          change: []
        };
        var table;
        for (table in oldSchema) {
          if (!newSchema[table])
            diff.del.push(table);
        }
        for (table in newSchema) {
          var oldDef = oldSchema[table], newDef = newSchema[table];
          if (!oldDef) {
            diff.add.push([table, newDef]);
          } else {
            var change = {
              name: table,
              def: newDef,
              recreate: false,
              del: [],
              add: [],
              change: []
            };
            if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto) {
              change.recreate = true;
              diff.change.push(change);
            } else {
              var oldIndexes = oldDef.idxByName;
              var newIndexes = newDef.idxByName;
              var idxName = void 0;
              for (idxName in oldIndexes) {
                if (!newIndexes[idxName])
                  change.del.push(idxName);
              }
              for (idxName in newIndexes) {
                var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                if (!oldIdx)
                  change.add.push(newIdx);
                else if (oldIdx.src !== newIdx.src)
                  change.change.push(newIdx);
              }
              if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                diff.change.push(change);
              }
            }
          }
        }
        return diff;
      }
      function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
        indexes.forEach(function(idx) {
          return addIndex(store, idx);
        });
        return store;
      }
      function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function(tableName) {
          if (!idbtrans.db.objectStoreNames.contains(tableName)) {
            if (debug)
              console.debug("Dexie: Creating missing table", tableName);
            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
          }
        });
      }
      function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function(storeName) {
          return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
      }
      function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
      }
      function buildGlobalSchema(db2, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function(storeName) {
          var store = tmpTrans.objectStore(storeName);
          var keyPath = store.keyPath;
          var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
          var indexes = [];
          for (var j = 0; j < store.indexNames.length; ++j) {
            var idbindex = store.index(store.indexNames[j]);
            keyPath = idbindex.keyPath;
            var index2 = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
            indexes.push(index2);
          }
          globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
      }
      function readGlobalSchema(db2, idbdb, tmpTrans) {
        db2.verno = idbdb.version / 10;
        var globalSchema = db2._dbSchema = buildGlobalSchema(db2, idbdb, tmpTrans);
        db2._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db2, [db2._allTables], keys(globalSchema), globalSchema);
      }
      function verifyInstalledSchema(db2, tmpTrans) {
        var installedSchema = buildGlobalSchema(db2, db2.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db2._dbSchema);
        return !(diff.add.length || diff.change.some(function(ch) {
          return ch.add.length || ch.change.length;
        }));
      }
      function adjustToExistingIndexNames(db2, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i2 = 0; i2 < storeNames.length; ++i2) {
          var storeName = storeNames[i2];
          var store = idbtrans.objectStore(storeName);
          db2._hasGetAll = "getAll" in store;
          for (var j = 0; j < store.indexNames.length; ++j) {
            var indexName = store.indexNames[j];
            var keyPath = store.index(indexName).keyPath;
            var dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
            if (schema[storeName]) {
              var indexSpec = schema[storeName].idxByName[dexieName];
              if (indexSpec) {
                indexSpec.name = indexName;
                delete schema[storeName].idxByName[dexieName];
                schema[storeName].idxByName[indexName] = indexSpec;
              }
            }
          }
        }
        if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
          db2._hasGetAll = false;
        }
      }
      function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(",").map(function(index2, indexNum) {
          index2 = index2.trim();
          var name = index2.replace(/([&*]|\+\+)/g, "");
          var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
          return createIndexSpec(name, keyPath || null, /\&/.test(index2), /\*/.test(index2), /\+\+/.test(index2), isArray3(keyPath), indexNum === 0);
        });
      }
      var Version = function() {
        function Version2() {
        }
        Version2.prototype._parseStoresSpec = function(stores, outSchema) {
          keys(stores).forEach(function(tableName) {
            if (stores[tableName] !== null) {
              var indexes = parseIndexSyntax(stores[tableName]);
              var primKey = indexes.shift();
              primKey.unique = true;
              if (primKey.multi)
                throw new exceptions.Schema("Primary key cannot be multi-valued");
              indexes.forEach(function(idx) {
                if (idx.auto)
                  throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
                if (!idx.keyPath)
                  throw new exceptions.Schema("Index must have a name and cannot be an empty string");
              });
              outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
            }
          });
        };
        Version2.prototype.stores = function(stores) {
          var db2 = this.db;
          this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
          var versions = db2._versions;
          var storesSpec = {};
          var dbschema = {};
          versions.forEach(function(version) {
            extend(storesSpec, version._cfg.storesSource);
            dbschema = version._cfg.dbschema = {};
            version._parseStoresSpec(storesSpec, dbschema);
          });
          db2._dbSchema = dbschema;
          removeTablesApi(db2, [db2._allTables, db2, db2.Transaction.prototype]);
          setApiOnPlace(db2, [db2._allTables, db2, db2.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
          db2._storeNames = keys(dbschema);
          return this;
        };
        Version2.prototype.upgrade = function(upgradeFunction) {
          this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
          return this;
        };
        return Version2;
      }();
      function createVersionConstructor(db2) {
        return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
          this.db = db2;
          this._cfg = {
            version: versionNumber,
            storesSource: null,
            dbschema: {},
            tables: {},
            contentUpgrade: null
          };
        });
      }
      function getDbNamesTable(indexedDB2, IDBKeyRange2) {
        var dbNamesDB = indexedDB2["_dbNamesDB"];
        if (!dbNamesDB) {
          dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
            addons: [],
            indexedDB: indexedDB2,
            IDBKeyRange: IDBKeyRange2
          });
          dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
      }
      function hasDatabasesNative(indexedDB2) {
        return indexedDB2 && typeof indexedDB2.databases === "function";
      }
      function getDatabaseNames(_a2) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange2 = _a2.IDBKeyRange;
        return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then(function(infos) {
          return infos.map(function(info) {
            return info.name;
          }).filter(function(name) {
            return name !== DBNAMES_DB;
          });
        }) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
      }
      function _onDatabaseCreated(_a2, name) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange2 = _a2.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop);
      }
      function _onDatabaseDeleted(_a2, name) {
        var indexedDB2 = _a2.indexedDB, IDBKeyRange2 = _a2.IDBKeyRange;
        !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop);
      }
      function vip(fn) {
        return newScope(function() {
          PSD.letThrough = true;
          return fn();
        });
      }
      function idbReady() {
        var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
          return Promise.resolve();
        var intervalId;
        return new Promise(function(resolve2) {
          var tryIdb = function() {
            return indexedDB.databases().finally(resolve2);
          };
          intervalId = setInterval(tryIdb, 100);
          tryIdb();
        }).finally(function() {
          return clearInterval(intervalId);
        });
      }
      var _a;
      function isEmptyRange(node) {
        return !("from" in node);
      }
      var RangeSet2 = function(fromOrTree, to) {
        if (this) {
          extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        } else {
          var rv = new RangeSet2();
          if (fromOrTree && "d" in fromOrTree) {
            extend(rv, fromOrTree);
          }
          return rv;
        }
      };
      props(RangeSet2.prototype, (_a = {
        add: function(rangeSet) {
          mergeRanges2(this, rangeSet);
          return this;
        },
        addKey: function(key) {
          addRange(this, key, key);
          return this;
        },
        addKeys: function(keys2) {
          var _this = this;
          keys2.forEach(function(key) {
            return addRange(_this, key, key);
          });
          return this;
        },
        hasKey: function(key) {
          var node = getRangeSetIterator(this).next(key).value;
          return node && cmp2(node.from, key) <= 0 && cmp2(node.to, key) >= 0;
        }
      }, _a[iteratorSymbol] = function() {
        return getRangeSetIterator(this);
      }, _a));
      function addRange(target, from2, to) {
        var diff = cmp2(from2, to);
        if (isNaN(diff))
          return;
        if (diff > 0)
          throw RangeError();
        if (isEmptyRange(target))
          return extend(target, { from: from2, to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp2(to, target.from) < 0) {
          left ? addRange(left, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from2, target.to) > 0) {
          right ? addRange(right, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
          return rebalance(target);
        }
        if (cmp2(from2, target.from) < 0) {
          target.from = from2;
          target.l = null;
          target.d = right ? right.d + 1 : 1;
        }
        if (cmp2(to, target.to) > 0) {
          target.to = to;
          target.r = null;
          target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
          mergeRanges2(target, left);
        }
        if (right && rightWasCutOff) {
          mergeRanges2(target, right);
        }
      }
      function mergeRanges2(target, newSet) {
        function _addRangeSet(target2, _a2) {
          var from2 = _a2.from, to = _a2.to, l = _a2.l, r = _a2.r;
          addRange(target2, from2, to);
          if (l)
            _addRangeSet(target2, l);
          if (r)
            _addRangeSet(target2, r);
        }
        if (!isEmptyRange(newSet))
          _addRangeSet(target, newSet);
      }
      function rangesOverlap2(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
          return false;
        var a2 = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a2.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
          if (cmp2(b.from, a2.to) <= 0 && cmp2(b.to, a2.from) >= 0)
            return true;
          cmp2(a2.from, b.from) < 0 ? a2 = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a2.from)).value;
        }
        return false;
      }
      function getRangeSetIterator(node) {
        var state2 = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
          next: function(key) {
            var keyProvided = arguments.length > 0;
            while (state2) {
              switch (state2.s) {
                case 0:
                  state2.s = 1;
                  if (keyProvided) {
                    while (state2.n.l && cmp2(key, state2.n.from) < 0)
                      state2 = { up: state2, n: state2.n.l, s: 1 };
                  } else {
                    while (state2.n.l)
                      state2 = { up: state2, n: state2.n.l, s: 1 };
                  }
                case 1:
                  state2.s = 2;
                  if (!keyProvided || cmp2(key, state2.n.to) <= 0)
                    return { value: state2.n, done: false };
                case 2:
                  if (state2.n.r) {
                    state2.s = 3;
                    state2 = { up: state2, n: state2.n.r, s: 0 };
                    continue;
                  }
                case 3:
                  state2 = state2.up;
              }
            }
            return { done: true };
          }
        };
      }
      function rebalance(target) {
        var _a2, _b;
        var diff = (((_a2 = target.r) === null || _a2 === void 0 ? void 0 : _a2.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
          var l = r === "r" ? "l" : "r";
          var rootClone = __assign({}, target);
          var oldRootRight = target[r];
          target.from = oldRootRight.from;
          target.to = oldRootRight.to;
          target[r] = oldRootRight[r];
          rootClone[r] = oldRootRight[l];
          target[l] = rootClone;
          rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
      }
      function computeDepth(_a2) {
        var r = _a2.r, l = _a2.l;
        return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
      }
      function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function(part) {
          if (target[part])
            mergeRanges2(target[part], newSet[part]);
          else
            target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
      }
      function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function(key) {
          return os2[key] && rangesOverlap2(os2[key], os1[key]);
        });
      }
      var cache = {};
      var unsignaledParts = {};
      var isTaskEnqueued = false;
      function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
          isTaskEnqueued = true;
          setTimeout(function() {
            isTaskEnqueued = false;
            var parts = unsignaledParts;
            unsignaledParts = {};
            signalSubscribersNow(parts, false);
          }, 0);
        }
      }
      function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) {
          deleteAffectedCacheEntries = false;
        }
        var queriesToSignal = /* @__PURE__ */ new Set();
        if (updatedParts.all) {
          for (var _i = 0, _a2 = Object.values(cache); _i < _a2.length; _i++) {
            var tblCache = _a2[_i];
            collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
          }
        } else {
          for (var key in updatedParts) {
            var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
            if (parts) {
              var dbName = parts[1], tableName = parts[2];
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (tblCache)
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
          }
        }
        queriesToSignal.forEach(function(requery) {
          return requery();
        });
      }
      function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a2 = Object.entries(tblCache.queries.query); _i < _a2.length; _i++) {
          var _b = _a2[_i], indexName = _b[0], entries = _b[1];
          var filteredEntries = [];
          for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
            var entry = entries_1[_c];
            if (obsSetsOverlap(updatedParts, entry.obsSet)) {
              entry.subscribers.forEach(function(requery) {
                return outQueriesToSignal.add(requery);
              });
            } else if (deleteAffectedCacheEntries) {
              filteredEntries.push(entry);
            }
          }
          if (deleteAffectedCacheEntries)
            updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
          for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
            var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
            tblCache.queries.query[indexName] = filteredEntries;
          }
        }
      }
      function dexieOpen(db2) {
        var state2 = db2._state;
        var indexedDB2 = db2._deps.indexedDB;
        if (state2.isBeingOpened || db2.idbdb)
          return state2.dbReadyPromise.then(function() {
            return state2.dbOpenError ? rejection(state2.dbOpenError) : db2;
          });
        state2.isBeingOpened = true;
        state2.dbOpenError = null;
        state2.openComplete = false;
        var openCanceller = state2.openCanceller;
        var nativeVerToOpen = Math.round(db2.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
          if (state2.openCanceller !== openCanceller)
            throw new exceptions.DatabaseClosed("db.open() was cancelled");
        }
        var resolveDbReady = state2.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = function() {
          return new DexiePromise(function(resolve2, reject) {
            throwIfCancelled();
            if (!indexedDB2)
              throw new exceptions.MissingAPI();
            var dbName = db2.name;
            var req = state2.autoSchema || !nativeVerToOpen ? indexedDB2.open(dbName) : indexedDB2.open(dbName, nativeVerToOpen);
            if (!req)
              throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db2._fireOnBlocked);
            req.onupgradeneeded = wrap(function(e) {
              upgradeTransaction = req.transaction;
              if (state2.autoSchema && !db2._options.allowEmptyDB) {
                req.onerror = preventDefault2;
                upgradeTransaction.abort();
                req.result.close();
                var delreq = indexedDB2.deleteDatabase(dbName);
                delreq.onsuccess = delreq.onerror = wrap(function() {
                  reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                });
              } else {
                upgradeTransaction.onerror = eventRejectHandler(reject);
                var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                wasCreated = oldVer < 1;
                db2.idbdb = req.result;
                if (schemaPatchMode) {
                  patchCurrentVersion(db2, upgradeTransaction);
                }
                runUpgraders(db2, oldVer / 10, upgradeTransaction, reject);
              }
            }, reject);
            req.onsuccess = wrap(function() {
              upgradeTransaction = null;
              var idbdb = db2.idbdb = req.result;
              var objectStoreNames = slice(idbdb.objectStoreNames);
              if (objectStoreNames.length > 0)
                try {
                  var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
                  if (state2.autoSchema)
                    readGlobalSchema(db2, idbdb, tmpTrans);
                  else {
                    adjustToExistingIndexNames(db2, db2._dbSchema, tmpTrans);
                    if (!verifyInstalledSchema(db2, tmpTrans) && !schemaPatchMode) {
                      console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                      idbdb.close();
                      nativeVerToOpen = idbdb.version + 1;
                      schemaPatchMode = true;
                      return resolve2(tryOpenDB());
                    }
                  }
                  generateMiddlewareStacks(db2, tmpTrans);
                } catch (e) {
                }
              connections.push(db2);
              idbdb.onversionchange = wrap(function(ev) {
                state2.vcFired = true;
                db2.on("versionchange").fire(ev);
              });
              idbdb.onclose = wrap(function(ev) {
                db2.on("close").fire(ev);
              });
              if (wasCreated)
                _onDatabaseCreated(db2._deps, dbName);
              resolve2();
            }, reject);
          }).catch(function(err) {
            switch (err === null || err === void 0 ? void 0 : err.name) {
              case "UnknownError":
                if (state2.PR1398_maxLoop > 0) {
                  state2.PR1398_maxLoop--;
                  console.warn("Dexie: Workaround for Chrome UnknownError on open()");
                  return tryOpenDB();
                }
                break;
              case "VersionError":
                if (nativeVerToOpen > 0) {
                  nativeVerToOpen = 0;
                  return tryOpenDB();
                }
                break;
            }
            return DexiePromise.reject(err);
          });
        };
        return DexiePromise.race([
          openCanceller,
          (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function() {
          throwIfCancelled();
          state2.onReadyBeingFired = [];
          return DexiePromise.resolve(vip(function() {
            return db2.on.ready.fire(db2.vip);
          })).then(function fireRemainders() {
            if (state2.onReadyBeingFired.length > 0) {
              var remainders_1 = state2.onReadyBeingFired.reduce(promisableChain, nop);
              state2.onReadyBeingFired = [];
              return DexiePromise.resolve(vip(function() {
                return remainders_1(db2.vip);
              })).then(fireRemainders);
            }
          });
        }).finally(function() {
          if (state2.openCanceller === openCanceller) {
            state2.onReadyBeingFired = null;
            state2.isBeingOpened = false;
          }
        }).catch(function(err) {
          state2.dbOpenError = err;
          try {
            upgradeTransaction && upgradeTransaction.abort();
          } catch (_a2) {
          }
          if (openCanceller === state2.openCanceller) {
            db2._close();
          }
          return rejection(err);
        }).finally(function() {
          state2.openComplete = true;
          resolveDbReady();
        }).then(function() {
          if (wasCreated) {
            var everything_1 = {};
            db2.tables.forEach(function(table) {
              table.schema.indexes.forEach(function(idx) {
                if (idx.name)
                  everything_1["idb://".concat(db2.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet2(-Infinity, [[[]]]);
              });
              everything_1["idb://".concat(db2.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db2.name, "/").concat(table.name, "/:dels")] = new RangeSet2(-Infinity, [[[]]]);
            });
            globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
            signalSubscribersNow(everything_1, true);
          }
          return db2;
        });
      }
      function awaitIterator(iterator2) {
        var callNext = function(result) {
          return iterator2.next(result);
        }, doThrow = function(error) {
          return iterator2.throw(error);
        }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
          return function(val) {
            var next2 = getNext(val), value = next2.value;
            return next2.done ? value : !value || typeof value.then !== "function" ? isArray3(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
          };
        }
        return step(callNext)();
      }
      function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i2 = arguments.length;
        if (i2 < 2)
          throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i2 - 1);
        while (--i2)
          args[i2 - 1] = arguments[i2];
        scopeFunc = args.pop();
        var tables = flatten2(args);
        return [mode, tables, scopeFunc];
      }
      function enterTransactionScope(db2, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function() {
          var transless = PSD.transless || PSD;
          var trans = db2._createTransaction(mode, storeNames, db2._dbSchema, parentTransaction);
          trans.explicit = true;
          var zoneProps = {
            trans,
            transless
          };
          if (parentTransaction) {
            trans.idbtrans = parentTransaction.idbtrans;
          } else {
            try {
              trans.create();
              trans.idbtrans._explicit = true;
              db2._state.PR1398_maxLoop = 3;
            } catch (ex) {
              if (ex.name === errnames.InvalidState && db2.isOpen() && --db2._state.PR1398_maxLoop > 0) {
                console.warn("Dexie: Need to reopen db");
                db2.close({ disableAutoOpen: false });
                return db2.open().then(function() {
                  return enterTransactionScope(db2, mode, storeNames, null, scopeFunc);
                });
              }
              return rejection(ex);
            }
          }
          var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
          if (scopeFuncIsAsync) {
            incrementExpectedAwaits();
          }
          var returnValue;
          var promiseFollowed = DexiePromise.follow(function() {
            returnValue = scopeFunc.call(trans, trans);
            if (returnValue) {
              if (scopeFuncIsAsync) {
                var decrementor = decrementExpectedAwaits.bind(null, null);
                returnValue.then(decrementor, decrementor);
              } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
                returnValue = awaitIterator(returnValue);
              }
            }
          }, zoneProps);
          return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then(function(x2) {
            return trans.active ? x2 : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
          }) : promiseFollowed.then(function() {
            return returnValue;
          })).then(function(x2) {
            if (parentTransaction)
              trans._resolve();
            return trans._completion.then(function() {
              return x2;
            });
          }).catch(function(e) {
            trans._reject(e);
            return rejection(e);
          });
        });
      }
      function pad(a2, value, count) {
        var result = isArray3(a2) ? a2.slice() : [a2];
        for (var i2 = 0; i2 < count; ++i2)
          result.push(value);
        return result;
      }
      function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function(tableName) {
          var table = down.table(tableName);
          var schema = table.schema;
          var indexLookup = {};
          var allVirtualIndexes = [];
          function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
            var keyPathAlias = getKeyPathAlias(keyPath);
            var indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
            var keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
            var isVirtual = keyTail > 0;
            var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")") : lowLevelIndex.name, lowLevelIndex, isVirtual, keyTail, keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
            indexList.push(virtualIndex);
            if (!virtualIndex.isPrimaryKey) {
              allVirtualIndexes.push(virtualIndex);
            }
            if (keyLength > 1) {
              var virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
              addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
            }
            indexList.sort(function(a2, b) {
              return a2.keyTail - b.keyTail;
            });
            return virtualIndex;
          }
          var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
          indexLookup[":id"] = [primaryKey];
          for (var _i = 0, _a2 = schema.indexes; _i < _a2.length; _i++) {
            var index2 = _a2[_i];
            addVirtualIndexes(index2.keyPath, 0, index2);
          }
          function findBestIndex(keyPath) {
            var result2 = indexLookup[getKeyPathAlias(keyPath)];
            return result2 && result2[0];
          }
          function translateRange(range, keyTail) {
            return {
              type: range.type === 1 ? 2 : range.type,
              lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
              lowerOpen: true,
              upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
              upperOpen: true
            };
          }
          function translateRequest(req) {
            var index3 = req.query.index;
            return index3.isVirtual ? __assign(__assign({}, req), { query: {
              index: index3.lowLevelIndex,
              range: translateRange(req.query.range, index3.keyTail)
            } }) : req;
          }
          var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function(req) {
            return table.count(translateRequest(req));
          }, query: function(req) {
            return table.query(translateRequest(req));
          }, openCursor: function(req) {
            var _a3 = req.query.index, keyTail = _a3.keyTail, isVirtual = _a3.isVirtual, keyLength = _a3.keyLength;
            if (!isVirtual)
              return table.openCursor(req);
            function createVirtualCursor(cursor) {
              function _continue(key) {
                key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
              }
              var virtualCursor = Object.create(cursor, {
                continue: { value: _continue },
                continuePrimaryKey: {
                  value: function(key, primaryKey2) {
                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                  }
                },
                primaryKey: {
                  get: function() {
                    return cursor.primaryKey;
                  }
                },
                key: {
                  get: function() {
                    var key = cursor.key;
                    return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                  }
                },
                value: {
                  get: function() {
                    return cursor.value;
                  }
                }
              });
              return virtualCursor;
            }
            return table.openCursor(translateRequest(req)).then(function(cursor) {
              return cursor && createVirtualCursor(cursor);
            });
          } });
          return result;
        } });
      }
      var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
      };
      function getObjectDiff(a2, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || "";
        keys(a2).forEach(function(prop2) {
          if (!hasOwn(b, prop2)) {
            rv[prfx + prop2] = void 0;
          } else {
            var ap = a2[prop2], bp = b[prop2];
            if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
              var apTypeName = toStringTag(ap);
              var bpTypeName = toStringTag(bp);
              if (apTypeName !== bpTypeName) {
                rv[prfx + prop2] = b[prop2];
              } else if (apTypeName === "Object") {
                getObjectDiff(ap, bp, rv, prfx + prop2 + ".");
              } else if (ap !== bp) {
                rv[prfx + prop2] = b[prop2];
              }
            } else if (ap !== bp)
              rv[prfx + prop2] = b[prop2];
          }
        });
        keys(b).forEach(function(prop2) {
          if (!hasOwn(a2, prop2)) {
            rv[prfx + prop2] = b[prop2];
          }
        });
        return rv;
      }
      function getEffectiveKeys(primaryKey, req) {
        if (req.type === "delete")
          return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
      }
      var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function(downCore) {
          return __assign(__assign({}, downCore), { table: function(tableName) {
            var downTable = downCore.table(tableName);
            var primaryKey = downTable.schema.primaryKey;
            var tableMiddleware = __assign(__assign({}, downTable), { mutate: function(req) {
              var dxTrans = PSD.trans;
              var _a2 = dxTrans.table(tableName).hook, deleting = _a2.deleting, creating = _a2.creating, updating = _a2.updating;
              switch (req.type) {
                case "add":
                  if (creating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "put":
                  if (creating.fire === nop && updating.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "delete":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return addPutOrDelete(req);
                  }, true);
                case "deleteRange":
                  if (deleting.fire === nop)
                    break;
                  return dxTrans._promise("readwrite", function() {
                    return deleteRange(req);
                  }, true);
              }
              return downTable.mutate(req);
              function addPutOrDelete(req2) {
                var dxTrans2 = PSD.trans;
                var keys2 = req2.keys || getEffectiveKeys(primaryKey, req2);
                if (!keys2)
                  throw new Error("Keys missing");
                req2 = req2.type === "add" || req2.type === "put" ? __assign(__assign({}, req2), { keys: keys2 }) : __assign({}, req2);
                if (req2.type !== "delete")
                  req2.values = __spreadArray2([], req2.values, true);
                if (req2.keys)
                  req2.keys = __spreadArray2([], req2.keys, true);
                return getExistingValues(downTable, req2, keys2).then(function(existingValues) {
                  var contexts = keys2.map(function(key, i2) {
                    var existingValue = existingValues[i2];
                    var ctx = { onerror: null, onsuccess: null };
                    if (req2.type === "delete") {
                      deleting.fire.call(ctx, key, existingValue, dxTrans2);
                    } else if (req2.type === "add" || existingValue === void 0) {
                      var generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i2], dxTrans2);
                      if (key == null && generatedPrimaryKey != null) {
                        key = generatedPrimaryKey;
                        req2.keys[i2] = key;
                        if (!primaryKey.outbound) {
                          setByKeyPath(req2.values[i2], primaryKey.keyPath, key);
                        }
                      }
                    } else {
                      var objectDiff = getObjectDiff(existingValue, req2.values[i2]);
                      var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                      if (additionalChanges_1) {
                        var requestedValue_1 = req2.values[i2];
                        Object.keys(additionalChanges_1).forEach(function(keyPath) {
                          if (hasOwn(requestedValue_1, keyPath)) {
                            requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                          } else {
                            setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                          }
                        });
                      }
                    }
                    return ctx;
                  });
                  return downTable.mutate(req2).then(function(_a3) {
                    var failures = _a3.failures, results = _a3.results, numFailures = _a3.numFailures, lastResult = _a3.lastResult;
                    for (var i2 = 0; i2 < keys2.length; ++i2) {
                      var primKey = results ? results[i2] : keys2[i2];
                      var ctx = contexts[i2];
                      if (primKey == null) {
                        ctx.onerror && ctx.onerror(failures[i2]);
                      } else {
                        ctx.onsuccess && ctx.onsuccess(
                          req2.type === "put" && existingValues[i2] ? req2.values[i2] : primKey
                        );
                      }
                    }
                    return { failures, results, numFailures, lastResult };
                  }).catch(function(error) {
                    contexts.forEach(function(ctx) {
                      return ctx.onerror && ctx.onerror(error);
                    });
                    return Promise.reject(error);
                  });
                });
              }
              function deleteRange(req2) {
                return deleteNextChunk(req2.trans, req2.range, 1e4);
              }
              function deleteNextChunk(trans, range, limit) {
                return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(function(_a3) {
                  var result = _a3.result;
                  return addPutOrDelete({ type: "delete", keys: result, trans }).then(function(res) {
                    if (res.numFailures > 0)
                      return Promise.reject(res.failures[0]);
                    if (result.length < limit) {
                      return { failures: [], numFailures: 0, lastResult: void 0 };
                    } else {
                      return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                    }
                  });
                });
              }
            } });
            return tableMiddleware;
          } });
        }
      };
      function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
      }
      function getFromTransactionCache(keys2, cache2, clone2) {
        try {
          if (!cache2)
            return null;
          if (cache2.keys.length < keys2.length)
            return null;
          var result = [];
          for (var i2 = 0, j = 0; i2 < cache2.keys.length && j < keys2.length; ++i2) {
            if (cmp2(cache2.keys[i2], keys2[j]) !== 0)
              continue;
            result.push(clone2 ? deepClone2(cache2.values[i2]) : cache2.values[i2]);
            ++j;
          }
          return result.length === keys2.length ? result : null;
        } catch (_a2) {
          return null;
        }
      }
      var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function(core) {
          return {
            table: function(tableName) {
              var table = core.table(tableName);
              return __assign(__assign({}, table), { getMany: function(req) {
                if (!req.cache) {
                  return table.getMany(req);
                }
                var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                if (cachedResult) {
                  return DexiePromise.resolve(cachedResult);
                }
                return table.getMany(req).then(function(res) {
                  req.trans["_cache"] = {
                    keys: req.keys,
                    values: req.cache === "clone" ? deepClone2(res) : res
                  };
                  return res;
                });
              }, mutate: function(req) {
                if (req.type !== "add")
                  req.trans["_cache"] = null;
                return table.mutate(req);
              } });
            }
          };
        }
      };
      function isCachableContext(ctx, table) {
        return ctx.trans.mode === "readonly" && !!ctx.subscr && !ctx.trans.explicit && ctx.trans.db._options.cache !== "disabled" && !table.schema.primaryKey.outbound;
      }
      function isCachableRequest(type6, req) {
        switch (type6) {
          case "query":
            return req.values && !req.unique;
          case "get":
            return false;
          case "getMany":
            return false;
          case "count":
            return false;
          case "openCursor":
            return false;
        }
      }
      var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: function(core) {
          var dbName = core.schema.name;
          var FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
          return __assign(__assign({}, core), { transaction: function(stores, mode, options) {
            if (PSD.subscr && mode !== "readonly") {
              throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
            }
            return core.transaction(stores, mode, options);
          }, table: function(tableName) {
            var table = core.table(tableName);
            var schema = table.schema;
            var primaryKey = schema.primaryKey, indexes = schema.indexes;
            var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
            var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function(index2) {
              return index2.compound && index2.keyPath.includes(primaryKey.keyPath);
            });
            var tableClone = __assign(__assign({}, table), { mutate: function(req) {
              var trans = req.trans;
              var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
              var getRangeSet = function(indexName) {
                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
              };
              var pkRangeSet = getRangeSet("");
              var delsRangeSet = getRangeSet(":dels");
              var type6 = req.type;
              var _a2 = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [getEffectiveKeys(primaryKey, req).filter(function(id) {
                return id;
              }), req.values] : [], keys2 = _a2[0], newObjs = _a2[1];
              var oldCache = req.trans["_cache"];
              if (isArray3(keys2)) {
                pkRangeSet.addKeys(keys2);
                var oldObjs = type6 === "delete" || keys2.length === newObjs.length ? getFromTransactionCache(keys2, oldCache) : null;
                if (!oldObjs) {
                  delsRangeSet.addKeys(keys2);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys2) {
                var range = { from: keys2.lower, to: keys2.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach(function(idx) {
                  return getRangeSet(idx.name).add(FULL_RANGE);
                });
              }
              return table.mutate(req).then(function(res) {
                if (keys2 && (req.type === "add" || req.type === "put")) {
                  pkRangeSet.addKeys(res.results);
                  if (indexesWithAutoIncPK) {
                    indexesWithAutoIncPK.forEach(function(idx) {
                      var idxVals = req.values.map(function(v) {
                        return idx.extractKey(v);
                      });
                      var pkPos = idx.keyPath.findIndex(function(prop2) {
                        return prop2 === primaryKey.keyPath;
                      });
                      res.results.forEach(function(pk) {
                        return idxVals[pkPos] = pk;
                      });
                      getRangeSet(idx.name).addKeys(idxVals);
                    });
                  }
                }
                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                return res;
              });
            } });
            var getRange = function(_a2) {
              var _b, _c;
              var _d = _a2.query, index2 = _d.index, range = _d.range;
              return [
                index2,
                new RangeSet2((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY)
              ];
            };
            var readSubscribers = {
              get: function(req) {
                return [primaryKey, new RangeSet2(req.key)];
              },
              getMany: function(req) {
                return [primaryKey, new RangeSet2().addKeys(req.keys)];
              },
              count: getRange,
              query: getRange,
              openCursor: getRange
            };
            keys(readSubscribers).forEach(function(method) {
              tableClone[method] = function(req) {
                var subscr = PSD.subscr;
                var isLiveQuery = !!subscr;
                var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                var obsSet = cachable ? req.obsSet = {} : subscr;
                if (isLiveQuery) {
                  var getRangeSet = function(indexName) {
                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                    return obsSet[part] || (obsSet[part] = new RangeSet2());
                  };
                  var pkRangeSet_1 = getRangeSet("");
                  var delsRangeSet_1 = getRangeSet(":dels");
                  var _a2 = readSubscribers[method](req), queriedIndex = _a2[0], queriedRanges = _a2[1];
                  if (method === "query" && queriedIndex.isPrimaryKey && !req.values) {
                    delsRangeSet_1.add(queriedRanges);
                  } else {
                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                  }
                  if (!queriedIndex.isPrimaryKey) {
                    if (method === "count") {
                      delsRangeSet_1.add(FULL_RANGE);
                    } else {
                      var keysPromise_1 = method === "query" && outbound && req.values && table.query(__assign(__assign({}, req), { values: false }));
                      return table[method].apply(this, arguments).then(function(res) {
                        if (method === "query") {
                          if (outbound && req.values) {
                            return keysPromise_1.then(function(_a3) {
                              var resultingKeys = _a3.result;
                              pkRangeSet_1.addKeys(resultingKeys);
                              return res;
                            });
                          }
                          var pKeys = req.values ? res.result.map(extractKey) : res.result;
                          if (req.values) {
                            pkRangeSet_1.addKeys(pKeys);
                          } else {
                            delsRangeSet_1.addKeys(pKeys);
                          }
                        } else if (method === "openCursor") {
                          var cursor_1 = res;
                          var wantValues_1 = req.values;
                          return cursor_1 && Object.create(cursor_1, {
                            key: {
                              get: function() {
                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.key;
                              }
                            },
                            primaryKey: {
                              get: function() {
                                var pkey = cursor_1.primaryKey;
                                delsRangeSet_1.addKey(pkey);
                                return pkey;
                              }
                            },
                            value: {
                              get: function() {
                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                return cursor_1.value;
                              }
                            }
                          });
                        }
                        return res;
                      });
                    }
                  }
                }
                return table[method].apply(this, arguments);
              };
            });
            return tableClone;
          } });
        }
      };
      function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
          var rangeSet = getRangeSet(ix.name || "");
          function extractKey(obj) {
            return obj != null ? ix.extractKey(obj) : null;
          }
          var addKeyOrKeys = function(key) {
            return ix.multiEntry && isArray3(key) ? key.forEach(function(key2) {
              return rangeSet.addKey(key2);
            }) : rangeSet.addKey(key);
          };
          (oldObjs || newObjs).forEach(function(_, i2) {
            var oldKey = oldObjs && extractKey(oldObjs[i2]);
            var newKey = newObjs && extractKey(newObjs[i2]);
            if (cmp2(oldKey, newKey) !== 0) {
              if (oldKey != null)
                addKeyOrKeys(oldKey);
              if (newKey != null)
                addKeyOrKeys(newKey);
            }
          });
        }
        schema.indexes.forEach(addAffectedIndex);
      }
      function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
          return req;
        if (req.type === "deleteRange") {
          return null;
        }
        var numBulkOps = req.keys ? req.keys.length : "values" in req && req.values ? req.values.length : 1;
        if (res.numFailures === numBulkOps) {
          return null;
        }
        var clone2 = __assign({}, req);
        if (isArray3(clone2.keys)) {
          clone2.keys = clone2.keys.filter(function(_, i2) {
            return !(i2 in res.failures);
          });
        }
        if ("values" in clone2 && isArray3(clone2.values)) {
          clone2.values = clone2.values.filter(function(_, i2) {
            return !(i2 in res.failures);
          });
        }
        return clone2;
      }
      function isAboveLower(key, range) {
        return range.lower === void 0 ? true : range.lowerOpen ? cmp2(key, range.lower) > 0 : cmp2(key, range.lower) >= 0;
      }
      function isBelowUpper(key, range) {
        return range.upper === void 0 ? true : range.upperOpen ? cmp2(key, range.upper) < 0 : cmp2(key, range.upper) <= 0;
      }
      function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
      }
      function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
          return result;
        var index2 = req.query.index;
        var multiEntry = index2.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index2.extractKey;
        var extractLowLevelIndex = (index2.lowLevelIndex || index2).extractKey;
        var finalResult = ops.reduce(function(result2, op) {
          var modifedResult = result2;
          var includedValues = [];
          if (op.type === "add" || op.type === "put") {
            var includedPKs = new RangeSet2();
            for (var i2 = op.values.length - 1; i2 >= 0; --i2) {
              var value = op.values[i2];
              var pk = extractPrimKey(value);
              if (includedPKs.hasKey(pk))
                continue;
              var key = extractIndex(value);
              if (multiEntry && isArray3(key) ? key.some(function(k) {
                return isWithinRange(k, queryRange);
              }) : isWithinRange(key, queryRange)) {
                includedPKs.addKey(pk);
                includedValues.push(value);
              }
            }
          }
          switch (op.type) {
            case "add":
              modifedResult = result2.concat(req.values ? includedValues : includedValues.map(function(v) {
                return extractPrimKey(v);
              }));
              break;
            case "put":
              var keySet_1 = new RangeSet2().addKeys(op.values.map(function(v) {
                return extractPrimKey(v);
              }));
              modifedResult = result2.filter(
                function(item) {
                  return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item);
                }
              ).concat(
                req.values ? includedValues : includedValues.map(function(v) {
                  return extractPrimKey(v);
                })
              );
              break;
            case "delete":
              var keysToDelete_1 = new RangeSet2().addKeys(op.keys);
              modifedResult = result2.filter(function(item) {
                return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
              });
              break;
            case "deleteRange":
              var range_1 = op.range;
              modifedResult = result2.filter(function(item) {
                return !isWithinRange(extractPrimKey(item), range_1);
              });
              break;
          }
          return modifedResult;
        }, result);
        if (finalResult === result)
          return result;
        finalResult.sort(function(a2, b) {
          return cmp2(extractLowLevelIndex(a2), extractLowLevelIndex(b)) || cmp2(extractPrimKey(a2), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
          if (finalResult.length > req.limit) {
            finalResult.length = req.limit;
          } else if (result.length === req.limit && finalResult.length < req.limit) {
            cacheEntry.dirty = true;
          }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
      }
      function areRangesEqual(r1, r2) {
        return cmp2(r1.lower, r2.lower) === 0 && cmp2(r1.upper, r2.upper) === 0 && !!r1.lowerOpen === !!r2.lowerOpen && !!r1.upperOpen === !!r2.upperOpen;
      }
      function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === void 0)
          return lower2 !== void 0 ? -1 : 0;
        if (lower2 === void 0)
          return 1;
        var c = cmp2(lower1, lower2);
        if (c === 0) {
          if (lowerOpen1 && lowerOpen2)
            return 0;
          if (lowerOpen1)
            return 1;
          if (lowerOpen2)
            return -1;
        }
        return c;
      }
      function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === void 0)
          return upper2 !== void 0 ? 1 : 0;
        if (upper2 === void 0)
          return -1;
        var c = cmp2(upper1, upper2);
        if (c === 0) {
          if (upperOpen1 && upperOpen2)
            return 0;
          if (upperOpen1)
            return -1;
          if (upperOpen2)
            return 1;
        }
        return c;
      }
      function isSuperRange(r1, r2) {
        return compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 && compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0;
      }
      function findCompatibleQuery(dbName, tableName, type6, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
          return [];
        var queries = tblCache.queries[type6];
        if (!queries)
          return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ""];
        if (!entries)
          return [null, false, tblCache, null];
        switch (type6) {
          case "query":
            var equalEntry = entries.find(function(entry) {
              return entry.req.limit === req.limit && entry.req.values === req.values && areRangesEqual(entry.req.query.range, req.query.range);
            });
            if (equalEntry)
              return [
                equalEntry,
                true,
                tblCache,
                entries
              ];
            var superEntry = entries.find(function(entry) {
              var limit = "limit" in entry.req ? entry.req.limit : Infinity;
              return limit >= req.limit && (req.values ? entry.req.values : true) && isSuperRange(entry.req.query.range, req.query.range);
            });
            return [superEntry, false, tblCache, entries];
          case "count":
            var countQuery = entries.find(function(entry) {
              return areRangesEqual(entry.req.query.range, req.query.range);
            });
            return [countQuery, !!countQuery, tblCache, entries];
        }
      }
      function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function() {
          cacheEntry.subscribers.delete(requery);
          if (cacheEntry.subscribers.size === 0) {
            enqueForDeletion(cacheEntry, container);
          }
        });
      }
      function enqueForDeletion(cacheEntry, container) {
        setTimeout(function() {
          if (cacheEntry.subscribers.size === 0) {
            delArrayItem(container, cacheEntry);
          }
        }, 3e3);
      }
      var cacheMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Cache",
        create: function(core) {
          var dbName = core.schema.name;
          var coreMW = __assign(__assign({}, core), { transaction: function(stores, mode, options) {
            var idbtrans = core.transaction(stores, mode, options);
            if (mode === "readwrite") {
              var ac_1 = new AbortController();
              var signal = ac_1.signal;
              var endTransaction = function(wasCommitted) {
                return function() {
                  ac_1.abort();
                  if (mode === "readwrite") {
                    var affectedSubscribers_1 = /* @__PURE__ */ new Set();
                    for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                      var storeName = stores_1[_i];
                      var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                      if (tblCache) {
                        var table = core.table(storeName);
                        var ops = tblCache.optimisticOps.filter(function(op) {
                          return op.trans === idbtrans;
                        });
                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                          for (var _a2 = 0, _b = Object.values(tblCache.queries.query); _a2 < _b.length; _a2++) {
                            var entries = _b[_a2];
                            for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                              var entry = _d[_c];
                              if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                delArrayItem(entries, entry);
                                entry.subscribers.forEach(function(requery) {
                                  return affectedSubscribers_1.add(requery);
                                });
                              }
                            }
                          }
                        } else if (ops.length > 0) {
                          tblCache.optimisticOps = tblCache.optimisticOps.filter(function(op) {
                            return op.trans !== idbtrans;
                          });
                          for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                            var entries = _f[_e];
                            for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                              var entry = _h[_g];
                              if (entry.res != null && idbtrans.mutatedParts) {
                                if (wasCommitted && !entry.dirty) {
                                  var freezeResults = Object.isFrozen(entry.res);
                                  var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                    entry.subscribers.forEach(function(requery) {
                                      return affectedSubscribers_1.add(requery);
                                    });
                                  } else if (modRes !== entry.res) {
                                    entry.res = modRes;
                                    entry.promise = DexiePromise.resolve({ result: modRes });
                                  }
                                } else {
                                  if (entry.dirty) {
                                    delArrayItem(entries, entry);
                                  }
                                  entry.subscribers.forEach(function(requery) {
                                    return affectedSubscribers_1.add(requery);
                                  });
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    affectedSubscribers_1.forEach(function(requery) {
                      return requery();
                    });
                  }
                };
              };
              idbtrans.addEventListener("abort", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("error", endTransaction(false), {
                signal
              });
              idbtrans.addEventListener("complete", endTransaction(true), {
                signal
              });
            }
            return idbtrans;
          }, table: function(tableName) {
            var downTable = core.table(tableName);
            var primKey = downTable.schema.primaryKey;
            var tableMW = __assign(__assign({}, downTable), { mutate: function(req) {
              var trans = PSD.trans;
              if (primKey.outbound || trans.db._options.cache === "disabled" || trans.explicit) {
                return downTable.mutate(req);
              }
              var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
              if (!tblCache)
                return downTable.mutate(req);
              var promise = downTable.mutate(req);
              if ((req.type === "add" || req.type === "put") && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function(key) {
                return key == null;
              }))) {
                promise.then(function(res) {
                  var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function(value, i2) {
                    var _a2;
                    var valueWithKey = ((_a2 = primKey.keyPath) === null || _a2 === void 0 ? void 0 : _a2.includes(".")) ? deepClone2(value) : __assign({}, value);
                    setByKeyPath(valueWithKey, primKey.keyPath, res.results[i2]);
                    return valueWithKey;
                  }) });
                  var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                  tblCache.optimisticOps.push(adjustedReq);
                  queueMicrotask(function() {
                    return req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  });
                });
              } else {
                tblCache.optimisticOps.push(req);
                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                promise.then(function(res) {
                  if (res.numFailures > 0) {
                    delArrayItem(tblCache.optimisticOps, req);
                    var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                    if (adjustedReq) {
                      tblCache.optimisticOps.push(adjustedReq);
                    }
                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                  }
                });
                promise.catch(function() {
                  delArrayItem(tblCache.optimisticOps, req);
                  req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                });
              }
              return promise;
            }, query: function(req) {
              var _a2;
              if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                return downTable.query(req);
              var freezeResults = ((_a2 = PSD.trans) === null || _a2 === void 0 ? void 0 : _a2.db._options.cache) === "immutable";
              var _b = PSD, requery = _b.requery, signal = _b.signal;
              var _c = findCompatibleQuery(dbName, tableName, "query", req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
              if (cacheEntry && exactMatch) {
                cacheEntry.obsSet = req.obsSet;
              } else {
                var promise = downTable.query(req).then(function(res) {
                  var result = res.result;
                  if (cacheEntry)
                    cacheEntry.res = result;
                  if (freezeResults) {
                    for (var i2 = 0, l = result.length; i2 < l; ++i2) {
                      Object.freeze(result[i2]);
                    }
                    Object.freeze(result);
                  } else {
                    res.result = deepClone2(result);
                  }
                  return res;
                }).catch(function(error) {
                  if (container && cacheEntry)
                    delArrayItem(container, cacheEntry);
                  return Promise.reject(error);
                });
                cacheEntry = {
                  obsSet: req.obsSet,
                  promise,
                  subscribers: /* @__PURE__ */ new Set(),
                  type: "query",
                  req,
                  dirty: false
                };
                if (container) {
                  container.push(cacheEntry);
                } else {
                  container = [cacheEntry];
                  if (!tblCache) {
                    tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                      queries: {
                        query: {},
                        count: {}
                      },
                      objs: /* @__PURE__ */ new Map(),
                      optimisticOps: [],
                      unsignaledParts: {}
                    };
                  }
                  tblCache.queries.query[req.query.index.name || ""] = container;
                }
              }
              subscribeToCacheEntry(cacheEntry, container, requery, signal);
              return cacheEntry.promise.then(function(res) {
                return {
                  result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults)
                };
              });
            } });
            return tableMW;
          } });
          return coreMW;
        }
      };
      function vipify(target, vipDb) {
        return new Proxy(target, {
          get: function(target2, prop2, receiver) {
            if (prop2 === "db")
              return vipDb;
            return Reflect.get(target2, prop2, receiver);
          }
        });
      }
      var Dexie$1 = function() {
        function Dexie3(name, options) {
          var _this = this;
          this._middlewares = {};
          this.verno = 0;
          var deps = Dexie3.dependencies;
          this._options = options = __assign({
            addons: Dexie3.addons,
            autoOpen: true,
            indexedDB: deps.indexedDB,
            IDBKeyRange: deps.IDBKeyRange,
            cache: "cloned"
          }, options);
          this._deps = {
            indexedDB: options.indexedDB,
            IDBKeyRange: options.IDBKeyRange
          };
          var addons = options.addons;
          this._dbSchema = {};
          this._versions = [];
          this._storeNames = [];
          this._allTables = {};
          this.idbdb = null;
          this._novip = this;
          var state2 = {
            dbOpenError: null,
            isBeingOpened: false,
            onReadyBeingFired: null,
            openComplete: false,
            dbReadyResolve: nop,
            dbReadyPromise: null,
            cancelOpen: nop,
            openCanceller: null,
            autoSchema: true,
            PR1398_maxLoop: 3,
            autoOpen: options.autoOpen
          };
          state2.dbReadyPromise = new DexiePromise(function(resolve2) {
            state2.dbReadyResolve = resolve2;
          });
          state2.openCanceller = new DexiePromise(function(_, reject) {
            state2.cancelOpen = reject;
          });
          this._state = state2;
          this.name = name;
          this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
          this.on.ready.subscribe = override(this.on.ready.subscribe, function(subscribe) {
            return function(subscriber, bSticky) {
              Dexie3.vip(function() {
                var state3 = _this._state;
                if (state3.openComplete) {
                  if (!state3.dbOpenError)
                    DexiePromise.resolve().then(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else if (state3.onReadyBeingFired) {
                  state3.onReadyBeingFired.push(subscriber);
                  if (bSticky)
                    subscribe(subscriber);
                } else {
                  subscribe(subscriber);
                  var db_1 = _this;
                  if (!bSticky)
                    subscribe(function unsubscribe() {
                      db_1.on.ready.unsubscribe(subscriber);
                      db_1.on.ready.unsubscribe(unsubscribe);
                    });
                }
              });
            };
          });
          this.Collection = createCollectionConstructor(this);
          this.Table = createTableConstructor(this);
          this.Transaction = createTransactionConstructor(this);
          this.Version = createVersionConstructor(this);
          this.WhereClause = createWhereClauseConstructor(this);
          this.on("versionchange", function(ev) {
            if (ev.newVersion > 0)
              console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
            else
              console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
            _this.close({ disableAutoOpen: false });
          });
          this.on("blocked", function(ev) {
            if (!ev.newVersion || ev.newVersion < ev.oldVersion)
              console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
            else
              console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
          });
          this._maxKey = getMaxKey(options.IDBKeyRange);
          this._createTransaction = function(mode, storeNames, dbschema, parentTransaction) {
            return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction);
          };
          this._fireOnBlocked = function(ev) {
            _this.on("blocked").fire(ev);
            connections.filter(function(c) {
              return c.name === _this.name && c !== _this && !c._state.vcFired;
            }).map(function(c) {
              return c.on("versionchange").fire(ev);
            });
          };
          this.use(cacheExistingValuesMiddleware);
          this.use(cacheMiddleware);
          this.use(observabilityMiddleware);
          this.use(virtualIndexMiddleware);
          this.use(hooksMiddleware);
          var vipDB = new Proxy(this, {
            get: function(_, prop2, receiver) {
              if (prop2 === "_vip")
                return true;
              if (prop2 === "table")
                return function(tableName) {
                  return vipify(_this.table(tableName), vipDB);
                };
              var rv = Reflect.get(_, prop2, receiver);
              if (rv instanceof Table)
                return vipify(rv, vipDB);
              if (prop2 === "tables")
                return rv.map(function(t) {
                  return vipify(t, vipDB);
                });
              if (prop2 === "_createTransaction")
                return function() {
                  var tx = rv.apply(this, arguments);
                  return vipify(tx, vipDB);
                };
              return rv;
            }
          });
          this.vip = vipDB;
          addons.forEach(function(addon) {
            return addon(_this);
          });
        }
        Dexie3.prototype.version = function(versionNumber) {
          if (isNaN(versionNumber) || versionNumber < 0.1)
            throw new exceptions.Type("Given version is not a positive number");
          versionNumber = Math.round(versionNumber * 10) / 10;
          if (this.idbdb || this._state.isBeingOpened)
            throw new exceptions.Schema("Cannot add version when database is open");
          this.verno = Math.max(this.verno, versionNumber);
          var versions = this._versions;
          var versionInstance = versions.filter(function(v) {
            return v._cfg.version === versionNumber;
          })[0];
          if (versionInstance)
            return versionInstance;
          versionInstance = new this.Version(versionNumber);
          versions.push(versionInstance);
          versions.sort(lowerVersionFirst);
          versionInstance.stores({});
          this._state.autoSchema = false;
          return versionInstance;
        };
        Dexie3.prototype._whenReady = function(fn) {
          var _this = this;
          return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise(function(resolve2, reject) {
            if (_this._state.openComplete) {
              return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
            }
            if (!_this._state.isBeingOpened) {
              if (!_this._state.autoOpen) {
                reject(new exceptions.DatabaseClosed());
                return;
              }
              _this.open().catch(nop);
            }
            _this._state.dbReadyPromise.then(resolve2, reject);
          }).then(fn);
        };
        Dexie3.prototype.use = function(_a2) {
          var stack2 = _a2.stack, create5 = _a2.create, level = _a2.level, name = _a2.name;
          if (name)
            this.unuse({ stack: stack2, name });
          var middlewares = this._middlewares[stack2] || (this._middlewares[stack2] = []);
          middlewares.push({ stack: stack2, create: create5, level: level == null ? 10 : level, name });
          middlewares.sort(function(a2, b) {
            return a2.level - b.level;
          });
          return this;
        };
        Dexie3.prototype.unuse = function(_a2) {
          var stack2 = _a2.stack, name = _a2.name, create5 = _a2.create;
          if (stack2 && this._middlewares[stack2]) {
            this._middlewares[stack2] = this._middlewares[stack2].filter(function(mw) {
              return create5 ? mw.create !== create5 : name ? mw.name !== name : false;
            });
          }
          return this;
        };
        Dexie3.prototype.open = function() {
          var _this = this;
          return usePSD(
            globalPSD,
            function() {
              return dexieOpen(_this);
            }
          );
        };
        Dexie3.prototype._close = function() {
          var state2 = this._state;
          var idx = connections.indexOf(this);
          if (idx >= 0)
            connections.splice(idx, 1);
          if (this.idbdb) {
            try {
              this.idbdb.close();
            } catch (e) {
            }
            this.idbdb = null;
          }
          if (!state2.isBeingOpened) {
            state2.dbReadyPromise = new DexiePromise(function(resolve2) {
              state2.dbReadyResolve = resolve2;
            });
            state2.openCanceller = new DexiePromise(function(_, reject) {
              state2.cancelOpen = reject;
            });
          }
        };
        Dexie3.prototype.close = function(_a2) {
          var _b = _a2 === void 0 ? { disableAutoOpen: true } : _a2, disableAutoOpen = _b.disableAutoOpen;
          var state2 = this._state;
          if (disableAutoOpen) {
            if (state2.isBeingOpened) {
              state2.cancelOpen(new exceptions.DatabaseClosed());
            }
            this._close();
            state2.autoOpen = false;
            state2.dbOpenError = new exceptions.DatabaseClosed();
          } else {
            this._close();
            state2.autoOpen = this._options.autoOpen || state2.isBeingOpened;
            state2.openComplete = false;
            state2.dbOpenError = null;
          }
        };
        Dexie3.prototype.delete = function(closeOptions) {
          var _this = this;
          if (closeOptions === void 0) {
            closeOptions = { disableAutoOpen: true };
          }
          var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== "object";
          var state2 = this._state;
          return new DexiePromise(function(resolve2, reject) {
            var doDelete = function() {
              _this.close(closeOptions);
              var req = _this._deps.indexedDB.deleteDatabase(_this.name);
              req.onsuccess = wrap(function() {
                _onDatabaseDeleted(_this._deps, _this.name);
                resolve2();
              });
              req.onerror = eventRejectHandler(reject);
              req.onblocked = _this._fireOnBlocked;
            };
            if (hasInvalidArguments)
              throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
            if (state2.isBeingOpened) {
              state2.dbReadyPromise.then(doDelete);
            } else {
              doDelete();
            }
          });
        };
        Dexie3.prototype.backendDB = function() {
          return this.idbdb;
        };
        Dexie3.prototype.isOpen = function() {
          return this.idbdb !== null;
        };
        Dexie3.prototype.hasBeenClosed = function() {
          var dbOpenError = this._state.dbOpenError;
          return dbOpenError && dbOpenError.name === "DatabaseClosed";
        };
        Dexie3.prototype.hasFailed = function() {
          return this._state.dbOpenError !== null;
        };
        Dexie3.prototype.dynamicallyOpened = function() {
          return this._state.autoSchema;
        };
        Object.defineProperty(Dexie3.prototype, "tables", {
          get: function() {
            var _this = this;
            return keys(this._allTables).map(function(name) {
              return _this._allTables[name];
            });
          },
          enumerable: false,
          configurable: true
        });
        Dexie3.prototype.transaction = function() {
          var args = extractTransactionArgs.apply(this, arguments);
          return this._transaction.apply(this, args);
        };
        Dexie3.prototype._transaction = function(mode, tables, scopeFunc) {
          var _this = this;
          var parentTransaction = PSD.trans;
          if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
            parentTransaction = null;
          var onlyIfCompatible = mode.indexOf("?") !== -1;
          mode = mode.replace("!", "").replace("?", "");
          var idbMode, storeNames;
          try {
            storeNames = tables.map(function(table) {
              var storeName = table instanceof _this.Table ? table.name : table;
              if (typeof storeName !== "string")
                throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
              return storeName;
            });
            if (mode == "r" || mode === READONLY)
              idbMode = READONLY;
            else if (mode == "rw" || mode == READWRITE)
              idbMode = READWRITE;
            else
              throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
            if (parentTransaction) {
              if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                if (onlyIfCompatible) {
                  parentTransaction = null;
                } else
                  throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              }
              if (parentTransaction) {
                storeNames.forEach(function(storeName) {
                  if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                    if (onlyIfCompatible) {
                      parentTransaction = null;
                    } else
                      throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
                  }
                });
              }
              if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                parentTransaction = null;
              }
            }
          } catch (e) {
            return parentTransaction ? parentTransaction._promise(null, function(_, reject) {
              reject(e);
            }) : rejection(e);
          }
          var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
          return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, function() {
            return _this._whenReady(enterTransaction);
          }) : this._whenReady(enterTransaction);
        };
        Dexie3.prototype.table = function(tableName) {
          if (!hasOwn(this._allTables, tableName)) {
            throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
          }
          return this._allTables[tableName];
        };
        return Dexie3;
      }();
      var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
      var Observable2 = function() {
        function Observable3(subscribe) {
          this._subscribe = subscribe;
        }
        Observable3.prototype.subscribe = function(x2, error, complete) {
          return this._subscribe(!x2 || typeof x2 === "function" ? { next: x2, error, complete } : x2);
        };
        Observable3.prototype[symbolObservable] = function() {
          return this;
        };
        return Observable3;
      }();
      var domDeps;
      try {
        domDeps = {
          indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
          IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
      } catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
      }
      function liveQuery2(querier) {
        var hasValue = false;
        var currentValue;
        var observable2 = new Observable2(function(observer) {
          var scopeFuncIsAsync = isAsyncFunction(querier);
          function execute(ctx) {
            var wasRootExec = beginMicroTickScope();
            try {
              if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
              }
              var rv = newScope(querier, ctx);
              if (scopeFuncIsAsync) {
                rv = rv.finally(decrementExpectedAwaits);
              }
              return rv;
            } finally {
              wasRootExec && endMicroTickScope();
            }
          }
          var closed = false;
          var abortController;
          var accumMuts = {};
          var currentObs = {};
          var subscription = {
            get closed() {
              return closed;
            },
            unsubscribe: function() {
              if (closed)
                return;
              closed = true;
              if (abortController)
                abortController.abort();
              if (startedListening)
                globalEvents.storagemutated.unsubscribe(mutationListener);
            }
          };
          observer.start && observer.start(subscription);
          var startedListening = false;
          var doQuery = function() {
            return execInGlobalContext(_doQuery);
          };
          function shouldNotify() {
            return obsSetsOverlap(currentObs, accumMuts);
          }
          var mutationListener = function(parts) {
            extendObservabilitySet(accumMuts, parts);
            if (shouldNotify()) {
              doQuery();
            }
          };
          var _doQuery = function() {
            if (closed || !domDeps.indexedDB) {
              return;
            }
            accumMuts = {};
            var subscr = {};
            if (abortController)
              abortController.abort();
            abortController = new AbortController();
            var ctx = {
              subscr,
              signal: abortController.signal,
              requery: doQuery,
              querier,
              trans: null
            };
            var ret = execute(ctx);
            Promise.resolve(ret).then(function(result) {
              hasValue = true;
              currentValue = result;
              if (closed || ctx.signal.aborted) {
                return;
              }
              accumMuts = {};
              currentObs = subscr;
              if (!objectIsEmpty(currentObs) && !startedListening) {
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                startedListening = true;
              }
              execInGlobalContext(function() {
                return !closed && observer.next && observer.next(result);
              });
            }, function(err) {
              hasValue = false;
              if (!["DatabaseClosedError", "AbortError"].includes(err === null || err === void 0 ? void 0 : err.name)) {
                if (!closed)
                  execInGlobalContext(function() {
                    if (closed)
                      return;
                    observer.error && observer.error(err);
                  });
              }
            });
          };
          setTimeout(doQuery, 0);
          return subscription;
        });
        observable2.hasValue = function() {
          return hasValue;
        };
        observable2.getValue = function() {
          return currentValue;
        };
        return observable2;
      }
      var Dexie2 = Dexie$1;
      props(Dexie2, __assign(__assign({}, fullNameExceptions), {
        delete: function(databaseName) {
          var db2 = new Dexie2(databaseName, { addons: [] });
          return db2.delete();
        },
        exists: function(name) {
          return new Dexie2(name, { addons: [] }).open().then(function(db2) {
            db2.close();
            return true;
          }).catch("NoSuchDatabaseError", function() {
            return false;
          });
        },
        getDatabaseNames: function(cb) {
          try {
            return getDatabaseNames(Dexie2.dependencies).then(cb);
          } catch (_a2) {
            return rejection(new exceptions.MissingAPI());
          }
        },
        defineClass: function() {
          function Class(content) {
            extend(this, content);
          }
          return Class;
        },
        ignoreTransaction: function(scopeFunc) {
          return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
        },
        vip,
        async: function(generatorFn) {
          return function() {
            try {
              var rv = awaitIterator(generatorFn.apply(this, arguments));
              if (!rv || typeof rv.then !== "function")
                return DexiePromise.resolve(rv);
              return rv;
            } catch (e) {
              return rejection(e);
            }
          };
        },
        spawn: function(generatorFn, args, thiz) {
          try {
            var rv = awaitIterator(generatorFn.apply(thiz, args || []));
            if (!rv || typeof rv.then !== "function")
              return DexiePromise.resolve(rv);
            return rv;
          } catch (e) {
            return rejection(e);
          }
        },
        currentTransaction: {
          get: function() {
            return PSD.trans || null;
          }
        },
        waitFor: function(promiseOrFunction, optionalTimeout) {
          var promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie2.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
          return PSD.trans ? PSD.trans.waitFor(promise) : promise;
        },
        Promise: DexiePromise,
        debug: {
          get: function() {
            return debug;
          },
          set: function(value) {
            setDebug(value);
          }
        },
        derive,
        extend,
        props,
        override,
        Events,
        on: globalEvents,
        liveQuery: liveQuery2,
        extendObservabilitySet,
        getByKeyPath,
        setByKeyPath,
        delByKeyPath,
        shallowClone,
        deepClone: deepClone2,
        getObjectDiff,
        cmp: cmp2,
        asap: asap$1,
        minKey,
        addons: [],
        connections,
        errnames,
        dependencies: domDeps,
        cache,
        semVer: DEXIE_VERSION,
        version: DEXIE_VERSION.split(".").map(function(n2) {
          return parseInt(n2);
        }).reduce(function(p2, c, i2) {
          return p2 + c / Math.pow(10, i2 * 2);
        })
      }));
      Dexie2.maxKey = getMaxKey(Dexie2.dependencies.IDBKeyRange);
      if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(updatedParts) {
          if (!propagatingLocally) {
            var event_1;
            event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
              detail: updatedParts
            });
            propagatingLocally = true;
            dispatchEvent(event_1);
            propagatingLocally = false;
          }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function(_a2) {
          var detail = _a2.detail;
          if (!propagatingLocally) {
            propagateLocally(detail);
          }
        });
      }
      function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
          propagatingLocally = true;
          globalEvents.storagemutated.fire(updateParts);
          signalSubscribersNow(updateParts, true);
        } finally {
          propagatingLocally = wasMe;
        }
      }
      var propagatingLocally = false;
      var bc;
      var createBC = function() {
      };
      if (typeof BroadcastChannel !== "undefined") {
        createBC = function() {
          bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
          bc.onmessage = function(ev) {
            return ev.data && propagateLocally(ev.data);
          };
        };
        createBC();
        if (typeof bc.unref === "function") {
          bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function(changedParts) {
          if (!propagatingLocally) {
            bc.postMessage(changedParts);
          }
        });
      }
      if (typeof addEventListener !== "undefined") {
        addEventListener("pagehide", function(event2) {
          if (!Dexie$1.disableBfCache && event2.persisted) {
            if (debug)
              console.debug("Dexie: handling persisted pagehide");
            bc === null || bc === void 0 ? void 0 : bc.close();
            for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
              var db2 = connections_1[_i];
              db2.close({ disableAutoOpen: false });
            }
          }
        });
        addEventListener("pageshow", function(event2) {
          if (!Dexie$1.disableBfCache && event2.persisted) {
            if (debug)
              console.debug("Dexie: handling persisted pageshow");
            createBC();
            propagateLocally({ all: new RangeSet2(-Infinity, [[]]) });
          }
        });
      }
      function add2(value) {
        return new PropModification2({ add: value });
      }
      function remove2(value) {
        return new PropModification2({ remove: value });
      }
      function replacePrefix2(a2, b) {
        return new PropModification2({ replacePrefix: [a2, b] });
      }
      DexiePromise.rejectionMapper = mapError;
      setDebug(debug);
      var namedExports = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery2,
        Entity: Entity2,
        cmp: cmp2,
        PropModSymbol: PropModSymbol2,
        PropModification: PropModification2,
        replacePrefix: replacePrefix2,
        add: add2,
        remove: remove2,
        "default": Dexie$1,
        RangeSet: RangeSet2,
        mergeRanges: mergeRanges2,
        rangesOverlap: rangesOverlap2
      });
      __assign(Dexie$1, namedExports, { default: Dexie$1 });
      return Dexie$1;
    });
  }
});

// node_modules/.pnpm/svelte-browser-import@0.0.4/node_modules/svelte-browser-import/dist/svelte-browser-import.es.js
var n = Object.defineProperty;
var F = (l, Z, b) => Z in l ? n(l, Z, { enumerable: true, configurable: true, writable: true, value: b }) : l[Z] = b;
var y = (l, Z, b) => (F(l, typeof Z != "symbol" ? Z + "" : Z, b), b);
var H = "KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO3NlbGYud2luZG93PXNlbGY7Y29uc3QgeGM9ZT0+bmV3IFByb21pc2UodD0+c2V0VGltZW91dCh0LGUpKTsvKgoJICBAbGljZW5zZQoJCVJvbGx1cC5qcyB2My4yOS40CgkJVGh1LCAyOCBTZXAgMjAyMyAwNDo1NDozMCBHTVQgLSBjb21taXQgNGU5MmQ2MGZhOTBjZWFkMzk0ODFlMzcwM2QyNmU1ZDgxMmY0M2JkMQoKCQlodHRwczovL2dpdGh1Yi5jb20vcm9sbHVwL3JvbGx1cAoKCQlSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCgkqL3ZhciBCbj0iMy4yOS40IjtmdW5jdGlvbiBXYShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwiZGVmYXVsdCIpP2UuZGVmYXVsdDplfXZhciBxYT17ZXhwb3J0czp7fX07KGZ1bmN0aW9uKGUpe2NvbnN0IHM9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iLG49bmV3IFVpbnQ4QXJyYXkoNjQpLHI9bmV3IFVpbnQ4QXJyYXkoMTI4KTtmb3IobGV0IGc9MDtnPHMubGVuZ3RoO2crKyl7Y29uc3QgeD1zLmNoYXJDb2RlQXQoZyk7bltnXT14LHJbeF09Z31jb25zdCBhPXR5cGVvZiBUZXh0RGVjb2RlcjwidSI/bmV3IFRleHREZWNvZGVyOnR5cGVvZiBCdWZmZXI8InUiP3tkZWNvZGU6Zz0+QnVmZmVyLmZyb20oZy5idWZmZXIsZy5ieXRlT2Zmc2V0LGcuYnl0ZUxlbmd0aCkudG9TdHJpbmcoKX06e2RlY29kZShnKXtsZXQgeD0iIjtmb3IobGV0IHY9MDt2PGcubGVuZ3RoO3YrKyl4Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGdbdl0pO3JldHVybiB4fX07ZnVuY3Rpb24gbyhnKXtjb25zdCB4PW5ldyBJbnQzMkFycmF5KDUpLHY9W107bGV0IHc9MDtkb3tjb25zdCBiPWgoZyx3KSxTPVtdO2xldCBrPSEwLEM9MDt4WzBdPTA7Zm9yKGxldCBQPXc7UDxiO1ArKyl7bGV0IF87UD1sKGcsUCx4LDApO2NvbnN0IEE9eFswXTtBPEMmJihrPSExKSxDPUEsYyhnLFAsYik/KFA9bChnLFAseCwxKSxQPWwoZyxQLHgsMiksUD1sKGcsUCx4LDMpLGMoZyxQLGIpPyhQPWwoZyxQLHgsNCksXz1bQSx4WzFdLHhbMl0seFszXSx4WzRdXSk6Xz1bQSx4WzFdLHhbMl0seFszXV0pOl89W0FdLFMucHVzaChfKX1rfHxwKFMpLHYucHVzaChTKSx3PWIrMX13aGlsZSh3PD1nLmxlbmd0aCk7cmV0dXJuIHZ9ZnVuY3Rpb24gaChnLHgpe2NvbnN0IHY9Zy5pbmRleE9mKCI7Iix4KTtyZXR1cm4gdj09PS0xP2cubGVuZ3RoOnZ9ZnVuY3Rpb24gbChnLHgsdix3KXtsZXQgYj0wLFM9MCxrPTA7ZG97Y29uc3QgUD1nLmNoYXJDb2RlQXQoeCsrKTtrPXJbUF0sYnw9KDMxJmspPDxTLFMrPTV9d2hpbGUoMzImayk7Y29uc3QgQz0xJmI7cmV0dXJuIGI+Pj49MSxDJiYoYj0tMjE0NzQ4MzY0OHwtYiksdlt3XSs9Yix4fWZ1bmN0aW9uIGMoZyx4LHYpe3JldHVybiEoeD49dikmJmcuY2hhckNvZGVBdCh4KSE9PTQ0fWZ1bmN0aW9uIHAoZyl7Zy5zb3J0KG0pfWZ1bmN0aW9uIG0oZyx4KXtyZXR1cm4gZ1swXS14WzBdfWZ1bmN0aW9uIHkoZyl7Y29uc3QgeD1uZXcgSW50MzJBcnJheSg1KSx2PTE2Mzg0LHc9di0zNixiPW5ldyBVaW50OEFycmF5KHYpLFM9Yi5zdWJhcnJheSgwLHcpO2xldCBrPTAsQz0iIjtmb3IobGV0IFA9MDtQPGcubGVuZ3RoO1ArKyl7Y29uc3QgXz1nW1BdO2lmKFA+MCYmKGs9PT12JiYoQys9YS5kZWNvZGUoYiksaz0wKSxiW2srK109NTkpLF8ubGVuZ3RoIT09MCl7eFswXT0wO2ZvcihsZXQgQT0wO0E8Xy5sZW5ndGg7QSsrKXtjb25zdCBOPV9bQV07az53JiYoQys9YS5kZWNvZGUoUyksYi5jb3B5V2l0aGluKDAsdyxrKSxrLT13KSxBPjAmJihiW2srK109NDQpLGs9RShiLGsseCxOLDApLE4ubGVuZ3RoIT09MSYmKGs9RShiLGsseCxOLDEpLGs9RShiLGsseCxOLDIpLGs9RShiLGsseCxOLDMpLE4ubGVuZ3RoIT09NCYmKGs9RShiLGsseCxOLDQpKSl9fX1yZXR1cm4gQythLmRlY29kZShiLnN1YmFycmF5KDAsaykpfWZ1bmN0aW9uIEUoZyx4LHYsdyxiKXtjb25zdCBTPXdbYl07bGV0IGs9Uy12W2JdO3ZbYl09UyxrPWs8MD8tazw8MXwxOms8PDE7ZG97bGV0IEM9MzEmaztrPj4+PTUsaz4wJiYoQ3w9MzIpLGdbeCsrXT1uW0NdfXdoaWxlKGs+MCk7cmV0dXJuIHh9ZS5kZWNvZGU9byxlLmVuY29kZT15LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJfX2VzTW9kdWxlIix7dmFsdWU6ITB9KX0pKHFhLmV4cG9ydHMpO3ZhciBGbj1xYS5leHBvcnRzO2xldCBIYT1jbGFzcyBnY3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJpdHM9dCBpbnN0YW5jZW9mIGdjP3QuYml0cy5zbGljZSgpOltdfWFkZCh0KXt0aGlzLmJpdHNbdD4+NV18PTE8PCgzMSZ0KX1oYXModCl7cmV0dXJuISEodGhpcy5iaXRzW3Q+PjVdJjE8PCgzMSZ0KSl9fSxLYT1jbGFzcyBHYXtjb25zdHJ1Y3Rvcih0LGkscyl7dGhpcy5zdGFydD10LHRoaXMuZW5kPWksdGhpcy5vcmlnaW5hbD1zLHRoaXMuaW50cm89IiIsdGhpcy5vdXRybz0iIix0aGlzLmNvbnRlbnQ9cyx0aGlzLnN0b3JlTmFtZT0hMSx0aGlzLmVkaXRlZD0hMSx0aGlzLnByZXZpb3VzPW51bGwsdGhpcy5uZXh0PW51bGx9YXBwZW5kTGVmdCh0KXt0aGlzLm91dHJvKz10fWFwcGVuZFJpZ2h0KHQpe3RoaXMuaW50cm89dGhpcy5pbnRybyt0fWNsb25lKCl7Y29uc3QgdD1uZXcgR2EodGhpcy5zdGFydCx0aGlzLmVuZCx0aGlzLm9yaWdpbmFsKTtyZXR1cm4gdC5pbnRybz10aGlzLmludHJvLHQub3V0cm89dGhpcy5vdXRybyx0LmNvbnRlbnQ9dGhpcy5jb250ZW50LHQuc3RvcmVOYW1lPXRoaXMuc3RvcmVOYW1lLHQuZWRpdGVkPXRoaXMuZWRpdGVkLHR9Y29udGFpbnModCl7cmV0dXJuIHRoaXMuc3RhcnQ8dCYmdDx0aGlzLmVuZH1lYWNoTmV4dCh0KXtsZXQgaT10aGlzO2Zvcig7aTspdChpKSxpPWkubmV4dH1lYWNoUHJldmlvdXModCl7bGV0IGk9dGhpcztmb3IoO2k7KXQoaSksaT1pLnByZXZpb3VzfWVkaXQodCxpLHMpe3JldHVybiB0aGlzLmNvbnRlbnQ9dCxzfHwodGhpcy5pbnRybz0iIix0aGlzLm91dHJvPSIiKSx0aGlzLnN0b3JlTmFtZT1pLHRoaXMuZWRpdGVkPSEwLHRoaXN9cHJlcGVuZExlZnQodCl7dGhpcy5vdXRybz10K3RoaXMub3V0cm99cHJlcGVuZFJpZ2h0KHQpe3RoaXMuaW50cm89dCt0aGlzLmludHJvfXNwbGl0KHQpe2NvbnN0IGk9dC10aGlzLnN0YXJ0LHM9dGhpcy5vcmlnaW5hbC5zbGljZSgwLGkpLG49dGhpcy5vcmlnaW5hbC5zbGljZShpKTt0aGlzLm9yaWdpbmFsPXM7Y29uc3Qgcj1uZXcgR2EodCx0aGlzLmVuZCxuKTtyZXR1cm4gci5vdXRybz10aGlzLm91dHJvLHRoaXMub3V0cm89IiIsdGhpcy5lbmQ9dCx0aGlzLmVkaXRlZD8oci5lZGl0KCIiLCExKSx0aGlzLmNvbnRlbnQ9IiIpOnRoaXMuY29udGVudD1zLHIubmV4dD10aGlzLm5leHQsci5uZXh0JiYoci5uZXh0LnByZXZpb3VzPXIpLHIucHJldmlvdXM9dGhpcyx0aGlzLm5leHQ9cixyfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuaW50cm8rdGhpcy5jb250ZW50K3RoaXMub3V0cm99dHJpbUVuZCh0KXtpZih0aGlzLm91dHJvPXRoaXMub3V0cm8ucmVwbGFjZSh0LCIiKSx0aGlzLm91dHJvLmxlbmd0aClyZXR1cm4hMDtjb25zdCBpPXRoaXMuY29udGVudC5yZXBsYWNlKHQsIiIpO3JldHVybiBpLmxlbmd0aD8oaSE9PXRoaXMuY29udGVudCYmKHRoaXMuc3BsaXQodGhpcy5zdGFydCtpLmxlbmd0aCkuZWRpdCgiIix2b2lkIDAsITApLHRoaXMuZWRpdGVkJiZ0aGlzLmVkaXQoaSx0aGlzLnN0b3JlTmFtZSwhMCkpLCEwKToodGhpcy5lZGl0KCIiLHZvaWQgMCwhMCksdGhpcy5pbnRybz10aGlzLmludHJvLnJlcGxhY2UodCwiIiksISF0aGlzLmludHJvLmxlbmd0aHx8dm9pZCAwKX10cmltU3RhcnQodCl7aWYodGhpcy5pbnRybz10aGlzLmludHJvLnJlcGxhY2UodCwiIiksdGhpcy5pbnRyby5sZW5ndGgpcmV0dXJuITA7Y29uc3QgaT10aGlzLmNvbnRlbnQucmVwbGFjZSh0LCIiKTtpZihpLmxlbmd0aCl7aWYoaSE9PXRoaXMuY29udGVudCl7Y29uc3Qgcz10aGlzLnNwbGl0KHRoaXMuZW5kLWkubGVuZ3RoKTt0aGlzLmVkaXRlZCYmcy5lZGl0KGksdGhpcy5zdG9yZU5hbWUsITApLHRoaXMuZWRpdCgiIix2b2lkIDAsITApfXJldHVybiEwfXJldHVybiB0aGlzLmVkaXQoIiIsdm9pZCAwLCEwKSx0aGlzLm91dHJvPXRoaXMub3V0cm8ucmVwbGFjZSh0LCIiKSwhIXRoaXMub3V0cm8ubGVuZ3RofHx2b2lkIDB9fTtmdW5jdGlvbiBiYygpe3JldHVybiB0eXBlb2Ygd2luZG93PCJ1IiYmdHlwZW9mIHdpbmRvdy5idG9hPT0iZnVuY3Rpb24iP2U9PndpbmRvdy5idG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChlKSkpOnR5cGVvZiBCdWZmZXI9PSJmdW5jdGlvbiI/ZT0+QnVmZmVyLmZyb20oZSwidXRmLTgiKS50b1N0cmluZygiYmFzZTY0Iik6KCk9Pnt0aHJvdyBuZXcgRXJyb3IoIlVuc3VwcG9ydGVkIGVudmlyb25tZW50OiBgd2luZG93LmJ0b2FgIG9yIGBCdWZmZXJgIHNob3VsZCBiZSBzdXBwb3J0ZWQuIil9fWNvbnN0IHZjPWJjKCk7Y2xhc3MgTnN7Y29uc3RydWN0b3IodCl7dGhpcy52ZXJzaW9uPTMsdGhpcy5maWxlPXQuZmlsZSx0aGlzLnNvdXJjZXM9dC5zb3VyY2VzLHRoaXMuc291cmNlc0NvbnRlbnQ9dC5zb3VyY2VzQ29udGVudCx0aGlzLm5hbWVzPXQubmFtZXMsdGhpcy5tYXBwaW5ncz1Gbi5lbmNvZGUodC5tYXBwaW5ncyksdC54X2dvb2dsZV9pZ25vcmVMaXN0IT09dm9pZCAwJiYodGhpcy54X2dvb2dsZV9pZ25vcmVMaXN0PXQueF9nb29nbGVfaWdub3JlTGlzdCl9dG9TdHJpbmcoKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyl9dG9VcmwoKXtyZXR1cm4iZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCIrdmModGhpcy50b1N0cmluZygpKX19ZnVuY3Rpb24gUWEoZSx0KXtjb25zdCBpPWUuc3BsaXQoL1svXFxdLykscz10LnNwbGl0KC9bL1xcXS8pO2ZvcihpLnBvcCgpO2lbMF09PT1zWzBdOylpLnNoaWZ0KCkscy5zaGlmdCgpO2lmKGkubGVuZ3RoKXtsZXQgbj1pLmxlbmd0aDtmb3IoO24tLTspaVtuXT0iLi4ifXJldHVybiBpLmNvbmNhdChzKS5qb2luKCIvIil9Y29uc3QgRWM9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBZYShlKXtyZXR1cm4gRWMuY2FsbChlKT09PSJbb2JqZWN0IE9iamVjdF0ifWZ1bmN0aW9uIHpuKGUpe2NvbnN0IHQ9ZS5zcGxpdChgCmApLGk9W107Zm9yKGxldCBzPTAsbj0wO3M8dC5sZW5ndGg7cysrKWkucHVzaChuKSxuKz10W3NdLmxlbmd0aCsxO3JldHVybiBmdW5jdGlvbihzKXtsZXQgbj0wLHI9aS5sZW5ndGg7Zm9yKDtuPHI7KXtjb25zdCBvPW4rcj4+MTtzPGlbb10/cj1vOm49bysxfWNvbnN0IGE9bi0xO3JldHVybntsaW5lOmEsY29sdW1uOnMtaVthXX19fWNvbnN0IFNjPS9cdy87Y2xhc3MgWGF7Y29uc3RydWN0b3IodCl7dGhpcy5oaXJlcz10LHRoaXMuZ2VuZXJhdGVkQ29kZUxpbmU9MCx0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW49MCx0aGlzLnJhdz1bXSx0aGlzLnJhd1NlZ21lbnRzPXRoaXMucmF3W3RoaXMuZ2VuZXJhdGVkQ29kZUxpbmVdPVtdLHRoaXMucGVuZGluZz1udWxsfWFkZEVkaXQodCxpLHMsbil7aWYoaS5sZW5ndGgpe2NvbnN0IHI9W3RoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbix0LHMubGluZSxzLmNvbHVtbl07bj49MCYmci5wdXNoKG4pLHRoaXMucmF3U2VnbWVudHMucHVzaChyKX1lbHNlIHRoaXMucGVuZGluZyYmdGhpcy5yYXdTZWdtZW50cy5wdXNoKHRoaXMucGVuZGluZyk7dGhpcy5hZHZhbmNlKGkpLHRoaXMucGVuZGluZz1udWxsfWFkZFVuZWRpdGVkQ2h1bmsodCxpLHMsbixyKXtsZXQgYT1pLnN0YXJ0LG89ITAsaD0hMTtmb3IoO2E8aS5lbmQ7KXtpZih0aGlzLmhpcmVzfHxvfHxyLmhhcyhhKSl7Y29uc3QgbD1bdGhpcy5nZW5lcmF0ZWRDb2RlQ29sdW1uLHQsbi5saW5lLG4uY29sdW1uXTt0aGlzLmhpcmVzPT09ImJvdW5kYXJ5Ij9TYy50ZXN0KHNbYV0pP2h8fCh0aGlzLnJhd1NlZ21lbnRzLnB1c2gobCksaD0hMCk6KHRoaXMucmF3U2VnbWVudHMucHVzaChsKSxoPSExKTp0aGlzLnJhd1NlZ21lbnRzLnB1c2gobCl9c1thXT09PWAKYD8obi5saW5lKz0xLG4uY29sdW1uPTAsdGhpcy5nZW5lcmF0ZWRDb2RlTGluZSs9MSx0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXT10aGlzLnJhd1NlZ21lbnRzPVtdLHRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbj0wLG89ITApOihuLmNvbHVtbis9MSx0aGlzLmdlbmVyYXRlZENvZGVDb2x1bW4rPTEsbz0hMSksYSs9MX10aGlzLnBlbmRpbmc9bnVsbH1hZHZhbmNlKHQpe2lmKCF0KXJldHVybjtjb25zdCBpPXQuc3BsaXQoYApgKTtpZihpLmxlbmd0aD4xKXtmb3IobGV0IHM9MDtzPGkubGVuZ3RoLTE7cysrKXRoaXMuZ2VuZXJhdGVkQ29kZUxpbmUrKyx0aGlzLnJhd1t0aGlzLmdlbmVyYXRlZENvZGVMaW5lXT10aGlzLnJhd1NlZ21lbnRzPVtdO3RoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbj0wfXRoaXMuZ2VuZXJhdGVkQ29kZUNvbHVtbis9aVtpLmxlbmd0aC0xXS5sZW5ndGh9fWNvbnN0IFVpPWAKYCx4aT17aW5zZXJ0TGVmdDohMSxpbnNlcnRSaWdodDohMSxzdG9yZU5hbWU6ITF9O2NsYXNzIFp0e2NvbnN0cnVjdG9yKHQsaT17fSl7Y29uc3Qgcz1uZXcgS2EoMCx0Lmxlbmd0aCx0KTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLHtvcmlnaW5hbDp7d3JpdGFibGU6ITAsdmFsdWU6dH0sb3V0cm86e3dyaXRhYmxlOiEwLHZhbHVlOiIifSxpbnRybzp7d3JpdGFibGU6ITAsdmFsdWU6IiJ9LGZpcnN0Q2h1bms6e3dyaXRhYmxlOiEwLHZhbHVlOnN9LGxhc3RDaHVuazp7d3JpdGFibGU6ITAsdmFsdWU6c30sbGFzdFNlYXJjaGVkQ2h1bms6e3dyaXRhYmxlOiEwLHZhbHVlOnN9LGJ5U3RhcnQ6e3dyaXRhYmxlOiEwLHZhbHVlOnt9fSxieUVuZDp7d3JpdGFibGU6ITAsdmFsdWU6e319LGZpbGVuYW1lOnt3cml0YWJsZTohMCx2YWx1ZTppLmZpbGVuYW1lfSxpbmRlbnRFeGNsdXNpb25SYW5nZXM6e3dyaXRhYmxlOiEwLHZhbHVlOmkuaW5kZW50RXhjbHVzaW9uUmFuZ2VzfSxzb3VyY2VtYXBMb2NhdGlvbnM6e3dyaXRhYmxlOiEwLHZhbHVlOm5ldyBIYX0sc3RvcmVkTmFtZXM6e3dyaXRhYmxlOiEwLHZhbHVlOnt9fSxpbmRlbnRTdHI6e3dyaXRhYmxlOiEwLHZhbHVlOnZvaWQgMH0saWdub3JlTGlzdDp7d3JpdGFibGU6ITAsdmFsdWU6aS5pZ25vcmVMaXN0fX0pLHRoaXMuYnlTdGFydFswXT1zLHRoaXMuYnlFbmRbdC5sZW5ndGhdPXN9YWRkU291cmNlbWFwTG9jYXRpb24odCl7dGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMuYWRkKHQpfWFwcGVuZCh0KXtpZih0eXBlb2YgdCE9InN0cmluZyIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3V0cm8gY29udGVudCBtdXN0IGJlIGEgc3RyaW5nIik7cmV0dXJuIHRoaXMub3V0cm8rPXQsdGhpc31hcHBlbmRMZWZ0KHQsaSl7aWYodHlwZW9mIGkhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoImluc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZyIpO3RoaXMuX3NwbGl0KHQpO2NvbnN0IHM9dGhpcy5ieUVuZFt0XTtyZXR1cm4gcz9zLmFwcGVuZExlZnQoaSk6dGhpcy5pbnRybys9aSx0aGlzfWFwcGVuZFJpZ2h0KHQsaSl7aWYodHlwZW9mIGkhPSJzdHJpbmciKXRocm93IG5ldyBUeXBlRXJyb3IoImluc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZyIpO3RoaXMuX3NwbGl0KHQpO2NvbnN0IHM9dGhpcy5ieVN0YXJ0W3RdO3JldHVybiBzP3MuYXBwZW5kUmlnaHQoaSk6dGhpcy5vdXRybys9aSx0aGlzfWNsb25lKCl7Y29uc3QgdD1uZXcgWnQodGhpcy5vcmlnaW5hbCx7ZmlsZW5hbWU6dGhpcy5maWxlbmFtZX0pO2xldCBpPXRoaXMuZmlyc3RDaHVuayxzPXQuZmlyc3RDaHVuaz10Lmxhc3RTZWFyY2hlZENodW5rPWkuY2xvbmUoKTtmb3IoO2k7KXt0LmJ5U3RhcnRbcy5zdGFydF09cyx0LmJ5RW5kW3MuZW5kXT1zO2NvbnN0IG49aS5uZXh0LHI9biYmbi5jbG9uZSgpO3ImJihzLm5leHQ9cixyLnByZXZpb3VzPXMscz1yKSxpPW59cmV0dXJuIHQubGFzdENodW5rPXMsdGhpcy5pbmRlbnRFeGNsdXNpb25SYW5nZXMmJih0LmluZGVudEV4Y2x1c2lvblJhbmdlcz10aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlcy5zbGljZSgpKSx0LnNvdXJjZW1hcExvY2F0aW9ucz1uZXcgSGEodGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMpLHQuaW50cm89dGhpcy5pbnRybyx0Lm91dHJvPXRoaXMub3V0cm8sdH1nZW5lcmF0ZURlY29kZWRNYXAodCl7dD10fHx7fTtjb25zdCBpPU9iamVjdC5rZXlzKHRoaXMuc3RvcmVkTmFtZXMpLHM9bmV3IFhhKHQuaGlyZXMpLG49em4odGhpcy5vcmlnaW5hbCk7cmV0dXJuIHRoaXMuaW50cm8mJnMuYWR2YW5jZSh0aGlzLmludHJvKSx0aGlzLmZpcnN0Q2h1bmsuZWFjaE5leHQocj0+e2NvbnN0IGE9bihyLnN0YXJ0KTtyLmludHJvLmxlbmd0aCYmcy5hZHZhbmNlKHIuaW50cm8pLHIuZWRpdGVkP3MuYWRkRWRpdCgwLHIuY29udGVudCxhLHIuc3RvcmVOYW1lP2kuaW5kZXhPZihyLm9yaWdpbmFsKTotMSk6cy5hZGRVbmVkaXRlZENodW5rKDAscix0aGlzLm9yaWdpbmFsLGEsdGhpcy5zb3VyY2VtYXBMb2NhdGlvbnMpLHIub3V0cm8ubGVuZ3RoJiZzLmFkdmFuY2Uoci5vdXRybyl9KSx7ZmlsZTp0LmZpbGU/dC5maWxlLnNwbGl0KC9bL1xcXS8pLnBvcCgpOnZvaWQgMCxzb3VyY2VzOlt0LnNvdXJjZT9RYSh0LmZpbGV8fCIiLHQuc291cmNlKTp0LmZpbGV8fCIiXSxzb3VyY2VzQ29udGVudDp0LmluY2x1ZGVDb250ZW50P1t0aGlzLm9yaWdpbmFsXTp2b2lkIDAsbmFtZXM6aSxtYXBwaW5nczpzLnJhdyx4X2dvb2dsZV9pZ25vcmVMaXN0OnRoaXMuaWdub3JlTGlzdD9bMF06dm9pZCAwfX1nZW5lcmF0ZU1hcCh0KXtyZXR1cm4gbmV3IE5zKHRoaXMuZ2VuZXJhdGVEZWNvZGVkTWFwKHQpKX1fZW5zdXJlaW5kZW50U3RyKCl7dGhpcy5pbmRlbnRTdHI9PT12b2lkIDAmJih0aGlzLmluZGVudFN0cj1mdW5jdGlvbih0KXtjb25zdCBpPXQuc3BsaXQoYApgKSxzPWkuZmlsdGVyKGE9Pi9eXHQrLy50ZXN0KGEpKSxuPWkuZmlsdGVyKGE9Pi9eIHsyLH0vLnRlc3QoYSkpO2lmKHMubGVuZ3RoPT09MCYmbi5sZW5ndGg9PT0wKXJldHVybiBudWxsO2lmKHMubGVuZ3RoPj1uLmxlbmd0aClyZXR1cm4iCSI7Y29uc3Qgcj1uLnJlZHVjZSgoYSxvKT0+e2NvbnN0IGg9L14gKy8uZXhlYyhvKVswXS5sZW5ndGg7cmV0dXJuIE1hdGgubWluKGgsYSl9LDEvMCk7cmV0dXJuIG5ldyBBcnJheShyKzEpLmpvaW4oIiAiKX0odGhpcy5vcmlnaW5hbCkpfV9nZXRSYXdJbmRlbnRTdHJpbmcoKXtyZXR1cm4gdGhpcy5fZW5zdXJlaW5kZW50U3RyKCksdGhpcy5pbmRlbnRTdHJ9Z2V0SW5kZW50U3RyaW5nKCl7cmV0dXJuIHRoaXMuX2Vuc3VyZWluZGVudFN0cigpLHRoaXMuaW5kZW50U3RyPT09bnVsbD8iCSI6dGhpcy5pbmRlbnRTdHJ9aW5kZW50KHQsaSl7Y29uc3Qgcz0vXlteXHJcbl0vZ207aWYoWWEodCkmJihpPXQsdD12b2lkIDApLHQ9PT12b2lkIDAmJih0aGlzLl9lbnN1cmVpbmRlbnRTdHIoKSx0PXRoaXMuaW5kZW50U3RyfHwiCSIpLHQ9PT0iIilyZXR1cm4gdGhpcztjb25zdCBuPXt9OyhpPWl8fHt9KS5leGNsdWRlJiYodHlwZW9mIGkuZXhjbHVkZVswXT09Im51bWJlciI/W2kuZXhjbHVkZV06aS5leGNsdWRlKS5mb3JFYWNoKGw9Pntmb3IobGV0IGM9bFswXTtjPGxbMV07Yys9MSluW2NdPSEwfSk7bGV0IHI9aS5pbmRlbnRTdGFydCE9PSExO2NvbnN0IGE9bD0+cj9gJHt0fSR7bH1gOihyPSEwLGwpO3RoaXMuaW50cm89dGhpcy5pbnRyby5yZXBsYWNlKHMsYSk7bGV0IG89MCxoPXRoaXMuZmlyc3RDaHVuaztmb3IoO2g7KXtjb25zdCBsPWguZW5kO2lmKGguZWRpdGVkKW5bb118fChoLmNvbnRlbnQ9aC5jb250ZW50LnJlcGxhY2UocyxhKSxoLmNvbnRlbnQubGVuZ3RoJiYocj1oLmNvbnRlbnRbaC5jb250ZW50Lmxlbmd0aC0xXT09PWAKYCkpO2Vsc2UgZm9yKG89aC5zdGFydDtvPGw7KXtpZighbltvXSl7Y29uc3QgYz10aGlzLm9yaWdpbmFsW29dO2M9PT1gCmA/cj0hMDpjIT09IlxyIiYmciYmKHI9ITEsbz09PWguc3RhcnR8fCh0aGlzLl9zcGxpdENodW5rKGgsbyksaD1oLm5leHQpLGgucHJlcGVuZFJpZ2h0KHQpKX1vKz0xfW89aC5lbmQsaD1oLm5leHR9cmV0dXJuIHRoaXMub3V0cm89dGhpcy5vdXRyby5yZXBsYWNlKHMsYSksdGhpc31pbnNlcnQoKXt0aHJvdyBuZXcgRXJyb3IoIm1hZ2ljU3RyaW5nLmluc2VydCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBwcmVwZW5kUmlnaHQoLi4uKSBvciBhcHBlbmRMZWZ0KC4uLikiKX1pbnNlcnRMZWZ0KHQsaSl7cmV0dXJuIHhpLmluc2VydExlZnR8fChjb25zb2xlLndhcm4oIm1hZ2ljU3RyaW5nLmluc2VydExlZnQoLi4uKSBpcyBkZXByZWNhdGVkLiBVc2UgbWFnaWNTdHJpbmcuYXBwZW5kTGVmdCguLi4pIGluc3RlYWQiKSx4aS5pbnNlcnRMZWZ0PSEwKSx0aGlzLmFwcGVuZExlZnQodCxpKX1pbnNlcnRSaWdodCh0LGkpe3JldHVybiB4aS5pbnNlcnRSaWdodHx8KGNvbnNvbGUud2FybigibWFnaWNTdHJpbmcuaW5zZXJ0UmlnaHQoLi4uKSBpcyBkZXByZWNhdGVkLiBVc2UgbWFnaWNTdHJpbmcucHJlcGVuZFJpZ2h0KC4uLikgaW5zdGVhZCIpLHhpLmluc2VydFJpZ2h0PSEwKSx0aGlzLnByZXBlbmRSaWdodCh0LGkpfW1vdmUodCxpLHMpe2lmKHM+PXQmJnM8PWkpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgbW92ZSBhIHNlbGVjdGlvbiBpbnNpZGUgaXRzZWxmIik7dGhpcy5fc3BsaXQodCksdGhpcy5fc3BsaXQoaSksdGhpcy5fc3BsaXQocyk7Y29uc3Qgbj10aGlzLmJ5U3RhcnRbdF0scj10aGlzLmJ5RW5kW2ldLGE9bi5wcmV2aW91cyxvPXIubmV4dCxoPXRoaXMuYnlTdGFydFtzXTtpZighaCYmcj09PXRoaXMubGFzdENodW5rKXJldHVybiB0aGlzO2NvbnN0IGw9aD9oLnByZXZpb3VzOnRoaXMubGFzdENodW5rO3JldHVybiBhJiYoYS5uZXh0PW8pLG8mJihvLnByZXZpb3VzPWEpLGwmJihsLm5leHQ9biksaCYmKGgucHJldmlvdXM9ciksbi5wcmV2aW91c3x8KHRoaXMuZmlyc3RDaHVuaz1yLm5leHQpLHIubmV4dHx8KHRoaXMubGFzdENodW5rPW4ucHJldmlvdXMsdGhpcy5sYXN0Q2h1bmsubmV4dD1udWxsKSxuLnByZXZpb3VzPWwsci5uZXh0PWh8fG51bGwsbHx8KHRoaXMuZmlyc3RDaHVuaz1uKSxofHwodGhpcy5sYXN0Q2h1bms9ciksdGhpc31vdmVyd3JpdGUodCxpLHMsbil7cmV0dXJuIG49bnx8e30sdGhpcy51cGRhdGUodCxpLHMsey4uLm4sb3ZlcndyaXRlOiFuLmNvbnRlbnRPbmx5fSl9dXBkYXRlKHQsaSxzLG4pe2lmKHR5cGVvZiBzIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJyZXBsYWNlbWVudCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmciKTtmb3IoO3Q8MDspdCs9dGhpcy5vcmlnaW5hbC5sZW5ndGg7Zm9yKDtpPDA7KWkrPXRoaXMub3JpZ2luYWwubGVuZ3RoO2lmKGk+dGhpcy5vcmlnaW5hbC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJlbmQgaXMgb3V0IG9mIGJvdW5kcyIpO2lmKHQ9PT1pKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IG92ZXJ3cml0ZSBhIHplcm8tbGVuZ3RoIHJhbmdlIOKAkyB1c2UgYXBwZW5kTGVmdCBvciBwcmVwZW5kUmlnaHQgaW5zdGVhZCIpO3RoaXMuX3NwbGl0KHQpLHRoaXMuX3NwbGl0KGkpLG49PT0hMCYmKHhpLnN0b3JlTmFtZXx8KGNvbnNvbGUud2FybigiVGhlIGZpbmFsIGFyZ3VtZW50IHRvIG1hZ2ljU3RyaW5nLm92ZXJ3cml0ZSguLi4pIHNob3VsZCBiZSBhbiBvcHRpb25zIG9iamVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yaWNoLWhhcnJpcy9tYWdpYy1zdHJpbmciKSx4aS5zdG9yZU5hbWU9ITApLG49e3N0b3JlTmFtZTohMH0pO2NvbnN0IHI9biE9PXZvaWQgMCYmbi5zdG9yZU5hbWUsYT1uIT09dm9pZCAwJiZuLm92ZXJ3cml0ZTtpZihyKXtjb25zdCBsPXRoaXMub3JpZ2luYWwuc2xpY2UodCxpKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5zdG9yZWROYW1lcyxsLHt3cml0YWJsZTohMCx2YWx1ZTohMCxlbnVtZXJhYmxlOiEwfSl9Y29uc3Qgbz10aGlzLmJ5U3RhcnRbdF0saD10aGlzLmJ5RW5kW2ldO2lmKG8pe2xldCBsPW87Zm9yKDtsIT09aDspe2lmKGwubmV4dCE9PXRoaXMuYnlTdGFydFtsLmVuZF0pdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgb3ZlcndyaXRlIGFjcm9zcyBhIHNwbGl0IHBvaW50Iik7bD1sLm5leHQsbC5lZGl0KCIiLCExKX1vLmVkaXQocyxyLCFhKX1lbHNle2NvbnN0IGw9bmV3IEthKHQsaSwiIikuZWRpdChzLHIpO2gubmV4dD1sLGwucHJldmlvdXM9aH1yZXR1cm4gdGhpc31wcmVwZW5kKHQpe2lmKHR5cGVvZiB0IT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmciKTtyZXR1cm4gdGhpcy5pbnRybz10K3RoaXMuaW50cm8sdGhpc31wcmVwZW5kTGVmdCh0LGkpe2lmKHR5cGVvZiBpIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmciKTt0aGlzLl9zcGxpdCh0KTtjb25zdCBzPXRoaXMuYnlFbmRbdF07cmV0dXJuIHM/cy5wcmVwZW5kTGVmdChpKTp0aGlzLmludHJvPWkrdGhpcy5pbnRybyx0aGlzfXByZXBlbmRSaWdodCh0LGkpe2lmKHR5cGVvZiBpIT0ic3RyaW5nIil0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmciKTt0aGlzLl9zcGxpdCh0KTtjb25zdCBzPXRoaXMuYnlTdGFydFt0XTtyZXR1cm4gcz9zLnByZXBlbmRSaWdodChpKTp0aGlzLm91dHJvPWkrdGhpcy5vdXRybyx0aGlzfXJlbW92ZSh0LGkpe2Zvcig7dDwwOyl0Kz10aGlzLm9yaWdpbmFsLmxlbmd0aDtmb3IoO2k8MDspaSs9dGhpcy5vcmlnaW5hbC5sZW5ndGg7aWYodD09PWkpcmV0dXJuIHRoaXM7aWYodDwwfHxpPnRoaXMub3JpZ2luYWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcigiQ2hhcmFjdGVyIGlzIG91dCBvZiBib3VuZHMiKTtpZih0PmkpdGhyb3cgbmV3IEVycm9yKCJlbmQgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnQiKTt0aGlzLl9zcGxpdCh0KSx0aGlzLl9zcGxpdChpKTtsZXQgcz10aGlzLmJ5U3RhcnRbdF07Zm9yKDtzOylzLmludHJvPSIiLHMub3V0cm89IiIscy5lZGl0KCIiKSxzPWk+cy5lbmQ/dGhpcy5ieVN0YXJ0W3MuZW5kXTpudWxsO3JldHVybiB0aGlzfWxhc3RDaGFyKCl7aWYodGhpcy5vdXRyby5sZW5ndGgpcmV0dXJuIHRoaXMub3V0cm9bdGhpcy5vdXRyby5sZW5ndGgtMV07bGV0IHQ9dGhpcy5sYXN0Q2h1bms7ZG97aWYodC5vdXRyby5sZW5ndGgpcmV0dXJuIHQub3V0cm9bdC5vdXRyby5sZW5ndGgtMV07aWYodC5jb250ZW50Lmxlbmd0aClyZXR1cm4gdC5jb250ZW50W3QuY29udGVudC5sZW5ndGgtMV07aWYodC5pbnRyby5sZW5ndGgpcmV0dXJuIHQuaW50cm9bdC5pbnRyby5sZW5ndGgtMV19d2hpbGUodD10LnByZXZpb3VzKTtyZXR1cm4gdGhpcy5pbnRyby5sZW5ndGg/dGhpcy5pbnRyb1t0aGlzLmludHJvLmxlbmd0aC0xXToiIn1sYXN0TGluZSgpe2xldCB0PXRoaXMub3V0cm8ubGFzdEluZGV4T2YoVWkpO2lmKHQhPT0tMSlyZXR1cm4gdGhpcy5vdXRyby5zdWJzdHIodCsxKTtsZXQgaT10aGlzLm91dHJvLHM9dGhpcy5sYXN0Q2h1bms7ZG97aWYocy5vdXRyby5sZW5ndGg+MCl7aWYodD1zLm91dHJvLmxhc3RJbmRleE9mKFVpKSx0IT09LTEpcmV0dXJuIHMub3V0cm8uc3Vic3RyKHQrMSkraTtpPXMub3V0cm8raX1pZihzLmNvbnRlbnQubGVuZ3RoPjApe2lmKHQ9cy5jb250ZW50Lmxhc3RJbmRleE9mKFVpKSx0IT09LTEpcmV0dXJuIHMuY29udGVudC5zdWJzdHIodCsxKStpO2k9cy5jb250ZW50K2l9aWYocy5pbnRyby5sZW5ndGg+MCl7aWYodD1zLmludHJvLmxhc3RJbmRleE9mKFVpKSx0IT09LTEpcmV0dXJuIHMuaW50cm8uc3Vic3RyKHQrMSkraTtpPXMuaW50cm8raX19d2hpbGUocz1zLnByZXZpb3VzKTtyZXR1cm4gdD10aGlzLmludHJvLmxhc3RJbmRleE9mKFVpKSx0IT09LTE/dGhpcy5pbnRyby5zdWJzdHIodCsxKStpOnRoaXMuaW50cm8raX1zbGljZSh0PTAsaT10aGlzLm9yaWdpbmFsLmxlbmd0aCl7Zm9yKDt0PDA7KXQrPXRoaXMub3JpZ2luYWwubGVuZ3RoO2Zvcig7aTwwOylpKz10aGlzLm9yaWdpbmFsLmxlbmd0aDtsZXQgcz0iIixuPXRoaXMuZmlyc3RDaHVuaztmb3IoO24mJihuLnN0YXJ0PnR8fG4uZW5kPD10KTspe2lmKG4uc3RhcnQ8aSYmbi5lbmQ+PWkpcmV0dXJuIHM7bj1uLm5leHR9aWYobiYmbi5lZGl0ZWQmJm4uc3RhcnQhPT10KXRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVzZSByZXBsYWNlZCBjaGFyYWN0ZXIgJHt0fSBhcyBzbGljZSBzdGFydCBhbmNob3IuYCk7Y29uc3Qgcj1uO2Zvcig7bjspeyFuLmludHJvfHxyPT09biYmbi5zdGFydCE9PXR8fChzKz1uLmludHJvKTtjb25zdCBhPW4uc3RhcnQ8aSYmbi5lbmQ+PWk7aWYoYSYmbi5lZGl0ZWQmJm4uZW5kIT09aSl0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB1c2UgcmVwbGFjZWQgY2hhcmFjdGVyICR7aX0gYXMgc2xpY2UgZW5kIGFuY2hvci5gKTtjb25zdCBvPXI9PT1uP3Qtbi5zdGFydDowLGg9YT9uLmNvbnRlbnQubGVuZ3RoK2ktbi5lbmQ6bi5jb250ZW50Lmxlbmd0aDtpZihzKz1uLmNvbnRlbnQuc2xpY2UobyxoKSwhbi5vdXRyb3x8YSYmbi5lbmQhPT1pfHwocys9bi5vdXRybyksYSlicmVhaztuPW4ubmV4dH1yZXR1cm4gc31zbmlwKHQsaSl7Y29uc3Qgcz10aGlzLmNsb25lKCk7cmV0dXJuIHMucmVtb3ZlKDAsdCkscy5yZW1vdmUoaSxzLm9yaWdpbmFsLmxlbmd0aCksc31fc3BsaXQodCl7aWYodGhpcy5ieVN0YXJ0W3RdfHx0aGlzLmJ5RW5kW3RdKXJldHVybjtsZXQgaT10aGlzLmxhc3RTZWFyY2hlZENodW5rO2NvbnN0IHM9dD5pLmVuZDtmb3IoO2k7KXtpZihpLmNvbnRhaW5zKHQpKXJldHVybiB0aGlzLl9zcGxpdENodW5rKGksdCk7aT1zP3RoaXMuYnlTdGFydFtpLmVuZF06dGhpcy5ieUVuZFtpLnN0YXJ0XX19X3NwbGl0Q2h1bmsodCxpKXtpZih0LmVkaXRlZCYmdC5jb250ZW50Lmxlbmd0aCl7Y29uc3Qgbj16bih0aGlzLm9yaWdpbmFsKShpKTt0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzcGxpdCBhIGNodW5rIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBlZGl0ZWQgKCR7bi5saW5lfToke24uY29sdW1ufSDigJMgIiR7dC5vcmlnaW5hbH0iKWApfWNvbnN0IHM9dC5zcGxpdChpKTtyZXR1cm4gdGhpcy5ieUVuZFtpXT10LHRoaXMuYnlTdGFydFtpXT1zLHRoaXMuYnlFbmRbcy5lbmRdPXMsdD09PXRoaXMubGFzdENodW5rJiYodGhpcy5sYXN0Q2h1bms9cyksdGhpcy5sYXN0U2VhcmNoZWRDaHVuaz10LCEwfXRvU3RyaW5nKCl7bGV0IHQ9dGhpcy5pbnRybyxpPXRoaXMuZmlyc3RDaHVuaztmb3IoO2k7KXQrPWkudG9TdHJpbmcoKSxpPWkubmV4dDtyZXR1cm4gdCt0aGlzLm91dHJvfWlzRW1wdHkoKXtsZXQgdD10aGlzLmZpcnN0Q2h1bms7ZG8gaWYodC5pbnRyby5sZW5ndGgmJnQuaW50cm8udHJpbSgpfHx0LmNvbnRlbnQubGVuZ3RoJiZ0LmNvbnRlbnQudHJpbSgpfHx0Lm91dHJvLmxlbmd0aCYmdC5vdXRyby50cmltKCkpcmV0dXJuITE7d2hpbGUodD10Lm5leHQpO3JldHVybiEwfWxlbmd0aCgpe2xldCB0PXRoaXMuZmlyc3RDaHVuayxpPTA7ZG8gaSs9dC5pbnRyby5sZW5ndGgrdC5jb250ZW50Lmxlbmd0aCt0Lm91dHJvLmxlbmd0aDt3aGlsZSh0PXQubmV4dCk7cmV0dXJuIGl9dHJpbUxpbmVzKCl7cmV0dXJuIHRoaXMudHJpbSgiW1xcclxcbl0iKX10cmltKHQpe3JldHVybiB0aGlzLnRyaW1TdGFydCh0KS50cmltRW5kKHQpfXRyaW1FbmRBYm9ydGVkKHQpe2NvbnN0IGk9bmV3IFJlZ0V4cCgodHx8IlxccyIpKyIrJCIpO2lmKHRoaXMub3V0cm89dGhpcy5vdXRyby5yZXBsYWNlKGksIiIpLHRoaXMub3V0cm8ubGVuZ3RoKXJldHVybiEwO2xldCBzPXRoaXMubGFzdENodW5rO2Rve2NvbnN0IG49cy5lbmQscj1zLnRyaW1FbmQoaSk7aWYocy5lbmQhPT1uJiYodGhpcy5sYXN0Q2h1bms9PT1zJiYodGhpcy5sYXN0Q2h1bms9cy5uZXh0KSx0aGlzLmJ5RW5kW3MuZW5kXT1zLHRoaXMuYnlTdGFydFtzLm5leHQuc3RhcnRdPXMubmV4dCx0aGlzLmJ5RW5kW3MubmV4dC5lbmRdPXMubmV4dCkscilyZXR1cm4hMDtzPXMucHJldmlvdXN9d2hpbGUocyk7cmV0dXJuITF9dHJpbUVuZCh0KXtyZXR1cm4gdGhpcy50cmltRW5kQWJvcnRlZCh0KSx0aGlzfXRyaW1TdGFydEFib3J0ZWQodCl7Y29uc3QgaT1uZXcgUmVnRXhwKCJeIisodHx8IlxccyIpKyIrIik7aWYodGhpcy5pbnRybz10aGlzLmludHJvLnJlcGxhY2UoaSwiIiksdGhpcy5pbnRyby5sZW5ndGgpcmV0dXJuITA7bGV0IHM9dGhpcy5maXJzdENodW5rO2Rve2NvbnN0IG49cy5lbmQscj1zLnRyaW1TdGFydChpKTtpZihzLmVuZCE9PW4mJihzPT09dGhpcy5sYXN0Q2h1bmsmJih0aGlzLmxhc3RDaHVuaz1zLm5leHQpLHRoaXMuYnlFbmRbcy5lbmRdPXMsdGhpcy5ieVN0YXJ0W3MubmV4dC5zdGFydF09cy5uZXh0LHRoaXMuYnlFbmRbcy5uZXh0LmVuZF09cy5uZXh0KSxyKXJldHVybiEwO3M9cy5uZXh0fXdoaWxlKHMpO3JldHVybiExfXRyaW1TdGFydCh0KXtyZXR1cm4gdGhpcy50cmltU3RhcnRBYm9ydGVkKHQpLHRoaXN9aGFzQ2hhbmdlZCgpe3JldHVybiB0aGlzLm9yaWdpbmFsIT09dGhpcy50b1N0cmluZygpfV9yZXBsYWNlUmVnZXhwKHQsaSl7ZnVuY3Rpb24gcyhuLHIpe3JldHVybiB0eXBlb2YgaT09InN0cmluZyI/aS5yZXBsYWNlKC9cJChcJHwmfFxkKykvZywoYSxvKT0+bz09PSIkIj8iJCI6bz09PSImIj9uWzBdOitvPG4ubGVuZ3RoP25bK29dOmAkJHtvfWApOmkoLi4ubixuLmluZGV4LHIsbi5ncm91cHMpfWlmKHQuZ2xvYmFsKShmdW5jdGlvbihuLHIpe2xldCBhO2NvbnN0IG89W107Zm9yKDthPW4uZXhlYyhyKTspby5wdXNoKGEpO3JldHVybiBvfSkodCx0aGlzLm9yaWdpbmFsKS5mb3JFYWNoKG49PntuLmluZGV4IT1udWxsJiZ0aGlzLm92ZXJ3cml0ZShuLmluZGV4LG4uaW5kZXgrblswXS5sZW5ndGgscyhuLHRoaXMub3JpZ2luYWwpKX0pO2Vsc2V7Y29uc3Qgbj10aGlzLm9yaWdpbmFsLm1hdGNoKHQpO24mJm4uaW5kZXghPW51bGwmJnRoaXMub3ZlcndyaXRlKG4uaW5kZXgsbi5pbmRleCtuWzBdLmxlbmd0aCxzKG4sdGhpcy5vcmlnaW5hbCkpfXJldHVybiB0aGlzfV9yZXBsYWNlU3RyaW5nKHQsaSl7Y29uc3R7b3JpZ2luYWw6c309dGhpcyxuPXMuaW5kZXhPZih0KTtyZXR1cm4gbiE9PS0xJiZ0aGlzLm92ZXJ3cml0ZShuLG4rdC5sZW5ndGgsaSksdGhpc31yZXBsYWNlKHQsaSl7cmV0dXJuIHR5cGVvZiB0PT0ic3RyaW5nIj90aGlzLl9yZXBsYWNlU3RyaW5nKHQsaSk6dGhpcy5fcmVwbGFjZVJlZ2V4cCh0LGkpfV9yZXBsYWNlQWxsU3RyaW5nKHQsaSl7Y29uc3R7b3JpZ2luYWw6c309dGhpcyxuPXQubGVuZ3RoO2ZvcihsZXQgcj1zLmluZGV4T2YodCk7ciE9PS0xO3I9cy5pbmRleE9mKHQscituKSl0aGlzLm92ZXJ3cml0ZShyLHIrbixpKTtyZXR1cm4gdGhpc31yZXBsYWNlQWxsKHQsaSl7aWYodHlwZW9mIHQ9PSJzdHJpbmciKXJldHVybiB0aGlzLl9yZXBsYWNlQWxsU3RyaW5nKHQsaSk7aWYoIXQuZ2xvYmFsKXRocm93IG5ldyBUeXBlRXJyb3IoIk1hZ2ljU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlQWxsIGNhbGxlZCB3aXRoIGEgbm9uLWdsb2JhbCBSZWdFeHAgYXJndW1lbnQiKTtyZXR1cm4gdGhpcy5fcmVwbGFjZVJlZ2V4cCh0LGkpfX1jb25zdCBaYT1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2xldCBrYz1jbGFzcyB5Y3tjb25zdHJ1Y3Rvcih0PXt9KXt0aGlzLmludHJvPXQuaW50cm98fCIiLHRoaXMuc2VwYXJhdG9yPXQuc2VwYXJhdG9yIT09dm9pZCAwP3Quc2VwYXJhdG9yOmAKYCx0aGlzLnNvdXJjZXM9W10sdGhpcy51bmlxdWVTb3VyY2VzPVtdLHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lPXt9fWFkZFNvdXJjZSh0KXtpZih0IGluc3RhbmNlb2YgWnQpcmV0dXJuIHRoaXMuYWRkU291cmNlKHtjb250ZW50OnQsZmlsZW5hbWU6dC5maWxlbmFtZSxzZXBhcmF0b3I6dGhpcy5zZXBhcmF0b3J9KTtpZighWWEodCl8fCF0LmNvbnRlbnQpdGhyb3cgbmV3IEVycm9yKCJidW5kbGUuYWRkU291cmNlKCkgdGFrZXMgYW4gb2JqZWN0IHdpdGggYSBgY29udGVudGAgcHJvcGVydHksIHdoaWNoIHNob3VsZCBiZSBhbiBpbnN0YW5jZSBvZiBNYWdpY1N0cmluZywgYW5kIGFuIG9wdGlvbmFsIGBmaWxlbmFtZWAiKTtpZihbImZpbGVuYW1lIiwiaWdub3JlTGlzdCIsImluZGVudEV4Y2x1c2lvblJhbmdlcyIsInNlcGFyYXRvciJdLmZvckVhY2goaT0+e1phLmNhbGwodCxpKXx8KHRbaV09dC5jb250ZW50W2ldKX0pLHQuc2VwYXJhdG9yPT09dm9pZCAwJiYodC5zZXBhcmF0b3I9dGhpcy5zZXBhcmF0b3IpLHQuZmlsZW5hbWUpaWYoWmEuY2FsbCh0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSx0LmZpbGVuYW1lKSl7Y29uc3QgaT10aGlzLnVuaXF1ZVNvdXJjZXNbdGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWVbdC5maWxlbmFtZV1dO2lmKHQuY29udGVudC5vcmlnaW5hbCE9PWkuY29udGVudCl0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgc291cmNlOiBzYW1lIGZpbGVuYW1lICgke3QuZmlsZW5hbWV9KSwgZGlmZmVyZW50IGNvbnRlbnRzYCl9ZWxzZSB0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVt0LmZpbGVuYW1lXT10aGlzLnVuaXF1ZVNvdXJjZXMubGVuZ3RoLHRoaXMudW5pcXVlU291cmNlcy5wdXNoKHtmaWxlbmFtZTp0LmZpbGVuYW1lLGNvbnRlbnQ6dC5jb250ZW50Lm9yaWdpbmFsfSk7cmV0dXJuIHRoaXMuc291cmNlcy5wdXNoKHQpLHRoaXN9YXBwZW5kKHQsaSl7cmV0dXJuIHRoaXMuYWRkU291cmNlKHtjb250ZW50Om5ldyBadCh0KSxzZXBhcmF0b3I6aSYmaS5zZXBhcmF0b3J8fCIifSksdGhpc31jbG9uZSgpe2NvbnN0IHQ9bmV3IHljKHtpbnRybzp0aGlzLmludHJvLHNlcGFyYXRvcjp0aGlzLnNlcGFyYXRvcn0pO3JldHVybiB0aGlzLnNvdXJjZXMuZm9yRWFjaChpPT57dC5hZGRTb3VyY2Uoe2ZpbGVuYW1lOmkuZmlsZW5hbWUsY29udGVudDppLmNvbnRlbnQuY2xvbmUoKSxzZXBhcmF0b3I6aS5zZXBhcmF0b3J9KX0pLHR9Z2VuZXJhdGVEZWNvZGVkTWFwKHQ9e30pe2NvbnN0IGk9W107bGV0IHM7dGhpcy5zb3VyY2VzLmZvckVhY2gocj0+e09iamVjdC5rZXlzKHIuY29udGVudC5zdG9yZWROYW1lcykuZm9yRWFjaChhPT57fmkuaW5kZXhPZihhKXx8aS5wdXNoKGEpfSl9KTtjb25zdCBuPW5ldyBYYSh0LmhpcmVzKTtyZXR1cm4gdGhpcy5pbnRybyYmbi5hZHZhbmNlKHRoaXMuaW50cm8pLHRoaXMuc291cmNlcy5mb3JFYWNoKChyLGEpPT57YT4wJiZuLmFkdmFuY2UodGhpcy5zZXBhcmF0b3IpO2NvbnN0IG89ci5maWxlbmFtZT90aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVtyLmZpbGVuYW1lXTotMSxoPXIuY29udGVudCxsPXpuKGgub3JpZ2luYWwpO2guaW50cm8mJm4uYWR2YW5jZShoLmludHJvKSxoLmZpcnN0Q2h1bmsuZWFjaE5leHQoYz0+e2NvbnN0IHA9bChjLnN0YXJ0KTtjLmludHJvLmxlbmd0aCYmbi5hZHZhbmNlKGMuaW50cm8pLHIuZmlsZW5hbWU/Yy5lZGl0ZWQ/bi5hZGRFZGl0KG8sYy5jb250ZW50LHAsYy5zdG9yZU5hbWU/aS5pbmRleE9mKGMub3JpZ2luYWwpOi0xKTpuLmFkZFVuZWRpdGVkQ2h1bmsobyxjLGgub3JpZ2luYWwscCxoLnNvdXJjZW1hcExvY2F0aW9ucyk6bi5hZHZhbmNlKGMuY29udGVudCksYy5vdXRyby5sZW5ndGgmJm4uYWR2YW5jZShjLm91dHJvKX0pLGgub3V0cm8mJm4uYWR2YW5jZShoLm91dHJvKSxyLmlnbm9yZUxpc3QmJm8hPT0tMSYmKHM9PT12b2lkIDAmJihzPVtdKSxzLnB1c2gobykpfSkse2ZpbGU6dC5maWxlP3QuZmlsZS5zcGxpdCgvWy9cXF0vKS5wb3AoKTp2b2lkIDAsc291cmNlczp0aGlzLnVuaXF1ZVNvdXJjZXMubWFwKHI9PnQuZmlsZT9RYSh0LmZpbGUsci5maWxlbmFtZSk6ci5maWxlbmFtZSksc291cmNlc0NvbnRlbnQ6dGhpcy51bmlxdWVTb3VyY2VzLm1hcChyPT50LmluY2x1ZGVDb250ZW50P3IuY29udGVudDpudWxsKSxuYW1lczppLG1hcHBpbmdzOm4ucmF3LHhfZ29vZ2xlX2lnbm9yZUxpc3Q6c319Z2VuZXJhdGVNYXAodCl7cmV0dXJuIG5ldyBOcyh0aGlzLmdlbmVyYXRlRGVjb2RlZE1hcCh0KSl9Z2V0SW5kZW50U3RyaW5nKCl7Y29uc3QgdD17fTtyZXR1cm4gdGhpcy5zb3VyY2VzLmZvckVhY2goaT0+e2NvbnN0IHM9aS5jb250ZW50Ll9nZXRSYXdJbmRlbnRTdHJpbmcoKTtzIT09bnVsbCYmKHRbc118fCh0W3NdPTApLHRbc10rPTEpfSksT2JqZWN0LmtleXModCkuc29ydCgoaSxzKT0+dFtpXS10W3NdKVswXXx8IgkifWluZGVudCh0KXtpZihhcmd1bWVudHMubGVuZ3RofHwodD10aGlzLmdldEluZGVudFN0cmluZygpKSx0PT09IiIpcmV0dXJuIHRoaXM7bGV0IGk9IXRoaXMuaW50cm98fHRoaXMuaW50cm8uc2xpY2UoLTEpPT09YApgO3JldHVybiB0aGlzLnNvdXJjZXMuZm9yRWFjaCgocyxuKT0+e2NvbnN0IHI9cy5zZXBhcmF0b3IhPT12b2lkIDA/cy5zZXBhcmF0b3I6dGhpcy5zZXBhcmF0b3IsYT1pfHxuPjAmJi9ccj9cbiQvLnRlc3Qocik7cy5jb250ZW50LmluZGVudCh0LHtleGNsdWRlOnMuaW5kZW50RXhjbHVzaW9uUmFuZ2VzLGluZGVudFN0YXJ0OmF9KSxpPXMuY29udGVudC5sYXN0Q2hhcigpPT09YApgfSksdGhpcy5pbnRybyYmKHRoaXMuaW50cm89dCt0aGlzLmludHJvLnJlcGxhY2UoL15bXlxuXS9nbSwocyxuKT0+bj4wP3QrczpzKSksdGhpc31wcmVwZW5kKHQpe3JldHVybiB0aGlzLmludHJvPXQrdGhpcy5pbnRybyx0aGlzfXRvU3RyaW5nKCl7Y29uc3QgdD10aGlzLnNvdXJjZXMubWFwKChpLHMpPT57Y29uc3Qgbj1pLnNlcGFyYXRvciE9PXZvaWQgMD9pLnNlcGFyYXRvcjp0aGlzLnNlcGFyYXRvcjtyZXR1cm4ocz4wP246IiIpK2kuY29udGVudC50b1N0cmluZygpfSkuam9pbigiIik7cmV0dXJuIHRoaXMuaW50cm8rdH1pc0VtcHR5KCl7cmV0dXJuKCF0aGlzLmludHJvLmxlbmd0aHx8IXRoaXMuaW50cm8udHJpbSgpKSYmIXRoaXMuc291cmNlcy5zb21lKHQ9PiF0LmNvbnRlbnQuaXNFbXB0eSgpKX1sZW5ndGgoKXtyZXR1cm4gdGhpcy5zb3VyY2VzLnJlZHVjZSgodCxpKT0+dCtpLmNvbnRlbnQubGVuZ3RoKCksdGhpcy5pbnRyby5sZW5ndGgpfXRyaW1MaW5lcygpe3JldHVybiB0aGlzLnRyaW0oIltcXHJcXG5dIil9dHJpbSh0KXtyZXR1cm4gdGhpcy50cmltU3RhcnQodCkudHJpbUVuZCh0KX10cmltU3RhcnQodCl7Y29uc3QgaT1uZXcgUmVnRXhwKCJeIisodHx8IlxccyIpKyIrIik7aWYodGhpcy5pbnRybz10aGlzLmludHJvLnJlcGxhY2UoaSwiIiksIXRoaXMuaW50cm8pe2xldCBzLG49MDtkbyBpZihzPXRoaXMuc291cmNlc1tuKytdLCFzKWJyZWFrO3doaWxlKCFzLmNvbnRlbnQudHJpbVN0YXJ0QWJvcnRlZCh0KSl9cmV0dXJuIHRoaXN9dHJpbUVuZCh0KXtjb25zdCBpPW5ldyBSZWdFeHAoKHR8fCJcXHMiKSsiKyQiKTtsZXQgcyxuPXRoaXMuc291cmNlcy5sZW5ndGgtMTtkbyBpZihzPXRoaXMuc291cmNlc1tuLS1dLCFzKXt0aGlzLmludHJvPXRoaXMuaW50cm8ucmVwbGFjZShpLCIiKTticmVha313aGlsZSghcy5jb250ZW50LnRyaW1FbmRBYm9ydGVkKHQpKTtyZXR1cm4gdGhpc319O2NvbnN0IHdjPS9eKD86XC98KD86W0EtWmEtel06KT9bL1xcfF0pLyxBYz0vXlwuP1wuXC8vLENjPS9cXC9nLGJpPS9bL1xcXS8sSWM9L1wuW14uXSskLztmdW5jdGlvbiBWdChlKXtyZXR1cm4gd2MudGVzdChlKX1mdW5jdGlvbiBqbihlKXtyZXR1cm4gQWMudGVzdChlKX1mdW5jdGlvbiBHaShlKXtyZXR1cm4gZS5yZXBsYWNlKENjLCIvIil9ZnVuY3Rpb24gQ3QoZSl7cmV0dXJuIGUuc3BsaXQoYmkpLnBvcCgpfHwiIn1mdW5jdGlvbiBKdChlKXtjb25zdCB0PS9bL1xcXVteL1xcXSokLy5leGVjKGUpO3JldHVybiB0P2Uuc2xpY2UoMCwtdFswXS5sZW5ndGgpfHwiLyI6Ii4ifWZ1bmN0aW9uIE10KGUpe2NvbnN0IHQ9SWMuZXhlYyhDdChlKSk7cmV0dXJuIHQ/dFswXToiIn1mdW5jdGlvbiB2aShlLHQpe2NvbnN0IGk9ZS5zcGxpdChiaSkuZmlsdGVyKEJvb2xlYW4pLHM9dC5zcGxpdChiaSkuZmlsdGVyKEJvb2xlYW4pO2ZvcihpWzBdPT09Ii4iJiZpLnNoaWZ0KCksc1swXT09PSIuIiYmcy5zaGlmdCgpO2lbMF0mJnNbMF0mJmlbMF09PT1zWzBdOylpLnNoaWZ0KCkscy5zaGlmdCgpO2Zvcig7c1swXT09PSIuLiImJmkubGVuZ3RoPjA7KXMuc2hpZnQoKSxpLnBvcCgpO2Zvcig7aS5wb3AoKTspcy51bnNoaWZ0KCIuLiIpO3JldHVybiBzLmpvaW4oIi8iKX1mdW5jdGlvbiBodCguLi5lKXtjb25zdCB0PWUuc2hpZnQoKTtpZighdClyZXR1cm4iLyI7bGV0IGk9dC5zcGxpdChiaSk7Zm9yKGNvbnN0IHMgb2YgZSlpZihWdChzKSlpPXMuc3BsaXQoYmkpO2Vsc2V7Y29uc3Qgbj1zLnNwbGl0KGJpKTtmb3IoO25bMF09PT0iLiJ8fG5bMF09PT0iLi4iOyluLnNoaWZ0KCk9PT0iLi4iJiZpLnBvcCgpO2kucHVzaCguLi5uKX1yZXR1cm4gaS5qb2luKCIvIil9Y29uc3QgUGM9L1tcblxyJ1xcXHUyMDI4XHUyMDI5XS8sX2M9LyhbXG5ccidcdTIwMjhcdTIwMjldKS9nLE5jPS9cXC9nO2Z1bmN0aW9uICRzKGUpe3JldHVybiBQYy50ZXN0KGUpP2UucmVwbGFjZShOYywiXFxcXCIpLnJlcGxhY2UoX2MsIlxcJDEiKTplfWZ1bmN0aW9uIFVuKGUpe2NvbnN0IHQ9Q3QoZSk7cmV0dXJuIHQuc2xpY2UoMCxNYXRoLm1heCgwLHQubGVuZ3RoLU10KGUpLmxlbmd0aCkpfWZ1bmN0aW9uIFgoZSl7cmV0dXJuIFZ0KGUpP3ZpKGh0KCksZSk6ZX1mdW5jdGlvbiBMcyhlKXtyZXR1cm4gZVswXT09PSIvInx8ZVswXT09PSIuIiYmKGVbMV09PT0iLyJ8fGVbMV09PT0iLiIpfHxWdChlKX1jb25zdCAkYz0vXihcLlwuXC8pKlwuXC4kLztmdW5jdGlvbiBKYShlLHQsaSxzKXtmb3IoO3Quc3RhcnRzV2l0aCgiLi4vIik7KXQ9dC5zbGljZSgzKSxlPSJfLyIrZTtsZXQgbj1HaSh2aShKdChlKSx0KSk7aWYoaSYmbi5lbmRzV2l0aCgiLmpzIikmJihuPW4uc2xpY2UoMCwtMykpLHMpe2lmKG49PT0iIilyZXR1cm4iLi4vIitDdCh0KTtpZigkYy50ZXN0KG4pKXJldHVyblsuLi5uLnNwbGl0KCIvIiksIi4uIixDdCh0KV0uam9pbigiLyIpfXJldHVybiBuP24uc3RhcnRzV2l0aCgiLi4iKT9uOiIuLyIrbjoiLiJ9Y2xhc3MgRWl7Y29uc3RydWN0b3IodCxpLHMpe3RoaXMub3B0aW9ucz1pLHRoaXMuaW5wdXRCYXNlPXMsdGhpcy5kZWZhdWx0VmFyaWFibGVOYW1lPSIiLHRoaXMubmFtZXNwYWNlVmFyaWFibGVOYW1lPSIiLHRoaXMudmFyaWFibGVOYW1lPSIiLHRoaXMuZmlsZU5hbWU9bnVsbCx0aGlzLmltcG9ydEFzc2VydGlvbnM9bnVsbCx0aGlzLmlkPXQuaWQsdGhpcy5tb2R1bGVJbmZvPXQuaW5mbyx0aGlzLnJlbm9ybWFsaXplUmVuZGVyUGF0aD10LnJlbm9ybWFsaXplUmVuZGVyUGF0aCx0aGlzLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZT10LnN1Z2dlc3RlZFZhcmlhYmxlTmFtZX1nZXRGaWxlTmFtZSgpe2lmKHRoaXMuZmlsZU5hbWUpcmV0dXJuIHRoaXMuZmlsZU5hbWU7Y29uc3R7cGF0aHM6dH09dGhpcy5vcHRpb25zO3JldHVybiB0aGlzLmZpbGVOYW1lPSh0eXBlb2YgdD09ImZ1bmN0aW9uIj90KHRoaXMuaWQpOnRbdGhpcy5pZF0pfHwodGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGg/R2kodmkodGhpcy5pbnB1dEJhc2UsdGhpcy5pZCkpOnRoaXMuaWQpfWdldEltcG9ydEFzc2VydGlvbnModCl7cmV0dXJuIHRoaXMuaW1wb3J0QXNzZXJ0aW9uc3x8KHRoaXMuaW1wb3J0QXNzZXJ0aW9ucz1mdW5jdGlvbihpLHtnZXRPYmplY3Q6c30pe2lmKCFpKXJldHVybiBudWxsO2NvbnN0IG49T2JqZWN0LmVudHJpZXMoaSkubWFwKChbcixhXSk9PltyLGAnJHthfSdgXSk7cmV0dXJuIG4ubGVuZ3RoPjA/cyhuLHtsaW5lQnJlYWtJbmRlbnQ6bnVsbH0pOm51bGx9KHRoaXMub3B0aW9ucy5mb3JtYXQ9PT0iZXMiJiZ0aGlzLm9wdGlvbnMuZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zJiZ0aGlzLm1vZHVsZUluZm8uYXNzZXJ0aW9ucyx0KSl9Z2V0SW1wb3J0UGF0aCh0KXtyZXR1cm4gJHModGhpcy5yZW5vcm1hbGl6ZVJlbmRlclBhdGg/SmEodCx0aGlzLmdldEZpbGVOYW1lKCksdGhpcy5vcHRpb25zLmZvcm1hdD09PSJhbWQiLCExKTp0aGlzLmdldEZpbGVOYW1lKCkpfX1mdW5jdGlvbiBHZShlLHQsaSl7Y29uc3Qgcz1lLmdldCh0KTtpZihzIT09dm9pZCAwKXJldHVybiBzO2NvbnN0IG49aSgpO3JldHVybiBlLnNldCh0LG4pLG59ZnVuY3Rpb24gZWkoKXtyZXR1cm4gbmV3IFNldH1mdW5jdGlvbiBlbygpe3JldHVybltdfWNvbnN0IGhlPVN5bWJvbCgiVW5rbm93biBLZXkiKSxUcz1TeW1ib2woIlVua25vd24gTm9uLUFjY2Vzc29yIEtleSIpLFdpPVN5bWJvbCgiVW5rbm93biBJbnRlZ2VyIiksR249U3ltYm9sKCJTeW1ib2wudG9TdHJpbmdUYWciKSxRPVtdLHRlPVtoZV0sTGM9W1RzXSxXbj1bV2ldLFNpPVN5bWJvbCgiRW50aXRpZXMiKTtjbGFzcyBraXtjb25zdHJ1Y3Rvcigpe3RoaXMuZW50aXR5UGF0aHM9T2JqZWN0LmNyZWF0ZShudWxsLHtbU2ldOnt2YWx1ZTpuZXcgU2V0fX0pfXRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHQsaSl7Y29uc3Qgcz10aGlzLmdldEVudGl0aWVzKHQpO3JldHVybiEhcy5oYXMoaSl8fChzLmFkZChpKSwhMSl9d2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgodCxpLHMsbil7Y29uc3Qgcj10aGlzLmdldEVudGl0aWVzKHQpO2lmKHIuaGFzKGkpKXJldHVybiBuO3IuYWRkKGkpO2NvbnN0IGE9cygpO3JldHVybiByLmRlbGV0ZShpKSxhfWdldEVudGl0aWVzKHQpe2xldCBpPXRoaXMuZW50aXR5UGF0aHM7Zm9yKGNvbnN0IHMgb2YgdClpPWlbc109aVtzXXx8T2JqZWN0LmNyZWF0ZShudWxsLHtbU2ldOnt2YWx1ZTpuZXcgU2V0fX0pO3JldHVybiBpW1NpXX19Y29uc3QgQWU9bmV3IGtpO2NsYXNzIHRve2NvbnN0cnVjdG9yKCl7dGhpcy5lbnRpdHlQYXRocz1PYmplY3QuY3JlYXRlKG51bGwse1tTaV06e3ZhbHVlOm5ldyBNYXB9fSl9dHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCxpLHMpe2xldCBuPXRoaXMuZW50aXR5UGF0aHM7Zm9yKGNvbnN0IGEgb2YgdCluPW5bYV09blthXXx8T2JqZWN0LmNyZWF0ZShudWxsLHtbU2ldOnt2YWx1ZTpuZXcgTWFwfX0pO2NvbnN0IHI9R2UobltTaV0saSxlaSk7cmV0dXJuISFyLmhhcyhzKXx8KHIuYWRkKHMpLCExKX19Y29uc3QgbWU9U3ltYm9sKCJVbmtub3duIFZhbHVlIiksaW89U3ltYm9sKCJVbmtub3duIFRydXRoeSBWYWx1ZSIpO2NsYXNzIFdle2NvbnN0cnVjdG9yKCl7dGhpcy5pbmNsdWRlZD0hMX1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7RHQodCl9ZGVvcHRpbWl6ZVBhdGgodCl7fWdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl7cmV0dXJuIG1lfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pe3JldHVybiBiZX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7cmV0dXJuITB9aW5jbHVkZSh0LGkscyl7dGhpcy5pbmNsdWRlZD0hMH1pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LGkpe2Zvcihjb25zdCBzIG9mIGkpcy5pbmNsdWRlKHQsITEpfXNob3VsZEJlSW5jbHVkZWQodCl7cmV0dXJuITB9fWNvbnN0IFk9bmV3IGNsYXNzIGV4dGVuZHMgV2V7fSxiZT1bWSwhMV0sRHQ9ZT0+e2Zvcihjb25zdCB0IG9mIGUuYXJncyl0PT1udWxsfHx0LmRlb3B0aW1pemVQYXRoKHRlKX0sUnM9e2FyZ3M6W251bGxdLHR5cGU6MH0scW49e2FyZ3M6W251bGwsWV0sdHlwZToxfSxPcz17YXJnczpbbnVsbF0sdHlwZToyLHdpdGhOZXc6ITF9O2NsYXNzIHRpIGV4dGVuZHMgV2V7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLm5hbWU9dCx0aGlzLmFsd2F5c1JlbmRlcmVkPSExLHRoaXMuZm9yYmlkZGVuTmFtZXM9bnVsbCx0aGlzLmluaXRSZWFjaGVkPSExLHRoaXMuaXNJZD0hMSx0aGlzLmlzUmVhc3NpZ25lZD0hMSx0aGlzLmtpbmQ9bnVsbCx0aGlzLnJlbmRlckJhc2VOYW1lPW51bGwsdGhpcy5yZW5kZXJOYW1lPW51bGx9YWRkUmVmZXJlbmNlKHQpe31mb3JiaWROYW1lKHQpeyh0aGlzLmZvcmJpZGRlbk5hbWVzfHwodGhpcy5mb3JiaWRkZW5OYW1lcz1uZXcgU2V0KSkuYWRkKHQpfWdldEJhc2VWYXJpYWJsZU5hbWUoKXtyZXR1cm4gdGhpcy5yZW5kZXJCYXNlTmFtZXx8dGhpcy5yZW5kZXJOYW1lfHx0aGlzLm5hbWV9Z2V0TmFtZSh0LGkpe2lmKGkhPW51bGwmJmkodGhpcykpcmV0dXJuIHRoaXMubmFtZTtjb25zdCBzPXRoaXMucmVuZGVyTmFtZXx8dGhpcy5uYW1lO3JldHVybiB0aGlzLnJlbmRlckJhc2VOYW1lP2Ake3RoaXMucmVuZGVyQmFzZU5hbWV9JHt0KHMpfWA6c31oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LHt0eXBlOml9LHMpe3JldHVybiBpIT09MHx8dC5sZW5ndGg+MH1pbmNsdWRlKCl7dGhpcy5pbmNsdWRlZD0hMH1tYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpe31zZXRSZW5kZXJOYW1lcyh0LGkpe3RoaXMucmVuZGVyQmFzZU5hbWU9dCx0aGlzLnJlbmRlck5hbWU9aX19Y2xhc3MgVnMgZXh0ZW5kcyB0aXtjb25zdHJ1Y3Rvcih0LGkpe3N1cGVyKGkpLHRoaXMucmVmZXJlbmNlZD0hMSx0aGlzLm1vZHVsZT10LHRoaXMuaXNOYW1lc3BhY2U9aT09PSIqIn1hZGRSZWZlcmVuY2UodCl7dGhpcy5yZWZlcmVuY2VkPSEwLHRoaXMubmFtZSE9PSJkZWZhdWx0IiYmdGhpcy5uYW1lIT09IioifHx0aGlzLm1vZHVsZS5zdWdnZXN0TmFtZSh0Lm5hbWUpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQse3R5cGU6aX0pe3JldHVybiBpIT09MHx8dC5sZW5ndGg+KHRoaXMuaXNOYW1lc3BhY2U/MTowKX1pbmNsdWRlKCl7dGhpcy5pbmNsdWRlZHx8KHRoaXMuaW5jbHVkZWQ9ITAsdGhpcy5tb2R1bGUudXNlZD0hMCl9fWNvbnN0ICRlPU9iamVjdC5mcmVlemUoT2JqZWN0LmNyZWF0ZShudWxsKSkscWU9T2JqZWN0LmZyZWV6ZSh7fSksdmU9T2JqZWN0LmZyZWV6ZShbXSksc289T2JqZWN0LmZyZWV6ZShuZXcgY2xhc3MgZXh0ZW5kcyBTZXR7YWRkKCl7dGhyb3cgbmV3IEVycm9yKCJDYW5ub3QgYWRkIHRvIGVtcHR5IHNldCIpfX0pO3ZhciBNcz1uZXcgU2V0KFsiYXdhaXQiLCJicmVhayIsImNhc2UiLCJjYXRjaCIsImNsYXNzIiwiY29uc3QiLCJjb250aW51ZSIsImRlYnVnZ2VyIiwiZGVmYXVsdCIsImRlbGV0ZSIsImRvIiwiZWxzZSIsImVudW0iLCJldmFsIiwiZXhwb3J0IiwiZXh0ZW5kcyIsImZhbHNlIiwiZmluYWxseSIsImZvciIsImZ1bmN0aW9uIiwiaWYiLCJpbXBsZW1lbnRzIiwiaW1wb3J0IiwiaW4iLCJpbnN0YW5jZW9mIiwiaW50ZXJmYWNlIiwibGV0IiwiTmFOIiwibmV3IiwibnVsbCIsInBhY2thZ2UiLCJwcml2YXRlIiwicHJvdGVjdGVkIiwicHVibGljIiwicmV0dXJuIiwic3RhdGljIiwic3VwZXIiLCJzd2l0Y2giLCJ0aGlzIiwidGhyb3ciLCJ0cnVlIiwidHJ5IiwidHlwZW9mIiwidW5kZWZpbmVkIiwidmFyIiwidm9pZCIsIndoaWxlIiwid2l0aCIsInlpZWxkIl0pO2NvbnN0IG5vPS9bXlx3JF0vZyxybz1lPT4odD0+L1xkLy50ZXN0KHRbMF0pKShlKXx8TXMuaGFzKGUpfHxlPT09ImFyZ3VtZW50cyI7ZnVuY3Rpb24gSG4oZSl7cmV0dXJuIGU9ZS5yZXBsYWNlKC8tKFx3KS9nLCh0LGkpPT5pLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2Uobm8sIl8iKSxybyhlKSYmKGU9YF8ke2V9YCksZXx8Il8ifWNvbnN0IEs9Indhcm4iLGlpPSJpbmZvIixxaT0iZGVidWciLHNpPXtbcWldOjAsW2lpXToxLHNpbGVudDozLFtLXToyfTtmdW5jdGlvbiBUYyhlLHQpe3JldHVybiBlLnN0YXJ0PD10JiZ0PGUuZW5kfWZ1bmN0aW9uIEtuKGUsdCxpKXtyZXR1cm4gZnVuY3Rpb24ocyxuPXt9KXtjb25zdHtvZmZzZXRMaW5lOnI9MCxvZmZzZXRDb2x1bW46YT0wfT1uO2xldCBvPTA7Y29uc3QgaD1zLnNwbGl0KGAKYCkubWFwKChjLHApPT57Y29uc3QgbT1vK2MubGVuZ3RoKzEseT17c3RhcnQ6byxlbmQ6bSxsaW5lOnB9O3JldHVybiBvPW0seX0pO2xldCBsPTA7cmV0dXJuIGZ1bmN0aW9uKGMscCl7aWYodHlwZW9mIGM9PSJzdHJpbmciJiYoYz1zLmluZGV4T2YoYyxwPz8wKSksYz09PS0xKXJldHVybjtsZXQgbT1oW2xdO2NvbnN0IHk9Yz49bS5lbmQ/MTotMTtmb3IoO207KXtpZihUYyhtLGMpKXJldHVybntsaW5lOnIrbS5saW5lLGNvbHVtbjphK2MtbS5zdGFydCxjaGFyYWN0ZXI6Y307bCs9eSxtPWhbbF19fX0oZSxpKSh0LGkmJmkuc3RhcnRJbmRleCl9ZnVuY3Rpb24gUW4oZSl7cmV0dXJuIGUucmVwbGFjZSgvXlx0Ky8sdD0+dC5zcGxpdCgiCSIpLmpvaW4oIiAgIikpfWNvbnN0IFJjPTEyMCxPYz0xMCxZbj0iLi4uIjtmdW5jdGlvbiBhbyhlLHQsaSl7bGV0IHM9ZS5zcGxpdChgCmApO2lmKHQ+cy5sZW5ndGgpcmV0dXJuIiI7Y29uc3Qgbj1NYXRoLm1heChRbihzW3QtMV0uc2xpY2UoMCxpKSkubGVuZ3RoK09jK1luLmxlbmd0aCxSYykscj1NYXRoLm1heCgwLHQtMyk7bGV0IGE9TWF0aC5taW4odCsyLHMubGVuZ3RoKTtmb3Iocz1zLnNsaWNlKHIsYSk7IS9cUy8udGVzdChzW3MubGVuZ3RoLTFdKTspcy5wb3AoKSxhLT0xO2NvbnN0IG89U3RyaW5nKGEpLmxlbmd0aDtyZXR1cm4gcy5tYXAoKGgsbCk9Pntjb25zdCBjPXIrbCsxPT09dDtsZXQgcD1TdHJpbmcobCtyKzEpO2Zvcig7cC5sZW5ndGg8bzspcD1gICR7cH1gO2xldCBtPVFuKGgpO2lmKG0ubGVuZ3RoPm4mJihtPWAke20uc2xpY2UoMCxuLVluLmxlbmd0aCl9JHtZbn1gKSxjKXtjb25zdCB5PWZ1bmN0aW9uKEUpe2xldCBnPSIiO2Zvcig7RS0tOylnKz0iICI7cmV0dXJuIGd9KG8rMitRbihoLnNsaWNlKDAsaSkpLmxlbmd0aCkrIl4iO3JldHVybmAke3B9OiAke219CiR7eX1gfXJldHVybmAke3B9OiAke219YH0pLmpvaW4oYApgKX1mdW5jdGlvbiBJdChlLHQpe2NvbnN0IGk9ZS5sZW5ndGg8PTEscz1lLm1hcChyPT5gIiR7cn0iYCk7bGV0IG49aT9zWzBdOmAke3Muc2xpY2UoMCwtMSkuam9pbigiLCAiKX0gYW5kICR7cy5zbGljZSgtMSlbMF19YDtyZXR1cm4gdCYmKG4rPWAgJHtpP3RbMF06dFsxXX1gKSxufWZ1bmN0aW9uIF9lKGUpe3JldHVybmBodHRwczovL3JvbGx1cGpzLm9yZy8ke2V9YH1jb25zdCBWYz0idHJvdWJsZXNob290aW5nLyNlcnJvci1uYW1lLWlzLW5vdC1leHBvcnRlZC1ieS1tb2R1bGUiLE1jPSJ0cm91Ymxlc2hvb3RpbmcvI3dhcm5pbmctc291cmNlbWFwLWlzLWxpa2VseS10by1iZS1pbmNvcnJlY3QiLG9vPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1hbWQtaWQiLEhpPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1kaXIiLFhuPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1leHBvcnRzIixEYz0iY29uZmlndXJhdGlvbi1vcHRpb25zLyNvdXRwdXQtZXh0ZW5kIixobz0iY29uZmlndXJhdGlvbi1vcHRpb25zLyNvdXRwdXQtZm9ybWF0IixCYz0iY29uZmlndXJhdGlvbi1vcHRpb25zLyNvdXRwdXQtZXhwZXJpbWVudGFsZGVlcGR5bmFtaWNjaHVua29wdGltaXphdGlvbiIsRmM9ImNvbmZpZ3VyYXRpb24tb3B0aW9ucy8jb3V0cHV0LWdsb2JhbHMiLFpuPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1pbmxpbmVkeW5hbWljaW1wb3J0cyIsSm49ImNvbmZpZ3VyYXRpb24tb3B0aW9ucy8jb3V0cHV0LWludGVyb3AiLGVyPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1tYW51YWxjaHVua3MiLGxvPSJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1uYW1lIix6Yz0iY29uZmlndXJhdGlvbi1vcHRpb25zLyNvdXRwdXQtc291cmNlbWFwZmlsZSIsdW89InBsdWdpbi1kZXZlbG9wbWVudC8jdGhpcy1nZXRtb2R1bGVpbmZvIjtmdW5jdGlvbiBMKGUpe3Rocm93IGUgaW5zdGFuY2VvZiBFcnJvcnx8KGU9T2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZS5tZXNzYWdlKSxlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwibmFtZSIse3ZhbHVlOiJSb2xsdXBFcnJvciJ9KSksZX1mdW5jdGlvbiBEcyhlLHQsaSxzKXtpZih0eXBlb2YgdD09Im9iamVjdCIpe2NvbnN0e2xpbmU6bixjb2x1bW46cn09dDtlLmxvYz17Y29sdW1uOnIsZmlsZTpzLGxpbmU6bn19ZWxzZXtlLnBvcz10O2NvbnN0e2xpbmU6bixjb2x1bW46cn09S24oaSx0LHtvZmZzZXRMaW5lOjF9KTtlLmxvYz17Y29sdW1uOnIsZmlsZTpzLGxpbmU6bn19aWYoZS5mcmFtZT09PXZvaWQgMCl7Y29uc3R7bGluZTpuLGNvbHVtbjpyfT1lLmxvYztlLmZyYW1lPWFvKGksbixyKX19Y29uc3QgamM9IkFERE9OX0VSUk9SIixVYz0iQUxSRUFEWV9DTE9TRUQiLEdjPSJBTk9OWU1PVVNfUExVR0lOX0NBQ0hFIixXYz0iQVNTRVRfTk9UX0ZJTkFMSVNFRCIscWM9IkNBTk5PVF9FTUlUX0ZST01fT1BUSU9OU19IT09LIixIYz0iQ0hVTktfTk9UX0dFTkVSQVRFRCIsS2M9IkNJUkNVTEFSX1JFRVhQT1JUIixRYz0iREVQUkVDQVRFRF9GRUFUVVJFIixZYz0iRFVQTElDQVRFX1BMVUdJTl9OQU1FIixYYz0iRklMRV9OQU1FX0NPTkZMSUNUIixaYz0iSUxMRUdBTF9JREVOVElGSUVSX0FTX05BTUUiLEpjPSJJTlZBTElEX0NIVU5LIixjbz0iSU5WQUxJRF9FWFBPUlRfT1BUSU9OIixlcD0iSU5WQUxJRF9MT0dfUE9TSVRJT04iLHRwPSJJTlZBTElEX09QVElPTiIscG89IklOVkFMSURfUExVR0lOX0hPT0siLGZvPSJJTlZBTElEX1JPTExVUF9QSEFTRSIsaXA9IklOVkFMSURfU0VUQVNTRVRTT1VSQ0UiLHNwPSJNSVNTSU5HX0VYUE9SVCIsbnA9Ik1JU1NJTkdfR0xPQkFMX05BTUUiLHRyPSJNSVNTSU5HX0lNUExJQ0lUX0RFUEVOREFOVCIsbW89Ik1JU1NJTkdfTkFNRV9PUFRJT05fRk9SX0lJRkVfRVhQT1JUIixycD0iTUlTU0lOR19OT0RFX0JVSUxUSU5TIixhcD0iTUlTU0lOR19PUFRJT04iLG9wPSJNSVhFRF9FWFBPUlRTIixocD0iTk9fVFJBTlNGT1JNX01BUF9PUl9BU1RfV0lUSE9VVF9DT0RFIixscD0iT1BUSU1JWkVfQ0hVTktfU1RBVFVTIix1cD0iUExVR0lOX0VSUk9SIixnbz0iU09VUkNFTUFQX0JST0tFTiIseW89IlVORVhQRUNURURfTkFNRURfSU1QT1JUIixjcD0iVU5LTk9XTl9PUFRJT04iLHhvPSJVTlJFU09MVkVEX0VOVFJZIixibz0iVU5SRVNPTFZFRF9JTVBPUlQiLHBwPSJWQUxJREFUSU9OX0VSUk9SIjtmdW5jdGlvbiB2bygpe3JldHVybntjb2RlOlVjLG1lc3NhZ2U6J0J1bmRsZSBpcyBhbHJlYWR5IGNsb3NlZCwgbm8gbW9yZSBjYWxscyB0byAiZ2VuZXJhdGUiIG9yICJ3cml0ZSIgYXJlIGFsbG93ZWQuJ319ZnVuY3Rpb24gRW8oZSl7cmV0dXJue2NvZGU6IkNBTk5PVF9DQUxMX05BTUVTUEFDRSIsbWVzc2FnZTpgQ2Fubm90IGNhbGwgYSBuYW1lc3BhY2UgKCIke2V9IikuYH19ZnVuY3Rpb24gZHAoe2ZpbGVOYW1lOmUsY29kZTp0fSxpKXtjb25zdCBzPXtjb2RlOiJDSFVOS19JTlZBTElEIixtZXNzYWdlOmBDaHVuayAiJHtlfSIgaXMgbm90IHZhbGlkIEphdmFTY3JpcHQ6ICR7aS5tZXNzYWdlfS5gfTtyZXR1cm4gRHMocyxpLmxvYyx0LGUpLHN9ZnVuY3Rpb24gZnAoZSl7cmV0dXJue2NvZGU6IkNJUkNVTEFSX0RFUEVOREVOQ1kiLGlkczplLG1lc3NhZ2U6YENpcmN1bGFyIGRlcGVuZGVuY3k6ICR7ZS5tYXAoWCkuam9pbigiIC0+ICIpfWB9fWZ1bmN0aW9uIG1wKGUsdCx7bGluZTppLGNvbHVtbjpzfSl7cmV0dXJue2NvZGU6IkZJUlNUX1NJREVfRUZGRUNUIixtZXNzYWdlOmBGaXJzdCBzaWRlIGVmZmVjdCBpbiAke1godCl9IGlzIGF0ICgke2l9OiR7c30pCiR7YW8oZSxpLHMpfWB9fWZ1bmN0aW9uIFNvKGUsdCl7cmV0dXJue2NvZGU6IklMTEVHQUxfUkVBU1NJR05NRU5UIixtZXNzYWdlOmBJbGxlZ2FsIHJlYXNzaWdubWVudCBvZiBpbXBvcnQgIiR7ZX0iIGluICIke1godCl9Ii5gfX1mdW5jdGlvbiBCcyhlLHQsaSxzKXtyZXR1cm57Y29kZToiSU5DT05TSVNURU5UX0lNUE9SVF9BU1NFUlRJT05TIixtZXNzYWdlOmBNb2R1bGUgIiR7WChzKX0iIHRyaWVkIHRvIGltcG9ydCAiJHtYKGkpfSIgd2l0aCAke2tvKHQpfSBhc3NlcnRpb25zLCBidXQgaXQgd2FzIGFscmVhZHkgaW1wb3J0ZWQgZWxzZXdoZXJlIHdpdGggJHtrbyhlKX0gYXNzZXJ0aW9ucy4gUGxlYXNlIGVuc3VyZSB0aGF0IGltcG9ydCBhc3NlcnRpb25zIGZvciB0aGUgc2FtZSBtb2R1bGUgYXJlIGFsd2F5cyBjb25zaXN0ZW50LmB9fWNvbnN0IGtvPWU9Pntjb25zdCB0PU9iamVjdC5lbnRyaWVzKGUpO3JldHVybiB0Lmxlbmd0aD09PTA/Im5vIjp0Lm1hcCgoW2ksc10pPT5gIiR7aX0iOiAiJHtzfSJgKS5qb2luKCIsICIpfTtmdW5jdGlvbiB3byhlLHQsaSl7cmV0dXJue2NvZGU6Y28sbWVzc2FnZTpgIiR7ZX0iIHdhcyBzcGVjaWZpZWQgZm9yICJvdXRwdXQuZXhwb3J0cyIsIGJ1dCBlbnRyeSBtb2R1bGUgIiR7WChpKX0iIGhhcyB0aGUgZm9sbG93aW5nIGV4cG9ydHM6ICR7SXQodCl9YCx1cmw6X2UoWG4pfX1mdW5jdGlvbiBFZShlLHQsaSxzKXtyZXR1cm57Y29kZTp0cCxtZXNzYWdlOmBJbnZhbGlkIHZhbHVlICR7cz09PXZvaWQgMD8iIjpgJHtKU09OLnN0cmluZ2lmeShzKX0gYH1mb3Igb3B0aW9uICIke2V9IiAtICR7aX0uYCx1cmw6X2UodCl9fWZ1bmN0aW9uIEZzKGUsdCxpKXtjb25zdCBzPU10KGkpPT09Ii5qc29uIjtyZXR1cm57YmluZGluZzplLGNvZGU6c3AsZXhwb3J0ZXI6aSxpZDp0LG1lc3NhZ2U6YCIke2V9IiBpcyBub3QgZXhwb3J0ZWQgYnkgIiR7WChpKX0iLCBpbXBvcnRlZCBieSAiJHtYKHQpfSIuJHtzPyIgKE5vdGUgdGhhdCB5b3UgbmVlZCBAcm9sbHVwL3BsdWdpbi1qc29uIHRvIGltcG9ydCBKU09OIGZpbGVzKSI6IiJ9YCx1cmw6X2UoVmMpfX1mdW5jdGlvbiBncChlKXtjb25zdCB0PVsuLi5lLmltcGxpY2l0bHlMb2FkZWRCZWZvcmVdLm1hcChpPT5YKGkuaWQpKS5zb3J0KCk7cmV0dXJue2NvZGU6dHIsbWVzc2FnZTpgTW9kdWxlICIke1goZS5pZCl9IiB0aGF0IHNob3VsZCBiZSBpbXBsaWNpdGx5IGxvYWRlZCBiZWZvcmUgJHtJdCh0KX0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBtb2R1bGUgZ3JhcGguIEVpdGhlciBpdCB3YXMgbm90IGltcG9ydGVkIGJ5IGFuIGluY2x1ZGVkIG1vZHVsZSBvciBvbmx5IHZpYSBhIHRyZWUtc2hha2VuIGR5bmFtaWMgaW1wb3J0LCBvciBubyBpbXBvcnRlZCBiaW5kaW5ncyB3ZXJlIHVzZWQgYW5kIGl0IGhhZCBvdGhlcndpc2Ugbm8gc2lkZS1lZmZlY3RzLmB9fWZ1bmN0aW9uIEFvKGUsdCxpKXtyZXR1cm57Y29kZTpscCxtZXNzYWdlOmAke2l9LCB0aGVyZSBhcmUKJHtlfSBjaHVua3MsIG9mIHdoaWNoCiR7dH0gYXJlIGJlbG93IG1pbkNodW5rU2l6ZS5gfX1mdW5jdGlvbiBLaShlLHQse2hvb2s6aSxpZDpzfT17fSl7Y29uc3Qgbj1lLmNvZGU7cmV0dXJuIGUucGx1Z2luQ29kZXx8bj09bnVsbHx8dHlwZW9mIG49PSJzdHJpbmciJiYodHlwZW9mIG4hPSJzdHJpbmcifHxuLnN0YXJ0c1dpdGgoIlBMVUdJTl8iKSl8fChlLnBsdWdpbkNvZGU9biksZS5jb2RlPXVwLGUucGx1Z2luPXQsaSYmKGUuaG9vaz1pKSxzJiYoZS5pZD1zKSxlfWZ1bmN0aW9uIHlwKGUpe3JldHVybntjb2RlOmdvLG1lc3NhZ2U6YE11bHRpcGxlIGNvbmZsaWN0aW5nIGNvbnRlbnRzIGZvciBzb3VyY2VtYXAgc291cmNlICR7ZX1gfX1mdW5jdGlvbiBDbyhlLHQsaSl7Y29uc3Qgcz1pPyJyZWV4cG9ydCI6ImltcG9ydCI7cmV0dXJue2NvZGU6eW8sZXhwb3J0ZXI6ZSxtZXNzYWdlOmBUaGUgbmFtZWQgZXhwb3J0ICIke3R9IiB3YXMgJHtzfWVkIGZyb20gdGhlIGV4dGVybmFsIG1vZHVsZSAiJHtYKGUpfSIgZXZlbiB0aG91Z2ggaXRzIGludGVyb3AgdHlwZSBpcyAiZGVmYXVsdE9ubHkiLiBFaXRoZXIgcmVtb3ZlIG9yIGNoYW5nZSB0aGlzICR7c30gb3IgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgIm91dHB1dC5pbnRlcm9wIiBvcHRpb24uYCx1cmw6X2UoSm4pfX1mdW5jdGlvbiB4cChlKXtyZXR1cm57Y29kZTp5byxleHBvcnRlcjplLG1lc3NhZ2U6YFRoZXJlIHdhcyBhIG5hbWVzcGFjZSAiKiIgcmVleHBvcnQgZnJvbSB0aGUgZXh0ZXJuYWwgbW9kdWxlICIke1goZSl9IiBldmVuIHRob3VnaCBpdHMgaW50ZXJvcCB0eXBlIGlzICJkZWZhdWx0T25seSIuIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGFzIG5hbWVzcGFjZSByZWV4cG9ydHMgb25seSByZWV4cG9ydCBuYW1lZCBleHBvcnRzLiBJZiB0aGlzIGlzIG5vdCBpbnRlbmRlZCwgZWl0aGVyIHJlbW92ZSBvciBjaGFuZ2UgdGhpcyByZWV4cG9ydCBvciBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSAib3V0cHV0LmludGVyb3AiIG9wdGlvbi5gLHVybDpfZShKbil9fWZ1bmN0aW9uIEJlKGUpe3JldHVybntjb2RlOnBwLG1lc3NhZ2U6ZX19ZnVuY3Rpb24gbmkoZSx0LGkscyxuKXtRaShlLHQsaSxzLm9uTG9nLHMuc3RyaWN0RGVwcmVjYXRpb25zLG4pfWZ1bmN0aW9uIFFpKGUsdCxpLHMsbixyKXtpZihpfHxuKXtjb25zdCBhPWZ1bmN0aW9uKG8saCxsKXtyZXR1cm57Y29kZTpRYyxtZXNzYWdlOm8sdXJsOl9lKGgpLC4uLmw/e3BsdWdpbjpsfTp7fX19KGUsdCxyKTtpZihuKXJldHVybiBMKGEpO3MoSyxhKX19Y2xhc3MgbGV7Y29uc3RydWN0b3IodCxpLHMsbixyLGEpe3RoaXMub3B0aW9ucz10LHRoaXMuaWQ9aSx0aGlzLnJlbm9ybWFsaXplUmVuZGVyUGF0aD1yLHRoaXMuZHluYW1pY0ltcG9ydGVycz1bXSx0aGlzLmV4ZWNJbmRleD0xLzAsdGhpcy5leHBvcnRlZFZhcmlhYmxlcz1uZXcgTWFwLHRoaXMuaW1wb3J0ZXJzPVtdLHRoaXMucmVleHBvcnRlZD0hMSx0aGlzLnVzZWQ9ITEsdGhpcy5kZWNsYXJhdGlvbnM9bmV3IE1hcCx0aGlzLm1vc3RDb21tb25TdWdnZXN0aW9uPTAsdGhpcy5uYW1lU3VnZ2VzdGlvbnM9bmV3IE1hcCx0aGlzLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZT1IbihpLnNwbGl0KC9bL1xcXS8pLnBvcCgpKTtjb25zdHtpbXBvcnRlcnM6byxkeW5hbWljSW1wb3J0ZXJzOmh9PXRoaXMsbD10aGlzLmluZm89e2Fzc2VydGlvbnM6YSxhc3Q6bnVsbCxjb2RlOm51bGwsZHluYW1pY2FsbHlJbXBvcnRlZElkUmVzb2x1dGlvbnM6dmUsZHluYW1pY2FsbHlJbXBvcnRlZElkczp2ZSxnZXQgZHluYW1pY0ltcG9ydGVycygpe3JldHVybiBoLnNvcnQoKX0sZXhwb3J0ZWRCaW5kaW5nczpudWxsLGV4cG9ydHM6bnVsbCxoYXNEZWZhdWx0RXhwb3J0Om51bGwsZ2V0IGhhc01vZHVsZVNpZGVFZmZlY3RzKCl7cmV0dXJuIG5pKCJBY2Nlc3NpbmcgTW9kdWxlSW5mby5oYXNNb2R1bGVTaWRlRWZmZWN0cyBmcm9tIHBsdWdpbnMgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBNb2R1bGVJbmZvLm1vZHVsZVNpZGVFZmZlY3RzIGluc3RlYWQuIix1bywhMCx0KSxsLm1vZHVsZVNpZGVFZmZlY3RzfSxpZDppLGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mOnZlLGltcGxpY2l0bHlMb2FkZWRCZWZvcmU6dmUsaW1wb3J0ZWRJZFJlc29sdXRpb25zOnZlLGltcG9ydGVkSWRzOnZlLGdldCBpbXBvcnRlcnMoKXtyZXR1cm4gby5zb3J0KCl9LGlzRW50cnk6ITEsaXNFeHRlcm5hbDohMCxpc0luY2x1ZGVkOm51bGwsbWV0YTpuLG1vZHVsZVNpZGVFZmZlY3RzOnMsc3ludGhldGljTmFtZWRFeHBvcnRzOiExfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pbmZvLCJoYXNNb2R1bGVTaWRlRWZmZWN0cyIse2VudW1lcmFibGU6ITF9KX1nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUodCl7Y29uc3QgaT10aGlzLmRlY2xhcmF0aW9ucy5nZXQodCk7aWYoaSlyZXR1cm5baV07Y29uc3Qgcz1uZXcgVnModGhpcyx0KTtyZXR1cm4gdGhpcy5kZWNsYXJhdGlvbnMuc2V0KHQscyksdGhpcy5leHBvcnRlZFZhcmlhYmxlcy5zZXQocyx0KSxbc119c3VnZ2VzdE5hbWUodCl7Y29uc3QgaT0odGhpcy5uYW1lU3VnZ2VzdGlvbnMuZ2V0KHQpPz8wKSsxO3RoaXMubmFtZVN1Z2dlc3Rpb25zLnNldCh0LGkpLGk+dGhpcy5tb3N0Q29tbW9uU3VnZ2VzdGlvbiYmKHRoaXMubW9zdENvbW1vblN1Z2dlc3Rpb249aSx0aGlzLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZT10KX13YXJuVW51c2VkSW1wb3J0cygpe2NvbnN0IHQ9Wy4uLnRoaXMuZGVjbGFyYXRpb25zXS5maWx0ZXIoKFtvLGhdKT0+byE9PSIqIiYmIWguaW5jbHVkZWQmJiF0aGlzLnJlZXhwb3J0ZWQmJiFoLnJlZmVyZW5jZWQpLm1hcCgoW29dKT0+byk7aWYodC5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBpPW5ldyBTZXQ7Zm9yKGNvbnN0IG8gb2YgdClmb3IoY29uc3QgaCBvZiB0aGlzLmRlY2xhcmF0aW9ucy5nZXQobykubW9kdWxlLmltcG9ydGVycylpLmFkZChoKTtjb25zdCBzPVsuLi5pXTt2YXIgbixyLGE7dGhpcy5vcHRpb25zLm9uTG9nKEsse2NvZGU6IlVOVVNFRF9FWFRFUk5BTF9JTVBPUlQiLGV4cG9ydGVyOm49dGhpcy5pZCxpZHM6YT1zLG1lc3NhZ2U6YCR7SXQocj10LFsiaXMiLCJhcmUiXSl9IGltcG9ydGVkIGZyb20gZXh0ZXJuYWwgbW9kdWxlICIke259IiBidXQgbmV2ZXIgdXNlZCBpbiAke0l0KGEubWFwKG89PlgobykpKX0uYCxuYW1lczpyfSl9fWNvbnN0IHdpPXtBcnJheVBhdHRlcm4oZSx0KXtmb3IoY29uc3QgaSBvZiB0LmVsZW1lbnRzKWkmJndpW2kudHlwZV0oZSxpKX0sQXNzaWdubWVudFBhdHRlcm4oZSx0KXt3aVt0LmxlZnQudHlwZV0oZSx0LmxlZnQpfSxJZGVudGlmaWVyKGUsdCl7ZS5wdXNoKHQubmFtZSl9LE1lbWJlckV4cHJlc3Npb24oKXt9LE9iamVjdFBhdHRlcm4oZSx0KXtmb3IoY29uc3QgaSBvZiB0LnByb3BlcnRpZXMpaS50eXBlPT09IlJlc3RFbGVtZW50Ij93aS5SZXN0RWxlbWVudChlLGkpOndpW2kudmFsdWUudHlwZV0oZSxpLnZhbHVlKX0sUmVzdEVsZW1lbnQoZSx0KXt3aVt0LmFyZ3VtZW50LnR5cGVdKGUsdC5hcmd1bWVudCl9fSxicD1mdW5jdGlvbihlKXtjb25zdCB0PVtdO3JldHVybiB3aVtlLnR5cGVdKHQsZSksdH07ZnVuY3Rpb24gaXIoKXtyZXR1cm57YnJva2VuRmxvdzohMSxoYXNCcmVhazohMSxoYXNDb250aW51ZTohMSxpbmNsdWRlZENhbGxBcmd1bWVudHM6bmV3IFNldCxpbmNsdWRlZExhYmVsczpuZXcgU2V0fX1mdW5jdGlvbiB6cygpe3JldHVybnthY2Nlc3NlZDpuZXcga2ksYXNzaWduZWQ6bmV3IGtpLGJyb2tlbkZsb3c6ITEsY2FsbGVkOm5ldyB0byxoYXNCcmVhazohMSxoYXNDb250aW51ZTohMSxpZ25vcmU6e2JyZWFrczohMSxjb250aW51ZXM6ITEsbGFiZWxzOm5ldyBTZXQscmV0dXJuWWllbGQ6ITEsdGhpczohMX0saW5jbHVkZWRMYWJlbHM6bmV3IFNldCxpbnN0YW50aWF0ZWQ6bmV3IHRvLHJlcGxhY2VkVmFyaWFibGVJbml0czpuZXcgTWFwfX1mdW5jdGlvbiBZaShlLHQ9bnVsbCl7cmV0dXJuIE9iamVjdC5jcmVhdGUodCxlKX1uZXcgU2V0KCJicmVhayBjYXNlIGNsYXNzIGNhdGNoIGNvbnN0IGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZGVsZXRlIGRvIGVsc2UgZXhwb3J0IGV4dGVuZHMgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgaW1wb3J0IGluIGluc3RhbmNlb2YgbGV0IG5ldyByZXR1cm4gc3VwZXIgc3dpdGNoIHRoaXMgdGhyb3cgdHJ5IHR5cGVvZiB2YXIgdm9pZCB3aGlsZSB3aXRoIHlpZWxkIGVudW0gYXdhaXQgaW1wbGVtZW50cyBwYWNrYWdlIHByb3RlY3RlZCBzdGF0aWMgaW50ZXJmYWNlIHByaXZhdGUgcHVibGljIGFyZ3VtZW50cyBJbmZpbml0eSBOYU4gdW5kZWZpbmVkIG51bGwgdHJ1ZSBmYWxzZSBldmFsIHVuZXZhbCBpc0Zpbml0ZSBpc05hTiBwYXJzZUZsb2F0IHBhcnNlSW50IGRlY29kZVVSSSBkZWNvZGVVUklDb21wb25lbnQgZW5jb2RlVVJJIGVuY29kZVVSSUNvbXBvbmVudCBlc2NhcGUgdW5lc2NhcGUgT2JqZWN0IEZ1bmN0aW9uIEJvb2xlYW4gU3ltYm9sIEVycm9yIEV2YWxFcnJvciBJbnRlcm5hbEVycm9yIFJhbmdlRXJyb3IgUmVmZXJlbmNlRXJyb3IgU3ludGF4RXJyb3IgVHlwZUVycm9yIFVSSUVycm9yIE51bWJlciBNYXRoIERhdGUgU3RyaW5nIFJlZ0V4cCBBcnJheSBJbnQ4QXJyYXkgVWludDhBcnJheSBVaW50OENsYW1wZWRBcnJheSBJbnQxNkFycmF5IFVpbnQxNkFycmF5IEludDMyQXJyYXkgVWludDMyQXJyYXkgRmxvYXQzMkFycmF5IEZsb2F0NjRBcnJheSBNYXAgU2V0IFdlYWtNYXAgV2Vha1NldCBTSU1EIEFycmF5QnVmZmVyIERhdGFWaWV3IEpTT04gUHJvbWlzZSBHZW5lcmF0b3IgR2VuZXJhdG9yRnVuY3Rpb24gUmVmbGVjdCBQcm94eSBJbnRsIi5zcGxpdCgiICIpKS5hZGQoIiIpO2NvbnN0IEFpPW5ldyBjbGFzcyBleHRlbmRzIFdle2dldExpdGVyYWxWYWx1ZUF0UGF0aCgpe319LHJpPXt2YWx1ZTp7aGFzRWZmZWN0c1doZW5DYWxsZWQ6bnVsbCxyZXR1cm5zOll9fSxzcj1uZXcgY2xhc3MgZXh0ZW5kcyBXZXtnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP0ppKHJyLGVbMF0pOmJlfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4gdC50eXBlPT09MD9lLmxlbmd0aD4xOnQudHlwZSE9PTJ8fGUubGVuZ3RoIT09MXx8WmkocnIsZVswXSx0LGkpfX0sQnQ9e3ZhbHVlOntoYXNFZmZlY3RzV2hlbkNhbGxlZDpudWxsLHJldHVybnM6c3J9fSxDaT1uZXcgY2xhc3MgZXh0ZW5kcyBXZXtnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP0ppKGFyLGVbMF0pOmJlfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4gdC50eXBlPT09MD9lLmxlbmd0aD4xOnQudHlwZSE9PTJ8fGUubGVuZ3RoIT09MXx8WmkoYXIsZVswXSx0LGkpfX0sSWk9e3ZhbHVlOntoYXNFZmZlY3RzV2hlbkNhbGxlZDpudWxsLHJldHVybnM6Q2l9fSxucj1uZXcgY2xhc3MgZXh0ZW5kcyBXZXtnZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlKXtyZXR1cm4gZS5sZW5ndGg9PT0xP0ppKFhpLGVbMF0pOmJlfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4gdC50eXBlPT09MD9lLmxlbmd0aD4xOnQudHlwZSE9PTJ8fGUubGVuZ3RoIT09MXx8WmkoWGksZVswXSx0LGkpfX0sWj17dmFsdWU6e2hhc0VmZmVjdHNXaGVuQ2FsbGVkOm51bGwscmV0dXJuczpucn19LElvPXt2YWx1ZTp7aGFzRWZmZWN0c1doZW5DYWxsZWQoe2FyZ3M6ZX0sdCl7Y29uc3QgaT1lWzJdO3JldHVybiBlLmxlbmd0aDwzfHx0eXBlb2YgaS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoUSxBZSx7ZGVvcHRpbWl6ZUNhY2hlKCl7fX0pPT0ic3ltYm9sIiYmaS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLE9zLHQpfSxyZXR1cm5zOm5yfX0sanM9WWkoe2hhc093blByb3BlcnR5OkJ0LGlzUHJvdG90eXBlT2Y6QnQscHJvcGVydHlJc0VudW1lcmFibGU6QnQsdG9Mb2NhbGVTdHJpbmc6Wix0b1N0cmluZzpaLHZhbHVlT2Y6cml9KSxycj1ZaSh7dmFsdWVPZjpCdH0sanMpLGFyPVlpKHt0b0V4cG9uZW50aWFsOlosdG9GaXhlZDpaLHRvTG9jYWxlU3RyaW5nOlosdG9QcmVjaXNpb246Wix2YWx1ZU9mOklpfSxqcyksdnA9WWkoe2V4ZWM6cmksdGVzdDpCdH0sanMpLFhpPVlpKHthbmNob3I6WixhdDpyaSxiaWc6WixibGluazpaLGJvbGQ6WixjaGFyQXQ6WixjaGFyQ29kZUF0OklpLGNvZGVQb2ludEF0OnJpLGNvbmNhdDpaLGVuZHNXaXRoOkJ0LGZpeGVkOlosZm9udGNvbG9yOlosZm9udHNpemU6WixpbmNsdWRlczpCdCxpbmRleE9mOklpLGl0YWxpY3M6WixsYXN0SW5kZXhPZjpJaSxsaW5rOlosbG9jYWxlQ29tcGFyZTpJaSxtYXRjaDpyaSxtYXRjaEFsbDpyaSxub3JtYWxpemU6WixwYWRFbmQ6WixwYWRTdGFydDpaLHJlcGVhdDpaLHJlcGxhY2U6SW8scmVwbGFjZUFsbDpJbyxzZWFyY2g6SWksc2xpY2U6WixzbWFsbDpaLHNwbGl0OnJpLHN0YXJ0c1dpdGg6QnQsc3RyaWtlOlosc3ViOlosc3Vic3RyOlosc3Vic3RyaW5nOlosc3VwOlosdG9Mb2NhbGVMb3dlckNhc2U6Wix0b0xvY2FsZVVwcGVyQ2FzZTpaLHRvTG93ZXJDYXNlOlosdG9TdHJpbmc6Wix0b1VwcGVyQ2FzZTpaLHRyaW06Wix0cmltRW5kOlosdHJpbUxlZnQ6Wix0cmltUmlnaHQ6Wix0cmltU3RhcnQ6Wix2YWx1ZU9mOlp9LGpzKTtmdW5jdGlvbiBaaShlLHQsaSxzKXt2YXIgbixyO3JldHVybiB0eXBlb2YgdCE9InN0cmluZyJ8fCFlW3RdfHwoKHI9KG49ZVt0XSkuaGFzRWZmZWN0c1doZW5DYWxsZWQpPT1udWxsP3ZvaWQgMDpyLmNhbGwobixpLHMpKXx8ITF9ZnVuY3Rpb24gSmkoZSx0KXtyZXR1cm4gdHlwZW9mIHQ9PSJzdHJpbmciJiZlW3RdP1tlW3RdLnJldHVybnMsITFdOmJlfWZ1bmN0aW9uIG9yKGUsdCxpKXtpKGUsdCl9ZnVuY3Rpb24gYWkoZSx0LGkpe312YXIgJD17fTskLlByb2dyYW09JC5CbG9ja1N0YXRlbWVudD0kLlN0YXRpY0Jsb2NrPWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIHM9MCxuPWUuYm9keTtzPG4ubGVuZ3RoO3MrPTEpaShuW3NdLHQsIlN0YXRlbWVudCIpfSwkLlN0YXRlbWVudD1vciwkLkVtcHR5U3RhdGVtZW50PWFpLCQuRXhwcmVzc2lvblN0YXRlbWVudD0kLlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uPSQuQ2hhaW5FeHByZXNzaW9uPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gaShlLmV4cHJlc3Npb24sdCwiRXhwcmVzc2lvbiIpfSwkLklmU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpKXtpKGUudGVzdCx0LCJFeHByZXNzaW9uIiksaShlLmNvbnNlcXVlbnQsdCwiU3RhdGVtZW50IiksZS5hbHRlcm5hdGUmJmkoZS5hbHRlcm5hdGUsdCwiU3RhdGVtZW50Iil9LCQuTGFiZWxlZFN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIGkoZS5ib2R5LHQsIlN0YXRlbWVudCIpfSwkLkJyZWFrU3RhdGVtZW50PSQuQ29udGludWVTdGF0ZW1lbnQ9YWksJC5XaXRoU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpKXtpKGUub2JqZWN0LHQsIkV4cHJlc3Npb24iKSxpKGUuYm9keSx0LCJTdGF0ZW1lbnQiKX0sJC5Td2l0Y2hTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSx0LGkpe2koZS5kaXNjcmltaW5hbnQsdCwiRXhwcmVzc2lvbiIpO2Zvcih2YXIgcz0wLG49ZS5jYXNlcztzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc107ci50ZXN0JiZpKHIudGVzdCx0LCJFeHByZXNzaW9uIik7Zm9yKHZhciBhPTAsbz1yLmNvbnNlcXVlbnQ7YTxvLmxlbmd0aDthKz0xKWkob1thXSx0LCJTdGF0ZW1lbnQiKX19LCQuU3dpdGNoQ2FzZT1mdW5jdGlvbihlLHQsaSl7ZS50ZXN0JiZpKGUudGVzdCx0LCJFeHByZXNzaW9uIik7Zm9yKHZhciBzPTAsbj1lLmNvbnNlcXVlbnQ7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0LCJTdGF0ZW1lbnQiKX0sJC5SZXR1cm5TdGF0ZW1lbnQ9JC5ZaWVsZEV4cHJlc3Npb249JC5Bd2FpdEV4cHJlc3Npb249ZnVuY3Rpb24oZSx0LGkpe2UuYXJndW1lbnQmJmkoZS5hcmd1bWVudCx0LCJFeHByZXNzaW9uIil9LCQuVGhyb3dTdGF0ZW1lbnQ9JC5TcHJlYWRFbGVtZW50PWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gaShlLmFyZ3VtZW50LHQsIkV4cHJlc3Npb24iKX0sJC5UcnlTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSx0LGkpe2koZS5ibG9jayx0LCJTdGF0ZW1lbnQiKSxlLmhhbmRsZXImJmkoZS5oYW5kbGVyLHQpLGUuZmluYWxpemVyJiZpKGUuZmluYWxpemVyLHQsIlN0YXRlbWVudCIpfSwkLkNhdGNoQ2xhdXNlPWZ1bmN0aW9uKGUsdCxpKXtlLnBhcmFtJiZpKGUucGFyYW0sdCwiUGF0dGVybiIpLGkoZS5ib2R5LHQsIlN0YXRlbWVudCIpfSwkLldoaWxlU3RhdGVtZW50PSQuRG9XaGlsZVN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSl7aShlLnRlc3QsdCwiRXhwcmVzc2lvbiIpLGkoZS5ib2R5LHQsIlN0YXRlbWVudCIpfSwkLkZvclN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSl7ZS5pbml0JiZpKGUuaW5pdCx0LCJGb3JJbml0IiksZS50ZXN0JiZpKGUudGVzdCx0LCJFeHByZXNzaW9uIiksZS51cGRhdGUmJmkoZS51cGRhdGUsdCwiRXhwcmVzc2lvbiIpLGkoZS5ib2R5LHQsIlN0YXRlbWVudCIpfSwkLkZvckluU3RhdGVtZW50PSQuRm9yT2ZTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSx0LGkpe2koZS5sZWZ0LHQsIkZvckluaXQiKSxpKGUucmlnaHQsdCwiRXhwcmVzc2lvbiIpLGkoZS5ib2R5LHQsIlN0YXRlbWVudCIpfSwkLkZvckluaXQ9ZnVuY3Rpb24oZSx0LGkpe2UudHlwZT09PSJWYXJpYWJsZURlY2xhcmF0aW9uIj9pKGUsdCk6aShlLHQsIkV4cHJlc3Npb24iKX0sJC5EZWJ1Z2dlclN0YXRlbWVudD1haSwkLkZ1bmN0aW9uRGVjbGFyYXRpb249ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBpKGUsdCwiRnVuY3Rpb24iKX0sJC5WYXJpYWJsZURlY2xhcmF0aW9uPWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIHM9MCxuPWUuZGVjbGFyYXRpb25zO3M8bi5sZW5ndGg7cys9MSlpKG5bc10sdCl9LCQuVmFyaWFibGVEZWNsYXJhdG9yPWZ1bmN0aW9uKGUsdCxpKXtpKGUuaWQsdCwiUGF0dGVybiIpLGUuaW5pdCYmaShlLmluaXQsdCwiRXhwcmVzc2lvbiIpfSwkLkZ1bmN0aW9uPWZ1bmN0aW9uKGUsdCxpKXtlLmlkJiZpKGUuaWQsdCwiUGF0dGVybiIpO2Zvcih2YXIgcz0wLG49ZS5wYXJhbXM7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0LCJQYXR0ZXJuIik7aShlLmJvZHksdCxlLmV4cHJlc3Npb24/IkV4cHJlc3Npb24iOiJTdGF0ZW1lbnQiKX0sJC5QYXR0ZXJuPWZ1bmN0aW9uKGUsdCxpKXtlLnR5cGU9PT0iSWRlbnRpZmllciI/aShlLHQsIlZhcmlhYmxlUGF0dGVybiIpOmUudHlwZT09PSJNZW1iZXJFeHByZXNzaW9uIj9pKGUsdCwiTWVtYmVyUGF0dGVybiIpOmkoZSx0KX0sJC5WYXJpYWJsZVBhdHRlcm49YWksJC5NZW1iZXJQYXR0ZXJuPW9yLCQuUmVzdEVsZW1lbnQ9ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBpKGUuYXJndW1lbnQsdCwiUGF0dGVybiIpfSwkLkFycmF5UGF0dGVybj1mdW5jdGlvbihlLHQsaSl7Zm9yKHZhciBzPTAsbj1lLmVsZW1lbnRzO3M8bi5sZW5ndGg7cys9MSl7dmFyIHI9bltzXTtyJiZpKHIsdCwiUGF0dGVybiIpfX0sJC5PYmplY3RQYXR0ZXJuPWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIHM9MCxuPWUucHJvcGVydGllcztzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc107ci50eXBlPT09IlByb3BlcnR5Ij8oci5jb21wdXRlZCYmaShyLmtleSx0LCJFeHByZXNzaW9uIiksaShyLnZhbHVlLHQsIlBhdHRlcm4iKSk6ci50eXBlPT09IlJlc3RFbGVtZW50IiYmaShyLmFyZ3VtZW50LHQsIlBhdHRlcm4iKX19LCQuRXhwcmVzc2lvbj1vciwkLlRoaXNFeHByZXNzaW9uPSQuU3VwZXI9JC5NZXRhUHJvcGVydHk9YWksJC5BcnJheUV4cHJlc3Npb249ZnVuY3Rpb24oZSx0LGkpe2Zvcih2YXIgcz0wLG49ZS5lbGVtZW50cztzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc107ciYmaShyLHQsIkV4cHJlc3Npb24iKX19LCQuT2JqZWN0RXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSl7Zm9yKHZhciBzPTAsbj1lLnByb3BlcnRpZXM7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0KX0sJC5GdW5jdGlvbkV4cHJlc3Npb249JC5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbj0kLkZ1bmN0aW9uRGVjbGFyYXRpb24sJC5TZXF1ZW5jZUV4cHJlc3Npb249ZnVuY3Rpb24oZSx0LGkpe2Zvcih2YXIgcz0wLG49ZS5leHByZXNzaW9ucztzPG4ubGVuZ3RoO3MrPTEpaShuW3NdLHQsIkV4cHJlc3Npb24iKX0sJC5UZW1wbGF0ZUxpdGVyYWw9ZnVuY3Rpb24oZSx0LGkpe2Zvcih2YXIgcz0wLG49ZS5xdWFzaXM7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0KTtmb3IodmFyIHI9MCxhPWUuZXhwcmVzc2lvbnM7cjxhLmxlbmd0aDtyKz0xKWkoYVtyXSx0LCJFeHByZXNzaW9uIil9LCQuVGVtcGxhdGVFbGVtZW50PWFpLCQuVW5hcnlFeHByZXNzaW9uPSQuVXBkYXRlRXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSl7aShlLmFyZ3VtZW50LHQsIkV4cHJlc3Npb24iKX0sJC5CaW5hcnlFeHByZXNzaW9uPSQuTG9naWNhbEV4cHJlc3Npb249ZnVuY3Rpb24oZSx0LGkpe2koZS5sZWZ0LHQsIkV4cHJlc3Npb24iKSxpKGUucmlnaHQsdCwiRXhwcmVzc2lvbiIpfSwkLkFzc2lnbm1lbnRFeHByZXNzaW9uPSQuQXNzaWdubWVudFBhdHRlcm49ZnVuY3Rpb24oZSx0LGkpe2koZS5sZWZ0LHQsIlBhdHRlcm4iKSxpKGUucmlnaHQsdCwiRXhwcmVzc2lvbiIpfSwkLkNvbmRpdGlvbmFsRXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSl7aShlLnRlc3QsdCwiRXhwcmVzc2lvbiIpLGkoZS5jb25zZXF1ZW50LHQsIkV4cHJlc3Npb24iKSxpKGUuYWx0ZXJuYXRlLHQsIkV4cHJlc3Npb24iKX0sJC5OZXdFeHByZXNzaW9uPSQuQ2FsbEV4cHJlc3Npb249ZnVuY3Rpb24oZSx0LGkpe2lmKGkoZS5jYWxsZWUsdCwiRXhwcmVzc2lvbiIpLGUuYXJndW1lbnRzKWZvcih2YXIgcz0wLG49ZS5hcmd1bWVudHM7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0LCJFeHByZXNzaW9uIil9LCQuTWVtYmVyRXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSl7aShlLm9iamVjdCx0LCJFeHByZXNzaW9uIiksZS5jb21wdXRlZCYmaShlLnByb3BlcnR5LHQsIkV4cHJlc3Npb24iKX0sJC5FeHBvcnROYW1lZERlY2xhcmF0aW9uPSQuRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uPWZ1bmN0aW9uKGUsdCxpKXtlLmRlY2xhcmF0aW9uJiZpKGUuZGVjbGFyYXRpb24sdCxlLnR5cGU9PT0iRXhwb3J0TmFtZWREZWNsYXJhdGlvbiJ8fGUuZGVjbGFyYXRpb24uaWQ/IlN0YXRlbWVudCI6IkV4cHJlc3Npb24iKSxlLnNvdXJjZSYmaShlLnNvdXJjZSx0LCJFeHByZXNzaW9uIil9LCQuRXhwb3J0QWxsRGVjbGFyYXRpb249ZnVuY3Rpb24oZSx0LGkpe2UuZXhwb3J0ZWQmJmkoZS5leHBvcnRlZCx0KSxpKGUuc291cmNlLHQsIkV4cHJlc3Npb24iKX0sJC5JbXBvcnREZWNsYXJhdGlvbj1mdW5jdGlvbihlLHQsaSl7Zm9yKHZhciBzPTAsbj1lLnNwZWNpZmllcnM7czxuLmxlbmd0aDtzKz0xKWkobltzXSx0KTtpKGUuc291cmNlLHQsIkV4cHJlc3Npb24iKX0sJC5JbXBvcnRFeHByZXNzaW9uPWZ1bmN0aW9uKGUsdCxpKXtpKGUuc291cmNlLHQsIkV4cHJlc3Npb24iKX0sJC5JbXBvcnRTcGVjaWZpZXI9JC5JbXBvcnREZWZhdWx0U3BlY2lmaWVyPSQuSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyPSQuSWRlbnRpZmllcj0kLlByaXZhdGVJZGVudGlmaWVyPSQuTGl0ZXJhbD1haSwkLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSl7aShlLnRhZyx0LCJFeHByZXNzaW9uIiksaShlLnF1YXNpLHQsIkV4cHJlc3Npb24iKX0sJC5DbGFzc0RlY2xhcmF0aW9uPSQuQ2xhc3NFeHByZXNzaW9uPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gaShlLHQsIkNsYXNzIil9LCQuQ2xhc3M9ZnVuY3Rpb24oZSx0LGkpe2UuaWQmJmkoZS5pZCx0LCJQYXR0ZXJuIiksZS5zdXBlckNsYXNzJiZpKGUuc3VwZXJDbGFzcyx0LCJFeHByZXNzaW9uIiksaShlLmJvZHksdCl9LCQuQ2xhc3NCb2R5PWZ1bmN0aW9uKGUsdCxpKXtmb3IodmFyIHM9MCxuPWUuYm9keTtzPG4ubGVuZ3RoO3MrPTEpaShuW3NdLHQpfSwkLk1ldGhvZERlZmluaXRpb249JC5Qcm9wZXJ0eURlZmluaXRpb249JC5Qcm9wZXJ0eT1mdW5jdGlvbihlLHQsaSl7ZS5jb21wdXRlZCYmaShlLmtleSx0LCJFeHByZXNzaW9uIiksZS52YWx1ZSYmaShlLnZhbHVlLHQsIkV4cHJlc3Npb24iKX07Y29uc3QgaHI9IkFycm93RnVuY3Rpb25FeHByZXNzaW9uIixFcD0iQmluYXJ5RXhwcmVzc2lvbiIsUG89IkJsb2NrU3RhdGVtZW50Iixfbz0iQ2FsbEV4cHJlc3Npb24iLFNwPSJDaGFpbkV4cHJlc3Npb24iLGtwPSJDb25kaXRpb25hbEV4cHJlc3Npb24iLHdwPSJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24iLEFwPSJFeHBvcnROYW1lZERlY2xhcmF0aW9uIixZZT0iRXhwcmVzc2lvblN0YXRlbWVudCIsQ3A9IkZ1bmN0aW9uRGVjbGFyYXRpb24iLE5vPSJJZGVudGlmaWVyIixJcD0iTG9naWNhbEV4cHJlc3Npb24iLFBwPSJOZXdFeHByZXNzaW9uIixVcz0iUHJvZ3JhbSIsX3A9IlNlcXVlbmNlRXhwcmVzc2lvbiIsTnA9IlZhcmlhYmxlRGVjbGFyYXRvciIsJHA9IlZhcmlhYmxlRGVjbGFyYXRpb24iO2xldCBscj0ic291cmNlTWEiO2xyKz0icHBpbmdVUkwiO2NvbnN0IExwPW5ldyBSZWdFeHAoYF4jWyBcXGZcXHJcXHRcXHZcXHUwMGEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwYVxcdTIwMjhcXHUyMDI5XFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0rJHtscn09LitgKSwkbz0iX3JvbGx1cEFubm90YXRpb25zIixMbz0iX3JvbGx1cFJlbW92ZWQiO2Z1bmN0aW9uIFRvKGUsdCxpPWUudHlwZSl7Y29uc3R7YW5ub3RhdGlvbnM6cyxjb2RlOm59PXQ7bGV0IHI9c1t0LmFubm90YXRpb25JbmRleF07Zm9yKDtyJiZlLnN0YXJ0Pj1yLmVuZDspUnAoZSxyLG4pLHI9c1srK3QuYW5ub3RhdGlvbkluZGV4XTtpZihyJiZyLmVuZDw9ZS5lbmQpZm9yKCRbaV0oZSx0LFRvKTsocj1zW3QuYW5ub3RhdGlvbkluZGV4XSkmJnIuZW5kPD1lLmVuZDspKyt0LmFubm90YXRpb25JbmRleCxXcyhlLHIsITEpfWNvbnN0IFRwPS9bXlxzKF0vZyx1cj0vXFMvZztmdW5jdGlvbiBScChlLHQsaSl7Y29uc3Qgcz1bXTtsZXQgbjtpZihHcyhpLnNsaWNlKHQuZW5kLGUuc3RhcnQpLFRwKSl7Y29uc3Qgcj1lLnN0YXJ0O2Zvcig7Oyl7c3dpdGNoKHMucHVzaChlKSxlLnR5cGUpe2Nhc2UgWWU6Y2FzZSBTcDplPWUuZXhwcmVzc2lvbjtjb250aW51ZTtjYXNlIF9wOmlmKEdzKGkuc2xpY2UocixlLnN0YXJ0KSx1cikpe2U9ZS5leHByZXNzaW9uc1swXTtjb250aW51ZX1uPSEwO2JyZWFrO2Nhc2Uga3A6aWYoR3MoaS5zbGljZShyLGUuc3RhcnQpLHVyKSl7ZT1lLnRlc3Q7Y29udGludWV9bj0hMDticmVhaztjYXNlIElwOmNhc2UgRXA6aWYoR3MoaS5zbGljZShyLGUuc3RhcnQpLHVyKSl7ZT1lLmxlZnQ7Y29udGludWV9bj0hMDticmVhaztjYXNlIEFwOmNhc2Ugd3A6ZT1lLmRlY2xhcmF0aW9uO2NvbnRpbnVlO2Nhc2UgJHA6e2NvbnN0IGE9ZTtpZihhLmtpbmQ9PT0iY29uc3QiKXtlPWEuZGVjbGFyYXRpb25zWzBdLmluaXQ7Y29udGludWV9bj0hMDticmVha31jYXNlIE5wOmU9ZS5pbml0O2NvbnRpbnVlO2Nhc2UgQ3A6Y2FzZSBocjpjYXNlIF9vOmNhc2UgUHA6YnJlYWs7ZGVmYXVsdDpuPSEwfWJyZWFrfX1lbHNlIG49ITA7aWYobilXcyhlLHQsITEpO2Vsc2UgZm9yKGNvbnN0IHIgb2YgcylXcyhyLHQsITApfWZ1bmN0aW9uIEdzKGUsdCl7bGV0IGk7Zm9yKDsoaT10LmV4ZWMoZSkpIT09bnVsbDspe2lmKGlbMF09PT0iLyIpe2NvbnN0IHM9ZS5jaGFyQ29kZUF0KHQubGFzdEluZGV4KTtpZihzPT09NDIpe3QubGFzdEluZGV4PWUuaW5kZXhPZigiKi8iLHQubGFzdEluZGV4KzEpKzI7Y29udGludWV9aWYocz09PTQ3KXt0Lmxhc3RJbmRleD1lLmluZGV4T2YoYApgLHQubGFzdEluZGV4KzEpKzE7Y29udGludWV9fXJldHVybiB0Lmxhc3RJbmRleD0wLCExfXJldHVybiEwfWNvbnN0IE9wPVtbInB1cmUiLC9bI0BdX19QVVJFX18vXSxbIm5vU2lkZUVmZmVjdHMiLC9bI0BdX19OT19TSURFX0VGRkVDVFNfXy9dXTtmdW5jdGlvbiBXcyhlLHQsaSl7Y29uc3Qgcz1pPyRvOkxvLG49ZVtzXTtuP24ucHVzaCh0KTplW3NdPVt0XX1jb25zdCBjcj17SW1wb3J0RXhwcmVzc2lvbjpbImFyZ3VtZW50cyJdLExpdGVyYWw6W10sUHJvZ3JhbTpbImJvZHkiXX0sUm89InZhcmlhYmxlcyI7Y2xhc3MgViBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQsaSxzLG49ITEpe3N1cGVyKCksdGhpcy5kZW9wdGltaXplZD0hMSx0aGlzLmVzVHJlZU5vZGU9bj90Om51bGwsdGhpcy5rZXlzPWNyW3QudHlwZV18fGZ1bmN0aW9uKHIpe3JldHVybiBjcltyLnR5cGVdPU9iamVjdC5rZXlzKHIpLmZpbHRlcihhPT50eXBlb2YgclthXT09Im9iamVjdCImJmEuY2hhckNvZGVBdCgwKSE9PTk1KSxjcltyLnR5cGVdfSh0KSx0aGlzLnBhcmVudD1pLHRoaXMuY29udGV4dD1pLmNvbnRleHQsdGhpcy5jcmVhdGVTY29wZShzKSx0aGlzLnBhcnNlTm9kZSh0KSx0aGlzLmluaXRpYWxpc2UoKSx0aGlzLmNvbnRleHQubWFnaWNTdHJpbmcuYWRkU291cmNlbWFwTG9jYXRpb24odGhpcy5zdGFydCksdGhpcy5jb250ZXh0Lm1hZ2ljU3RyaW5nLmFkZFNvdXJjZW1hcExvY2F0aW9uKHRoaXMuZW5kKX1hZGRFeHBvcnRlZFZhcmlhYmxlcyh0LGkpe31iaW5kKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5rZXlzKXtjb25zdCBpPXRoaXNbdF07aWYoQXJyYXkuaXNBcnJheShpKSlmb3IoY29uc3QgcyBvZiBpKXM9PW51bGx8fHMuYmluZCgpO2Vsc2UgaSYmaS5iaW5kKCl9fWNyZWF0ZVNjb3BlKHQpe3RoaXMuc2NvcGU9dH1oYXNFZmZlY3RzKHQpe3RoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKTtmb3IoY29uc3QgaSBvZiB0aGlzLmtleXMpe2NvbnN0IHM9dGhpc1tpXTtpZihzIT09bnVsbCl7aWYoQXJyYXkuaXNBcnJheShzKSl7Zm9yKGNvbnN0IG4gb2YgcylpZihuIT1udWxsJiZuLmhhc0VmZmVjdHModCkpcmV0dXJuITB9ZWxzZSBpZihzLmhhc0VmZmVjdHModCkpcmV0dXJuITB9fXJldHVybiExfWhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQodCxpKXtyZXR1cm4gdGhpcy5oYXNFZmZlY3RzKHQpfHx0aGlzLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFEsdGhpcy5hc3NpZ25tZW50SW50ZXJhY3Rpb24sdCl9aW5jbHVkZSh0LGkscyl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHRoaXMuaW5jbHVkZWQ9ITA7Zm9yKGNvbnN0IG4gb2YgdGhpcy5rZXlzKXtjb25zdCByPXRoaXNbbl07aWYociE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShyKSlmb3IoY29uc3QgYSBvZiByKWE9PW51bGx8fGEuaW5jbHVkZSh0LGkpO2Vsc2Ugci5pbmNsdWRlKHQsaSl9fWluY2x1ZGVBc0Fzc2lnbm1lbnRUYXJnZXQodCxpLHMpe3RoaXMuaW5jbHVkZSh0LGkpfWluaXRpYWxpc2UoKXt9aW5zZXJ0U2VtaWNvbG9uKHQpe3Qub3JpZ2luYWxbdGhpcy5lbmQtMV0hPT0iOyImJnQuYXBwZW5kTGVmdCh0aGlzLmVuZCwiOyIpfXBhcnNlTm9kZSh0LGkpe2Zvcihjb25zdFtzLG5db2YgT2JqZWN0LmVudHJpZXModCkpaWYoIXRoaXMuaGFzT3duUHJvcGVydHkocykpaWYocy5jaGFyQ29kZUF0KDApPT09OTUpe2lmKHM9PT0kbyl7Y29uc3Qgcj1uO3RoaXMuYW5ub3RhdGlvbnM9cix0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UuYW5ub3RhdGlvbnMmJih0aGlzLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzPXIuc29tZShhPT5hLmFubm90YXRpb25UeXBlPT09Im5vU2lkZUVmZmVjdHMiKSx0aGlzLmFubm90YXRpb25QdXJlPXIuc29tZShhPT5hLmFubm90YXRpb25UeXBlPT09InB1cmUiKSl9ZWxzZSBpZihzPT09TG8pZm9yKGNvbnN0e3N0YXJ0OnIsZW5kOmF9b2Ygbil0aGlzLmNvbnRleHQubWFnaWNTdHJpbmcucmVtb3ZlKHIsYSl9ZWxzZSBpZih0eXBlb2YgbiE9Im9iamVjdCJ8fG49PT1udWxsKXRoaXNbc109bjtlbHNlIGlmKEFycmF5LmlzQXJyYXkobikpe3RoaXNbc109W107Zm9yKGNvbnN0IHIgb2Ygbil0aGlzW3NdLnB1c2gocj09PW51bGw/bnVsbDpuZXcodGhpcy5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3RvcihyLnR5cGUpKShyLHRoaXMsdGhpcy5zY29wZSxpPT1udWxsP3ZvaWQgMDppLmluY2x1ZGVzKHMpKSl9ZWxzZSB0aGlzW3NdPW5ldyh0aGlzLmNvbnRleHQuZ2V0Tm9kZUNvbnN0cnVjdG9yKG4udHlwZSkpKG4sdGhpcyx0aGlzLnNjb3BlLGk9PW51bGw/dm9pZCAwOmkuaW5jbHVkZXMocykpfXJlbmRlcih0LGkpe2Zvcihjb25zdCBzIG9mIHRoaXMua2V5cyl7Y29uc3Qgbj10aGlzW3NdO2lmKG4hPT1udWxsKWlmKEFycmF5LmlzQXJyYXkobikpZm9yKGNvbnN0IHIgb2YgbilyPT1udWxsfHxyLnJlbmRlcih0LGkpO2Vsc2Ugbi5yZW5kZXIodCxpKX19c2V0QXNzaWduZWRWYWx1ZSh0KXt0aGlzLmFzc2lnbm1lbnRJbnRlcmFjdGlvbj17YXJnczpbbnVsbCx0XSx0eXBlOjF9fXNob3VsZEJlSW5jbHVkZWQodCl7cmV0dXJuIHRoaXMuaW5jbHVkZWR8fCF0LmJyb2tlbkZsb3cmJnRoaXMuaGFzRWZmZWN0cyh6cygpKX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITA7Zm9yKGNvbnN0IHQgb2YgdGhpcy5rZXlzKXtjb25zdCBpPXRoaXNbdF07aWYoaSE9PW51bGwpaWYoQXJyYXkuaXNBcnJheShpKSlmb3IoY29uc3QgcyBvZiBpKXM9PW51bGx8fHMuZGVvcHRpbWl6ZVBhdGgodGUpO2Vsc2UgaS5kZW9wdGltaXplUGF0aCh0ZSl9dGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKX19Y2xhc3MgZXMgZXh0ZW5kcyBWe2Rlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtpLmxlbmd0aD4wJiZ0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsW2hlLC4uLmldLHMpfWhhc0VmZmVjdHModCl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO2NvbnN0e3Byb3BlcnR5UmVhZFNpZGVFZmZlY3RzOml9PXRoaXMuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZTtyZXR1cm4gdGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzKHQpfHxpJiYoaT09PSJhbHdheXMifHx0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHRlLFJzLHQpKX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITAsdGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChbaGUsaGVdKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpfX1jbGFzcyBSZSBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5kZXNjcmlwdGlvbj10fWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHthcmdzOnQsdHlwZTppfSxzKXt2YXIgbjtpPT09MiYmcy5sZW5ndGg9PT0wJiZ0aGlzLmRlc2NyaXB0aW9uLm11dGF0ZXNTZWxmQXNBcnJheSYmKChuPXRbMF0pPT1udWxsfHxuLmRlb3B0aW1pemVQYXRoKFduKSl9Z2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCx7YXJnczppfSl7cmV0dXJuIHQubGVuZ3RoPjA/YmU6W3RoaXMuZGVzY3JpcHRpb24ucmV0dXJuc1ByaW1pdGl2ZXx8KHRoaXMuZGVzY3JpcHRpb24ucmV0dXJucz09PSJzZWxmIj9pWzBdfHxZOnRoaXMuZGVzY3JpcHRpb24ucmV0dXJucygpKSwhMV19aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3ZhciByLGE7Y29uc3R7dHlwZTpufT1pO2lmKHQubGVuZ3RoPihuPT09MD8xOjApKXJldHVybiEwO2lmKG49PT0yKXtjb25zdHthcmdzOm99PWk7aWYodGhpcy5kZXNjcmlwdGlvbi5tdXRhdGVzU2VsZkFzQXJyYXk9PT0hMCYmKChyPW9bMF0pIT1udWxsJiZyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFduLHFuLHMpKSlyZXR1cm4hMDtpZih0aGlzLmRlc2NyaXB0aW9uLmNhbGxzQXJncyl7Zm9yKGNvbnN0IGggb2YgdGhpcy5kZXNjcmlwdGlvbi5jYWxsc0FyZ3MpaWYoKGE9b1toKzFdKSE9bnVsbCYmYS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLE9zLHMpKXJldHVybiEwfX1yZXR1cm4hMX19Y29uc3QgcXM9W25ldyBSZSh7Y2FsbHNBcmdzOm51bGwsbXV0YXRlc1NlbGZBc0FycmF5OiExLHJldHVybnM6bnVsbCxyZXR1cm5zUHJpbWl0aXZlOnNyfSldLHRzPVtuZXcgUmUoe2NhbGxzQXJnczpudWxsLG11dGF0ZXNTZWxmQXNBcnJheTohMSxyZXR1cm5zOm51bGwscmV0dXJuc1ByaW1pdGl2ZTpucn0pXSxPbz1bbmV3IFJlKHtjYWxsc0FyZ3M6bnVsbCxtdXRhdGVzU2VsZkFzQXJyYXk6ITEscmV0dXJuczpudWxsLHJldHVybnNQcmltaXRpdmU6Q2l9KV0sVm89W25ldyBSZSh7Y2FsbHNBcmdzOm51bGwsbXV0YXRlc1NlbGZBc0FycmF5OiExLHJldHVybnM6bnVsbCxyZXR1cm5zUHJpbWl0aXZlOll9KV0saXM9L15cZCskLztjbGFzcyBIZSBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQsaSxzPSExKXtpZihzdXBlcigpLHRoaXMucHJvdG90eXBlRXhwcmVzc2lvbj1pLHRoaXMuaW1tdXRhYmxlPXMsdGhpcy5hZGRpdGlvbmFsRXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9bmV3IFNldCx0aGlzLmFsbFByb3BlcnRpZXM9W10sdGhpcy5kZW9wdGltaXplZFBhdGhzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZEJ5S2V5PU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5nZXR0ZXJzQnlLZXk9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLmhhc0xvc3RUcmFjaz0hMSx0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXI9ITEsdGhpcy5oYXNVbmtub3duRGVvcHRpbWl6ZWRQcm9wZXJ0eT0hMSx0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXk9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLnByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXk9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLnNldHRlcnNCeUtleT1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMudW5rbm93bkludGVnZXJQcm9wcz1bXSx0aGlzLnVubWF0Y2hhYmxlR2V0dGVycz1bXSx0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnM9W10sdGhpcy51bm1hdGNoYWJsZVNldHRlcnM9W10sQXJyYXkuaXNBcnJheSh0KSl0aGlzLmJ1aWxkUHJvcGVydHlNYXBzKHQpO2Vsc2V7dGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5PXRoaXMucHJvcGVydGllc0FuZFNldHRlcnNCeUtleT10O2Zvcihjb25zdCBuIG9mIE9iamVjdC52YWx1ZXModCkpdGhpcy5hbGxQcm9wZXJ0aWVzLnB1c2goLi4ubil9fWRlb3B0aW1pemVBbGxQcm9wZXJ0aWVzKHQpe3ZhciBzO2NvbnN0IGk9dGhpcy5oYXNMb3N0VHJhY2t8fHRoaXMuaGFzVW5rbm93bkRlb3B0aW1pemVkUHJvcGVydHk7aWYodD90aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5PSEwOnRoaXMuaGFzTG9zdFRyYWNrPSEwLCFpKXtmb3IoY29uc3QgbiBvZlsuLi5PYmplY3QudmFsdWVzKHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSksLi4uT2JqZWN0LnZhbHVlcyh0aGlzLnNldHRlcnNCeUtleSldKWZvcihjb25zdCByIG9mIG4pci5kZW9wdGltaXplUGF0aCh0ZSk7KHM9dGhpcy5wcm90b3R5cGVFeHByZXNzaW9uKT09bnVsbHx8cy5kZW9wdGltaXplUGF0aChbaGUsaGVdKSx0aGlzLmRlb3B0aW1pemVDYWNoZWRFbnRpdGllcygpfX1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7dmFyIHA7Y29uc3RbbiwuLi5yXT1pLHthcmdzOmEsdHlwZTpvfT10O2lmKHRoaXMuaGFzTG9zdFRyYWNrfHwobz09PTJ8fGkubGVuZ3RoPjEpJiYodGhpcy5oYXNVbmtub3duRGVvcHRpbWl6ZWRQcm9wZXJ0eXx8dHlwZW9mIG49PSJzdHJpbmciJiZ0aGlzLmRlb3B0aW1pemVkUGF0aHNbbl0pKXJldHVybiB2b2lkIER0KHQpO2NvbnN0W2gsbCxjXT1vPT09Mnx8aS5sZW5ndGg+MT9bdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LHRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleSx0aGlzLnVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnNdOm89PT0wP1t0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXksdGhpcy5nZXR0ZXJzQnlLZXksdGhpcy51bm1hdGNoYWJsZUdldHRlcnNdOlt0aGlzLnByb3BlcnRpZXNBbmRTZXR0ZXJzQnlLZXksdGhpcy5zZXR0ZXJzQnlLZXksdGhpcy51bm1hdGNoYWJsZVNldHRlcnNdO2lmKHR5cGVvZiBuPT0ic3RyaW5nIil7aWYoaFtuXSl7Y29uc3QgbT1sW25dO2lmKG0pZm9yKGNvbnN0IHkgb2YgbSl5LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQscixzKTtpZighdGhpcy5pbW11dGFibGUpZm9yKGNvbnN0IHkgb2YgYSl5JiZ0aGlzLmFkZGl0aW9uYWxFeHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5hZGQoeSk7cmV0dXJufWZvcihjb25zdCBtIG9mIGMpbS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LHIscyk7aWYoaXMudGVzdChuKSlmb3IoY29uc3QgbSBvZiB0aGlzLnVua25vd25JbnRlZ2VyUHJvcHMpbS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LHIscyl9ZWxzZXtmb3IoY29uc3QgbSBvZlsuLi5PYmplY3QudmFsdWVzKGwpLGNdKWZvcihjb25zdCB5IG9mIG0peS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LHIscyk7Zm9yKGNvbnN0IG0gb2YgdGhpcy51bmtub3duSW50ZWdlclByb3BzKW0uZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxyLHMpfWlmKCF0aGlzLmltbXV0YWJsZSlmb3IoY29uc3QgbSBvZiBhKW0mJnRoaXMuYWRkaXRpb25hbEV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLmFkZChtKTsocD10aGlzLnByb3RvdHlwZUV4cHJlc3Npb24pPT1udWxsfHxwLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX1kZW9wdGltaXplSW50ZWdlclByb3BlcnRpZXMoKXtpZighKHRoaXMuaGFzTG9zdFRyYWNrfHx0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZFByb3BlcnR5fHx0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXIpKXt0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXI9ITA7Zm9yKGNvbnN0W3QsaV1vZiBPYmplY3QuZW50cmllcyh0aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXkpKWlmKGlzLnRlc3QodCkpZm9yKGNvbnN0IHMgb2YgaSlzLmRlb3B0aW1pemVQYXRoKHRlKTt0aGlzLmRlb3B0aW1pemVDYWNoZWRJbnRlZ2VyRW50aXRpZXMoKX19ZGVvcHRpbWl6ZVBhdGgodCl7dmFyIG47aWYodGhpcy5oYXNMb3N0VHJhY2t8fHRoaXMuaW1tdXRhYmxlKXJldHVybjtjb25zdCBpPXRbMF07aWYodC5sZW5ndGg9PT0xKXtpZih0eXBlb2YgaSE9InN0cmluZyIpcmV0dXJuIGk9PT1XaT90aGlzLmRlb3B0aW1pemVJbnRlZ2VyUHJvcGVydGllcygpOnRoaXMuZGVvcHRpbWl6ZUFsbFByb3BlcnRpZXMoaT09PVRzKTtpZighdGhpcy5kZW9wdGltaXplZFBhdGhzW2ldKXt0aGlzLmRlb3B0aW1pemVkUGF0aHNbaV09ITA7Y29uc3Qgcj10aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXlbaV07aWYocilmb3IoY29uc3QgYSBvZiByKWEuZGVvcHRpbWl6ZUNhY2hlKCl9fWNvbnN0IHM9dC5sZW5ndGg9PT0xP3RlOnQuc2xpY2UoMSk7Zm9yKGNvbnN0IHIgb2YgdHlwZW9mIGk9PSJzdHJpbmciP1suLi50aGlzLnByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXlbaV18fHRoaXMudW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kR2V0dGVycywuLi50aGlzLnNldHRlcnNCeUtleVtpXXx8dGhpcy51bm1hdGNoYWJsZVNldHRlcnNdOnRoaXMuYWxsUHJvcGVydGllcylyLmRlb3B0aW1pemVQYXRoKHMpOyhuPXRoaXMucHJvdG90eXBlRXhwcmVzc2lvbik9PW51bGx8fG4uZGVvcHRpbWl6ZVBhdGgodC5sZW5ndGg9PT0xP1suLi50LGhlXTp0KX1nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCxpLHMpe2lmKHQubGVuZ3RoPT09MClyZXR1cm4gaW87Y29uc3Qgbj10WzBdLHI9dGhpcy5nZXRNZW1iZXJFeHByZXNzaW9uQW5kVHJhY2tEZW9wdChuLHMpO3JldHVybiByP3IuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQuc2xpY2UoMSksaSxzKTp0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24/dGhpcy5wcm90b3R5cGVFeHByZXNzaW9uLmdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyk6dC5sZW5ndGghPT0xP21lOnZvaWQgMH1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtpZih0Lmxlbmd0aD09PTApcmV0dXJuIGJlO2NvbnN0W3IsLi4uYV09dCxvPXRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbkFuZFRyYWNrRGVvcHQocixuKTtyZXR1cm4gbz9vLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGEsaSxzLG4pOnRoaXMucHJvdG90eXBlRXhwcmVzc2lvbj90aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCxpLHMsbik6YmV9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe2NvbnN0W24sLi4ucl09dDtpZihyLmxlbmd0aD4wfHxpLnR5cGU9PT0yKXtjb25zdCBsPXRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbihuKTtyZXR1cm4gbD9sLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHIsaSxzKTohdGhpcy5wcm90b3R5cGVFeHByZXNzaW9ufHx0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfWlmKG49PT1UcylyZXR1cm4hMTtpZih0aGlzLmhhc0xvc3RUcmFjaylyZXR1cm4hMDtjb25zdFthLG8saF09aS50eXBlPT09MD9bdGhpcy5wcm9wZXJ0aWVzQW5kR2V0dGVyc0J5S2V5LHRoaXMuZ2V0dGVyc0J5S2V5LHRoaXMudW5tYXRjaGFibGVHZXR0ZXJzXTpbdGhpcy5wcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5LHRoaXMuc2V0dGVyc0J5S2V5LHRoaXMudW5tYXRjaGFibGVTZXR0ZXJzXTtpZih0eXBlb2Ygbj09InN0cmluZyIpe2lmKGFbbl0pe2NvbnN0IGw9b1tuXTtpZihsKXtmb3IoY29uc3QgYyBvZiBsKWlmKGMuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgocixpLHMpKXJldHVybiEwfXJldHVybiExfWZvcihjb25zdCBsIG9mIGgpaWYobC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChyLGkscykpcmV0dXJuITB9ZWxzZSBmb3IoY29uc3QgbCBvZlsuLi5PYmplY3QudmFsdWVzKG8pLGhdKWZvcihjb25zdCBjIG9mIGwpaWYoYy5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChyLGkscykpcmV0dXJuITA7cmV0dXJuISF0aGlzLnByb3RvdHlwZUV4cHJlc3Npb24mJnRoaXMucHJvdG90eXBlRXhwcmVzc2lvbi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl9YnVpbGRQcm9wZXJ0eU1hcHModCl7Y29uc3R7YWxsUHJvcGVydGllczppLHByb3BlcnRpZXNBbmRHZXR0ZXJzQnlLZXk6cyxwcm9wZXJ0aWVzQW5kU2V0dGVyc0J5S2V5Om4sc2V0dGVyc0J5S2V5OnIsZ2V0dGVyc0J5S2V5OmEsdW5rbm93bkludGVnZXJQcm9wczpvLHVubWF0Y2hhYmxlUHJvcGVydGllc0FuZEdldHRlcnM6aCx1bm1hdGNoYWJsZUdldHRlcnM6bCx1bm1hdGNoYWJsZVNldHRlcnM6Y309dGhpcyxwPVtdO2ZvcihsZXQgbT10Lmxlbmd0aC0xO20+PTA7bS0tKXtjb25zdHtrZXk6eSxraW5kOkUscHJvcGVydHk6Z309dFttXTtpZihpLnB1c2goZyksdHlwZW9mIHk9PSJzdHJpbmciKUU9PT0ic2V0Ij9uW3ldfHwoblt5XT1bZywuLi5wXSxyW3ldPVtnLC4uLmNdKTpFPT09ImdldCI/c1t5XXx8KHNbeV09W2csLi4uaF0sYVt5XT1bZywuLi5sXSk6KG5beV18fChuW3ldPVtnLC4uLnBdKSxzW3ldfHwoc1t5XT1bZywuLi5oXSkpO2Vsc2V7aWYoeT09PVdpKXtvLnB1c2goZyk7Y29udGludWV9RT09PSJzZXQiJiZjLnB1c2goZyksRT09PSJnZXQiJiZsLnB1c2goZyksRSE9PSJnZXQiJiZwLnB1c2goZyksRSE9PSJzZXQiJiZoLnB1c2goZyl9fX1kZW9wdGltaXplQ2FjaGVkRW50aXRpZXMoKXtmb3IoY29uc3QgdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWRCeUtleSkpZm9yKGNvbnN0IGkgb2YgdClpLmRlb3B0aW1pemVDYWNoZSgpO2Zvcihjb25zdCB0IG9mIHRoaXMuYWRkaXRpb25hbEV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkKXQuZGVvcHRpbWl6ZVBhdGgodGUpfWRlb3B0aW1pemVDYWNoZWRJbnRlZ2VyRW50aXRpZXMoKXtmb3IoY29uc3RbdCxpXW9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWRCeUtleSkpaWYoaXMudGVzdCh0KSlmb3IoY29uc3QgcyBvZiBpKXMuZGVvcHRpbWl6ZUNhY2hlKCk7Zm9yKGNvbnN0IHQgb2YgdGhpcy5hZGRpdGlvbmFsRXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQpdC5kZW9wdGltaXplUGF0aChXbil9Z2V0TWVtYmVyRXhwcmVzc2lvbih0KXtpZih0aGlzLmhhc0xvc3RUcmFja3x8dGhpcy5oYXNVbmtub3duRGVvcHRpbWl6ZWRQcm9wZXJ0eXx8dHlwZW9mIHQhPSJzdHJpbmcifHx0aGlzLmhhc1Vua25vd25EZW9wdGltaXplZEludGVnZXImJmlzLnRlc3QodCl8fHRoaXMuZGVvcHRpbWl6ZWRQYXRoc1t0XSlyZXR1cm4gWTtjb25zdCBpPXRoaXMucHJvcGVydGllc0FuZEdldHRlcnNCeUtleVt0XTtyZXR1cm4oaT09bnVsbD92b2lkIDA6aS5sZW5ndGgpPT09MT9pWzBdOml8fHRoaXMudW5tYXRjaGFibGVQcm9wZXJ0aWVzQW5kR2V0dGVycy5sZW5ndGg+MHx8dGhpcy51bmtub3duSW50ZWdlclByb3BzLmxlbmd0aD4wJiZpcy50ZXN0KHQpP1k6bnVsbH1nZXRNZW1iZXJFeHByZXNzaW9uQW5kVHJhY2tEZW9wdCh0LGkpe2lmKHR5cGVvZiB0IT0ic3RyaW5nIilyZXR1cm4gWTtjb25zdCBzPXRoaXMuZ2V0TWVtYmVyRXhwcmVzc2lvbih0KTtyZXR1cm4gcyE9PVkmJiF0aGlzLmltbXV0YWJsZSYmKHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWRCeUtleVt0XT10aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkQnlLZXlbdF18fFtdKS5wdXNoKGkpLHN9fWNvbnN0IE1vPWU9PnR5cGVvZiBlPT0ic3RyaW5nIiYmL15cZCskLy50ZXN0KGUpLFZwPW5ldyBjbGFzcyBleHRlbmRzIFdle2Rlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCl7ZS50eXBlIT09Mnx8dC5sZW5ndGghPT0xfHxNbyh0WzBdKXx8RHQoZSl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUpe3JldHVybiBlLmxlbmd0aD09PTEmJk1vKGVbMF0pP3ZvaWQgMDptZX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHt0eXBlOnR9KXtyZXR1cm4gZS5sZW5ndGg+MXx8dD09PTJ9fSxGdD1uZXcgSGUoe19fcHJvdG9fXzpudWxsLGhhc093blByb3BlcnR5OnFzLGlzUHJvdG90eXBlT2Y6cXMscHJvcGVydHlJc0VudW1lcmFibGU6cXMsdG9Mb2NhbGVTdHJpbmc6dHMsdG9TdHJpbmc6dHMsdmFsdWVPZjpWb30sVnAsITApLHByPVt7a2V5OldpLGtpbmQ6ImluaXQiLHByb3BlcnR5Oll9LHtrZXk6Imxlbmd0aCIsa2luZDoiaW5pdCIscHJvcGVydHk6Q2l9XSxEbz1bbmV3IFJlKHtjYWxsc0FyZ3M6WzBdLG11dGF0ZXNTZWxmQXNBcnJheToiZGVvcHQtb25seSIscmV0dXJuczpudWxsLHJldHVybnNQcmltaXRpdmU6c3J9KV0sQm89W25ldyBSZSh7Y2FsbHNBcmdzOlswXSxtdXRhdGVzU2VsZkFzQXJyYXk6ImRlb3B0LW9ubHkiLHJldHVybnM6bnVsbCxyZXR1cm5zUHJpbWl0aXZlOkNpfSldLE1wPVtuZXcgUmUoe2NhbGxzQXJnczpudWxsLG11dGF0ZXNTZWxmQXNBcnJheTohMCxyZXR1cm5zOigpPT5uZXcgSGUocHIsS3MpLHJldHVybnNQcmltaXRpdmU6bnVsbH0pXSxIcz1bbmV3IFJlKHtjYWxsc0FyZ3M6bnVsbCxtdXRhdGVzU2VsZkFzQXJyYXk6ImRlb3B0LW9ubHkiLHJldHVybnM6KCk9Pm5ldyBIZShwcixLcykscmV0dXJuc1ByaW1pdGl2ZTpudWxsfSldLGRyPVtuZXcgUmUoe2NhbGxzQXJnczpbMF0sbXV0YXRlc1NlbGZBc0FycmF5OiJkZW9wdC1vbmx5IixyZXR1cm5zOigpPT5uZXcgSGUocHIsS3MpLHJldHVybnNQcmltaXRpdmU6bnVsbH0pXSxGbz1bbmV3IFJlKHtjYWxsc0FyZ3M6bnVsbCxtdXRhdGVzU2VsZkFzQXJyYXk6ITAscmV0dXJuczpudWxsLHJldHVybnNQcmltaXRpdmU6Q2l9KV0sem89W25ldyBSZSh7Y2FsbHNBcmdzOm51bGwsbXV0YXRlc1NlbGZBc0FycmF5OiEwLHJldHVybnM6bnVsbCxyZXR1cm5zUHJpbWl0aXZlOll9KV0sam89W25ldyBSZSh7Y2FsbHNBcmdzOm51bGwsbXV0YXRlc1NlbGZBc0FycmF5OiJkZW9wdC1vbmx5IixyZXR1cm5zOm51bGwscmV0dXJuc1ByaW1pdGl2ZTpZfSldLHNzPVtuZXcgUmUoe2NhbGxzQXJnczpbMF0sbXV0YXRlc1NlbGZBc0FycmF5OiJkZW9wdC1vbmx5IixyZXR1cm5zOm51bGwscmV0dXJuc1ByaW1pdGl2ZTpZfSldLGZyPVtuZXcgUmUoe2NhbGxzQXJnczpudWxsLG11dGF0ZXNTZWxmQXNBcnJheTohMCxyZXR1cm5zOiJzZWxmIixyZXR1cm5zUHJpbWl0aXZlOm51bGx9KV0sRHA9W25ldyBSZSh7Y2FsbHNBcmdzOlswXSxtdXRhdGVzU2VsZkFzQXJyYXk6ITAscmV0dXJuczoic2VsZiIscmV0dXJuc1ByaW1pdGl2ZTpudWxsfSldLEtzPW5ldyBIZSh7X19wcm90b19fOm51bGwsYXQ6am8sY29uY2F0OkhzLGNvcHlXaXRoaW46ZnIsZW50cmllczpIcyxldmVyeTpEbyxmaWxsOmZyLGZpbHRlcjpkcixmaW5kOnNzLGZpbmRJbmRleDpCbyxmaW5kTGFzdDpzcyxmaW5kTGFzdEluZGV4OkJvLGZsYXQ6SHMsZmxhdE1hcDpkcixmb3JFYWNoOnNzLGluY2x1ZGVzOnFzLGluZGV4T2Y6T28sam9pbjp0cyxrZXlzOlZvLGxhc3RJbmRleE9mOk9vLG1hcDpkcixwb3A6em8scHVzaDpGbyxyZWR1Y2U6c3MscmVkdWNlUmlnaHQ6c3MscmV2ZXJzZTpmcixzaGlmdDp6byxzbGljZTpIcyxzb21lOkRvLHNvcnQ6RHAsc3BsaWNlOk1wLHRvTG9jYWxlU3RyaW5nOnRzLHRvU3RyaW5nOnRzLHVuc2hpZnQ6Rm8sdmFsdWVzOmpvfSxGdCwhMCk7Y2xhc3MgVW8gZXh0ZW5kcyBWe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLm9iamVjdEVudGl0eT1udWxsfWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXt0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX1kZW9wdGltaXplUGF0aCh0KXt0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVQYXRoKHQpfWdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMDtsZXQgdD0hMTtmb3IobGV0IGk9MDtpPHRoaXMuZWxlbWVudHMubGVuZ3RoO2krKyl7Y29uc3Qgcz10aGlzLmVsZW1lbnRzW2ldO3MmJih0fHxzIGluc3RhbmNlb2YgZXMpJiYodD0hMCxzLmRlb3B0aW1pemVQYXRoKHRlKSl9dGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKX1nZXRPYmplY3RFbnRpdHkoKXtpZih0aGlzLm9iamVjdEVudGl0eSE9PW51bGwpcmV0dXJuIHRoaXMub2JqZWN0RW50aXR5O2NvbnN0IHQ9W3trZXk6Imxlbmd0aCIsa2luZDoiaW5pdCIscHJvcGVydHk6Q2l9XTtsZXQgaT0hMTtmb3IobGV0IHM9MDtzPHRoaXMuZWxlbWVudHMubGVuZ3RoO3MrKyl7Y29uc3Qgbj10aGlzLmVsZW1lbnRzW3NdO2l8fG4gaW5zdGFuY2VvZiBlcz9uJiYoaT0hMCx0LnVuc2hpZnQoe2tleTpXaSxraW5kOiJpbml0Iixwcm9wZXJ0eTpufSkpOm4/dC5wdXNoKHtrZXk6U3RyaW5nKHMpLGtpbmQ6ImluaXQiLHByb3BlcnR5Om59KTp0LnB1c2goe2tleTpTdHJpbmcocyksa2luZDoiaW5pdCIscHJvcGVydHk6QWl9KX1yZXR1cm4gdGhpcy5vYmplY3RFbnRpdHk9bmV3IEhlKHQsS3MpfX1jbGFzcyBHbyBleHRlbmRzIFZ7YWRkRXhwb3J0ZWRWYXJpYWJsZXModCxpKXtmb3IoY29uc3QgcyBvZiB0aGlzLmVsZW1lbnRzKXM9PW51bGx8fHMuYWRkRXhwb3J0ZWRWYXJpYWJsZXModCxpKX1kZWNsYXJlKHQpe2NvbnN0IGk9W107Zm9yKGNvbnN0IHMgb2YgdGhpcy5lbGVtZW50cylzIT09bnVsbCYmaS5wdXNoKC4uLnMuZGVjbGFyZSh0LFkpKTtyZXR1cm4gaX1kZW9wdGltaXplUGF0aCgpe2Zvcihjb25zdCB0IG9mIHRoaXMuZWxlbWVudHMpdD09bnVsbHx8dC5kZW9wdGltaXplUGF0aChRKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7Zm9yKGNvbnN0IG4gb2YgdGhpcy5lbGVtZW50cylpZihuIT1udWxsJiZuLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFEsaSxzKSlyZXR1cm4hMDtyZXR1cm4hMX1tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5lbGVtZW50cyl0PT1udWxsfHx0Lm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKX19Y2xhc3MgUHQgZXh0ZW5kcyB0aXtjb25zdHJ1Y3Rvcih0LGkscyxuKXtzdXBlcih0KSx0aGlzLmluaXQ9cyx0aGlzLmNhbGxlZEZyb21UcnlTdGF0ZW1lbnQ9ITEsdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzPW51bGwsdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZD1bXSx0aGlzLmRlY2xhcmF0aW9ucz1pP1tpXTpbXSx0aGlzLmRlb3B0aW1pemF0aW9uVHJhY2tlcj1uLmRlb3B0aW1pemF0aW9uVHJhY2tlcix0aGlzLm1vZHVsZT1uLm1vZHVsZX1hZGREZWNsYXJhdGlvbih0LGkpe3RoaXMuZGVjbGFyYXRpb25zLnB1c2godCksdGhpcy5tYXJrSW5pdGlhbGl6ZXJzRm9yRGVvcHRpbWl6YXRpb24oKS5wdXNoKGkpfWNvbnNvbGlkYXRlSW5pdGlhbGl6ZXJzKCl7aWYodGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzKXtmb3IoY29uc3QgdCBvZiB0aGlzLmFkZGl0aW9uYWxJbml0aWFsaXplcnMpdC5kZW9wdGltaXplUGF0aCh0ZSk7dGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzPW51bGx9fWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXt0aGlzLmlzUmVhc3NpZ25lZD9EdCh0KTpzLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKGksdGhpcy5pbml0LCgpPT50aGlzLmluaXQuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpLHZvaWQgMCl9ZGVvcHRpbWl6ZVBhdGgodCl7aWYoIXRoaXMuaXNSZWFzc2lnbmVkJiYhdGhpcy5kZW9wdGltaXphdGlvblRyYWNrZXIudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCx0aGlzKSlpZih0Lmxlbmd0aD09PTApe2lmKCF0aGlzLmlzUmVhc3NpZ25lZCl7dGhpcy5pc1JlYXNzaWduZWQ9ITA7Y29uc3QgaT10aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkO3RoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9dmU7Zm9yKGNvbnN0IHMgb2YgaSlzLmRlb3B0aW1pemVDYWNoZSgpO3RoaXMuaW5pdC5kZW9wdGltaXplUGF0aCh0ZSl9fWVsc2UgdGhpcy5pbml0LmRlb3B0aW1pemVQYXRoKHQpfWdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl7cmV0dXJuIHRoaXMuaXNSZWFzc2lnbmVkP21lOmkud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgodCx0aGlzLmluaXQsKCk9Pih0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gocyksdGhpcy5pbml0LmdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscykpLG1lKX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtyZXR1cm4gdGhpcy5pc1JlYXNzaWduZWQ/YmU6cy53aXRoVHJhY2tlZEVudGl0eUF0UGF0aCh0LHRoaXMuaW5pdCwoKT0+KHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQucHVzaChuKSx0aGlzLmluaXQuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCxpLHMsbikpLGJlKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7c3dpdGNoKGkudHlwZSl7Y2FzZSAwOnJldHVybiEhdGhpcy5pc1JlYXNzaWduZWR8fCFzLmFjY2Vzc2VkLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKHQsdGhpcykmJnRoaXMuaW5pdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyk7Y2FzZSAxOnJldHVybiEhdGhpcy5pbmNsdWRlZHx8dC5sZW5ndGghPT0wJiYoISF0aGlzLmlzUmVhc3NpZ25lZHx8IXMuYXNzaWduZWQudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCx0aGlzKSYmdGhpcy5pbml0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKSk7Y2FzZSAyOnJldHVybiEhdGhpcy5pc1JlYXNzaWduZWR8fCEoaS53aXRoTmV3P3MuaW5zdGFudGlhdGVkOnMuY2FsbGVkKS50cmFja0VudGl0eUF0UGF0aEFuZEdldElmVHJhY2tlZCh0LGkuYXJncyx0aGlzKSYmdGhpcy5pbml0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX19aW5jbHVkZSgpe2lmKCF0aGlzLmluY2x1ZGVkKXt0aGlzLmluY2x1ZGVkPSEwO2Zvcihjb25zdCB0IG9mIHRoaXMuZGVjbGFyYXRpb25zKXt0LmluY2x1ZGVkfHx0LmluY2x1ZGUoaXIoKSwhMSk7bGV0IGk9dC5wYXJlbnQ7Zm9yKDshaS5pbmNsdWRlZCYmKGkuaW5jbHVkZWQ9ITAsaS50eXBlIT09VXMpOylpPWkucGFyZW50fX19aW5jbHVkZUNhbGxBcmd1bWVudHModCxpKXtpZih0aGlzLmlzUmVhc3NpZ25lZHx8dC5pbmNsdWRlZENhbGxBcmd1bWVudHMuaGFzKHRoaXMuaW5pdCkpZm9yKGNvbnN0IHMgb2YgaSlzLmluY2x1ZGUodCwhMSk7ZWxzZSB0LmluY2x1ZGVkQ2FsbEFyZ3VtZW50cy5hZGQodGhpcy5pbml0KSx0aGlzLmluaXQuaW5jbHVkZUNhbGxBcmd1bWVudHModCxpKSx0LmluY2x1ZGVkQ2FsbEFyZ3VtZW50cy5kZWxldGUodGhpcy5pbml0KX1tYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpe3RoaXMuY2FsbGVkRnJvbVRyeVN0YXRlbWVudD0hMH1tYXJrSW5pdGlhbGl6ZXJzRm9yRGVvcHRpbWl6YXRpb24oKXtyZXR1cm4gdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzPT09bnVsbCYmKHRoaXMuYWRkaXRpb25hbEluaXRpYWxpemVycz1bdGhpcy5pbml0XSx0aGlzLmluaXQ9WSx0aGlzLmlzUmVhc3NpZ25lZD0hMCksdGhpcy5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzfW1lcmdlRGVjbGFyYXRpb25zKHQpe2NvbnN0e2RlY2xhcmF0aW9uczppfT10aGlzO2Zvcihjb25zdCBuIG9mIHQuZGVjbGFyYXRpb25zKWkucHVzaChuKTtjb25zdCBzPXRoaXMubWFya0luaXRpYWxpemVyc0ZvckRlb3B0aW1pemF0aW9uKCk7aWYocy5wdXNoKHQuaW5pdCksdC5hZGRpdGlvbmFsSW5pdGlhbGl6ZXJzKWZvcihjb25zdCBuIG9mIHQuYWRkaXRpb25hbEluaXRpYWxpemVycylzLnB1c2gobil9fWNvbnN0IFdvPXZlLEJwPW5ldyBTZXQoW2hlXSksRnA9bmV3IGtpLHpwPW5ldyBTZXQoW1ldKTtjbGFzcyBxbyBleHRlbmRzIFB0e2NvbnN0cnVjdG9yKHQsaSxzKXtzdXBlcih0LGksWSxzKSx0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zPVtdLHRoaXMuZGVvcHRpbWl6YXRpb25zPW5ldyBraSx0aGlzLmRlb3B0aW1pemVkRmllbGRzPW5ldyBTZXQsdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZD1uZXcgU2V0fWFkZEVudGl0eVRvQmVEZW9wdGltaXplZCh0KXtpZih0PT09WSl7aWYoIXRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuaGFzKFkpKXt0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkLmFkZChZKTtmb3IoY29uc3R7aW50ZXJhY3Rpb246aX1vZiB0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zKUR0KGkpO3RoaXMuZGVvcHRpbWl6YXRpb25JbnRlcmFjdGlvbnM9V299fWVsc2UgaWYodGhpcy5kZW9wdGltaXplZEZpZWxkcy5oYXMoaGUpKXQuZGVvcHRpbWl6ZVBhdGgodGUpO2Vsc2UgaWYoIXRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuaGFzKHQpKXt0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkLmFkZCh0KTtmb3IoY29uc3QgaSBvZiB0aGlzLmRlb3B0aW1pemVkRmllbGRzKXQuZGVvcHRpbWl6ZVBhdGgoW2ldKTtmb3IoY29uc3R7aW50ZXJhY3Rpb246aSxwYXRoOnN9b2YgdGhpcy5kZW9wdGltaXphdGlvbkludGVyYWN0aW9ucyl0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGkscyxBZSl9fWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSl7aWYoaS5sZW5ndGg+PTJ8fHRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQuaGFzKFkpfHx0aGlzLmRlb3B0aW1pemF0aW9uSW50ZXJhY3Rpb25zLmxlbmd0aD49MjB8fGkubGVuZ3RoPT09MSYmKHRoaXMuZGVvcHRpbWl6ZWRGaWVsZHMuaGFzKGhlKXx8dC50eXBlPT09MiYmdGhpcy5kZW9wdGltaXplZEZpZWxkcy5oYXMoaVswXSkpKUR0KHQpO2Vsc2UgaWYoIXRoaXMuZGVvcHRpbWl6YXRpb25zLnRyYWNrRW50aXR5QXRQYXRoQW5kR2V0SWZUcmFja2VkKGksdC5hcmdzKSl7Zm9yKGNvbnN0IHMgb2YgdGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZClzLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxBZSk7dGhpcy5lbnRpdGllc1RvQmVEZW9wdGltaXplZC5oYXMoWSl8fHRoaXMuZGVvcHRpbWl6YXRpb25JbnRlcmFjdGlvbnMucHVzaCh7aW50ZXJhY3Rpb246dCxwYXRoOml9KX19ZGVvcHRpbWl6ZVBhdGgodCl7aWYodC5sZW5ndGg9PT0wfHx0aGlzLmRlb3B0aW1pemVkRmllbGRzLmhhcyhoZSkpcmV0dXJuO2NvbnN0IGk9dFswXTtpZighdGhpcy5kZW9wdGltaXplZEZpZWxkcy5oYXMoaSkpe3RoaXMuZGVvcHRpbWl6ZWRGaWVsZHMuYWRkKGkpO2Zvcihjb25zdCBzIG9mIHRoaXMuZW50aXRpZXNUb0JlRGVvcHRpbWl6ZWQpcy5kZW9wdGltaXplUGF0aChbaV0pO2k9PT1oZSYmKHRoaXMuZGVvcHRpbWl6YXRpb25JbnRlcmFjdGlvbnM9V28sdGhpcy5kZW9wdGltaXphdGlvbnM9RnAsdGhpcy5kZW9wdGltaXplZEZpZWxkcz1CcCx0aGlzLmVudGl0aWVzVG9CZURlb3B0aW1pemVkPXpwKX19Z2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCl7cmV0dXJuIHQubGVuZ3RoPT09MD90aGlzLmRlb3B0aW1pemVQYXRoKHRlKTp0aGlzLmRlb3B0aW1pemVkRmllbGRzLmhhcyh0WzBdKXx8dGhpcy5kZW9wdGltaXplUGF0aChbdFswXV0pLGJlfX1jb25zdCBqcD0iMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfJCIsSG89NjQ7ZnVuY3Rpb24gUXMoZSl7bGV0IHQ9IiI7ZG97Y29uc3QgaT1lJUhvO2U9ZS9Ib3wwLHQ9anBbaV0rdH13aGlsZShlIT09MCk7cmV0dXJuIHR9ZnVuY3Rpb24gZnQoZSx0LGkpe2xldCBzPWUsbj0xO2Zvcig7dC5oYXMocyl8fE1zLmhhcyhzKXx8aSE9bnVsbCYmaS5oYXMocyk7KXM9YCR7ZX0kJHtRcyhuKyspfWA7cmV0dXJuIHQuYWRkKHMpLHN9bGV0IEtvPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jaGlsZHJlbj1bXSx0aGlzLnZhcmlhYmxlcz1uZXcgTWFwfWFkZERlY2xhcmF0aW9uKGUsdCxpLHMpe2NvbnN0IG49ZS5uYW1lO2xldCByPXRoaXMudmFyaWFibGVzLmdldChuKTtyZXR1cm4gcj9yLmFkZERlY2xhcmF0aW9uKGUsaSk6KHI9bmV3IFB0KGUubmFtZSxlLGl8fEFpLHQpLHRoaXMudmFyaWFibGVzLnNldChuLHIpKSxyfWNvbnRhaW5zKGUpe3JldHVybiB0aGlzLnZhcmlhYmxlcy5oYXMoZSl9ZmluZFZhcmlhYmxlKGUpe3Rocm93IG5ldyBFcnJvcigiSW50ZXJuYWwgRXJyb3I6IGZpbmRWYXJpYWJsZSBuZWVkcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIHN1YmNsYXNzIil9fTtjbGFzcyBsdCBleHRlbmRzIEtve2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXM9bmV3IE1hcCx0aGlzLnBhcmVudD10LHQuY2hpbGRyZW4ucHVzaCh0aGlzKX1hZGRBY2Nlc3NlZER5bmFtaWNJbXBvcnQodCl7KHRoaXMuYWNjZXNzZWREeW5hbWljSW1wb3J0c3x8KHRoaXMuYWNjZXNzZWREeW5hbWljSW1wb3J0cz1uZXcgU2V0KSkuYWRkKHQpLHRoaXMucGFyZW50IGluc3RhbmNlb2YgbHQmJnRoaXMucGFyZW50LmFkZEFjY2Vzc2VkRHluYW1pY0ltcG9ydCh0KX1hZGRBY2Nlc3NlZEdsb2JhbHModCxpKXtjb25zdCBzPWkuZ2V0KHRoaXMpfHxuZXcgU2V0O2Zvcihjb25zdCBuIG9mIHQpcy5hZGQobik7aS5zZXQodGhpcyxzKSx0aGlzLnBhcmVudCBpbnN0YW5jZW9mIGx0JiZ0aGlzLnBhcmVudC5hZGRBY2Nlc3NlZEdsb2JhbHModCxpKX1hZGROYW1lc3BhY2VNZW1iZXJBY2Nlc3ModCxpKXt0aGlzLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy5zZXQodCxpKSx0aGlzLnBhcmVudC5hZGROYW1lc3BhY2VNZW1iZXJBY2Nlc3ModCxpKX1hZGRSZXR1cm5FeHByZXNzaW9uKHQpe3RoaXMucGFyZW50IGluc3RhbmNlb2YgbHQmJnRoaXMucGFyZW50LmFkZFJldHVybkV4cHJlc3Npb24odCl9YWRkVXNlZE91dHNpZGVOYW1lcyh0LGkscyxuKXtmb3IoY29uc3QgYSBvZiB0aGlzLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy52YWx1ZXMoKSlhLmluY2x1ZGVkJiYodC5hZGQoYS5nZXRCYXNlVmFyaWFibGVOYW1lKCkpLGk9PT0ic3lzdGVtIiYmcy5oYXMoYSkmJnQuYWRkKCJleHBvcnRzIikpO2NvbnN0IHI9bi5nZXQodGhpcyk7aWYocilmb3IoY29uc3QgYSBvZiByKXQuYWRkKGEpfWNvbnRhaW5zKHQpe3JldHVybiB0aGlzLnZhcmlhYmxlcy5oYXModCl8fHRoaXMucGFyZW50LmNvbnRhaW5zKHQpfWRlY29uZmxpY3QodCxpLHMpe2NvbnN0IG49bmV3IFNldDtpZih0aGlzLmFkZFVzZWRPdXRzaWRlTmFtZXMobix0LGkscyksdGhpcy5hY2Nlc3NlZER5bmFtaWNJbXBvcnRzKWZvcihjb25zdCByIG9mIHRoaXMuYWNjZXNzZWREeW5hbWljSW1wb3J0cylyLmlubGluZU5hbWVzcGFjZSYmbi5hZGQoci5pbmxpbmVOYW1lc3BhY2UuZ2V0QmFzZVZhcmlhYmxlTmFtZSgpKTtmb3IoY29uc3RbcixhXW9mIHRoaXMudmFyaWFibGVzKShhLmluY2x1ZGVkfHxhLmFsd2F5c1JlbmRlcmVkKSYmYS5zZXRSZW5kZXJOYW1lcyhudWxsLGZ0KHIsbixhLmZvcmJpZGRlbk5hbWVzKSk7Zm9yKGNvbnN0IHIgb2YgdGhpcy5jaGlsZHJlbilyLmRlY29uZmxpY3QodCxpLHMpfWZpbmRMZXhpY2FsQm91bmRhcnkoKXtyZXR1cm4gdGhpcy5wYXJlbnQuZmluZExleGljYWxCb3VuZGFyeSgpfWZpbmRWYXJpYWJsZSh0KXtjb25zdCBpPXRoaXMudmFyaWFibGVzLmdldCh0KXx8dGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuZ2V0KHQpO2lmKGkpcmV0dXJuIGk7Y29uc3Qgcz10aGlzLnBhcmVudC5maW5kVmFyaWFibGUodCk7cmV0dXJuIHRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnNldCh0LHMpLHN9fWNsYXNzIFFvIGV4dGVuZHMgbHR7Y29uc3RydWN0b3IodCxpKXtzdXBlcih0KSx0aGlzLnBhcmFtZXRlcnM9W10sdGhpcy5oYXNSZXN0PSExLHRoaXMuY29udGV4dD1pLHRoaXMuaG9pc3RlZEJvZHlWYXJTY29wZT1uZXcgbHQodGhpcyl9YWRkUGFyYW1ldGVyRGVjbGFyYXRpb24odCl7Y29uc3R7bmFtZTppfT10LHM9bmV3IHFvKGksdCx0aGlzLmNvbnRleHQpLG49dGhpcy5ob2lzdGVkQm9keVZhclNjb3BlLnZhcmlhYmxlcy5nZXQoaSk7cmV0dXJuIG4mJih0aGlzLmhvaXN0ZWRCb2R5VmFyU2NvcGUudmFyaWFibGVzLnNldChpLHMpLHMubWVyZ2VEZWNsYXJhdGlvbnMobikpLHRoaXMudmFyaWFibGVzLnNldChpLHMpLHN9YWRkUGFyYW1ldGVyVmFyaWFibGVzKHQsaSl7dGhpcy5wYXJhbWV0ZXJzPXQ7Zm9yKGNvbnN0IHMgb2YgdClmb3IoY29uc3QgbiBvZiBzKW4uYWx3YXlzUmVuZGVyZWQ9ITA7dGhpcy5oYXNSZXN0PWl9aW5jbHVkZUNhbGxBcmd1bWVudHModCxpKXtsZXQgcz0hMSxuPSExO2NvbnN0IHI9dGhpcy5oYXNSZXN0JiZ0aGlzLnBhcmFtZXRlcnNbdGhpcy5wYXJhbWV0ZXJzLmxlbmd0aC0xXTtmb3IoY29uc3QgYSBvZiBpKWlmKGEgaW5zdGFuY2VvZiBlcyl7Zm9yKGNvbnN0IG8gb2YgaSlvLmluY2x1ZGUodCwhMSk7YnJlYWt9Zm9yKGxldCBhPWkubGVuZ3RoLTE7YT49MDthLS0pe2NvbnN0IG89dGhpcy5wYXJhbWV0ZXJzW2FdfHxyLGg9aVthXTtpZihvKWlmKHM9ITEsby5sZW5ndGg9PT0wKW49ITA7ZWxzZSBmb3IoY29uc3QgbCBvZiBvKWwuaW5jbHVkZWQmJihuPSEwKSxsLmNhbGxlZEZyb21UcnlTdGF0ZW1lbnQmJihzPSEwKTshbiYmaC5zaG91bGRCZUluY2x1ZGVkKHQpJiYobj0hMCksbiYmaC5pbmNsdWRlKHQscyl9fX1jbGFzcyBZbyBleHRlbmRzIFFve2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnJldHVybkV4cHJlc3Npb249bnVsbCx0aGlzLnJldHVybkV4cHJlc3Npb25zPVtdfWFkZFJldHVybkV4cHJlc3Npb24odCl7dGhpcy5yZXR1cm5FeHByZXNzaW9ucy5wdXNoKHQpfWdldFJldHVybkV4cHJlc3Npb24oKXtyZXR1cm4gdGhpcy5yZXR1cm5FeHByZXNzaW9uPT09bnVsbCYmdGhpcy51cGRhdGVSZXR1cm5FeHByZXNzaW9uKCksdGhpcy5yZXR1cm5FeHByZXNzaW9ufXVwZGF0ZVJldHVybkV4cHJlc3Npb24oKXtpZih0aGlzLnJldHVybkV4cHJlc3Npb25zLmxlbmd0aD09PTEpdGhpcy5yZXR1cm5FeHByZXNzaW9uPXRoaXMucmV0dXJuRXhwcmVzc2lvbnNbMF07ZWxzZXt0aGlzLnJldHVybkV4cHJlc3Npb249WTtmb3IoY29uc3QgdCBvZiB0aGlzLnJldHVybkV4cHJlc3Npb25zKXQuZGVvcHRpbWl6ZVBhdGgodGUpfX19ZnVuY3Rpb24gWG8oZSx0KXtpZihlLnR5cGU9PT0iTWVtYmVyRXhwcmVzc2lvbiIpcmV0dXJuIWUuY29tcHV0ZWQmJlhvKGUub2JqZWN0LGUpO2lmKGUudHlwZT09PSJJZGVudGlmaWVyIil7aWYoIXQpcmV0dXJuITA7c3dpdGNoKHQudHlwZSl7Y2FzZSJNZW1iZXJFeHByZXNzaW9uIjpyZXR1cm4gdC5jb21wdXRlZHx8ZT09PXQub2JqZWN0O2Nhc2UiTWV0aG9kRGVmaW5pdGlvbiI6cmV0dXJuIHQuY29tcHV0ZWQ7Y2FzZSJQcm9wZXJ0eURlZmluaXRpb24iOmNhc2UiUHJvcGVydHkiOnJldHVybiB0LmNvbXB1dGVkfHxlPT09dC52YWx1ZTtjYXNlIkV4cG9ydFNwZWNpZmllciI6Y2FzZSJJbXBvcnRTcGVjaWZpZXIiOnJldHVybiBlPT09dC5sb2NhbDtjYXNlIkxhYmVsZWRTdGF0ZW1lbnQiOmNhc2UiQnJlYWtTdGF0ZW1lbnQiOmNhc2UiQ29udGludWVTdGF0ZW1lbnQiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXJldHVybiExfWNvbnN0IG1yPVN5bWJvbCgiUHVyZUZ1bmN0aW9uIiksdXQ9KCk9Pnt9LHVlPVN5bWJvbCgiVmFsdWUgUHJvcGVydGllcyIpLFBpPSgpPT5pbyxabz0oKT0+ITEsSm89KCk9PiEwLG10PXtkZW9wdGltaXplQXJndW1lbnRzT25DYWxsOnV0LGdldExpdGVyYWxWYWx1ZTpQaSxoYXNFZmZlY3RzV2hlbkNhbGxlZDpab30sX3Q9e2Rlb3B0aW1pemVBcmd1bWVudHNPbkNhbGw6dXQsZ2V0TGl0ZXJhbFZhbHVlOlBpLGhhc0VmZmVjdHNXaGVuQ2FsbGVkOkpvfSxJPXtfX3Byb3RvX186bnVsbCxbdWVdOl90fSxUPXtfX3Byb3RvX186bnVsbCxbdWVdOm10fSxlaD17X19wcm90b19fOm51bGwsW3VlXTp7ZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbDp1dCxnZXRMaXRlcmFsVmFsdWU6UGksaGFzRWZmZWN0c1doZW5DYWxsZWQoe2FyZ3M6ZX0sdCl7Y29uc3RbaSxzXT1lO3JldHVybiEocyBpbnN0YW5jZW9mIFdlKXx8cy5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0ZSxScyx0KX19fSxncj17X19wcm90b19fOm51bGwsW3VlXTp7ZGVvcHRpbWl6ZUFyZ3VtZW50c09uQ2FsbCh7YXJnczpbLGVdfSl7ZT09bnVsbHx8ZS5kZW9wdGltaXplUGF0aCh0ZSl9LGdldExpdGVyYWxWYWx1ZTpQaSxoYXNFZmZlY3RzV2hlbkNhbGxlZDooe2FyZ3M6ZX0sdCk9PmUubGVuZ3RoPD0xfHxlWzFdLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKExjLHFuLHQpfX0sdT17X19wcm90b19fOm51bGwsW3VlXTpfdCxwcm90b3R5cGU6SX0sY3Q9e19fcHJvdG9fXzpudWxsLFt1ZV06bXQscHJvdG90eXBlOkl9LFlzPXtfX3Byb3RvX186bnVsbCxbdWVdOntkZW9wdGltaXplQXJndW1lbnRzT25DYWxsOnV0LGdldExpdGVyYWxWYWx1ZTpQaSxoYXNFZmZlY3RzV2hlbkNhbGxlZDooe2FyZ3M6ZX0pPT5lLmxlbmd0aD4xJiYhKGVbMV1pbnN0YW5jZW9mIFVvKX0scHJvdG90eXBlOkl9LE50PXtfX3Byb3RvX186bnVsbCxbdWVdOm10LGZyb206SSxvZjpULHByb3RvdHlwZTpJfSwkdD17X19wcm90b19fOm51bGwsW3VlXTptdCxzdXBwb3J0ZWRMb2NhbGVzT2Y6Y3R9LHlyPXtnbG9iYWw6SSxnbG9iYWxUaGlzOkksc2VsZjpJLHdpbmRvdzpJLF9fcHJvdG9fXzpudWxsLFt1ZV06X3QsQXJyYXk6e19fcHJvdG9fXzpudWxsLFt1ZV06X3QsZnJvbTpJLGlzQXJyYXk6VCxvZjpULHByb3RvdHlwZTpJfSxBcnJheUJ1ZmZlcjp7X19wcm90b19fOm51bGwsW3VlXTptdCxpc1ZpZXc6VCxwcm90b3R5cGU6SX0sQXRvbWljczpJLEJpZ0ludDp1LEJpZ0ludDY0QXJyYXk6dSxCaWdVaW50NjRBcnJheTp1LEJvb2xlYW46Y3QsY29uc3RydWN0b3I6dSxEYXRhVmlldzpjdCxEYXRlOntfX3Byb3RvX186bnVsbCxbdWVdOm10LG5vdzpULHBhcnNlOlQscHJvdG90eXBlOkksVVRDOlR9LGRlY29kZVVSSTpULGRlY29kZVVSSUNvbXBvbmVudDpULGVuY29kZVVSSTpULGVuY29kZVVSSUNvbXBvbmVudDpULEVycm9yOmN0LGVzY2FwZTpULGV2YWw6SSxFdmFsRXJyb3I6Y3QsRmxvYXQzMkFycmF5Ok50LEZsb2F0NjRBcnJheTpOdCxGdW5jdGlvbjp1LGhhc093blByb3BlcnR5OkksSW5maW5pdHk6SSxJbnQxNkFycmF5Ok50LEludDMyQXJyYXk6TnQsSW50OEFycmF5Ok50LGlzRmluaXRlOlQsaXNOYU46VCxpc1Byb3RvdHlwZU9mOkksSlNPTjpJLE1hcDpZcyxNYXRoOntfX3Byb3RvX186bnVsbCxbdWVdOl90LGFiczpULGFjb3M6VCxhY29zaDpULGFzaW46VCxhc2luaDpULGF0YW46VCxhdGFuMjpULGF0YW5oOlQsY2JydDpULGNlaWw6VCxjbHozMjpULGNvczpULGNvc2g6VCxleHA6VCxleHBtMTpULGZsb29yOlQsZnJvdW5kOlQsaHlwb3Q6VCxpbXVsOlQsbG9nOlQsbG9nMTA6VCxsb2cxcDpULGxvZzI6VCxtYXg6VCxtaW46VCxwb3c6VCxyYW5kb206VCxyb3VuZDpULHNpZ246VCxzaW46VCxzaW5oOlQsc3FydDpULHRhbjpULHRhbmg6VCx0cnVuYzpUfSxOYU46SSxOdW1iZXI6e19fcHJvdG9fXzpudWxsLFt1ZV06bXQsaXNGaW5pdGU6VCxpc0ludGVnZXI6VCxpc05hTjpULGlzU2FmZUludGVnZXI6VCxwYXJzZUZsb2F0OlQscGFyc2VJbnQ6VCxwcm90b3R5cGU6SX0sT2JqZWN0OntfX3Byb3RvX186bnVsbCxbdWVdOm10LGNyZWF0ZTpULGRlZmluZVByb3BlcnR5OmdyLGRlZmluZVByb3BlcnRpZXM6Z3IsZnJlZXplOmdyLGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpULGdldE93blByb3BlcnR5RGVzY3JpcHRvcnM6VCxnZXRPd25Qcm9wZXJ0eU5hbWVzOlQsZ2V0T3duUHJvcGVydHlTeW1ib2xzOlQsZ2V0UHJvdG90eXBlT2Y6VCxoYXNPd246VCxpczpULGlzRXh0ZW5zaWJsZTpULGlzRnJvemVuOlQsaXNTZWFsZWQ6VCxrZXlzOlQsZnJvbUVudHJpZXM6SSxlbnRyaWVzOmVoLHZhbHVlczplaCxwcm90b3R5cGU6SX0scGFyc2VGbG9hdDpULHBhcnNlSW50OlQsUHJvbWlzZTp7X19wcm90b19fOm51bGwsW3VlXTpfdCxhbGw6SSxhbGxTZXR0bGVkOkksYW55OkkscHJvdG90eXBlOkkscmFjZTpJLHJlamVjdDpJLHJlc29sdmU6SX0scHJvcGVydHlJc0VudW1lcmFibGU6SSxQcm94eTpJLFJhbmdlRXJyb3I6Y3QsUmVmZXJlbmNlRXJyb3I6Y3QsUmVmbGVjdDpJLFJlZ0V4cDpjdCxTZXQ6WXMsU2hhcmVkQXJyYXlCdWZmZXI6dSxTdHJpbmc6e19fcHJvdG9fXzpudWxsLFt1ZV06bXQsZnJvbUNoYXJDb2RlOlQsZnJvbUNvZGVQb2ludDpULHByb3RvdHlwZTpJLHJhdzpUfSxTeW1ib2w6e19fcHJvdG9fXzpudWxsLFt1ZV06bXQsZm9yOlQsa2V5Rm9yOlQscHJvdG90eXBlOkksdG9TdHJpbmdUYWc6e19fcHJvdG9fXzpudWxsLFt1ZV06e2Rlb3B0aW1pemVBcmd1bWVudHNPbkNhbGw6dXQsZ2V0TGl0ZXJhbFZhbHVlOigpPT5HbixoYXNFZmZlY3RzV2hlbkNhbGxlZDpKb319fSxTeW50YXhFcnJvcjpjdCx0b0xvY2FsZVN0cmluZzpJLHRvU3RyaW5nOkksVHlwZUVycm9yOmN0LFVpbnQxNkFycmF5Ok50LFVpbnQzMkFycmF5Ok50LFVpbnQ4QXJyYXk6TnQsVWludDhDbGFtcGVkQXJyYXk6TnQsdW5lc2NhcGU6VCxVUklFcnJvcjpjdCx2YWx1ZU9mOkksV2Vha01hcDpZcyxXZWFrU2V0OllzLGNsZWFySW50ZXJ2YWw6dSxjbGVhclRpbWVvdXQ6dSxjb25zb2xlOntfX3Byb3RvX186bnVsbCxbdWVdOl90LGFzc2VydDp1LGNsZWFyOnUsY291bnQ6dSxjb3VudFJlc2V0OnUsZGVidWc6dSxkaXI6dSxkaXJ4bWw6dSxlcnJvcjp1LGV4Y2VwdGlvbjp1LGdyb3VwOnUsZ3JvdXBDb2xsYXBzZWQ6dSxncm91cEVuZDp1LGluZm86dSxsb2c6dSx0YWJsZTp1LHRpbWU6dSx0aW1lRW5kOnUsdGltZUxvZzp1LHRyYWNlOnUsd2Fybjp1fSxJbnRsOntfX3Byb3RvX186bnVsbCxbdWVdOl90LENvbGxhdG9yOiR0LERhdGVUaW1lRm9ybWF0OiR0LERpc3BsYXlOYW1lczokdCxMaXN0Rm9ybWF0OiR0LExvY2FsZTokdCxOdW1iZXJGb3JtYXQ6JHQsUGx1cmFsUnVsZXM6JHQsUmVsYXRpdmVUaW1lRm9ybWF0OiR0LFNlZ21lbnRlcjokdH0sc2V0SW50ZXJ2YWw6dSxzZXRUaW1lb3V0OnUsVGV4dERlY29kZXI6dSxUZXh0RW5jb2Rlcjp1LFVSTDp7X19wcm90b19fOm51bGwsW3VlXTpfdCxwcm90b3R5cGU6SSxjYW5QYXJzZTpUfSxVUkxTZWFyY2hQYXJhbXM6dSxBYm9ydENvbnRyb2xsZXI6dSxBYm9ydFNpZ25hbDp1LGFkZEV2ZW50TGlzdGVuZXI6SSxhbGVydDpJLEFuYWx5c2VyTm9kZTp1LEFuaW1hdGlvbjp1LEFuaW1hdGlvbkV2ZW50OnUsYXBwbGljYXRpb25DYWNoZTpJLEFwcGxpY2F0aW9uQ2FjaGU6dSxBcHBsaWNhdGlvbkNhY2hlRXJyb3JFdmVudDp1LGF0b2I6SSxBdHRyOnUsQXVkaW86dSxBdWRpb0J1ZmZlcjp1LEF1ZGlvQnVmZmVyU291cmNlTm9kZTp1LEF1ZGlvQ29udGV4dDp1LEF1ZGlvRGVzdGluYXRpb25Ob2RlOnUsQXVkaW9MaXN0ZW5lcjp1LEF1ZGlvTm9kZTp1LEF1ZGlvUGFyYW06dSxBdWRpb1Byb2Nlc3NpbmdFdmVudDp1LEF1ZGlvU2NoZWR1bGVkU291cmNlTm9kZTp1LEF1ZGlvV29ya2xldE5vZGU6dSxCYXJQcm9wOnUsQmFzZUF1ZGlvQ29udGV4dDp1LEJhdHRlcnlNYW5hZ2VyOnUsQmVmb3JlVW5sb2FkRXZlbnQ6dSxCaXF1YWRGaWx0ZXJOb2RlOnUsQmxvYjp1LEJsb2JFdmVudDp1LGJsdXI6SSxCcm9hZGNhc3RDaGFubmVsOnUsYnRvYTpJLEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k6dSxDYWNoZTp1LGNhY2hlczpJLENhY2hlU3RvcmFnZTp1LGNhbmNlbEFuaW1hdGlvbkZyYW1lOkksY2FuY2VsSWRsZUNhbGxiYWNrOkksQ2FudmFzQ2FwdHVyZU1lZGlhU3RyZWFtVHJhY2s6dSxDYW52YXNHcmFkaWVudDp1LENhbnZhc1BhdHRlcm46dSxDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ6dSxDaGFubmVsTWVyZ2VyTm9kZTp1LENoYW5uZWxTcGxpdHRlck5vZGU6dSxDaGFyYWN0ZXJEYXRhOnUsY2xpZW50SW5mb3JtYXRpb246SSxDbGlwYm9hcmRFdmVudDp1LGNsb3NlOkksY2xvc2VkOkksQ2xvc2VFdmVudDp1LENvbW1lbnQ6dSxDb21wb3NpdGlvbkV2ZW50OnUsY29uZmlybTpJLENvbnN0YW50U291cmNlTm9kZTp1LENvbnZvbHZlck5vZGU6dSxDb3VudFF1ZXVpbmdTdHJhdGVneTp1LGNyZWF0ZUltYWdlQml0bWFwOkksQ3JlZGVudGlhbDp1LENyZWRlbnRpYWxzQ29udGFpbmVyOnUsY3J5cHRvOkksQ3J5cHRvOnUsQ3J5cHRvS2V5OnUsQ1NTOnUsQ1NTQ29uZGl0aW9uUnVsZTp1LENTU0ZvbnRGYWNlUnVsZTp1LENTU0dyb3VwaW5nUnVsZTp1LENTU0ltcG9ydFJ1bGU6dSxDU1NLZXlmcmFtZVJ1bGU6dSxDU1NLZXlmcmFtZXNSdWxlOnUsQ1NTTWVkaWFSdWxlOnUsQ1NTTmFtZXNwYWNlUnVsZTp1LENTU1BhZ2VSdWxlOnUsQ1NTUnVsZTp1LENTU1J1bGVMaXN0OnUsQ1NTU3R5bGVEZWNsYXJhdGlvbjp1LENTU1N0eWxlUnVsZTp1LENTU1N0eWxlU2hlZXQ6dSxDU1NTdXBwb3J0c1J1bGU6dSxDdXN0b21FbGVtZW50UmVnaXN0cnk6dSxjdXN0b21FbGVtZW50czpJLEN1c3RvbUV2ZW50OntfX3Byb3RvX186bnVsbCxbdWVdOntkZW9wdGltaXplQXJndW1lbnRzT25DYWxsKHthcmdzOmV9KXt2YXIgdDsodD1lWzJdKT09bnVsbHx8dC5kZW9wdGltaXplUGF0aChbImRldGFpbCJdKX0sZ2V0TGl0ZXJhbFZhbHVlOlBpLGhhc0VmZmVjdHNXaGVuQ2FsbGVkOlpvfSxwcm90b3R5cGU6SX0sRGF0YVRyYW5zZmVyOnUsRGF0YVRyYW5zZmVySXRlbTp1LERhdGFUcmFuc2Zlckl0ZW1MaXN0OnUsZGVmYXVsdHN0YXR1czpJLGRlZmF1bHRTdGF0dXM6SSxEZWxheU5vZGU6dSxEZXZpY2VNb3Rpb25FdmVudDp1LERldmljZU9yaWVudGF0aW9uRXZlbnQ6dSxkZXZpY2VQaXhlbFJhdGlvOkksZGlzcGF0Y2hFdmVudDpJLGRvY3VtZW50OkksRG9jdW1lbnQ6dSxEb2N1bWVudEZyYWdtZW50OnUsRG9jdW1lbnRUeXBlOnUsRE9NRXJyb3I6dSxET01FeGNlcHRpb246dSxET01JbXBsZW1lbnRhdGlvbjp1LERPTU1hdHJpeDp1LERPTU1hdHJpeFJlYWRPbmx5OnUsRE9NUGFyc2VyOnUsRE9NUG9pbnQ6dSxET01Qb2ludFJlYWRPbmx5OnUsRE9NUXVhZDp1LERPTVJlY3Q6dSxET01SZWN0UmVhZE9ubHk6dSxET01TdHJpbmdMaXN0OnUsRE9NU3RyaW5nTWFwOnUsRE9NVG9rZW5MaXN0OnUsRHJhZ0V2ZW50OnUsRHluYW1pY3NDb21wcmVzc29yTm9kZTp1LEVsZW1lbnQ6dSxFcnJvckV2ZW50OnUsRXZlbnQ6dSxFdmVudFNvdXJjZTp1LEV2ZW50VGFyZ2V0OnUsZXh0ZXJuYWw6SSxmZXRjaDpJLEZpbGU6dSxGaWxlTGlzdDp1LEZpbGVSZWFkZXI6dSxmaW5kOkksZm9jdXM6SSxGb2N1c0V2ZW50OnUsRm9udEZhY2U6dSxGb250RmFjZVNldExvYWRFdmVudDp1LEZvcm1EYXRhOnUsZnJhbWVzOkksR2Fpbk5vZGU6dSxHYW1lcGFkOnUsR2FtZXBhZEJ1dHRvbjp1LEdhbWVwYWRFdmVudDp1LGdldENvbXB1dGVkU3R5bGU6SSxnZXRTZWxlY3Rpb246SSxIYXNoQ2hhbmdlRXZlbnQ6dSxIZWFkZXJzOnUsaGlzdG9yeTpJLEhpc3Rvcnk6dSxIVE1MQWxsQ29sbGVjdGlvbjp1LEhUTUxBbmNob3JFbGVtZW50OnUsSFRNTEFyZWFFbGVtZW50OnUsSFRNTEF1ZGlvRWxlbWVudDp1LEhUTUxCYXNlRWxlbWVudDp1LEhUTUxCb2R5RWxlbWVudDp1LEhUTUxCUkVsZW1lbnQ6dSxIVE1MQnV0dG9uRWxlbWVudDp1LEhUTUxDYW52YXNFbGVtZW50OnUsSFRNTENvbGxlY3Rpb246dSxIVE1MQ29udGVudEVsZW1lbnQ6dSxIVE1MRGF0YUVsZW1lbnQ6dSxIVE1MRGF0YUxpc3RFbGVtZW50OnUsSFRNTERldGFpbHNFbGVtZW50OnUsSFRNTERpYWxvZ0VsZW1lbnQ6dSxIVE1MRGlyZWN0b3J5RWxlbWVudDp1LEhUTUxEaXZFbGVtZW50OnUsSFRNTERMaXN0RWxlbWVudDp1LEhUTUxEb2N1bWVudDp1LEhUTUxFbGVtZW50OnUsSFRNTEVtYmVkRWxlbWVudDp1LEhUTUxGaWVsZFNldEVsZW1lbnQ6dSxIVE1MRm9udEVsZW1lbnQ6dSxIVE1MRm9ybUNvbnRyb2xzQ29sbGVjdGlvbjp1LEhUTUxGb3JtRWxlbWVudDp1LEhUTUxGcmFtZUVsZW1lbnQ6dSxIVE1MRnJhbWVTZXRFbGVtZW50OnUsSFRNTEhlYWRFbGVtZW50OnUsSFRNTEhlYWRpbmdFbGVtZW50OnUsSFRNTEhSRWxlbWVudDp1LEhUTUxIdG1sRWxlbWVudDp1LEhUTUxJRnJhbWVFbGVtZW50OnUsSFRNTEltYWdlRWxlbWVudDp1LEhUTUxJbnB1dEVsZW1lbnQ6dSxIVE1MTGFiZWxFbGVtZW50OnUsSFRNTExlZ2VuZEVsZW1lbnQ6dSxIVE1MTElFbGVtZW50OnUsSFRNTExpbmtFbGVtZW50OnUsSFRNTE1hcEVsZW1lbnQ6dSxIVE1MTWFycXVlZUVsZW1lbnQ6dSxIVE1MTWVkaWFFbGVtZW50OnUsSFRNTE1lbnVFbGVtZW50OnUsSFRNTE1ldGFFbGVtZW50OnUsSFRNTE1ldGVyRWxlbWVudDp1LEhUTUxNb2RFbGVtZW50OnUsSFRNTE9iamVjdEVsZW1lbnQ6dSxIVE1MT0xpc3RFbGVtZW50OnUsSFRNTE9wdEdyb3VwRWxlbWVudDp1LEhUTUxPcHRpb25FbGVtZW50OnUsSFRNTE9wdGlvbnNDb2xsZWN0aW9uOnUsSFRNTE91dHB1dEVsZW1lbnQ6dSxIVE1MUGFyYWdyYXBoRWxlbWVudDp1LEhUTUxQYXJhbUVsZW1lbnQ6dSxIVE1MUGljdHVyZUVsZW1lbnQ6dSxIVE1MUHJlRWxlbWVudDp1LEhUTUxQcm9ncmVzc0VsZW1lbnQ6dSxIVE1MUXVvdGVFbGVtZW50OnUsSFRNTFNjcmlwdEVsZW1lbnQ6dSxIVE1MU2VsZWN0RWxlbWVudDp1LEhUTUxTaGFkb3dFbGVtZW50OnUsSFRNTFNsb3RFbGVtZW50OnUsSFRNTFNvdXJjZUVsZW1lbnQ6dSxIVE1MU3BhbkVsZW1lbnQ6dSxIVE1MU3R5bGVFbGVtZW50OnUsSFRNTFRhYmxlQ2FwdGlvbkVsZW1lbnQ6dSxIVE1MVGFibGVDZWxsRWxlbWVudDp1LEhUTUxUYWJsZUNvbEVsZW1lbnQ6dSxIVE1MVGFibGVFbGVtZW50OnUsSFRNTFRhYmxlUm93RWxlbWVudDp1LEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50OnUsSFRNTFRlbXBsYXRlRWxlbWVudDp1LEhUTUxUZXh0QXJlYUVsZW1lbnQ6dSxIVE1MVGltZUVsZW1lbnQ6dSxIVE1MVGl0bGVFbGVtZW50OnUsSFRNTFRyYWNrRWxlbWVudDp1LEhUTUxVTGlzdEVsZW1lbnQ6dSxIVE1MVW5rbm93bkVsZW1lbnQ6dSxIVE1MVmlkZW9FbGVtZW50OnUsSURCQ3Vyc29yOnUsSURCQ3Vyc29yV2l0aFZhbHVlOnUsSURCRGF0YWJhc2U6dSxJREJGYWN0b3J5OnUsSURCSW5kZXg6dSxJREJLZXlSYW5nZTp1LElEQk9iamVjdFN0b3JlOnUsSURCT3BlbkRCUmVxdWVzdDp1LElEQlJlcXVlc3Q6dSxJREJUcmFuc2FjdGlvbjp1LElEQlZlcnNpb25DaGFuZ2VFdmVudDp1LElkbGVEZWFkbGluZTp1LElJUkZpbHRlck5vZGU6dSxJbWFnZTp1LEltYWdlQml0bWFwOnUsSW1hZ2VCaXRtYXBSZW5kZXJpbmdDb250ZXh0OnUsSW1hZ2VDYXB0dXJlOnUsSW1hZ2VEYXRhOnUsaW5kZXhlZERCOkksaW5uZXJIZWlnaHQ6SSxpbm5lcldpZHRoOkksSW5wdXRFdmVudDp1LEludGVyc2VjdGlvbk9ic2VydmVyOnUsSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTp1LGlzU2VjdXJlQ29udGV4dDpJLEtleWJvYXJkRXZlbnQ6dSxLZXlmcmFtZUVmZmVjdDp1LGxlbmd0aDpJLGxvY2FsU3RvcmFnZTpJLGxvY2F0aW9uOkksTG9jYXRpb246dSxsb2NhdGlvbmJhcjpJLG1hdGNoTWVkaWE6SSxNZWRpYURldmljZUluZm86dSxNZWRpYURldmljZXM6dSxNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGU6dSxNZWRpYUVuY3J5cHRlZEV2ZW50OnUsTWVkaWFFcnJvcjp1LE1lZGlhS2V5TWVzc2FnZUV2ZW50OnUsTWVkaWFLZXlTZXNzaW9uOnUsTWVkaWFLZXlTdGF0dXNNYXA6dSxNZWRpYUtleVN5c3RlbUFjY2Vzczp1LE1lZGlhTGlzdDp1LE1lZGlhUXVlcnlMaXN0OnUsTWVkaWFRdWVyeUxpc3RFdmVudDp1LE1lZGlhUmVjb3JkZXI6dSxNZWRpYVNldHRpbmdzUmFuZ2U6dSxNZWRpYVNvdXJjZTp1LE1lZGlhU3RyZWFtOnUsTWVkaWFTdHJlYW1BdWRpb0Rlc3RpbmF0aW9uTm9kZTp1LE1lZGlhU3RyZWFtQXVkaW9Tb3VyY2VOb2RlOnUsTWVkaWFTdHJlYW1FdmVudDp1LE1lZGlhU3RyZWFtVHJhY2s6dSxNZWRpYVN0cmVhbVRyYWNrRXZlbnQ6dSxtZW51YmFyOkksTWVzc2FnZUNoYW5uZWw6dSxNZXNzYWdlRXZlbnQ6dSxNZXNzYWdlUG9ydDp1LE1JRElBY2Nlc3M6dSxNSURJQ29ubmVjdGlvbkV2ZW50OnUsTUlESUlucHV0OnUsTUlESUlucHV0TWFwOnUsTUlESU1lc3NhZ2VFdmVudDp1LE1JRElPdXRwdXQ6dSxNSURJT3V0cHV0TWFwOnUsTUlESVBvcnQ6dSxNaW1lVHlwZTp1LE1pbWVUeXBlQXJyYXk6dSxNb3VzZUV2ZW50OnUsbW92ZUJ5OkksbW92ZVRvOkksTXV0YXRpb25FdmVudDp1LE11dGF0aW9uT2JzZXJ2ZXI6dSxNdXRhdGlvblJlY29yZDp1LG5hbWU6SSxOYW1lZE5vZGVNYXA6dSxOYXZpZ2F0aW9uUHJlbG9hZE1hbmFnZXI6dSxuYXZpZ2F0b3I6SSxOYXZpZ2F0b3I6dSxOZXR3b3JrSW5mb3JtYXRpb246dSxOb2RlOnUsTm9kZUZpbHRlcjpJLE5vZGVJdGVyYXRvcjp1LE5vZGVMaXN0OnUsTm90aWZpY2F0aW9uOnUsT2ZmbGluZUF1ZGlvQ29tcGxldGlvbkV2ZW50OnUsT2ZmbGluZUF1ZGlvQ29udGV4dDp1LG9mZnNjcmVlbkJ1ZmZlcmluZzpJLE9mZnNjcmVlbkNhbnZhczp1LG9wZW46SSxvcGVuRGF0YWJhc2U6SSxPcHRpb246dSxvcmlnaW46SSxPc2NpbGxhdG9yTm9kZTp1LG91dGVySGVpZ2h0Okksb3V0ZXJXaWR0aDpJLFBhZ2VUcmFuc2l0aW9uRXZlbnQ6dSxwYWdlWE9mZnNldDpJLHBhZ2VZT2Zmc2V0OkksUGFubmVyTm9kZTp1LHBhcmVudDpJLFBhdGgyRDp1LFBheW1lbnRBZGRyZXNzOnUsUGF5bWVudFJlcXVlc3Q6dSxQYXltZW50UmVxdWVzdFVwZGF0ZUV2ZW50OnUsUGF5bWVudFJlc3BvbnNlOnUscGVyZm9ybWFuY2U6SSxQZXJmb3JtYW5jZTp1LFBlcmZvcm1hbmNlRW50cnk6dSxQZXJmb3JtYW5jZUxvbmdUYXNrVGltaW5nOnUsUGVyZm9ybWFuY2VNYXJrOnUsUGVyZm9ybWFuY2VNZWFzdXJlOnUsUGVyZm9ybWFuY2VOYXZpZ2F0aW9uOnUsUGVyZm9ybWFuY2VOYXZpZ2F0aW9uVGltaW5nOnUsUGVyZm9ybWFuY2VPYnNlcnZlcjp1LFBlcmZvcm1hbmNlT2JzZXJ2ZXJFbnRyeUxpc3Q6dSxQZXJmb3JtYW5jZVBhaW50VGltaW5nOnUsUGVyZm9ybWFuY2VSZXNvdXJjZVRpbWluZzp1LFBlcmZvcm1hbmNlVGltaW5nOnUsUGVyaW9kaWNXYXZlOnUsUGVybWlzc2lvbnM6dSxQZXJtaXNzaW9uU3RhdHVzOnUscGVyc29uYWxiYXI6SSxQaG90b0NhcGFiaWxpdGllczp1LFBsdWdpbjp1LFBsdWdpbkFycmF5OnUsUG9pbnRlckV2ZW50OnUsUG9wU3RhdGVFdmVudDp1LHBvc3RNZXNzYWdlOkksUHJlc2VudGF0aW9uOnUsUHJlc2VudGF0aW9uQXZhaWxhYmlsaXR5OnUsUHJlc2VudGF0aW9uQ29ubmVjdGlvbjp1LFByZXNlbnRhdGlvbkNvbm5lY3Rpb25BdmFpbGFibGVFdmVudDp1LFByZXNlbnRhdGlvbkNvbm5lY3Rpb25DbG9zZUV2ZW50OnUsUHJlc2VudGF0aW9uQ29ubmVjdGlvbkxpc3Q6dSxQcmVzZW50YXRpb25SZWNlaXZlcjp1LFByZXNlbnRhdGlvblJlcXVlc3Q6dSxwcmludDpJLFByb2Nlc3NpbmdJbnN0cnVjdGlvbjp1LFByb2dyZXNzRXZlbnQ6dSxQcm9taXNlUmVqZWN0aW9uRXZlbnQ6dSxwcm9tcHQ6SSxQdXNoTWFuYWdlcjp1LFB1c2hTdWJzY3JpcHRpb246dSxQdXNoU3Vic2NyaXB0aW9uT3B0aW9uczp1LHF1ZXVlTWljcm90YXNrOkksUmFkaW9Ob2RlTGlzdDp1LFJhbmdlOnUsUmVhZGFibGVTdHJlYW06dSxSZW1vdGVQbGF5YmFjazp1LHJlbW92ZUV2ZW50TGlzdGVuZXI6SSxSZXF1ZXN0OnUscmVxdWVzdEFuaW1hdGlvbkZyYW1lOkkscmVxdWVzdElkbGVDYWxsYmFjazpJLHJlc2l6ZUJ5OkksUmVzaXplT2JzZXJ2ZXI6dSxSZXNpemVPYnNlcnZlckVudHJ5OnUscmVzaXplVG86SSxSZXNwb25zZTp1LFJUQ0NlcnRpZmljYXRlOnUsUlRDRGF0YUNoYW5uZWw6dSxSVENEYXRhQ2hhbm5lbEV2ZW50OnUsUlRDRHRsc1RyYW5zcG9ydDp1LFJUQ0ljZUNhbmRpZGF0ZTp1LFJUQ0ljZVRyYW5zcG9ydDp1LFJUQ1BlZXJDb25uZWN0aW9uOnUsUlRDUGVlckNvbm5lY3Rpb25JY2VFdmVudDp1LFJUQ1J0cFJlY2VpdmVyOnUsUlRDUnRwU2VuZGVyOnUsUlRDU2N0cFRyYW5zcG9ydDp1LFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjp1LFJUQ1N0YXRzUmVwb3J0OnUsUlRDVHJhY2tFdmVudDp1LHNjcmVlbjpJLFNjcmVlbjp1LHNjcmVlbkxlZnQ6SSxTY3JlZW5PcmllbnRhdGlvbjp1LHNjcmVlblRvcDpJLHNjcmVlblg6SSxzY3JlZW5ZOkksU2NyaXB0UHJvY2Vzc29yTm9kZTp1LHNjcm9sbDpJLHNjcm9sbGJhcnM6SSxzY3JvbGxCeTpJLHNjcm9sbFRvOkksc2Nyb2xsWDpJLHNjcm9sbFk6SSxTZWN1cml0eVBvbGljeVZpb2xhdGlvbkV2ZW50OnUsU2VsZWN0aW9uOnUsU2VydmljZVdvcmtlcjp1LFNlcnZpY2VXb3JrZXJDb250YWluZXI6dSxTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uOnUsc2Vzc2lvblN0b3JhZ2U6SSxTaGFkb3dSb290OnUsU2hhcmVkV29ya2VyOnUsU291cmNlQnVmZmVyOnUsU291cmNlQnVmZmVyTGlzdDp1LHNwZWVjaFN5bnRoZXNpczpJLFNwZWVjaFN5bnRoZXNpc0V2ZW50OnUsU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlOnUsU3RhdGljUmFuZ2U6dSxzdGF0dXM6SSxzdGF0dXNiYXI6SSxTdGVyZW9QYW5uZXJOb2RlOnUsc3RvcDpJLFN0b3JhZ2U6dSxTdG9yYWdlRXZlbnQ6dSxTdG9yYWdlTWFuYWdlcjp1LHN0eWxlTWVkaWE6SSxTdHlsZVNoZWV0OnUsU3R5bGVTaGVldExpc3Q6dSxTdWJ0bGVDcnlwdG86dSxTVkdBRWxlbWVudDp1LFNWR0FuZ2xlOnUsU1ZHQW5pbWF0ZWRBbmdsZTp1LFNWR0FuaW1hdGVkQm9vbGVhbjp1LFNWR0FuaW1hdGVkRW51bWVyYXRpb246dSxTVkdBbmltYXRlZEludGVnZXI6dSxTVkdBbmltYXRlZExlbmd0aDp1LFNWR0FuaW1hdGVkTGVuZ3RoTGlzdDp1LFNWR0FuaW1hdGVkTnVtYmVyOnUsU1ZHQW5pbWF0ZWROdW1iZXJMaXN0OnUsU1ZHQW5pbWF0ZWRQcmVzZXJ2ZUFzcGVjdFJhdGlvOnUsU1ZHQW5pbWF0ZWRSZWN0OnUsU1ZHQW5pbWF0ZWRTdHJpbmc6dSxTVkdBbmltYXRlZFRyYW5zZm9ybUxpc3Q6dSxTVkdBbmltYXRlRWxlbWVudDp1LFNWR0FuaW1hdGVNb3Rpb25FbGVtZW50OnUsU1ZHQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQ6dSxTVkdBbmltYXRpb25FbGVtZW50OnUsU1ZHQ2lyY2xlRWxlbWVudDp1LFNWR0NsaXBQYXRoRWxlbWVudDp1LFNWR0NvbXBvbmVudFRyYW5zZmVyRnVuY3Rpb25FbGVtZW50OnUsU1ZHRGVmc0VsZW1lbnQ6dSxTVkdEZXNjRWxlbWVudDp1LFNWR0Rpc2NhcmRFbGVtZW50OnUsU1ZHRWxlbWVudDp1LFNWR0VsbGlwc2VFbGVtZW50OnUsU1ZHRkVCbGVuZEVsZW1lbnQ6dSxTVkdGRUNvbG9yTWF0cml4RWxlbWVudDp1LFNWR0ZFQ29tcG9uZW50VHJhbnNmZXJFbGVtZW50OnUsU1ZHRkVDb21wb3NpdGVFbGVtZW50OnUsU1ZHRkVDb252b2x2ZU1hdHJpeEVsZW1lbnQ6dSxTVkdGRURpZmZ1c2VMaWdodGluZ0VsZW1lbnQ6dSxTVkdGRURpc3BsYWNlbWVudE1hcEVsZW1lbnQ6dSxTVkdGRURpc3RhbnRMaWdodEVsZW1lbnQ6dSxTVkdGRURyb3BTaGFkb3dFbGVtZW50OnUsU1ZHRkVGbG9vZEVsZW1lbnQ6dSxTVkdGRUZ1bmNBRWxlbWVudDp1LFNWR0ZFRnVuY0JFbGVtZW50OnUsU1ZHRkVGdW5jR0VsZW1lbnQ6dSxTVkdGRUZ1bmNSRWxlbWVudDp1LFNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudDp1LFNWR0ZFSW1hZ2VFbGVtZW50OnUsU1ZHRkVNZXJnZUVsZW1lbnQ6dSxTVkdGRU1lcmdlTm9kZUVsZW1lbnQ6dSxTVkdGRU1vcnBob2xvZ3lFbGVtZW50OnUsU1ZHRkVPZmZzZXRFbGVtZW50OnUsU1ZHRkVQb2ludExpZ2h0RWxlbWVudDp1LFNWR0ZFU3BlY3VsYXJMaWdodGluZ0VsZW1lbnQ6dSxTVkdGRVNwb3RMaWdodEVsZW1lbnQ6dSxTVkdGRVRpbGVFbGVtZW50OnUsU1ZHRkVUdXJidWxlbmNlRWxlbWVudDp1LFNWR0ZpbHRlckVsZW1lbnQ6dSxTVkdGb3JlaWduT2JqZWN0RWxlbWVudDp1LFNWR0dFbGVtZW50OnUsU1ZHR2VvbWV0cnlFbGVtZW50OnUsU1ZHR3JhZGllbnRFbGVtZW50OnUsU1ZHR3JhcGhpY3NFbGVtZW50OnUsU1ZHSW1hZ2VFbGVtZW50OnUsU1ZHTGVuZ3RoOnUsU1ZHTGVuZ3RoTGlzdDp1LFNWR0xpbmVhckdyYWRpZW50RWxlbWVudDp1LFNWR0xpbmVFbGVtZW50OnUsU1ZHTWFya2VyRWxlbWVudDp1LFNWR01hc2tFbGVtZW50OnUsU1ZHTWF0cml4OnUsU1ZHTWV0YWRhdGFFbGVtZW50OnUsU1ZHTVBhdGhFbGVtZW50OnUsU1ZHTnVtYmVyOnUsU1ZHTnVtYmVyTGlzdDp1LFNWR1BhdGhFbGVtZW50OnUsU1ZHUGF0dGVybkVsZW1lbnQ6dSxTVkdQb2ludDp1LFNWR1BvaW50TGlzdDp1LFNWR1BvbHlnb25FbGVtZW50OnUsU1ZHUG9seWxpbmVFbGVtZW50OnUsU1ZHUHJlc2VydmVBc3BlY3RSYXRpbzp1LFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudDp1LFNWR1JlY3Q6dSxTVkdSZWN0RWxlbWVudDp1LFNWR1NjcmlwdEVsZW1lbnQ6dSxTVkdTZXRFbGVtZW50OnUsU1ZHU3RvcEVsZW1lbnQ6dSxTVkdTdHJpbmdMaXN0OnUsU1ZHU3R5bGVFbGVtZW50OnUsU1ZHU1ZHRWxlbWVudDp1LFNWR1N3aXRjaEVsZW1lbnQ6dSxTVkdTeW1ib2xFbGVtZW50OnUsU1ZHVGV4dENvbnRlbnRFbGVtZW50OnUsU1ZHVGV4dEVsZW1lbnQ6dSxTVkdUZXh0UGF0aEVsZW1lbnQ6dSxTVkdUZXh0UG9zaXRpb25pbmdFbGVtZW50OnUsU1ZHVGl0bGVFbGVtZW50OnUsU1ZHVHJhbnNmb3JtOnUsU1ZHVHJhbnNmb3JtTGlzdDp1LFNWR1RTcGFuRWxlbWVudDp1LFNWR1VuaXRUeXBlczp1LFNWR1VzZUVsZW1lbnQ6dSxTVkdWaWV3RWxlbWVudDp1LFRhc2tBdHRyaWJ1dGlvblRpbWluZzp1LFRleHQ6dSxUZXh0RXZlbnQ6dSxUZXh0TWV0cmljczp1LFRleHRUcmFjazp1LFRleHRUcmFja0N1ZTp1LFRleHRUcmFja0N1ZUxpc3Q6dSxUZXh0VHJhY2tMaXN0OnUsVGltZVJhbmdlczp1LHRvb2xiYXI6SSx0b3A6SSxUb3VjaDp1LFRvdWNoRXZlbnQ6dSxUb3VjaExpc3Q6dSxUcmFja0V2ZW50OnUsVHJhbnNpdGlvbkV2ZW50OnUsVHJlZVdhbGtlcjp1LFVJRXZlbnQ6dSxWYWxpZGl0eVN0YXRlOnUsdmlzdWFsVmlld3BvcnQ6SSxWaXN1YWxWaWV3cG9ydDp1LFZUVEN1ZTp1LFdhdmVTaGFwZXJOb2RlOnUsV2ViQXNzZW1ibHk6SSxXZWJHTDJSZW5kZXJpbmdDb250ZXh0OnUsV2ViR0xBY3RpdmVJbmZvOnUsV2ViR0xCdWZmZXI6dSxXZWJHTENvbnRleHRFdmVudDp1LFdlYkdMRnJhbWVidWZmZXI6dSxXZWJHTFByb2dyYW06dSxXZWJHTFF1ZXJ5OnUsV2ViR0xSZW5kZXJidWZmZXI6dSxXZWJHTFJlbmRlcmluZ0NvbnRleHQ6dSxXZWJHTFNhbXBsZXI6dSxXZWJHTFNoYWRlcjp1LFdlYkdMU2hhZGVyUHJlY2lzaW9uRm9ybWF0OnUsV2ViR0xTeW5jOnUsV2ViR0xUZXh0dXJlOnUsV2ViR0xUcmFuc2Zvcm1GZWVkYmFjazp1LFdlYkdMVW5pZm9ybUxvY2F0aW9uOnUsV2ViR0xWZXJ0ZXhBcnJheU9iamVjdDp1LFdlYlNvY2tldDp1LFdoZWVsRXZlbnQ6dSxXaW5kb3c6dSxXb3JrZXI6dSxXcml0YWJsZVN0cmVhbTp1LFhNTERvY3VtZW50OnUsWE1MSHR0cFJlcXVlc3Q6dSxYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0OnUsWE1MSHR0cFJlcXVlc3RVcGxvYWQ6dSxYTUxTZXJpYWxpemVyOnUsWFBhdGhFdmFsdWF0b3I6dSxYUGF0aEV4cHJlc3Npb246dSxYUGF0aFJlc3VsdDp1LFhTTFRQcm9jZXNzb3I6dX07Zm9yKGNvbnN0IGUgb2ZbIndpbmRvdyIsImdsb2JhbCIsInNlbGYiLCJnbG9iYWxUaGlzIl0peXJbZV09eXI7ZnVuY3Rpb24gX2koZSl7bGV0IHQ9eXI7Zm9yKGNvbnN0IGkgb2YgZSlpZih0eXBlb2YgaSE9InN0cmluZyJ8fCh0PXRbaV0sIXQpKXJldHVybiBudWxsO3JldHVybiB0W3VlXX1jbGFzcyB4ciBleHRlbmRzIHRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLmlzUmVhc3NpZ25lZD0hMH1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7c3dpdGNoKHQudHlwZSl7Y2FzZSAwOmNhc2UgMTpyZXR1cm4gdm9pZChfaShbdGhpcy5uYW1lLC4uLmldLnNsaWNlKDAsLTEpKXx8c3VwZXIuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpKTtjYXNlIDI6e2NvbnN0IG49X2koW3RoaXMubmFtZSwuLi5pXSk7cmV0dXJuIHZvaWQobj9uLmRlb3B0aW1pemVBcmd1bWVudHNPbkNhbGwodCk6c3VwZXIuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpKX19fWdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl7Y29uc3Qgbj1faShbdGhpcy5uYW1lLC4uLnRdKTtyZXR1cm4gbj9uLmdldExpdGVyYWxWYWx1ZSgpOm1lfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtzd2l0Y2goaS50eXBlKXtjYXNlIDA6cmV0dXJuIHQubGVuZ3RoPT09MD90aGlzLm5hbWUhPT0idW5kZWZpbmVkIiYmIV9pKFt0aGlzLm5hbWVdKTohX2koW3RoaXMubmFtZSwuLi50XS5zbGljZSgwLC0xKSk7Y2FzZSAxOnJldHVybiEwO2Nhc2UgMjp7Y29uc3Qgbj1faShbdGhpcy5uYW1lLC4uLnRdKTtyZXR1cm4hbnx8bi5oYXNFZmZlY3RzV2hlbkNhbGxlZChpLHMpfX19fWNvbnN0IFVwPXtfX3Byb3RvX186bnVsbCxjbGFzczohMCxjb25zdDohMCxsZXQ6ITAsdmFyOiEwfTtjbGFzcyBjZSBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudmFyaWFibGU9bnVsbCx0aGlzLmlzVERaQWNjZXNzPW51bGx9YWRkRXhwb3J0ZWRWYXJpYWJsZXModCxpKXtpLmhhcyh0aGlzLnZhcmlhYmxlKSYmdC5wdXNoKHRoaXMudmFyaWFibGUpfWJpbmQoKXshdGhpcy52YXJpYWJsZSYmWG8odGhpcyx0aGlzLnBhcmVudCkmJih0aGlzLnZhcmlhYmxlPXRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKHRoaXMubmFtZSksdGhpcy52YXJpYWJsZS5hZGRSZWZlcmVuY2UodGhpcykpfWRlY2xhcmUodCxpKXtsZXQgcztjb25zdHt0cmVlc2hha2U6bn09dGhpcy5jb250ZXh0Lm9wdGlvbnM7c3dpdGNoKHQpe2Nhc2UidmFyIjpzPXRoaXMuc2NvcGUuYWRkRGVjbGFyYXRpb24odGhpcyx0aGlzLmNvbnRleHQsaSwhMCksbiYmbi5jb3JyZWN0VmFyVmFsdWVCZWZvcmVEZWNsYXJhdGlvbiYmcy5tYXJrSW5pdGlhbGl6ZXJzRm9yRGVvcHRpbWl6YXRpb24oKTticmVhaztjYXNlImZ1bmN0aW9uIjpjYXNlImxldCI6Y2FzZSJjb25zdCI6Y2FzZSJjbGFzcyI6cz10aGlzLnNjb3BlLmFkZERlY2xhcmF0aW9uKHRoaXMsdGhpcy5jb250ZXh0LGksITEpO2JyZWFrO2Nhc2UicGFyYW1ldGVyIjpzPXRoaXMuc2NvcGUuYWRkUGFyYW1ldGVyRGVjbGFyYXRpb24odGhpcyk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiBVbmV4cGVjdGVkIGlkZW50aWZpZXIga2luZCAke3R9LmApfXJldHVybiBzLmtpbmQ9dCxbdGhpcy52YXJpYWJsZT1zXX1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7dGhpcy52YXJpYWJsZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl9ZGVvcHRpbWl6ZVBhdGgodCl7dmFyIGk7dC5sZW5ndGghPT0wfHx0aGlzLnNjb3BlLmNvbnRhaW5zKHRoaXMubmFtZSl8fHRoaXMuZGlzYWxsb3dJbXBvcnRSZWFzc2lnbm1lbnQoKSwoaT10aGlzLnZhcmlhYmxlKT09bnVsbHx8aS5kZW9wdGltaXplUGF0aCh0KX1nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCxpLHMpe3JldHVybiB0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl9Z2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCxpLHMsbil7Y29uc3RbcixhXT10aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pO3JldHVybltyLGF8fHRoaXMuaXNQdXJlRnVuY3Rpb24odCldfWhhc0VmZmVjdHModCl7cmV0dXJuIHRoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSwhKCF0aGlzLmlzUG9zc2libGVURFooKXx8dGhpcy52YXJpYWJsZS5raW5kPT09InZhciIpfHx0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UudW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzJiZ0aGlzLnZhcmlhYmxlIGluc3RhbmNlb2YgeHImJiF0aGlzLmlzUHVyZUZ1bmN0aW9uKFEpJiZ0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFEsUnMsdCl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3N3aXRjaChpLnR5cGUpe2Nhc2UgMDpyZXR1cm4gdGhpcy52YXJpYWJsZSE9PW51bGwmJiF0aGlzLmlzUHVyZUZ1bmN0aW9uKHQpJiZ0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKTtjYXNlIDE6cmV0dXJuKHQubGVuZ3RoPjA/dGhpcy5nZXRWYXJpYWJsZVJlc3BlY3RpbmdURFooKTp0aGlzLnZhcmlhYmxlKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyk7Y2FzZSAyOnJldHVybiF0aGlzLmlzUHVyZUZ1bmN0aW9uKHQpJiZ0aGlzLmdldFZhcmlhYmxlUmVzcGVjdGluZ1REWigpLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX19aW5jbHVkZSgpe3RoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLmluY2x1ZGVkfHwodGhpcy5pbmNsdWRlZD0hMCx0aGlzLnZhcmlhYmxlIT09bnVsbCYmdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpKX1pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LGkpe3RoaXMudmFyaWFibGUuaW5jbHVkZUNhbGxBcmd1bWVudHModCxpKX1pc1Bvc3NpYmxlVERaKCl7aWYodGhpcy5pc1REWkFjY2VzcyE9PW51bGwpcmV0dXJuIHRoaXMuaXNURFpBY2Nlc3M7aWYoISh0aGlzLnZhcmlhYmxlIGluc3RhbmNlb2YgUHQmJnRoaXMudmFyaWFibGUua2luZCYmdGhpcy52YXJpYWJsZS5raW5kIGluIFVwJiZ0aGlzLnZhcmlhYmxlLm1vZHVsZT09PXRoaXMuY29udGV4dC5tb2R1bGUpKXJldHVybiB0aGlzLmlzVERaQWNjZXNzPSExO2xldCB0O3JldHVybiB0aGlzLnZhcmlhYmxlLmRlY2xhcmF0aW9ucyYmdGhpcy52YXJpYWJsZS5kZWNsYXJhdGlvbnMubGVuZ3RoPT09MSYmKHQ9dGhpcy52YXJpYWJsZS5kZWNsYXJhdGlvbnNbMF0pJiZ0aGlzLnN0YXJ0PHQuc3RhcnQmJnRoKHRoaXMpPT09dGgodCk/dGhpcy5pc1REWkFjY2Vzcz0hMDp0aGlzLnZhcmlhYmxlLmluaXRSZWFjaGVkP3RoaXMuaXNURFpBY2Nlc3M9ITE6dGhpcy5pc1REWkFjY2Vzcz0hMH1tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCl7dGhpcy52YXJpYWJsZS5pbml0UmVhY2hlZD0hMH1yZW5kZXIodCx7c25pcHBldHM6e2dldFByb3BlcnR5QWNjZXNzOml9LHVzZU9yaWdpbmFsTmFtZTpzfSx7cmVuZGVyZWRQYXJlbnRUeXBlOm4saXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50OnIsaXNTaG9ydGhhbmRQcm9wZXJ0eTphfT0kZSl7aWYodGhpcy52YXJpYWJsZSl7Y29uc3Qgbz10aGlzLnZhcmlhYmxlLmdldE5hbWUoaSxzKTtvIT09dGhpcy5uYW1lJiYodC5vdmVyd3JpdGUodGhpcy5zdGFydCx0aGlzLmVuZCxvLHtjb250ZW50T25seTohMCxzdG9yZU5hbWU6ITB9KSxhJiZ0LnByZXBlbmRSaWdodCh0aGlzLnN0YXJ0LGAke3RoaXMubmFtZX06IGApKSxvPT09ImV2YWwiJiZuPT09X28mJnImJnQuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwiMCwgIil9fWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLnZhcmlhYmxlIGluc3RhbmNlb2YgUHQmJih0aGlzLnZhcmlhYmxlLmNvbnNvbGlkYXRlSW5pdGlhbGl6ZXJzKCksdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKSl9ZGlzYWxsb3dJbXBvcnRSZWFzc2lnbm1lbnQoKXtyZXR1cm4gdGhpcy5jb250ZXh0LmVycm9yKFNvKHRoaXMubmFtZSx0aGlzLmNvbnRleHQubW9kdWxlLmlkKSx0aGlzLnN0YXJ0KX1nZXRWYXJpYWJsZVJlc3BlY3RpbmdURFooKXtyZXR1cm4gdGhpcy5pc1Bvc3NpYmxlVERaKCk/WTp0aGlzLnZhcmlhYmxlfWlzUHVyZUZ1bmN0aW9uKHQpe2xldCBpPXRoaXMuY29udGV4dC5tYW51YWxQdXJlRnVuY3Rpb25zW3RoaXMubmFtZV07Zm9yKGNvbnN0IHMgb2YgdCl7aWYoIWkpcmV0dXJuITE7aWYoaVttcl0pcmV0dXJuITA7aT1pW3NdfXJldHVybiBpPT1udWxsP3ZvaWQgMDppW21yXX19ZnVuY3Rpb24gdGgoZSl7Zm9yKDtlJiYhL15Qcm9ncmFtfEZ1bmN0aW9uLy50ZXN0KGUudHlwZSk7KWU9ZS5wYXJlbnQ7cmV0dXJuIGV9ZnVuY3Rpb24gYnIoZSx0LGkscyl7aWYodC5yZW1vdmUoaSxzKSxlLmFubm90YXRpb25zKWZvcihjb25zdCBuIG9mIGUuYW5ub3RhdGlvbnMpe2lmKCEobi5zdGFydDxpKSlyZXR1cm47dC5yZW1vdmUobi5zdGFydCxuLmVuZCl9fWZ1bmN0aW9uIGloKGUsdCl7aWYoZS5hbm5vdGF0aW9uc3x8ZS5wYXJlbnQudHlwZSE9PVllfHwoZT1lLnBhcmVudCksZS5hbm5vdGF0aW9ucylmb3IoY29uc3QgaSBvZiBlLmFubm90YXRpb25zKXQucmVtb3ZlKGkuc3RhcnQsaS5lbmQpfWNvbnN0IG9pPXtpc05vU3RhdGVtZW50OiEwfTtmdW5jdGlvbiBJZShlLHQsaT0wKXtsZXQgcyxuO2ZvcihzPWUuaW5kZXhPZih0LGkpOzspe2lmKChpPWUuaW5kZXhPZigiLyIsaSkpPT09LTF8fGk+PXMpcmV0dXJuIHM7bj1lLmNoYXJDb2RlQXQoKytpKSwrK2ksKGk9bj09PTQ3P2UuaW5kZXhPZihgCmAsaSkrMTplLmluZGV4T2YoIiovIixpKSsyKT5zJiYocz1lLmluZGV4T2YodCxpKSl9fWNvbnN0IHNoPS9cUy9nO2Z1bmN0aW9uIHp0KGUsdCl7cmV0dXJuIHNoLmxhc3RJbmRleD10LHNoLmV4ZWMoZSkuaW5kZXh9ZnVuY3Rpb24gbnMoZSl7bGV0IHQsaSxzPTA7Zm9yKHQ9ZS5pbmRleE9mKGAKYCxzKTs7KXtpZihzPWUuaW5kZXhPZigiLyIscykscz09PS0xfHxzPnQpcmV0dXJuW3QsdCsxXTtpZihpPWUuY2hhckNvZGVBdChzKzEpLGk9PT00NylyZXR1cm5bcyx0KzFdO3M9ZS5pbmRleE9mKCIqLyIscyszKSsyLHM+dCYmKHQ9ZS5pbmRleE9mKGAKYCxzKSl9fWZ1bmN0aW9uIHJzKGUsdCxpLHMsbil7bGV0IHIsYSxvLGgsbD1lWzBdLGM9IWwuaW5jbHVkZWR8fGwubmVlZHNCb3VuZGFyaWVzO2MmJihoPWkrbnModC5vcmlnaW5hbC5zbGljZShpLGwuc3RhcnQpKVsxXSk7Zm9yKGxldCBwPTE7cDw9ZS5sZW5ndGg7cCsrKXI9bCxhPWgsbz1jLGw9ZVtwXSxjPWwhPT12b2lkIDAmJighbC5pbmNsdWRlZHx8bC5uZWVkc0JvdW5kYXJpZXMpLG98fGM/KGg9ci5lbmQrbnModC5vcmlnaW5hbC5zbGljZShyLmVuZCxsPT09dm9pZCAwP3M6bC5zdGFydCkpWzFdLHIuaW5jbHVkZWQ/bz9yLnJlbmRlcih0LG4se2VuZDpoLHN0YXJ0OmF9KTpyLnJlbmRlcih0LG4pOmJyKHIsdCxhLGgpKTpyLnJlbmRlcih0LG4pfWZ1bmN0aW9uIG5oKGUsdCxpLHMpe2NvbnN0IG49W107bGV0IHIsYSxvLGgsbD1pLTE7Zm9yKGNvbnN0IGMgb2YgZSl7Zm9yKHIhPT12b2lkIDAmJihsPXIuZW5kK0llKHQub3JpZ2luYWwuc2xpY2Uoci5lbmQsYy5zdGFydCksIiwiKSksYT1vPWwrMStucyh0Lm9yaWdpbmFsLnNsaWNlKGwrMSxjLnN0YXJ0KSlbMV07aD10Lm9yaWdpbmFsLmNoYXJDb2RlQXQoYSksaD09PTMyfHxoPT09OXx8aD09PTEwfHxoPT09MTM7KWErKztyIT09dm9pZCAwJiZuLnB1c2goe2NvbnRlbnRFbmQ6byxlbmQ6YSxub2RlOnIsc2VwYXJhdG9yOmwsc3RhcnQ6aX0pLHI9YyxpPWF9cmV0dXJuIG4ucHVzaCh7Y29udGVudEVuZDpzLGVuZDpzLG5vZGU6cixzZXBhcmF0b3I6bnVsbCxzdGFydDppfSksbn1mdW5jdGlvbiBYcyhlLHQsaSl7Zm9yKDs7KXtjb25zdFtzLG5dPW5zKGUub3JpZ2luYWwuc2xpY2UodCxpKSk7aWYocz09PS0xKWJyZWFrO2UucmVtb3ZlKHQrcyx0Kz1uKX19Y2xhc3MgaGkgZXh0ZW5kcyBsdHthZGREZWNsYXJhdGlvbih0LGkscyxuKXtpZihuKXtjb25zdCByPXRoaXMucGFyZW50LmFkZERlY2xhcmF0aW9uKHQsaSxzLG4pO3JldHVybiByLm1hcmtJbml0aWFsaXplcnNGb3JEZW9wdGltaXphdGlvbigpLHJ9cmV0dXJuIHN1cGVyLmFkZERlY2xhcmF0aW9uKHQsaSxzLCExKX19Y2xhc3MgbGkgZXh0ZW5kcyBWe2luaXRpYWxpc2UoKXt2YXIgdCxpO3RoaXMuZGlyZWN0aXZlJiZ0aGlzLmRpcmVjdGl2ZSE9PSJ1c2Ugc3RyaWN0IiYmdGhpcy5wYXJlbnQudHlwZT09PVVzJiZ0aGlzLmNvbnRleHQubG9nKEssKHQ9dGhpcy5kaXJlY3RpdmUse2NvZGU6Ik1PRFVMRV9MRVZFTF9ESVJFQ1RJVkUiLGlkOmk9dGhpcy5jb250ZXh0Lm1vZHVsZS5pZCxtZXNzYWdlOmBNb2R1bGUgbGV2ZWwgZGlyZWN0aXZlcyBjYXVzZSBlcnJvcnMgd2hlbiBidW5kbGVkLCAiJHt0fSIgaW4gIiR7WChpKX0iIHdhcyBpZ25vcmVkLmB9KSx0aGlzLnN0YXJ0KX1yZW5kZXIodCxpKXtzdXBlci5yZW5kZXIodCxpKSx0aGlzLmluY2x1ZGVkJiZ0aGlzLmluc2VydFNlbWljb2xvbih0KX1zaG91bGRCZUluY2x1ZGVkKHQpe3JldHVybiB0aGlzLmRpcmVjdGl2ZSYmdGhpcy5kaXJlY3RpdmUhPT0idXNlIHN0cmljdCI/dGhpcy5wYXJlbnQudHlwZSE9PVVzOnN1cGVyLnNob3VsZEJlSW5jbHVkZWQodCl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9fWNsYXNzIFpzIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5kaXJlY3RseUluY2x1ZGVkPSExfWFkZEltcGxpY2l0UmV0dXJuRXhwcmVzc2lvblRvU2NvcGUoKXtjb25zdCB0PXRoaXMuYm9keVt0aGlzLmJvZHkubGVuZ3RoLTFdO3QmJnQudHlwZT09PSJSZXR1cm5TdGF0ZW1lbnQifHx0aGlzLnNjb3BlLmFkZFJldHVybkV4cHJlc3Npb24oWSl9Y3JlYXRlU2NvcGUodCl7dGhpcy5zY29wZT10aGlzLnBhcmVudC5wcmV2ZW50Q2hpbGRCbG9ja1Njb3BlP3Q6bmV3IGhpKHQpfWhhc0VmZmVjdHModCl7aWYodGhpcy5kZW9wdGltaXplQm9keSlyZXR1cm4hMDtmb3IoY29uc3QgaSBvZiB0aGlzLmJvZHkpe2lmKHQuYnJva2VuRmxvdylicmVhaztpZihpLmhhc0VmZmVjdHModCkpcmV0dXJuITB9cmV0dXJuITF9aW5jbHVkZSh0LGkpe2lmKCF0aGlzLmRlb3B0aW1pemVCb2R5fHwhdGhpcy5kaXJlY3RseUluY2x1ZGVkKXt0aGlzLmluY2x1ZGVkPSEwLHRoaXMuZGlyZWN0bHlJbmNsdWRlZD0hMCx0aGlzLmRlb3B0aW1pemVCb2R5JiYoaT0hMCk7Zm9yKGNvbnN0IHMgb2YgdGhpcy5ib2R5KShpfHxzLnNob3VsZEJlSW5jbHVkZWQodCkpJiZzLmluY2x1ZGUodCxpKX19aW5pdGlhbGlzZSgpe2NvbnN0IHQ9dGhpcy5ib2R5WzBdO3RoaXMuZGVvcHRpbWl6ZUJvZHk9dCBpbnN0YW5jZW9mIGxpJiZ0LmRpcmVjdGl2ZT09PSJ1c2UgYXNtIn1yZW5kZXIodCxpKXt0aGlzLmJvZHkubGVuZ3RoPjA/cnModGhpcy5ib2R5LHQsdGhpcy5zdGFydCsxLHRoaXMuZW5kLTEsaSk6c3VwZXIucmVuZGVyKHQsaSl9fWNsYXNzIHZyIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5kZWNsYXJhdGlvbkluaXQ9bnVsbH1hZGRFeHBvcnRlZFZhcmlhYmxlcyh0LGkpe3RoaXMuYXJndW1lbnQuYWRkRXhwb3J0ZWRWYXJpYWJsZXModCxpKX1kZWNsYXJlKHQsaSl7cmV0dXJuIHRoaXMuZGVjbGFyYXRpb25Jbml0PWksdGhpcy5hcmd1bWVudC5kZWNsYXJlKHQsWSl9ZGVvcHRpbWl6ZVBhdGgodCl7dC5sZW5ndGg9PT0wJiZ0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFEpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtyZXR1cm4gdC5sZW5ndGg+MHx8dGhpcy5hcmd1bWVudC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLGkscyl9bWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpe3RoaXMuYXJndW1lbnQubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLmRlY2xhcmF0aW9uSW5pdCE9PW51bGwmJih0aGlzLmRlY2xhcmF0aW9uSW5pdC5kZW9wdGltaXplUGF0aChbaGUsaGVdKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpKX19Y2xhc3MgRXIgZXh0ZW5kcyBWe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLm9iamVjdEVudGl0eT1udWxsLHRoaXMuZGVvcHRpbWl6ZWRSZXR1cm49ITF9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe2lmKHQudHlwZT09PTIpe2NvbnN0e3BhcmFtZXRlcnM6bn09dGhpcy5zY29wZSx7YXJnczpyfT10O2xldCBhPSExO2ZvcihsZXQgbz0wO288ci5sZW5ndGgtMTtvKyspe2NvbnN0IGg9dGhpcy5wYXJhbXNbb10sbD1yW28rMV07YXx8aCBpbnN0YW5jZW9mIHZyPyhhPSEwLGwuZGVvcHRpbWl6ZVBhdGgodGUpKTpoIGluc3RhbmNlb2YgY2U/KG5bb11bMF0uYWRkRW50aXR5VG9CZURlb3B0aW1pemVkKGwpLHRoaXMuYWRkQXJndW1lbnRUb0JlRGVvcHRpbWl6ZWQobCkpOmg/bC5kZW9wdGltaXplUGF0aCh0ZSk6dGhpcy5hZGRBcmd1bWVudFRvQmVEZW9wdGltaXplZChsKX19ZWxzZSB0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX1kZW9wdGltaXplUGF0aCh0KXtpZih0aGlzLmdldE9iamVjdEVudGl0eSgpLmRlb3B0aW1pemVQYXRoKHQpLHQubGVuZ3RoPT09MSYmdFswXT09PWhlKXt0aGlzLnNjb3BlLmdldFJldHVybkV4cHJlc3Npb24oKS5kZW9wdGltaXplUGF0aCh0ZSk7Zm9yKGNvbnN0IGkgb2YgdGhpcy5zY29wZS5wYXJhbWV0ZXJzKWZvcihjb25zdCBzIG9mIGkpcy5kZW9wdGltaXplUGF0aCh0ZSl9fWdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyl7cmV0dXJuIHRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtyZXR1cm4gdC5sZW5ndGg+MD90aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pOnRoaXMuYXN5bmM/KHRoaXMuZGVvcHRpbWl6ZWRSZXR1cm58fCh0aGlzLmRlb3B0aW1pemVkUmV0dXJuPSEwLHRoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLmRlb3B0aW1pemVQYXRoKHRlKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpKSxiZSk6W3RoaXMuc2NvcGUuZ2V0UmV0dXJuRXhwcmVzc2lvbigpLCExXX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7aWYodC5sZW5ndGg+MHx8aS50eXBlIT09MilyZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyk7aWYodGhpcy5hbm5vdGF0aW9uTm9TaWRlRWZmZWN0cylyZXR1cm4hMTtpZih0aGlzLmFzeW5jKXtjb25zdHtwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0czpufT10aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2Uscj10aGlzLnNjb3BlLmdldFJldHVybkV4cHJlc3Npb24oKTtpZihyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFsidGhlbiJdLE9zLHMpfHxuJiYobj09PSJhbHdheXMifHxyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFsidGhlbiJdLFJzLHMpKSlyZXR1cm4hMH1mb3IoY29uc3QgbiBvZiB0aGlzLnBhcmFtcylpZihuLmhhc0VmZmVjdHMocykpcmV0dXJuITA7cmV0dXJuITF9aW5jbHVkZSh0LGkpe3RoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLmluY2x1ZGVkPSEwO2NvbnN0e2Jyb2tlbkZsb3c6c309dDt0LmJyb2tlbkZsb3c9ITEsdGhpcy5ib2R5LmluY2x1ZGUodCxpKSx0LmJyb2tlbkZsb3c9c31pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LGkpe3RoaXMuc2NvcGUuaW5jbHVkZUNhbGxBcmd1bWVudHModCxpKX1pbml0aWFsaXNlKCl7dGhpcy5zY29wZS5hZGRQYXJhbWV0ZXJWYXJpYWJsZXModGhpcy5wYXJhbXMubWFwKHQ9PnQuZGVjbGFyZSgicGFyYW1ldGVyIixZKSksdGhpcy5wYXJhbXNbdGhpcy5wYXJhbXMubGVuZ3RoLTFdaW5zdGFuY2VvZiB2ciksdGhpcy5ib2R5IGluc3RhbmNlb2YgWnM/dGhpcy5ib2R5LmFkZEltcGxpY2l0UmV0dXJuRXhwcmVzc2lvblRvU2NvcGUoKTp0aGlzLnNjb3BlLmFkZFJldHVybkV4cHJlc3Npb24odGhpcy5ib2R5KX1wYXJzZU5vZGUodCl7dC5ib2R5LnR5cGU9PT1QbyYmKHRoaXMuYm9keT1uZXcgWnModC5ib2R5LHRoaXMsdGhpcy5zY29wZS5ob2lzdGVkQm9keVZhclNjb3BlKSksc3VwZXIucGFyc2VOb2RlKHQpfWFkZEFyZ3VtZW50VG9CZURlb3B0aW1pemVkKHQpe31hcHBseURlb3B0aW1pemF0aW9ucygpe319RXIucHJvdG90eXBlLnByZXZlbnRDaGlsZEJsb2NrU2NvcGU9ITA7Y2xhc3MgU3IgZXh0ZW5kcyBFcntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5vYmplY3RFbnRpdHk9bnVsbH1jcmVhdGVTY29wZSh0KXt0aGlzLnNjb3BlPW5ldyBZbyh0LHRoaXMuY29udGV4dCl9aGFzRWZmZWN0cygpe3JldHVybiB0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCksITF9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe2lmKHN1cGVyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKSlyZXR1cm4hMDtpZih0aGlzLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzKXJldHVybiExO2lmKGkudHlwZT09PTIpe2NvbnN0e2lnbm9yZTpuLGJyb2tlbkZsb3c6cn09cztpZihzLmlnbm9yZT17YnJlYWtzOiExLGNvbnRpbnVlczohMSxsYWJlbHM6bmV3IFNldCxyZXR1cm5ZaWVsZDohMCx0aGlzOiExfSx0aGlzLmJvZHkuaGFzRWZmZWN0cyhzKSlyZXR1cm4hMDtzLmlnbm9yZT1uLHMuYnJva2VuRmxvdz1yfXJldHVybiExfWluY2x1ZGUodCxpKXtzdXBlci5pbmNsdWRlKHQsaSk7Zm9yKGNvbnN0IHMgb2YgdGhpcy5wYXJhbXMpcyBpbnN0YW5jZW9mIGNlfHxzLmluY2x1ZGUodCxpKX1nZXRPYmplY3RFbnRpdHkoKXtyZXR1cm4gdGhpcy5vYmplY3RFbnRpdHkhPT1udWxsP3RoaXMub2JqZWN0RW50aXR5OnRoaXMub2JqZWN0RW50aXR5PW5ldyBIZShbXSxGdCl9fWZ1bmN0aW9uIHVpKGUse2V4cG9ydE5hbWVzQnlWYXJpYWJsZTp0LHNuaXBwZXRzOntfOmksZ2V0T2JqZWN0OnMsZ2V0UHJvcGVydHlBY2Nlc3M6bn19LHI9IiIpe2lmKGUubGVuZ3RoPT09MSYmdC5nZXQoZVswXSkubGVuZ3RoPT09MSl7Y29uc3QgYT1lWzBdO3JldHVybmBleHBvcnRzKCcke3QuZ2V0KGEpfScsJHtpfSR7YS5nZXROYW1lKG4pfSR7cn0pYH17Y29uc3QgYT1bXTtmb3IoY29uc3QgbyBvZiBlKWZvcihjb25zdCBoIG9mIHQuZ2V0KG8pKWEucHVzaChbaCxvLmdldE5hbWUobikrcl0pO3JldHVybmBleHBvcnRzKCR7cyhhLHtsaW5lQnJlYWtJbmRlbnQ6bnVsbH0pfSlgfX1mdW5jdGlvbiBrcihlLHQsaSxzLHtleHBvcnROYW1lc0J5VmFyaWFibGU6bixzbmlwcGV0czp7XzpyfX0pe3MucHJlcGVuZFJpZ2h0KHQsYGV4cG9ydHMoJyR7bi5nZXQoZSl9Jywke3J9YCkscy5hcHBlbmRMZWZ0KGksIikiKX1mdW5jdGlvbiByaChlLHQsaSxzLG4scil7Y29uc3R7XzphLGdldFByb3BlcnR5QWNjZXNzOm99PXIuc25pcHBldHM7bi5hcHBlbmRMZWZ0KGksYCwke2F9JHt1aShbZV0scil9LCR7YX0ke2UuZ2V0TmFtZShvKX1gKSxzJiYobi5wcmVwZW5kUmlnaHQodCwiKCIpLG4uYXBwZW5kTGVmdChpLCIpIikpfWNsYXNzIGFzIGV4dGVuZHMgVnthZGRFeHBvcnRlZFZhcmlhYmxlcyh0LGkpe2Zvcihjb25zdCBzIG9mIHRoaXMucHJvcGVydGllcylzLnR5cGU9PT0iUHJvcGVydHkiP3MudmFsdWUuYWRkRXhwb3J0ZWRWYXJpYWJsZXModCxpKTpzLmFyZ3VtZW50LmFkZEV4cG9ydGVkVmFyaWFibGVzKHQsaSl9ZGVjbGFyZSh0LGkpe2NvbnN0IHM9W107Zm9yKGNvbnN0IG4gb2YgdGhpcy5wcm9wZXJ0aWVzKXMucHVzaCguLi5uLmRlY2xhcmUodCxpKSk7cmV0dXJuIHN9ZGVvcHRpbWl6ZVBhdGgodCl7aWYodC5sZW5ndGg9PT0wKWZvcihjb25zdCBpIG9mIHRoaXMucHJvcGVydGllcylpLmRlb3B0aW1pemVQYXRoKHQpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtmb3IoY29uc3QgbiBvZiB0aGlzLnByb3BlcnRpZXMpaWYobi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLGkscykpcmV0dXJuITA7cmV0dXJuITF9bWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpe2Zvcihjb25zdCB0IG9mIHRoaXMucHJvcGVydGllcyl0Lm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKX19Y2xhc3MgR3AgZXh0ZW5kcyBQdHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigiYXJndW1lbnRzIixudWxsLFksdCksdGhpcy5kZW9wdGltaXplZEFyZ3VtZW50cz1bXX1hZGRBcmd1bWVudFRvQmVEZW9wdGltaXplZCh0KXt0aGlzLmluY2x1ZGVkP3QuZGVvcHRpbWl6ZVBhdGgodGUpOnRoaXMuZGVvcHRpbWl6ZWRBcmd1bWVudHMucHVzaCh0KX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LHt0eXBlOml9KXtyZXR1cm4gaSE9PTB8fHQubGVuZ3RoPjF9aW5jbHVkZSgpe3N1cGVyLmluY2x1ZGUoKTtmb3IoY29uc3QgdCBvZiB0aGlzLmRlb3B0aW1pemVkQXJndW1lbnRzKXQuZGVvcHRpbWl6ZVBhdGgodGUpO3RoaXMuZGVvcHRpbWl6ZWRBcmd1bWVudHMubGVuZ3RoPTB9fWNsYXNzIGFoIGV4dGVuZHMgcW97Y29uc3RydWN0b3IodCl7c3VwZXIoInRoaXMiLG51bGwsdCl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3JldHVybihzLnJlcGxhY2VkVmFyaWFibGVJbml0cy5nZXQodGhpcyl8fFkpLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX19Y2xhc3MgV3AgZXh0ZW5kcyBZb3tjb25zdHJ1Y3Rvcih0LGkpe3N1cGVyKHQsaSksdGhpcy52YXJpYWJsZXMuc2V0KCJhcmd1bWVudHMiLHRoaXMuYXJndW1lbnRzVmFyaWFibGU9bmV3IEdwKGkpKSx0aGlzLnZhcmlhYmxlcy5zZXQoInRoaXMiLHRoaXMudGhpc1ZhcmlhYmxlPW5ldyBhaChpKSl9ZmluZExleGljYWxCb3VuZGFyeSgpe3JldHVybiB0aGlzfWluY2x1ZGVDYWxsQXJndW1lbnRzKHQsaSl7aWYoc3VwZXIuaW5jbHVkZUNhbGxBcmd1bWVudHModCxpKSx0aGlzLmFyZ3VtZW50c1ZhcmlhYmxlLmluY2x1ZGVkKWZvcihjb25zdCBzIG9mIGkpcy5pbmNsdWRlZHx8cy5pbmNsdWRlKHQsITEpfX1jbGFzcyB3ciBleHRlbmRzIEVye2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLm9iamVjdEVudGl0eT1udWxsfWNyZWF0ZVNjb3BlKHQpe3RoaXMuc2NvcGU9bmV3IFdwKHQsdGhpcy5jb250ZXh0KSx0aGlzLmNvbnN0cnVjdGVkRW50aXR5PW5ldyBIZShPYmplY3QuY3JlYXRlKG51bGwpLEZ0KSx0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZS5hZGRFbnRpdHlUb0JlRGVvcHRpbWl6ZWQodGhpcy5jb25zdHJ1Y3RlZEVudGl0eSl9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3N1cGVyLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKSx0LnR5cGU9PT0yJiZpLmxlbmd0aD09PTAmJnQuYXJnc1swXSYmdGhpcy5zY29wZS50aGlzVmFyaWFibGUuYWRkRW50aXR5VG9CZURlb3B0aW1pemVkKHQuYXJnc1swXSl9aGFzRWZmZWN0cyh0KXt2YXIgaTtyZXR1cm4gdGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLCF0aGlzLmFubm90YXRpb25Ob1NpZGVFZmZlY3RzJiYhISgoaT10aGlzLmlkKSE9bnVsbCYmaS5oYXNFZmZlY3RzKHQpKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7aWYoc3VwZXIuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpKXJldHVybiEwO2lmKHRoaXMuYW5ub3RhdGlvbk5vU2lkZUVmZmVjdHMpcmV0dXJuITE7aWYoaS50eXBlPT09Mil7Y29uc3Qgbj1zLnJlcGxhY2VkVmFyaWFibGVJbml0cy5nZXQodGhpcy5zY29wZS50aGlzVmFyaWFibGUpO3MucmVwbGFjZWRWYXJpYWJsZUluaXRzLnNldCh0aGlzLnNjb3BlLnRoaXNWYXJpYWJsZSxpLndpdGhOZXc/dGhpcy5jb25zdHJ1Y3RlZEVudGl0eTpZKTtjb25zdHticm9rZW5GbG93OnIsaWdub3JlOmEscmVwbGFjZWRWYXJpYWJsZUluaXRzOm99PXM7aWYocy5pZ25vcmU9e2JyZWFrczohMSxjb250aW51ZXM6ITEsbGFiZWxzOm5ldyBTZXQscmV0dXJuWWllbGQ6ITAsdGhpczppLndpdGhOZXd9LHRoaXMuYm9keS5oYXNFZmZlY3RzKHMpKXJldHVybiEwO3MuYnJva2VuRmxvdz1yLG4/by5zZXQodGhpcy5zY29wZS50aGlzVmFyaWFibGUsbik6by5kZWxldGUodGhpcy5zY29wZS50aGlzVmFyaWFibGUpLHMuaWdub3JlPWF9cmV0dXJuITF9aW5jbHVkZSh0LGkpe3ZhciBuO3N1cGVyLmluY2x1ZGUodCxpKSwobj10aGlzLmlkKT09bnVsbHx8bi5pbmNsdWRlKCk7Y29uc3Qgcz10aGlzLnNjb3BlLmFyZ3VtZW50c1ZhcmlhYmxlLmluY2x1ZGVkO2Zvcihjb25zdCByIG9mIHRoaXMucGFyYW1zKXIgaW5zdGFuY2VvZiBjZSYmIXN8fHIuaW5jbHVkZSh0LGkpfWluaXRpYWxpc2UoKXt2YXIgdDtzdXBlci5pbml0aWFsaXNlKCksKHQ9dGhpcy5pZCk9PW51bGx8fHQuZGVjbGFyZSgiZnVuY3Rpb24iLHRoaXMpfWFkZEFyZ3VtZW50VG9CZURlb3B0aW1pemVkKHQpe3RoaXMuc2NvcGUuYXJndW1lbnRzVmFyaWFibGUuYWRkQXJndW1lbnRUb0JlRGVvcHRpbWl6ZWQodCl9Z2V0T2JqZWN0RW50aXR5KCl7cmV0dXJuIHRoaXMub2JqZWN0RW50aXR5IT09bnVsbD90aGlzLm9iamVjdEVudGl0eTp0aGlzLm9iamVjdEVudGl0eT1uZXcgSGUoW3trZXk6InByb3RvdHlwZSIsa2luZDoiaW5pdCIscHJvcGVydHk6bmV3IEhlKFtdLEZ0KX1dLEZ0KX19Y2xhc3Mgb2ggZXh0ZW5kcyBWe2hhc0VmZmVjdHMoKXtyZXR1cm4gdGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLCEwfWluY2x1ZGUodCxpKXtpZih0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCksIXRoaXMuaW5jbHVkZWQpe3RoaXMuaW5jbHVkZWQ9ITA7ZTppZighdGhpcy5jb250ZXh0LnVzZXNUb3BMZXZlbEF3YWl0KXtsZXQgcz10aGlzLnBhcmVudDtkbyBpZihzIGluc3RhbmNlb2Ygd3J8fHMgaW5zdGFuY2VvZiBTcilicmVhayBlO3doaWxlKHM9cy5wYXJlbnQpO3RoaXMuY29udGV4dC51c2VzVG9wTGV2ZWxBd2FpdD0hMH19dGhpcy5hcmd1bWVudC5pbmNsdWRlKHQsaSl9fWNvbnN0IHFwPXsiIT0iOihlLHQpPT5lIT10LCIhPT0iOihlLHQpPT5lIT09dCwiJSI6KGUsdCk9PmUldCwiJiI6KGUsdCk9PmUmdCwiKiI6KGUsdCk9PmUqdCwiKioiOihlLHQpPT5lKip0LCIrIjooZSx0KT0+ZSt0LCItIjooZSx0KT0+ZS10LCIvIjooZSx0KT0+ZS90LCI8IjooZSx0KT0+ZTx0LCI8PCI6KGUsdCk9PmU8PHQsIjw9IjooZSx0KT0+ZTw9dCwiPT0iOihlLHQpPT5lPT10LCI9PT0iOihlLHQpPT5lPT09dCwiPiI6KGUsdCk9PmU+dCwiPj0iOihlLHQpPT5lPj10LCI+PiI6KGUsdCk9PmU+PnQsIj4+PiI6KGUsdCk9PmU+Pj50LCJeIjooZSx0KT0+ZV50LCJ8IjooZSx0KT0+ZXx0fTtmdW5jdGlvbiBoaChlLHQsaSl7aWYoaS5hcmd1bWVudHMubGVuZ3RoPjApaWYoaS5hcmd1bWVudHNbaS5hcmd1bWVudHMubGVuZ3RoLTFdLmluY2x1ZGVkKWZvcihjb25zdCBzIG9mIGkuYXJndW1lbnRzKXMucmVuZGVyKGUsdCk7ZWxzZXtsZXQgcz1pLmFyZ3VtZW50cy5sZW5ndGgtMjtmb3IoO3M+PTAmJiFpLmFyZ3VtZW50c1tzXS5pbmNsdWRlZDspcy0tO2lmKHM+PTApe2ZvcihsZXQgbj0wO248PXM7bisrKWkuYXJndW1lbnRzW25dLnJlbmRlcihlLHQpO2UucmVtb3ZlKEllKGUub3JpZ2luYWwsIiwiLGkuYXJndW1lbnRzW3NdLmVuZCksaS5lbmQtMSl9ZWxzZSBlLnJlbW92ZShJZShlLm9yaWdpbmFsLCIoIixpLmNhbGxlZS5lbmQpKzEsaS5lbmQtMSl9fWNsYXNzIGNpIGV4dGVuZHMgVntkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCgpe31nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCl7cmV0dXJuIHQubGVuZ3RoPjB8fHRoaXMudmFsdWU9PT1udWxsJiZ0aGlzLmNvbnRleHQuY29kZS5jaGFyQ29kZUF0KHRoaXMuc3RhcnQpIT09MTEwfHx0eXBlb2YgdGhpcy52YWx1ZT09ImJpZ2ludCJ8fHRoaXMuY29udGV4dC5jb2RlLmNoYXJDb2RlQXQodGhpcy5zdGFydCk9PT00Nz9tZTp0aGlzLnZhbHVlfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQpe3JldHVybiB0Lmxlbmd0aCE9PTE/YmU6SmkodGhpcy5tZW1iZXJzLHRbMF0pfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtzd2l0Y2goaS50eXBlKXtjYXNlIDA6cmV0dXJuIHQubGVuZ3RoPih0aGlzLnZhbHVlPT09bnVsbD8wOjEpO2Nhc2UgMTpyZXR1cm4hMDtjYXNlIDI6cmV0dXJuISEodGhpcy5pbmNsdWRlZCYmdGhpcy52YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCYmKHRoaXMudmFsdWUuZ2xvYmFsfHx0aGlzLnZhbHVlLnN0aWNreSkpfHx0Lmxlbmd0aCE9PTF8fFppKHRoaXMubWVtYmVycyx0WzBdLGkscyl9fWluaXRpYWxpc2UoKXt0aGlzLm1lbWJlcnM9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFJlZ0V4cClyZXR1cm4gdnA7c3dpdGNoKHR5cGVvZiB0KXtjYXNlImJvb2xlYW4iOnJldHVybiBycjtjYXNlIm51bWJlciI6cmV0dXJuIGFyO2Nhc2Uic3RyaW5nIjpyZXR1cm4gWGl9cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCl9KHRoaXMudmFsdWUpfXBhcnNlTm9kZSh0KXt0aGlzLnZhbHVlPXQudmFsdWUsdGhpcy5yZWdleD10LnJlZ2V4LHN1cGVyLnBhcnNlTm9kZSh0KX1yZW5kZXIodCl7dHlwZW9mIHRoaXMudmFsdWU9PSJzdHJpbmciJiZ0LmluZGVudEV4Y2x1c2lvblJhbmdlcy5wdXNoKFt0aGlzLnN0YXJ0KzEsdGhpcy5lbmQtMV0pfX1mdW5jdGlvbiBIcChlKXtyZXR1cm4gZS5jb21wdXRlZD9mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGNpP1N0cmluZyh0LnZhbHVlKTpudWxsfShlLnByb3BlcnR5KTplLnByb3BlcnR5Lm5hbWV9ZnVuY3Rpb24gbGgoZSl7Y29uc3QgdD1lLnByb3BlcnR5S2V5LGk9ZS5vYmplY3Q7aWYodHlwZW9mIHQ9PSJzdHJpbmciKXtpZihpIGluc3RhbmNlb2YgY2UpcmV0dXJuW3trZXk6aS5uYW1lLHBvczppLnN0YXJ0fSx7a2V5OnQscG9zOmUucHJvcGVydHkuc3RhcnR9XTtpZihpIGluc3RhbmNlb2YganQpe2NvbnN0IHM9bGgoaSk7cmV0dXJuIHMmJlsuLi5zLHtrZXk6dCxwb3M6ZS5wcm9wZXJ0eS5zdGFydH1dfX1yZXR1cm4gbnVsbH1jbGFzcyBqdCBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudmFyaWFibGU9bnVsbCx0aGlzLmFzc2lnbm1lbnREZW9wdGltaXplZD0hMSx0aGlzLmJvdW5kPSExLHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9W10sdGhpcy5pc1VuZGVmaW5lZD0hMX1iaW5kKCl7dGhpcy5ib3VuZD0hMDtjb25zdCB0PWxoKHRoaXMpLGk9dCYmdGhpcy5zY29wZS5maW5kVmFyaWFibGUodFswXS5rZXkpO2lmKGkhPW51bGwmJmkuaXNOYW1lc3BhY2Upe2NvbnN0IHM9dWgoaSx0LnNsaWNlKDEpLHRoaXMuY29udGV4dCk7cz9zPT09InVuZGVmaW5lZCI/dGhpcy5pc1VuZGVmaW5lZD0hMDoodGhpcy52YXJpYWJsZT1zLHRoaXMuc2NvcGUuYWRkTmFtZXNwYWNlTWVtYmVyQWNjZXNzKGZ1bmN0aW9uKG4pe2xldCByPW5bMF0ua2V5O2ZvcihsZXQgYT0xO2E8bi5sZW5ndGg7YSsrKXIrPSIuIituW2FdLmtleTtyZXR1cm4gcn0odCkscykpOnN1cGVyLmJpbmQoKX1lbHNlIHN1cGVyLmJpbmQoKX1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7dGhpcy52YXJpYWJsZT90aGlzLnZhcmlhYmxlLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKTp0aGlzLmlzVW5kZWZpbmVkfHwoaS5sZW5ndGg8Nz90aGlzLm9iamVjdC5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LFt0aGlzLmdldFByb3BlcnR5S2V5KCksLi4uaV0scyk6RHQodCkpfWRlb3B0aW1pemVDYWNoZSgpe2NvbnN0e2V4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkOnQsb2JqZWN0Oml9PXRoaXM7dGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZD12ZSx0aGlzLnByb3BlcnR5S2V5PWhlLGkuZGVvcHRpbWl6ZVBhdGgodGUpO2Zvcihjb25zdCBzIG9mIHQpcy5kZW9wdGltaXplQ2FjaGUoKX1kZW9wdGltaXplUGF0aCh0KXtpZih0Lmxlbmd0aD09PTAmJnRoaXMuZGlzYWxsb3dOYW1lc3BhY2VSZWFzc2lnbm1lbnQoKSx0aGlzLnZhcmlhYmxlKXRoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgodCk7ZWxzZSBpZighdGhpcy5pc1VuZGVmaW5lZCYmdC5sZW5ndGg8Nyl7Y29uc3QgaT10aGlzLmdldFByb3BlcnR5S2V5KCk7dGhpcy5vYmplY3QuZGVvcHRpbWl6ZVBhdGgoW2k9PT1oZT9UczppLC4uLnRdKX19Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKXtyZXR1cm4gdGhpcy52YXJpYWJsZT90aGlzLnZhcmlhYmxlLmdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscyk6dGhpcy5pc1VuZGVmaW5lZD92b2lkIDA6dGhpcy5wcm9wZXJ0eUtleSE9PWhlJiZ0Lmxlbmd0aDw3Pyh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gocyksdGhpcy5vYmplY3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFt0aGlzLmdldFByb3BlcnR5S2V5KCksLi4udF0saSxzKSk6bWV9Z2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCxpLHMsbil7cmV0dXJuIHRoaXMudmFyaWFibGU/dGhpcy52YXJpYWJsZS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKTp0aGlzLmlzVW5kZWZpbmVkP1tBaSwhMV06dGhpcy5wcm9wZXJ0eUtleSE9PWhlJiZ0Lmxlbmd0aDw3Pyh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gobiksdGhpcy5vYmplY3QuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKSwuLi50XSxpLHMsbikpOmJlfWhhc0VmZmVjdHModCl7cmV0dXJuIHRoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLnByb3BlcnR5Lmhhc0VmZmVjdHModCl8fHRoaXMub2JqZWN0Lmhhc0VmZmVjdHModCl8fHRoaXMuaGFzQWNjZXNzRWZmZWN0KHQpfWhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQodCxpKXtyZXR1cm4gaSYmIXRoaXMuZGVvcHRpbWl6ZWQmJnRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLmFzc2lnbm1lbnREZW9wdGltaXplZHx8dGhpcy5hcHBseUFzc2lnbm1lbnREZW9wdGltaXphdGlvbigpLHRoaXMucHJvcGVydHkuaGFzRWZmZWN0cyh0KXx8dGhpcy5vYmplY3QuaGFzRWZmZWN0cyh0KXx8aSYmdGhpcy5oYXNBY2Nlc3NFZmZlY3QodCl8fHRoaXMuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoUSx0aGlzLmFzc2lnbm1lbnRJbnRlcmFjdGlvbix0KX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7cmV0dXJuIHRoaXMudmFyaWFibGU/dGhpcy52YXJpYWJsZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyk6ISF0aGlzLmlzVW5kZWZpbmVkfHwhKHQubGVuZ3RoPDcpfHx0aGlzLm9iamVjdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChbdGhpcy5nZXRQcm9wZXJ0eUtleSgpLC4uLnRdLGkscyl9aW5jbHVkZSh0LGkpe3RoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLmluY2x1ZGVQcm9wZXJ0aWVzKHQsaSl9aW5jbHVkZUFzQXNzaWdubWVudFRhcmdldCh0LGkscyl7dGhpcy5hc3NpZ25tZW50RGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlBc3NpZ25tZW50RGVvcHRpbWl6YXRpb24oKSxzP3RoaXMuaW5jbHVkZSh0LGkpOnRoaXMuaW5jbHVkZVByb3BlcnRpZXModCxpKX1pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LGkpe3RoaXMudmFyaWFibGU/dGhpcy52YXJpYWJsZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LGkpOnN1cGVyLmluY2x1ZGVDYWxsQXJndW1lbnRzKHQsaSl9aW5pdGlhbGlzZSgpe3RoaXMucHJvcGVydHlLZXk9SHAodGhpcyksdGhpcy5hY2Nlc3NJbnRlcmFjdGlvbj17YXJnczpbdGhpcy5vYmplY3RdLHR5cGU6MH19aXNTa2lwcGVkQXNPcHRpb25hbCh0KXt2YXIgaSxzO3JldHVybiF0aGlzLnZhcmlhYmxlJiYhdGhpcy5pc1VuZGVmaW5lZCYmKCgocz0oaT10aGlzLm9iamVjdCkuaXNTa2lwcGVkQXNPcHRpb25hbCk9PW51bGw/dm9pZCAwOnMuY2FsbChpLHQpKXx8dGhpcy5vcHRpb25hbCYmdGhpcy5vYmplY3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFEsQWUsdCk9PW51bGwpfXJlbmRlcih0LGkse3JlbmRlcmVkUGFyZW50VHlwZTpzLGlzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDpuLHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OnJ9PSRlKXtpZih0aGlzLnZhcmlhYmxlfHx0aGlzLmlzVW5kZWZpbmVkKXtjb25zdHtzbmlwcGV0czp7Z2V0UHJvcGVydHlBY2Nlc3M6YX19PWk7bGV0IG89dGhpcy52YXJpYWJsZT90aGlzLnZhcmlhYmxlLmdldE5hbWUoYSk6InVuZGVmaW5lZCI7cyYmbiYmKG89IjAsICIrbyksdC5vdmVyd3JpdGUodGhpcy5zdGFydCx0aGlzLmVuZCxvLHtjb250ZW50T25seTohMCxzdG9yZU5hbWU6ITB9KX1lbHNlIHMmJm4mJnQuYXBwZW5kUmlnaHQodGhpcy5zdGFydCwiMCwgIiksdGhpcy5vYmplY3QucmVuZGVyKHQsaSx7cmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6cn0pLHRoaXMucHJvcGVydHkucmVuZGVyKHQsaSl9c2V0QXNzaWduZWRWYWx1ZSh0KXt0aGlzLmFzc2lnbm1lbnRJbnRlcmFjdGlvbj17YXJnczpbdGhpcy5vYmplY3QsdF0sdHlwZToxfX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITA7Y29uc3R7cHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6dH09dGhpcy5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlO2lmKHRoaXMuYm91bmQmJnQmJiF0aGlzLnZhcmlhYmxlJiYhdGhpcy5pc1VuZGVmaW5lZCl7Y29uc3QgaT10aGlzLmdldFByb3BlcnR5S2V5KCk7dGhpcy5vYmplY3QuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodGhpcy5hY2Nlc3NJbnRlcmFjdGlvbixbaV0sQWUpLHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCl9fWFwcGx5QXNzaWdubWVudERlb3B0aW1pemF0aW9uKCl7dGhpcy5hc3NpZ25tZW50RGVvcHRpbWl6ZWQ9ITA7Y29uc3R7cHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6dH09dGhpcy5jb250ZXh0Lm9wdGlvbnMudHJlZXNoYWtlO3RoaXMuYm91bmQmJnQmJiF0aGlzLnZhcmlhYmxlJiYhdGhpcy5pc1VuZGVmaW5lZCYmKHRoaXMub2JqZWN0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuYXNzaWdubWVudEludGVyYWN0aW9uLFt0aGlzLmdldFByb3BlcnR5S2V5KCldLEFlKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpKX1kaXNhbGxvd05hbWVzcGFjZVJlYXNzaWdubWVudCgpe3RoaXMub2JqZWN0IGluc3RhbmNlb2YgY2UmJnRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKHRoaXMub2JqZWN0Lm5hbWUpLmlzTmFtZXNwYWNlJiYodGhpcy52YXJpYWJsZSYmdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpLHRoaXMuY29udGV4dC5sb2coSyxTbyh0aGlzLm9iamVjdC5uYW1lLHRoaXMuY29udGV4dC5tb2R1bGUuaWQpLHRoaXMuc3RhcnQpKX1nZXRQcm9wZXJ0eUtleSgpe2lmKHRoaXMucHJvcGVydHlLZXk9PT1udWxsKXt0aGlzLnByb3BlcnR5S2V5PWhlO2NvbnN0IHQ9dGhpcy5wcm9wZXJ0eS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoUSxBZSx0aGlzKTtyZXR1cm4gdGhpcy5wcm9wZXJ0eUtleT10PT09R24/dDp0eXBlb2YgdD09InN5bWJvbCI/aGU6U3RyaW5nKHQpfXJldHVybiB0aGlzLnByb3BlcnR5S2V5fWhhc0FjY2Vzc0VmZmVjdCh0KXtjb25zdHtwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0czppfT10aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2U7cmV0dXJuISh0aGlzLnZhcmlhYmxlfHx0aGlzLmlzVW5kZWZpbmVkKSYmaSYmKGk9PT0iYWx3YXlzInx8dGhpcy5vYmplY3QuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoW3RoaXMuZ2V0UHJvcGVydHlLZXkoKV0sdGhpcy5hY2Nlc3NJbnRlcmFjdGlvbix0KSl9aW5jbHVkZVByb3BlcnRpZXModCxpKXt0aGlzLmluY2x1ZGVkfHwodGhpcy5pbmNsdWRlZD0hMCx0aGlzLnZhcmlhYmxlJiZ0aGlzLmNvbnRleHQuaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodGhpcy52YXJpYWJsZSkpLHRoaXMub2JqZWN0LmluY2x1ZGUodCxpKSx0aGlzLnByb3BlcnR5LmluY2x1ZGUodCxpKX19ZnVuY3Rpb24gdWgoZSx0LGkpe2lmKHQubGVuZ3RoPT09MClyZXR1cm4gZTtpZighZS5pc05hbWVzcGFjZXx8ZSBpbnN0YW5jZW9mIFZzKXJldHVybiBudWxsO2NvbnN0IHM9dFswXS5rZXksbj1lLmNvbnRleHQudHJhY2VFeHBvcnQocyk7aWYoIW4pe2lmKHQubGVuZ3RoPT09MSl7Y29uc3Qgcj1lLmNvbnRleHQuZmlsZU5hbWU7cmV0dXJuIGkubG9nKEssRnMocyxpLm1vZHVsZS5pZCxyKSx0WzBdLnBvcyksInVuZGVmaW5lZCJ9cmV0dXJuIG51bGx9cmV0dXJuIHVoKG4sdC5zbGljZSgxKSxpKX1jbGFzcyBjaCBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMucmV0dXJuRXhwcmVzc2lvbj1udWxsLHRoaXMuZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zPVtdLHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9bmV3IFNldH1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7Y29uc3R7YXJnczpufT10LFtyLGFdPXRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbihzKTtpZihhKXJldHVybjtjb25zdCBvPW4uZmlsdGVyKGg9PiEhaCYmaCE9PVkpO2lmKG8ubGVuZ3RoIT09MClpZihyPT09WSlmb3IoY29uc3QgaCBvZiBvKWguZGVvcHRpbWl6ZVBhdGgodGUpO2Vsc2Ugcy53aXRoVHJhY2tlZEVudGl0eUF0UGF0aChpLHIsKCk9Pntmb3IoY29uc3QgaCBvZiBvKXRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQuYWRkKGgpO3IuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfSxudWxsKX1kZW9wdGltaXplQ2FjaGUoKXt2YXIgdDtpZigoKHQ9dGhpcy5yZXR1cm5FeHByZXNzaW9uKT09bnVsbD92b2lkIDA6dFswXSkhPT1ZKXt0aGlzLnJldHVybkV4cHJlc3Npb249YmU7Y29uc3R7ZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zOmksZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ6c309dGhpczt0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkPXNvLHRoaXMuZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zPXZlO2Zvcihjb25zdCBuIG9mIGkpbi5kZW9wdGltaXplQ2FjaGUoKTtmb3IoY29uc3QgbiBvZiBzKW4uZGVvcHRpbWl6ZVBhdGgodGUpfX1kZW9wdGltaXplUGF0aCh0KXtpZih0Lmxlbmd0aD09PTB8fHRoaXMuY29udGV4dC5kZW9wdGltaXphdGlvblRyYWNrZXIudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCx0aGlzKSlyZXR1cm47Y29uc3RbaV09dGhpcy5nZXRSZXR1cm5FeHByZXNzaW9uKCk7aSE9PVkmJmkuZGVvcHRpbWl6ZVBhdGgodCl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKXtjb25zdFtuXT10aGlzLmdldFJldHVybkV4cHJlc3Npb24oaSk7cmV0dXJuIG49PT1ZP21lOmkud2l0aFRyYWNrZWRFbnRpdHlBdFBhdGgodCxuLCgpPT4odGhpcy5kZW9wdGltaXphYmxlRGVwZW5kZW50RXhwcmVzc2lvbnMucHVzaChzKSxuLmdldExpdGVyYWxWYWx1ZUF0UGF0aCh0LGkscykpLG1lKX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtjb25zdCByPXRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbihzKTtyZXR1cm4gclswXT09PVk/cjpzLndpdGhUcmFja2VkRW50aXR5QXRQYXRoKHQsciwoKT0+e3RoaXMuZGVvcHRpbWl6YWJsZURlcGVuZGVudEV4cHJlc3Npb25zLnB1c2gobik7Y29uc3RbYSxvXT1yWzBdLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pO3JldHVyblthLG98fHJbMV1dfSxiZSl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe2NvbnN0e3R5cGU6bn09aTtpZihuPT09Mil7Y29uc3R7YXJnczpvLHdpdGhOZXc6aH09aTtpZigoaD9zLmluc3RhbnRpYXRlZDpzLmNhbGxlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCxvLHRoaXMpKXJldHVybiExfWVsc2UgaWYoKG49PT0xP3MuYXNzaWduZWQ6cy5hY2Nlc3NlZCkudHJhY2tFbnRpdHlBdFBhdGhBbmRHZXRJZlRyYWNrZWQodCx0aGlzKSlyZXR1cm4hMTtjb25zdFtyLGFdPXRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO3JldHVybihuPT09MXx8IWEpJiZyLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKX19Y2xhc3MgcGggZXh0ZW5kcyBjaHtiaW5kKCl7c3VwZXIuYmluZCgpLHRoaXMuY2FsbGVlIGluc3RhbmNlb2YgY2UmJih0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZSh0aGlzLmNhbGxlZS5uYW1lKS5pc05hbWVzcGFjZSYmdGhpcy5jb250ZXh0LmxvZyhLLEVvKHRoaXMuY2FsbGVlLm5hbWUpLHRoaXMuc3RhcnQpLHRoaXMuY2FsbGVlLm5hbWU9PT0iZXZhbCImJnRoaXMuY29udGV4dC5sb2coSyx7Y29kZToiRVZBTCIsaWQ6dD10aGlzLmNvbnRleHQubW9kdWxlLmlkLG1lc3NhZ2U6YFVzZSBvZiBldmFsIGluICIke1godCl9IiBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZCBhcyBpdCBwb3NlcyBzZWN1cml0eSByaXNrcyBhbmQgbWF5IGNhdXNlIGlzc3VlcyB3aXRoIG1pbmlmaWNhdGlvbi5gLHVybDpfZSgidHJvdWJsZXNob290aW5nLyNhdm9pZGluZy1ldmFsIil9LHRoaXMuc3RhcnQpKTt2YXIgdDt0aGlzLmludGVyYWN0aW9uPXthcmdzOlt0aGlzLmNhbGxlZSBpbnN0YW5jZW9mIGp0JiYhdGhpcy5jYWxsZWUudmFyaWFibGU/dGhpcy5jYWxsZWUub2JqZWN0Om51bGwsLi4udGhpcy5hcmd1bWVudHNdLHR5cGU6Mix3aXRoTmV3OiExfX1oYXNFZmZlY3RzKHQpe3RyeXtmb3IoY29uc3QgaSBvZiB0aGlzLmFyZ3VtZW50cylpZihpLmhhc0VmZmVjdHModCkpcmV0dXJuITA7cmV0dXJuIXRoaXMuYW5ub3RhdGlvblB1cmUmJih0aGlzLmNhbGxlZS5oYXNFZmZlY3RzKHQpfHx0aGlzLmNhbGxlZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLHRoaXMuaW50ZXJhY3Rpb24sdCkpfWZpbmFsbHl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpfX1pbmNsdWRlKHQsaSl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLGk/KHN1cGVyLmluY2x1ZGUodCxpKSxpPT09Um8mJnRoaXMuY2FsbGVlIGluc3RhbmNlb2YgY2UmJnRoaXMuY2FsbGVlLnZhcmlhYmxlJiZ0aGlzLmNhbGxlZS52YXJpYWJsZS5tYXJrQ2FsbGVkRnJvbVRyeVN0YXRlbWVudCgpKToodGhpcy5pbmNsdWRlZD0hMCx0aGlzLmNhbGxlZS5pbmNsdWRlKHQsITEpKSx0aGlzLmNhbGxlZS5pbmNsdWRlQ2FsbEFyZ3VtZW50cyh0LHRoaXMuYXJndW1lbnRzKX1pc1NraXBwZWRBc09wdGlvbmFsKHQpe3ZhciBpLHM7cmV0dXJuKChzPShpPXRoaXMuY2FsbGVlKS5pc1NraXBwZWRBc09wdGlvbmFsKT09bnVsbD92b2lkIDA6cy5jYWxsKGksdCkpfHx0aGlzLm9wdGlvbmFsJiZ0aGlzLmNhbGxlZS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoUSxBZSx0KT09bnVsbH1yZW5kZXIodCxpLHtyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpzfT0kZSl7dGhpcy5jYWxsZWUucmVuZGVyKHQsaSx7aXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50OiEwLHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OnN9KSxoaCh0LGksdGhpcyl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt0aGlzLmRlb3B0aW1pemVkPSEwLHRoaXMuY2FsbGVlLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHRoaXMuaW50ZXJhY3Rpb24sUSxBZSksdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKX1nZXRSZXR1cm5FeHByZXNzaW9uKHQ9QWUpe3JldHVybiB0aGlzLnJldHVybkV4cHJlc3Npb249PT1udWxsPyh0aGlzLnJldHVybkV4cHJlc3Npb249YmUsdGhpcy5yZXR1cm5FeHByZXNzaW9uPXRoaXMuY2FsbGVlLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKFEsdGhpcy5pbnRlcmFjdGlvbix0LHRoaXMpKTp0aGlzLnJldHVybkV4cHJlc3Npb259fWNsYXNzIEtwIGV4dGVuZHMgUW97YWRkRGVjbGFyYXRpb24odCxpLHMsbil7Y29uc3Qgcj10aGlzLnZhcmlhYmxlcy5nZXQodC5uYW1lKTtyZXR1cm4gcj8odGhpcy5wYXJlbnQuYWRkRGVjbGFyYXRpb24odCxpLEFpLG4pLHIuYWRkRGVjbGFyYXRpb24odCxzKSxyKTp0aGlzLnBhcmVudC5hZGREZWNsYXJhdGlvbih0LGkscyxuKX19Y2xhc3MgUXAgZXh0ZW5kcyBsdHtjb25zdHJ1Y3Rvcih0LGkscyl7c3VwZXIodCksdGhpcy52YXJpYWJsZXMuc2V0KCJ0aGlzIix0aGlzLnRoaXNWYXJpYWJsZT1uZXcgUHQoInRoaXMiLG51bGwsaSxzKSksdGhpcy5pbnN0YW5jZVNjb3BlPW5ldyBsdCh0aGlzKSx0aGlzLmluc3RhbmNlU2NvcGUudmFyaWFibGVzLnNldCgidGhpcyIsbmV3IGFoKHMpKX1maW5kTGV4aWNhbEJvdW5kYXJ5KCl7cmV0dXJuIHRoaXN9fWNsYXNzIGRoIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5hY2Nlc3NlZFZhbHVlPW51bGx9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3JldHVybiB0LnR5cGU9PT0wJiZ0aGlzLmtpbmQ9PT0iZ2V0IiYmaS5sZW5ndGg9PT0wfHx0LnR5cGU9PT0xJiZ0aGlzLmtpbmQ9PT0ic2V0IiYmaS5sZW5ndGg9PT0wP3RoaXMudmFsdWUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoe2FyZ3M6dC5hcmdzLHR5cGU6Mix3aXRoTmV3OiExfSxRLHMpOnZvaWQgdGhpcy5nZXRBY2Nlc3NlZFZhbHVlKClbMF0uZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfWRlb3B0aW1pemVDYWNoZSgpe31kZW9wdGltaXplUGF0aCh0KXt0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKVswXS5kZW9wdGltaXplUGF0aCh0KX1nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCxpLHMpe3JldHVybiB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKVswXS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCxpLHMpfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pe3JldHVybiB0aGlzLmdldEFjY2Vzc2VkVmFsdWUoKVswXS5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKX1oYXNFZmZlY3RzKHQpe3JldHVybiB0aGlzLmtleS5oYXNFZmZlY3RzKHQpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtyZXR1cm4gdGhpcy5raW5kPT09ImdldCImJmkudHlwZT09PTAmJnQubGVuZ3RoPT09MHx8dGhpcy5raW5kPT09InNldCImJmkudHlwZT09PTE/dGhpcy52YWx1ZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLHthcmdzOmkuYXJncyx0eXBlOjIsd2l0aE5ldzohMX0scyk6dGhpcy5nZXRBY2Nlc3NlZFZhbHVlKClbMF0uaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7fWdldEFjY2Vzc2VkVmFsdWUoKXtyZXR1cm4gdGhpcy5hY2Nlc3NlZFZhbHVlPT09bnVsbD90aGlzLmtpbmQ9PT0iZ2V0Ij8odGhpcy5hY2Nlc3NlZFZhbHVlPWJlLHRoaXMuYWNjZXNzZWRWYWx1ZT10aGlzLnZhbHVlLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKFEsT3MsQWUsdGhpcykpOnRoaXMuYWNjZXNzZWRWYWx1ZT1bdGhpcy52YWx1ZSwhMV06dGhpcy5hY2Nlc3NlZFZhbHVlfX1jbGFzcyBBciBleHRlbmRzIGRoe2FwcGx5RGVvcHRpbWl6YXRpb25zKCl7fX1jbGFzcyBZcCBleHRlbmRzIFdle2NvbnN0cnVjdG9yKHQsaSl7c3VwZXIoKSx0aGlzLm9iamVjdD10LHRoaXMua2V5PWl9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3RoaXMub2JqZWN0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsW3RoaXMua2V5LC4uLmldLHMpfWRlb3B0aW1pemVQYXRoKHQpe3RoaXMub2JqZWN0LmRlb3B0aW1pemVQYXRoKFt0aGlzLmtleSwuLi50XSl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKXtyZXR1cm4gdGhpcy5vYmplY3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFt0aGlzLmtleSwuLi50XSxpLHMpfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pe3JldHVybiB0aGlzLm9iamVjdC5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChbdGhpcy5rZXksLi4udF0saSxzLG4pfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtyZXR1cm4gdGhpcy5vYmplY3QuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoW3RoaXMua2V5LC4uLnRdLGkscyl9fWNsYXNzIGZoIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5vYmplY3RFbnRpdHk9bnVsbH1jcmVhdGVTY29wZSh0KXt0aGlzLnNjb3BlPW5ldyBsdCh0KX1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl7dGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyl9ZGVvcHRpbWl6ZUNhY2hlKCl7dGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplQWxsUHJvcGVydGllcygpfWRlb3B0aW1pemVQYXRoKHQpe3RoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZGVvcHRpbWl6ZVBhdGgodCl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKHQsaSxzKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCxpLHMpfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pe3JldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQsaSxzLG4pfWhhc0VmZmVjdHModCl7dmFyIHMsbjt0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7Y29uc3QgaT0oKHM9dGhpcy5zdXBlckNsYXNzKT09bnVsbD92b2lkIDA6cy5oYXNFZmZlY3RzKHQpKXx8dGhpcy5ib2R5Lmhhc0VmZmVjdHModCk7cmV0dXJuKG49dGhpcy5pZCk9PW51bGx8fG4ubWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpLGl8fHN1cGVyLmhhc0VmZmVjdHModCl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3ZhciBuO3JldHVybiBpLnR5cGU9PT0yJiZ0Lmxlbmd0aD09PTA/IWkud2l0aE5ld3x8KHRoaXMuY2xhc3NDb25zdHJ1Y3Rvcj09PW51bGw/KG49dGhpcy5zdXBlckNsYXNzKT09bnVsbD92b2lkIDA6bi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscyk6dGhpcy5jbGFzc0NvbnN0cnVjdG9yLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKSl8fCExOnRoaXMuZ2V0T2JqZWN0RW50aXR5KCkuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpfWluY2x1ZGUodCxpKXt2YXIgczt0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCksdGhpcy5pbmNsdWRlZD0hMCwocz10aGlzLnN1cGVyQ2xhc3MpPT1udWxsfHxzLmluY2x1ZGUodCxpKSx0aGlzLmJvZHkuaW5jbHVkZSh0LGkpLHRoaXMuaWQmJih0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKSx0aGlzLmlkLmluY2x1ZGUoKSl9aW5pdGlhbGlzZSgpe3ZhciB0Oyh0PXRoaXMuaWQpPT1udWxsfHx0LmRlY2xhcmUoImNsYXNzIix0aGlzKTtmb3IoY29uc3QgaSBvZiB0aGlzLmJvZHkuYm9keSlpZihpIGluc3RhbmNlb2YgQXImJmkua2luZD09PSJjb25zdHJ1Y3RvciIpcmV0dXJuIHZvaWQodGhpcy5jbGFzc0NvbnN0cnVjdG9yPWkpO3RoaXMuY2xhc3NDb25zdHJ1Y3Rvcj1udWxsfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMDtmb3IoY29uc3QgdCBvZiB0aGlzLmJvZHkuYm9keSl0LnN0YXRpY3x8dCBpbnN0YW5jZW9mIEFyJiZ0LmtpbmQ9PT0iY29uc3RydWN0b3IifHx0LmRlb3B0aW1pemVQYXRoKHRlKTt0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpfWdldE9iamVjdEVudGl0eSgpe2lmKHRoaXMub2JqZWN0RW50aXR5IT09bnVsbClyZXR1cm4gdGhpcy5vYmplY3RFbnRpdHk7Y29uc3QgdD1bXSxpPVtdO2Zvcihjb25zdCBzIG9mIHRoaXMuYm9keS5ib2R5KXtjb25zdCBuPXMuc3RhdGljP3Q6aSxyPXMua2luZDtpZihuPT09aSYmIXIpY29udGludWU7Y29uc3QgYT1yPT09InNldCJ8fHI9PT0iZ2V0Ij9yOiJpbml0IjtsZXQgbztpZihzLmNvbXB1dGVkKXtjb25zdCBoPXMua2V5LmdldExpdGVyYWxWYWx1ZUF0UGF0aChRLEFlLHRoaXMpO2lmKHR5cGVvZiBoPT0ic3ltYm9sIil7bi5wdXNoKHtrZXk6aGUsa2luZDphLHByb3BlcnR5OnN9KTtjb250aW51ZX1vPVN0cmluZyhoKX1lbHNlIG89cy5rZXkgaW5zdGFuY2VvZiBjZT9zLmtleS5uYW1lOlN0cmluZyhzLmtleS52YWx1ZSk7bi5wdXNoKHtrZXk6byxraW5kOmEscHJvcGVydHk6c30pfXJldHVybiB0LnVuc2hpZnQoe2tleToicHJvdG90eXBlIixraW5kOiJpbml0Iixwcm9wZXJ0eTpuZXcgSGUoaSx0aGlzLnN1cGVyQ2xhc3M/bmV3IFlwKHRoaXMuc3VwZXJDbGFzcywicHJvdG90eXBlIik6RnQpfSksdGhpcy5vYmplY3RFbnRpdHk9bmV3IEhlKHQsdGhpcy5zdXBlckNsYXNzfHxGdCl9fWNsYXNzIEpzIGV4dGVuZHMgZmh7aW5pdGlhbGlzZSgpe3N1cGVyLmluaXRpYWxpc2UoKSx0aGlzLmlkIT09bnVsbCYmKHRoaXMuaWQudmFyaWFibGUuaXNJZD0hMCl9cGFyc2VOb2RlKHQpe3QuaWQhPT1udWxsJiYodGhpcy5pZD1uZXcgY2UodC5pZCx0aGlzLHRoaXMuc2NvcGUucGFyZW50KSksc3VwZXIucGFyc2VOb2RlKHQpfXJlbmRlcih0LGkpe3ZhciBvO2NvbnN0e2V4cG9ydE5hbWVzQnlWYXJpYWJsZTpzLGZvcm1hdDpuLHNuaXBwZXRzOntfOnIsZ2V0UHJvcGVydHlBY2Nlc3M6YX19PWk7aWYodGhpcy5pZCl7Y29uc3R7dmFyaWFibGU6aCxuYW1lOmx9PXRoaXMuaWQ7bj09PSJzeXN0ZW0iJiZzLmhhcyhoKSYmdC5hcHBlbmRMZWZ0KHRoaXMuZW5kLGAke3J9JHt1aShbaF0saSl9O2ApO2NvbnN0IGM9aC5nZXROYW1lKGEpO2lmKGMhPT1sKXJldHVybihvPXRoaXMuc3VwZXJDbGFzcyk9PW51bGx8fG8ucmVuZGVyKHQsaSksdGhpcy5ib2R5LnJlbmRlcih0LHsuLi5pLHVzZU9yaWdpbmFsTmFtZTpwPT5wPT09aH0pLHQucHJlcGVuZFJpZ2h0KHRoaXMuc3RhcnQsYGxldCAke2N9JHtyfT0ke3J9YCksdm9pZCB0LnByZXBlbmRMZWZ0KHRoaXMuZW5kLCI7Iil9c3VwZXIucmVuZGVyKHQsaSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXtzdXBlci5hcHBseURlb3B0aW1pemF0aW9ucygpO2NvbnN0e2lkOnQsc2NvcGU6aX09dGhpcztpZih0KXtjb25zdHtuYW1lOnMsdmFyaWFibGU6bn09dDtmb3IoY29uc3QgciBvZiBpLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy52YWx1ZXMoKSlyIT09biYmci5mb3JiaWROYW1lKHMpfX19Y2xhc3MgQ3IgZXh0ZW5kcyBmaHtyZW5kZXIodCxpLHtyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpzfT0kZSl7c3VwZXIucmVuZGVyKHQsaSkscz09PVllJiYodC5hcHBlbmRSaWdodCh0aGlzLnN0YXJ0LCIoIiksdC5wcmVwZW5kTGVmdCh0aGlzLmVuZCwiKSIpKX19Y2xhc3MgZW4gZXh0ZW5kcyBXZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuZXhwcmVzc2lvbnM9dCx0aGlzLmluY2x1ZGVkPSExfWRlb3B0aW1pemVQYXRoKHQpe2Zvcihjb25zdCBpIG9mIHRoaXMuZXhwcmVzc2lvbnMpaS5kZW9wdGltaXplUGF0aCh0KX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aCh0LGkscyxuKXtyZXR1cm5bbmV3IGVuKHRoaXMuZXhwcmVzc2lvbnMubWFwKHI9PnIuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgodCxpLHMsbilbMF0pKSwhMV19aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe2Zvcihjb25zdCBuIG9mIHRoaXMuZXhwcmVzc2lvbnMpaWYobi5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aCh0LGkscykpcmV0dXJuITA7cmV0dXJuITF9fWZ1bmN0aW9uIHRuKGUsdCl7Y29uc3R7YnJva2VuRmxvdzppLGhhc0JyZWFrOnMsaGFzQ29udGludWU6bixpZ25vcmU6cn09ZSx7YnJlYWtzOmEsY29udGludWVzOm99PXI7cmV0dXJuIHIuYnJlYWtzPSEwLHIuY29udGludWVzPSEwLGUuaGFzQnJlYWs9ITEsZS5oYXNDb250aW51ZT0hMSwhIXQuaGFzRWZmZWN0cyhlKXx8KHIuYnJlYWtzPWEsci5jb250aW51ZXM9byxlLmhhc0JyZWFrPXMsZS5oYXNDb250aW51ZT1uLGUuYnJva2VuRmxvdz1pLCExKX1mdW5jdGlvbiBvcyhlLHQsaSl7Y29uc3R7YnJva2VuRmxvdzpzLGhhc0JyZWFrOm4saGFzQ29udGludWU6cn09ZTtlLmhhc0JyZWFrPSExLGUuaGFzQ29udGludWU9ITEsdC5pbmNsdWRlKGUsaSx7YXNTaW5nbGVTdGF0ZW1lbnQ6ITB9KSxlLmhhc0JyZWFrPW4sZS5oYXNDb250aW51ZT1yLGUuYnJva2VuRmxvdz1zfWNsYXNzIElyIGV4dGVuZHMgVntoYXNFZmZlY3RzKCl7cmV0dXJuITF9aW5pdGlhbGlzZSgpe3RoaXMuY29udGV4dC5hZGRFeHBvcnQodGhpcyl9cmVuZGVyKHQsaSxzKXt0LnJlbW92ZShzLnN0YXJ0LHMuZW5kKX1hcHBseURlb3B0aW1pemF0aW9ucygpe319SXIucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcz0hMDtjbGFzcyBocyBleHRlbmRzIHdye2luaXRpYWxpc2UoKXtzdXBlci5pbml0aWFsaXNlKCksdGhpcy5pZCE9PW51bGwmJih0aGlzLmlkLnZhcmlhYmxlLmlzSWQ9ITApfXBhcnNlTm9kZSh0KXt0LmlkIT09bnVsbCYmKHRoaXMuaWQ9bmV3IGNlKHQuaWQsdGhpcyx0aGlzLnNjb3BlLnBhcmVudCkpLHN1cGVyLnBhcnNlTm9kZSh0KX19Y2xhc3Mgc24gZXh0ZW5kcyBWe2luY2x1ZGUodCxpKXtzdXBlci5pbmNsdWRlKHQsaSksaSYmdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpfWluaXRpYWxpc2UoKXtjb25zdCB0PXRoaXMuZGVjbGFyYXRpb247dGhpcy5kZWNsYXJhdGlvbk5hbWU9dC5pZCYmdC5pZC5uYW1lfHx0aGlzLmRlY2xhcmF0aW9uLm5hbWUsdGhpcy52YXJpYWJsZT10aGlzLnNjb3BlLmFkZEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbih0aGlzLmRlY2xhcmF0aW9uTmFtZXx8dGhpcy5jb250ZXh0LmdldE1vZHVsZU5hbWUoKSx0aGlzLHRoaXMuY29udGV4dCksdGhpcy5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKX1yZW5kZXIodCxpLHMpe2NvbnN0e3N0YXJ0Om4sZW5kOnJ9PXMsYT1mdW5jdGlvbihvLGgpe3JldHVybiB6dChvLEllKG8sImRlZmF1bHQiLGgpKzcpfSh0Lm9yaWdpbmFsLHRoaXMuc3RhcnQpO2lmKHRoaXMuZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBocyl0aGlzLnJlbmRlck5hbWVkRGVjbGFyYXRpb24odCxhLHRoaXMuZGVjbGFyYXRpb24uaWQ9PT1udWxsP2Z1bmN0aW9uKG8saCl7Y29uc3QgbD1JZShvLCJmdW5jdGlvbiIsaCkrODtvPW8uc2xpY2UobCxJZShvLCIoIixsKSk7Y29uc3QgYz1JZShvLCIqIik7cmV0dXJuIGM9PT0tMT9sOmwrYysxfSh0Lm9yaWdpbmFsLGEpOm51bGwsaSk7ZWxzZSBpZih0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgSnMpdGhpcy5yZW5kZXJOYW1lZERlY2xhcmF0aW9uKHQsYSx0aGlzLmRlY2xhcmF0aW9uLmlkPT09bnVsbD9JZSh0Lm9yaWdpbmFsLCJjbGFzcyIsbikrNTpudWxsLGkpO2Vsc2V7aWYodGhpcy52YXJpYWJsZS5nZXRPcmlnaW5hbFZhcmlhYmxlKCkhPT10aGlzLnZhcmlhYmxlKXJldHVybiB2b2lkIGJyKHRoaXMsdCxuLHIpO2lmKCF0aGlzLnZhcmlhYmxlLmluY2x1ZGVkKXJldHVybiB0LnJlbW92ZSh0aGlzLnN0YXJ0LGEpLHRoaXMuZGVjbGFyYXRpb24ucmVuZGVyKHQsaSx7cmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6WWV9KSx2b2lkKHQub3JpZ2luYWxbdGhpcy5lbmQtMV0hPT0iOyImJnQuYXBwZW5kTGVmdCh0aGlzLmVuZCwiOyIpKTt0aGlzLnJlbmRlclZhcmlhYmxlRGVjbGFyYXRpb24odCxhLGkpfXRoaXMuZGVjbGFyYXRpb24ucmVuZGVyKHQsaSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9cmVuZGVyTmFtZWREZWNsYXJhdGlvbih0LGkscyxuKXtjb25zdHtleHBvcnROYW1lc0J5VmFyaWFibGU6cixmb3JtYXQ6YSxzbmlwcGV0czp7Z2V0UHJvcGVydHlBY2Nlc3M6b319PW4saD10aGlzLnZhcmlhYmxlLmdldE5hbWUobyk7dC5yZW1vdmUodGhpcy5zdGFydCxpKSxzIT09bnVsbCYmdC5hcHBlbmRMZWZ0KHMsYCAke2h9YCksYT09PSJzeXN0ZW0iJiZ0aGlzLmRlY2xhcmF0aW9uIGluc3RhbmNlb2YgSnMmJnIuaGFzKHRoaXMudmFyaWFibGUpJiZ0LmFwcGVuZExlZnQodGhpcy5lbmQsYCAke3VpKFt0aGlzLnZhcmlhYmxlXSxuKX07YCl9cmVuZGVyVmFyaWFibGVEZWNsYXJhdGlvbih0LGkse2Zvcm1hdDpzLGV4cG9ydE5hbWVzQnlWYXJpYWJsZTpuLHNuaXBwZXRzOntjbnN0OnIsZ2V0UHJvcGVydHlBY2Nlc3M6YX19KXtjb25zdCBvPXQub3JpZ2luYWwuY2hhckNvZGVBdCh0aGlzLmVuZC0xKT09PTU5LGg9cz09PSJzeXN0ZW0iJiZuLmdldCh0aGlzLnZhcmlhYmxlKTtoPyh0Lm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LGksYCR7cn0gJHt0aGlzLnZhcmlhYmxlLmdldE5hbWUoYSl9ID0gZXhwb3J0cygnJHtoWzBdfScsIGApLHQuYXBwZW5kUmlnaHQobz90aGlzLmVuZC0xOnRoaXMuZW5kLCIpIisobz8iIjoiOyIpKSk6KHQub3ZlcndyaXRlKHRoaXMuc3RhcnQsaSxgJHtyfSAke3RoaXMudmFyaWFibGUuZ2V0TmFtZShhKX0gPSBgKSxvfHx0LmFwcGVuZExlZnQodGhpcy5lbmQsIjsiKSl9fXNuLnByb3RvdHlwZS5uZWVkc0JvdW5kYXJpZXM9ITA7Y2xhc3MgbWggZXh0ZW5kcyBWe2JpbmQoKXt2YXIgdDsodD10aGlzLmRlY2xhcmF0aW9uKT09bnVsbHx8dC5iaW5kKCl9aGFzRWZmZWN0cyh0KXt2YXIgaTtyZXR1cm4hISgoaT10aGlzLmRlY2xhcmF0aW9uKSE9bnVsbCYmaS5oYXNFZmZlY3RzKHQpKX1pbml0aWFsaXNlKCl7dGhpcy5jb250ZXh0LmFkZEV4cG9ydCh0aGlzKX1yZW5kZXIodCxpLHMpe2NvbnN0e3N0YXJ0Om4sZW5kOnJ9PXM7dGhpcy5kZWNsYXJhdGlvbj09PW51bGw/dC5yZW1vdmUobixyKToodC5yZW1vdmUodGhpcy5zdGFydCx0aGlzLmRlY2xhcmF0aW9uLnN0YXJ0KSx0aGlzLmRlY2xhcmF0aW9uLnJlbmRlcih0LGkse2VuZDpyLHN0YXJ0Om59KSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9fW1oLnByb3RvdHlwZS5uZWVkc0JvdW5kYXJpZXM9ITA7Y2xhc3MgZ2ggZXh0ZW5kcyB3cntyZW5kZXIodCxpLHtyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpzfT0kZSl7c3VwZXIucmVuZGVyKHQsaSkscz09PVllJiYodC5hcHBlbmRSaWdodCh0aGlzLnN0YXJ0LCIoIiksdC5wcmVwZW5kTGVmdCh0aGlzLmVuZCwiKSIpKX19Y2xhc3MgeWggZXh0ZW5kcyBoaXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5ob2lzdGVkRGVjbGFyYXRpb25zPVtdfWFkZERlY2xhcmF0aW9uKHQsaSxzLG4pe3JldHVybiB0aGlzLmhvaXN0ZWREZWNsYXJhdGlvbnMucHVzaCh0KSxzdXBlci5hZGREZWNsYXJhdGlvbih0LGkscyxuKX19Y29uc3QgeGg9U3ltYm9sKCJ1bnNldCIpO2NsYXNzIFByIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50ZXN0VmFsdWU9eGh9ZGVvcHRpbWl6ZUNhY2hlKCl7dGhpcy50ZXN0VmFsdWU9bWV9aGFzRWZmZWN0cyh0KXt2YXIgcztpZih0aGlzLnRlc3QuaGFzRWZmZWN0cyh0KSlyZXR1cm4hMDtjb25zdCBpPXRoaXMuZ2V0VGVzdFZhbHVlKCk7aWYodHlwZW9mIGk9PSJzeW1ib2wiKXtjb25zdHticm9rZW5GbG93Om59PXQ7aWYodGhpcy5jb25zZXF1ZW50Lmhhc0VmZmVjdHModCkpcmV0dXJuITA7Y29uc3Qgcj10LmJyb2tlbkZsb3c7cmV0dXJuIHQuYnJva2VuRmxvdz1uLHRoaXMuYWx0ZXJuYXRlPT09bnVsbD8hMTohIXRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHModCl8fCh0LmJyb2tlbkZsb3c9dC5icm9rZW5GbG93JiZyLCExKX1yZXR1cm4gaT90aGlzLmNvbnNlcXVlbnQuaGFzRWZmZWN0cyh0KTohISgocz10aGlzLmFsdGVybmF0ZSkhPW51bGwmJnMuaGFzRWZmZWN0cyh0KSl9aW5jbHVkZSh0LGkpe2lmKHRoaXMuaW5jbHVkZWQ9ITAsaSl0aGlzLmluY2x1ZGVSZWN1cnNpdmVseShpLHQpO2Vsc2V7Y29uc3Qgcz10aGlzLmdldFRlc3RWYWx1ZSgpO3R5cGVvZiBzPT0ic3ltYm9sIj90aGlzLmluY2x1ZGVVbmtub3duVGVzdCh0KTp0aGlzLmluY2x1ZGVLbm93blRlc3QodCxzKX19cGFyc2VOb2RlKHQpe3RoaXMuY29uc2VxdWVudFNjb3BlPW5ldyB5aCh0aGlzLnNjb3BlKSx0aGlzLmNvbnNlcXVlbnQ9bmV3KHRoaXMuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IodC5jb25zZXF1ZW50LnR5cGUpKSh0LmNvbnNlcXVlbnQsdGhpcyx0aGlzLmNvbnNlcXVlbnRTY29wZSksdC5hbHRlcm5hdGUmJih0aGlzLmFsdGVybmF0ZVNjb3BlPW5ldyB5aCh0aGlzLnNjb3BlKSx0aGlzLmFsdGVybmF0ZT1uZXcodGhpcy5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3Rvcih0LmFsdGVybmF0ZS50eXBlKSkodC5hbHRlcm5hdGUsdGhpcyx0aGlzLmFsdGVybmF0ZVNjb3BlKSksc3VwZXIucGFyc2VOb2RlKHQpfXJlbmRlcih0LGkpe2NvbnN0e3NuaXBwZXRzOntnZXRQcm9wZXJ0eUFjY2VzczpzfX09aSxuPXRoaXMuZ2V0VGVzdFZhbHVlKCkscj1bXSxhPXRoaXMudGVzdC5pbmNsdWRlZCxvPSF0aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2U7YT90aGlzLnRlc3QucmVuZGVyKHQsaSk6dC5yZW1vdmUodGhpcy5zdGFydCx0aGlzLmNvbnNlcXVlbnQuc3RhcnQpLHRoaXMuY29uc2VxdWVudC5pbmNsdWRlZCYmKG98fHR5cGVvZiBuPT0ic3ltYm9sInx8bik/dGhpcy5jb25zZXF1ZW50LnJlbmRlcih0LGkpOih0Lm92ZXJ3cml0ZSh0aGlzLmNvbnNlcXVlbnQuc3RhcnQsdGhpcy5jb25zZXF1ZW50LmVuZCxhPyI7IjoiIiksci5wdXNoKC4uLnRoaXMuY29uc2VxdWVudFNjb3BlLmhvaXN0ZWREZWNsYXJhdGlvbnMpKSx0aGlzLmFsdGVybmF0ZSYmKCF0aGlzLmFsdGVybmF0ZS5pbmNsdWRlZHx8IW8mJnR5cGVvZiBuIT0ic3ltYm9sIiYmbj8oYSYmdGhpcy5zaG91bGRLZWVwQWx0ZXJuYXRlQnJhbmNoKCk/dC5vdmVyd3JpdGUodGhpcy5hbHRlcm5hdGUuc3RhcnQsdGhpcy5lbmQsIjsiKTp0LnJlbW92ZSh0aGlzLmNvbnNlcXVlbnQuZW5kLHRoaXMuZW5kKSxyLnB1c2goLi4udGhpcy5hbHRlcm5hdGVTY29wZS5ob2lzdGVkRGVjbGFyYXRpb25zKSk6KGE/dC5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuYWx0ZXJuYXRlLnN0YXJ0LTEpPT09MTAxJiZ0LnByZXBlbmRMZWZ0KHRoaXMuYWx0ZXJuYXRlLnN0YXJ0LCIgIik6dC5yZW1vdmUodGhpcy5jb25zZXF1ZW50LmVuZCx0aGlzLmFsdGVybmF0ZS5zdGFydCksdGhpcy5hbHRlcm5hdGUucmVuZGVyKHQsaSkpKSx0aGlzLnJlbmRlckhvaXN0ZWREZWNsYXJhdGlvbnMocix0LHMpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7fWdldFRlc3RWYWx1ZSgpe3JldHVybiB0aGlzLnRlc3RWYWx1ZT09PXhoP3RoaXMudGVzdFZhbHVlPXRoaXMudGVzdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoUSxBZSx0aGlzKTp0aGlzLnRlc3RWYWx1ZX1pbmNsdWRlS25vd25UZXN0KHQsaSl7dmFyIHM7dGhpcy50ZXN0LnNob3VsZEJlSW5jbHVkZWQodCkmJnRoaXMudGVzdC5pbmNsdWRlKHQsITEpLGkmJnRoaXMuY29uc2VxdWVudC5zaG91bGRCZUluY2x1ZGVkKHQpJiZ0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZSh0LCExLHthc1NpbmdsZVN0YXRlbWVudDohMH0pLCFpJiYoKHM9dGhpcy5hbHRlcm5hdGUpIT1udWxsJiZzLnNob3VsZEJlSW5jbHVkZWQodCkpJiZ0aGlzLmFsdGVybmF0ZS5pbmNsdWRlKHQsITEse2FzU2luZ2xlU3RhdGVtZW50OiEwfSl9aW5jbHVkZVJlY3Vyc2l2ZWx5KHQsaSl7dmFyIHM7dGhpcy50ZXN0LmluY2x1ZGUoaSx0KSx0aGlzLmNvbnNlcXVlbnQuaW5jbHVkZShpLHQpLChzPXRoaXMuYWx0ZXJuYXRlKT09bnVsbHx8cy5pbmNsdWRlKGksdCl9aW5jbHVkZVVua25vd25UZXN0KHQpe3ZhciBuO3RoaXMudGVzdC5pbmNsdWRlKHQsITEpO2NvbnN0e2Jyb2tlbkZsb3c6aX09dDtsZXQgcz0hMTt0aGlzLmNvbnNlcXVlbnQuc2hvdWxkQmVJbmNsdWRlZCh0KSYmKHRoaXMuY29uc2VxdWVudC5pbmNsdWRlKHQsITEse2FzU2luZ2xlU3RhdGVtZW50OiEwfSkscz10LmJyb2tlbkZsb3csdC5icm9rZW5GbG93PWkpLChuPXRoaXMuYWx0ZXJuYXRlKSE9bnVsbCYmbi5zaG91bGRCZUluY2x1ZGVkKHQpJiYodGhpcy5hbHRlcm5hdGUuaW5jbHVkZSh0LCExLHthc1NpbmdsZVN0YXRlbWVudDohMH0pLHQuYnJva2VuRmxvdz10LmJyb2tlbkZsb3cmJnMpfXJlbmRlckhvaXN0ZWREZWNsYXJhdGlvbnModCxpLHMpe2NvbnN0IG49Wy4uLm5ldyBTZXQodC5tYXAocj0+e2NvbnN0IGE9ci52YXJpYWJsZTtyZXR1cm4gYS5pbmNsdWRlZD9hLmdldE5hbWUocyk6IiJ9KSldLmZpbHRlcihCb29sZWFuKS5qb2luKCIsICIpO2lmKG4pe2NvbnN0IHI9dGhpcy5wYXJlbnQudHlwZSxhPXIhPT1VcyYmciE9PVBvO2kucHJlcGVuZFJpZ2h0KHRoaXMuc3RhcnQsYCR7YT8ieyAiOiIifXZhciAke259OyBgKSxhJiZpLmFwcGVuZExlZnQodGhpcy5lbmQsIiB9Iil9fXNob3VsZEtlZXBBbHRlcm5hdGVCcmFuY2goKXtsZXQgdD10aGlzLnBhcmVudDtkb3tpZih0IGluc3RhbmNlb2YgUHImJnQuYWx0ZXJuYXRlKXJldHVybiEwO2lmKHQgaW5zdGFuY2VvZiBacylyZXR1cm4hMTt0PXQucGFyZW50fXdoaWxlKHQpO3JldHVybiExfX1jbGFzcyBiaCBleHRlbmRzIFZ7YmluZCgpe31oYXNFZmZlY3RzKCl7cmV0dXJuITF9aW5pdGlhbGlzZSgpe3RoaXMuY29udGV4dC5hZGRJbXBvcnQodGhpcyl9cmVuZGVyKHQsaSxzKXt0LnJlbW92ZShzLnN0YXJ0LHMuZW5kKX1hcHBseURlb3B0aW1pemF0aW9ucygpe319YmgucHJvdG90eXBlLm5lZWRzQm91bmRhcmllcz0hMDtjbGFzcyB2aCBleHRlbmRzIFZ7YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9fWNvbnN0IF9yPSJfaW50ZXJvcERlZmF1bHQiLE5yPSJfaW50ZXJvcERlZmF1bHRDb21wYXQiLG5uPSJfaW50ZXJvcE5hbWVzcGFjZSIscm49Il9pbnRlcm9wTmFtZXNwYWNlQ29tcGF0IixwaT0iX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0Iixscz0iX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0T25seSIsYW49Il9tZXJnZU5hbWVzcGFjZXMiLFV0PSJfZG9jdW1lbnRDdXJyZW50U2NyaXB0Iixvbj17YXV0bzpfcixjb21wYXQ6TnIsZGVmYXVsdDpudWxsLGRlZmF1bHRPbmx5Om51bGwsZXNNb2R1bGU6bnVsbH0saG49KGUsdCk9PmU9PT0iZXNNb2R1bGUifHx0JiYoZT09PSJhdXRvInx8ZT09PSJjb21wYXQiKSx1cz17YXV0bzpubixjb21wYXQ6cm4sZGVmYXVsdDpwaSxkZWZhdWx0T25seTpscyxlc01vZHVsZTpudWxsfSxYcD0oZSx0KT0+ZSE9PSJlc01vZHVsZSImJmhuKGUsdCksJHI9KGUsdCxpLHMsbixyLGEpPT57Y29uc3Qgbz1uZXcgU2V0KGUpO2Zvcihjb25zdCBoIG9mIE9yKXQuaGFzKGgpJiZvLmFkZChoKTtyZXR1cm4gT3IubWFwKGg9Pm8uaGFzKGgpP0VoW2hdKGkscyxuLHIsYSxvKToiIikuam9pbigiIil9LEVoPXtbVXRdOihlLHtfOnQsbjppfSk9PmB2YXIke3R9JHtVdH0ke3R9PSR7dH10eXBlb2Yke3R9ZG9jdW1lbnQke3R9IT09JHt0fSd1bmRlZmluZWQnJHt0fT8ke3R9ZG9jdW1lbnQuY3VycmVudFNjcmlwdCR7dH06JHt0fW51bGw7JHtpfWAsW05yXShlLHQsaSl7Y29uc3R7XzpzLGdldERpcmVjdFJldHVybkZ1bmN0aW9uOm4sbjpyfT10LFthLG9dPW4oWyJlIl0se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6TnJ9KTtyZXR1cm5gJHthfSR7THIodCl9JHtzfT8ke3N9JHtpP1NoKHQpOmtoKHQpfSR7b30ke3J9JHtyfWB9LFtfcl0oZSx0LGkpe2NvbnN0e186cyxnZXREaXJlY3RSZXR1cm5GdW5jdGlvbjpuLG46cn09dCxbYSxvXT1uKFsiZSJdLHtmdW5jdGlvblJldHVybjohMCxsaW5lQnJlYWtJbmRlbnQ6bnVsbCxuYW1lOl9yfSk7cmV0dXJuYCR7YX1lJHtzfSYmJHtzfWUuX19lc01vZHVsZSR7c30/JHtzfSR7aT9TaCh0KTpraCh0KX0ke299JHtyfSR7cn1gfSxbcm5dKGUsdCxpLHMsbixyKXtjb25zdHtfOmEsZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb246byxuOmh9PXQ7aWYoci5oYXMocGkpKXtjb25zdFtsLGNdPW8oWyJlIl0se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6cm59KTtyZXR1cm5gJHtsfSR7THIodCl9JHthfT8ke2F9ZSR7YX06JHthfSR7cGl9KGUpJHtjfSR7aH0ke2h9YH1yZXR1cm5gZnVuY3Rpb24gJHtybn0oZSkke2F9eyR7aH0ke2V9aWYke2F9KCR7THIodCl9KSR7YX1yZXR1cm4gZTske2h9YCtUcihlLGUsdCxpLHMsbikrYH0ke2h9JHtofWB9LFtsc10oZSx0LGkscyxuKXtjb25zdHtnZXREaXJlY3RSZXR1cm5GdW5jdGlvbjpyLGdldE9iamVjdDphLG46b309dCxbaCxsXT1yKFsiZSJdLHtmdW5jdGlvblJldHVybjohMCxsaW5lQnJlYWtJbmRlbnQ6bnVsbCxuYW1lOmxzfSk7cmV0dXJuYCR7aH0ke1JyKHMsQ2gobixhKFtbIl9fcHJvdG9fXyIsIm51bGwiXSxbImRlZmF1bHQiLCJlIl1dLHtsaW5lQnJlYWtJbmRlbnQ6bnVsbH0pLHQpKX0ke2x9JHtvfSR7b31gfSxbcGldKGUsdCxpLHMsbil7Y29uc3R7XzpyLG46YX09dDtyZXR1cm5gZnVuY3Rpb24gJHtwaX0oZSkke3J9eyR7YX1gK1RyKGUsZSx0LGkscyxuKStgfSR7YX0ke2F9YH0sW25uXShlLHQsaSxzLG4scil7Y29uc3R7XzphLGdldERpcmVjdFJldHVybkZ1bmN0aW9uOm8sbjpofT10O2lmKHIuaGFzKHBpKSl7Y29uc3RbbCxjXT1vKFsiZSJdLHtmdW5jdGlvblJldHVybjohMCxsaW5lQnJlYWtJbmRlbnQ6bnVsbCxuYW1lOm5ufSk7cmV0dXJuYCR7bH1lJHthfSYmJHthfWUuX19lc01vZHVsZSR7YX0/JHthfWUke2F9OiR7YX0ke3BpfShlKSR7Y30ke2h9JHtofWB9cmV0dXJuYGZ1bmN0aW9uICR7bm59KGUpJHthfXske2h9JHtlfWlmJHthfShlJHthfSYmJHthfWUuX19lc01vZHVsZSkke2F9cmV0dXJuIGU7JHtofWArVHIoZSxlLHQsaSxzLG4pK2B9JHtofSR7aH1gfSxbYW5dKGUsdCxpLHMsbil7Y29uc3R7XzpyLGNuc3Q6YSxuOm99PXQsaD1hPT09InZhciImJmk7cmV0dXJuYGZ1bmN0aW9uICR7YW59KG4sIG0pJHtyfXske299JHtlfSR7SnAoYHske299JHtlfSR7ZX0ke2V9aWYke3J9KGske3J9IT09JHtyfSdkZWZhdWx0JyR7cn0mJiR7cn0hKGsgaW4gbikpJHtyfXske299YCsoaT9oP3doOnRkOkFoKShlLGUrZStlK2UsdCkrYCR7ZX0ke2V9JHtlfX0ke299JHtlfSR7ZX19YCxoLGUsdCl9JHtvfSR7ZX1yZXR1cm4gJHtScihzLENoKG4sIm4iLHQpKX07JHtvfX0ke299JHtvfWB9fSxTaD0oe186ZSxnZXRPYmplY3Q6dH0pPT5gZSR7ZX06JHtlfSR7dChbWyJkZWZhdWx0IiwiZSJdXSx7bGluZUJyZWFrSW5kZW50Om51bGx9KX1gLGtoPSh7XzplLGdldFByb3BlcnR5QWNjZXNzOnR9KT0+YGUke3QoImRlZmF1bHQiKX0ke2V9OiR7ZX1lYCxMcj0oe186ZX0pPT5gZSR7ZX0mJiR7ZX10eXBlb2YgZSR7ZX09PT0ke2V9J29iamVjdCcke2V9JiYke2V9J2RlZmF1bHQnJHtlfWluIGVgLFRyPShlLHQsaSxzLG4scik9Pntjb25zdHtfOmEsY25zdDpvLGdldE9iamVjdDpoLGdldFByb3BlcnR5QWNjZXNzOmwsbjpjLHM6cH09aSxtPWB7JHtjfWArKHM/ZWQ6QWgpKGUsdCtlK2UsaSkrYCR7dH0ke2V9fWA7cmV0dXJuYCR7dH0ke299IG4ke2F9PSR7YX1PYmplY3QuY3JlYXRlKG51bGwke3I/YCwke2F9eyR7YX1bU3ltYm9sLnRvU3RyaW5nVGFnXToke2F9JHtjcyhoKX0ke2F9fWA6IiJ9KTske2N9JHt0fWlmJHthfShlKSR7YX17JHtjfSR7dH0ke2V9JHtacChtLCFzLGkpfSR7Y30ke3R9fSR7Y30ke3R9biR7bCgiZGVmYXVsdCIpfSR7YX09JHthfWU7JHtjfSR7dH1yZXR1cm4gJHtScihuLCJuIil9JHtwfSR7Y31gfSxacD0oZSx0LHtfOmksY25zdDpzLGdldEZ1bmN0aW9uSW50cm86bixzOnJ9KT0+cyE9PSJ2YXIifHx0P2Bmb3Ike2l9KCR7c30gayBpbiBlKSR7aX0ke2V9YDpgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgke24oWyJrIl0se2lzQXN5bmM6ITEsbmFtZTpudWxsfSl9JHtlfSkke3J9YCxKcD0oZSx0LGkse186cyxjbnN0Om4sZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb246cixnZXRGdW5jdGlvbkludHJvOmEsbjpvfSk9PntpZih0KXtjb25zdFtoLGxdPXIoWyJlIl0se2Z1bmN0aW9uUmV0dXJuOiExLGxpbmVCcmVha0luZGVudDp7YmFzZTppLHQ6aX0sbmFtZTpudWxsfSk7cmV0dXJuYG0uZm9yRWFjaCgke2h9ZSR7c30mJiR7c310eXBlb2YgZSR7c30hPT0ke3N9J3N0cmluZycke3N9JiYke3N9IUFycmF5LmlzQXJyYXkoZSkke3N9JiYke3N9T2JqZWN0LmtleXMoZSkuZm9yRWFjaCgke2EoWyJrIl0se2lzQXN5bmM6ITEsbmFtZTpudWxsfSl9JHtlfSkke2x9KTtgfXJldHVybmBmb3Ike3N9KHZhciBpJHtzfT0ke3N9MDske3N9aSR7c308JHtzfW0ubGVuZ3RoOyR7c31pKyspJHtzfXske299JHtpfSR7aX0ke259IGUke3N9PSR7c31tW2ldOyR7b30ke2l9JHtpfWlmJHtzfSh0eXBlb2YgZSR7c30hPT0ke3N9J3N0cmluZycke3N9JiYke3N9IUFycmF5LmlzQXJyYXkoZSkpJHtzfXske3N9Zm9yJHtzfSgke259IGsgaW4gZSkke3N9JHtlfSR7c319JHtvfSR7aX19YH0sZWQ9KGUsdCxpKT0+e2NvbnN0e186cyxufT1pO3JldHVybmAke3R9aWYke3N9KGske3N9IT09JHtzfSdkZWZhdWx0Jykke3N9eyR7bn1gK3doKGUsdCtlLGkpK2Ake3R9fSR7bn1gfSx3aD0oZSx0LHtfOmksY25zdDpzLGdldERpcmVjdFJldHVybkZ1bmN0aW9uOm4sbjpyfSk9Pntjb25zdFthLG9dPW4oW10se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO3JldHVybmAke3R9JHtzfSBkJHtpfT0ke2l9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCR7aX1rKTske3J9JHt0fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCR7aX1rLCR7aX1kLmdldCR7aX0/JHtpfWQke2l9OiR7aX17JHtyfSR7dH0ke2V9ZW51bWVyYWJsZToke2l9dHJ1ZSwke3J9JHt0fSR7ZX1nZXQ6JHtpfSR7YX1lW2tdJHtvfSR7cn0ke3R9fSk7JHtyfWB9LHRkPShlLHQse186aSxjbnN0OnMsZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb246bixuOnJ9KT0+e2NvbnN0W2Esb109bihbXSx7ZnVuY3Rpb25SZXR1cm46ITAsbGluZUJyZWFrSW5kZW50Om51bGwsbmFtZTpudWxsfSk7cmV0dXJuYCR7dH0ke3N9IGQke2l9PSR7aX1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsJHtpfWspOyR7cn0ke3R9aWYke2l9KGQpJHtpfXske3J9JHt0fSR7ZX1PYmplY3QuZGVmaW5lUHJvcGVydHkobiwke2l9aywke2l9ZC5nZXQke2l9PyR7aX1kJHtpfToke2l9eyR7cn0ke3R9JHtlfSR7ZX1lbnVtZXJhYmxlOiR7aX10cnVlLCR7cn0ke3R9JHtlfSR7ZX1nZXQ6JHtpfSR7YX1lW2tdJHtvfSR7cn0ke3R9JHtlfX0pOyR7cn0ke3R9fSR7cn1gfSxBaD0oZSx0LHtfOmksbjpzfSk9PmAke3R9bltrXSR7aX09JHtpfWVba107JHtzfWAsUnI9KGUsdCk9PmU/YE9iamVjdC5mcmVlemUoJHt0fSlgOnQsQ2g9KGUsdCx7XzppLGdldE9iamVjdDpzfSk9PmU/YE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgke3R9LCR7aX1TeW1ib2wudG9TdHJpbmdUYWcsJHtpfSR7Y3Mocyl9KWA6dCxPcj1PYmplY3Qua2V5cyhFaCk7ZnVuY3Rpb24gY3MoZSl7cmV0dXJuIGUoW1sidmFsdWUiLCInTW9kdWxlJyJdXSx7bGluZUJyZWFrSW5kZW50Om51bGx9KX1mdW5jdGlvbiBJaChlLHQpe3JldHVybiBlLnJlbmRlckJhc2VOYW1lIT09bnVsbCYmdC5oYXMoZSkmJmUuaXNSZWFzc2lnbmVkfWNsYXNzIFBoIGV4dGVuZHMgVntkZWNsYXJlRGVjbGFyYXRvcih0KXt0aGlzLmlkLmRlY2xhcmUodCx0aGlzLmluaXR8fEFpKX1kZW9wdGltaXplUGF0aCh0KXt0aGlzLmlkLmRlb3B0aW1pemVQYXRoKHQpfWhhc0VmZmVjdHModCl7dmFyIHM7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpO2NvbnN0IGk9KHM9dGhpcy5pbml0KT09bnVsbD92b2lkIDA6cy5oYXNFZmZlY3RzKHQpO3JldHVybiB0aGlzLmlkLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKSxpfHx0aGlzLmlkLmhhc0VmZmVjdHModCl9aW5jbHVkZSh0LGkpe2NvbnN0e2Rlb3B0aW1pemVkOnMsaWQ6bixpbml0OnJ9PXRoaXM7c3x8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHRoaXMuaW5jbHVkZWQ9ITAscj09bnVsbHx8ci5pbmNsdWRlKHQsaSksbi5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCksKGl8fG4uc2hvdWxkQmVJbmNsdWRlZCh0KSkmJm4uaW5jbHVkZSh0LGkpfXJlbmRlcih0LGkpe2NvbnN0e2V4cG9ydE5hbWVzQnlWYXJpYWJsZTpzLHNuaXBwZXRzOntfOm4sZ2V0UHJvcGVydHlBY2Nlc3M6cn19PWkse2VuZDphLGlkOm8saW5pdDpoLHN0YXJ0Omx9PXRoaXMsYz1vLmluY2x1ZGVkO2lmKGMpby5yZW5kZXIodCxpKTtlbHNle2NvbnN0IHA9SWUodC5vcmlnaW5hbCwiPSIsby5lbmQpO3QucmVtb3ZlKGwsenQodC5vcmlnaW5hbCxwKzEpKX1oPyhvIGluc3RhbmNlb2YgY2UmJmggaW5zdGFuY2VvZiBDciYmIWguaWQmJm8udmFyaWFibGUuZ2V0TmFtZShyKSE9PW8ubmFtZSYmdC5hcHBlbmRMZWZ0KGguc3RhcnQrNSxgICR7by5uYW1lfWApLGgucmVuZGVyKHQsaSxjPyRlOntyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpZZX0pKTpvIGluc3RhbmNlb2YgY2UmJkloKG8udmFyaWFibGUscykmJnQuYXBwZW5kTGVmdChhLGAke259PSR7bn12b2lkIDBgKX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITA7Y29uc3R7aWQ6dCxpbml0Oml9PXRoaXM7aWYoaSYmdCBpbnN0YW5jZW9mIGNlJiZpIGluc3RhbmNlb2YgQ3ImJiFpLmlkKXtjb25zdHtuYW1lOnMsdmFyaWFibGU6bn09dDtmb3IoY29uc3QgciBvZiBpLnNjb3BlLmFjY2Vzc2VkT3V0c2lkZVZhcmlhYmxlcy52YWx1ZXMoKSlyIT09biYmci5mb3JiaWROYW1lKHMpfX19ZnVuY3Rpb24gX2goZSx0LGkpe3JldHVybiB0PT09ImV4dGVybmFsIj91c1tpKGUgaW5zdGFuY2VvZiBsZT9lLmlkOm51bGwpXTp0PT09ImRlZmF1bHQiP2xzOm51bGx9Y29uc3QgaWQ9e2FtZDpbInJlcXVpcmUiXSxjanM6WyJyZXF1aXJlIl0sc3lzdGVtOlsibW9kdWxlIl19O2Z1bmN0aW9uIE5oKGUpe2NvbnN0IHQ9W107Zm9yKGNvbnN0IGkgb2YgZS5wcm9wZXJ0aWVzKXtpZihpLnR5cGU9PT0iUmVzdEVsZW1lbnQifHxpLmNvbXB1dGVkfHxpLmtleS50eXBlIT09IklkZW50aWZpZXIiKXJldHVybjt0LnB1c2goaS5rZXkubmFtZSl9cmV0dXJuIHR9Y2xhc3MgJGggZXh0ZW5kcyBWe2FwcGx5RGVvcHRpbWl6YXRpb25zKCl7fX1jb25zdCBWcj0iUk9MTFVQX0ZJTEVfVVJMXyIsTXI9ImltcG9ydCIsTGg9WyJjanMiLCJpaWZlIiwidW1kIl0sc2Q9e2FtZDpbImRvY3VtZW50IiwibW9kdWxlIiwiVVJMIl0sY2pzOlsiZG9jdW1lbnQiLCJyZXF1aXJlIiwiVVJMIixVdF0sZXM6W10saWlmZTpbImRvY3VtZW50IiwiVVJMIixVdF0sc3lzdGVtOlsibW9kdWxlIl0sdW1kOlsiZG9jdW1lbnQiLCJyZXF1aXJlIiwiVVJMIixVdF19LG5kPXthbWQ6WyJkb2N1bWVudCIsInJlcXVpcmUiLCJVUkwiXSxjanM6WyJkb2N1bWVudCIsInJlcXVpcmUiLCJVUkwiXSxlczpbXSxpaWZlOlsiZG9jdW1lbnQiLCJVUkwiXSxzeXN0ZW06WyJtb2R1bGUiLCJVUkwiXSx1bWQ6WyJkb2N1bWVudCIsInJlcXVpcmUiLCJVUkwiXX0scHM9KGUsdD0iVVJMIik9PmBuZXcgJHt0fSgke2V9KS5ocmVmYCxEcj0oZSx0PSExKT0+cHMoYCckeyRzKGUpfScsICR7dD8idHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLmhyZWYgOiAiOiIifWRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMgfHwgZG9jdW1lbnQuYmFzZVVSSWApLGxuPWU9Pih0LHtjaHVua0lkOml9KT0+e2NvbnN0IHM9ZShpKTtyZXR1cm4gdD09PW51bGw/YCh7IHVybDogJHtzfSB9KWA6dD09PSJ1cmwiP3M6InVuZGVmaW5lZCJ9LEJyPWU9PmByZXF1aXJlKCd1JyArICdybCcpLnBhdGhUb0ZpbGVVUkwoJHtlfSkuaHJlZmAsVGg9ZT0+QnIoYF9fZGlybmFtZSArICcvJHtlfSdgKSxGcj0oZSx0PSExKT0+YCR7dD8idHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLmhyZWYgOiAiOiIifSgke1V0fSAmJiAke1V0fS5zcmMgfHwgbmV3IFVSTCgnJHskcyhlKX0nLCBkb2N1bWVudC5iYXNlVVJJKS5ocmVmKWAscmQ9e2FtZDplPT4oZVswXSE9PSIuIiYmKGU9Ii4vIitlKSxwcyhgcmVxdWlyZS50b1VybCgnJHtlfScpLCBkb2N1bWVudC5iYXNlVVJJYCkpLGNqczplPT5gKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyAke1RoKGUpfSA6ICR7RHIoZSl9KWAsZXM6ZT0+cHMoYCcke2V9JywgaW1wb3J0Lm1ldGEudXJsYCksaWlmZTplPT5EcihlKSxzeXN0ZW06ZT0+cHMoYCcke2V9JywgbW9kdWxlLm1ldGEudXJsYCksdW1kOmU9PmAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gJHtUaChlKX0gOiAke0RyKGUsITApfSlgfSx6cj17YW1kOmxuKCgpPT5wcygibW9kdWxlLnVyaSwgZG9jdW1lbnQuYmFzZVVSSSIpKSxjanM6bG4oZT0+YCh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gJHtCcigiX19maWxlbmFtZSIpfSA6ICR7RnIoZSl9KWApLGlpZmU6bG4oZT0+RnIoZSkpLHN5c3RlbTooZSx7c25pcHBldHM6e2dldFByb3BlcnR5QWNjZXNzOnR9fSk9PmU9PT1udWxsPyJtb2R1bGUubWV0YSI6YG1vZHVsZS5tZXRhJHt0KGUpfWAsdW1kOmxuKGU9PmAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbG9jYXRpb24gPT09ICd1bmRlZmluZWQnID8gJHtCcigiX19maWxlbmFtZSIpfSA6ICR7RnIoZSwhMCl9KWApfTtjbGFzcyBSaCBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuaGFzQ2FjaGVkRWZmZWN0PW51bGwsdGhpcy5oYXNMb2dnZWRFZmZlY3Q9ITF9aGFzQ2FjaGVkRWZmZWN0cygpe3JldHVybiEhdGhpcy5pbmNsdWRlZCYmKHRoaXMuaGFzQ2FjaGVkRWZmZWN0PT09bnVsbD90aGlzLmhhc0NhY2hlZEVmZmVjdD10aGlzLmhhc0VmZmVjdHMoenMoKSk6dGhpcy5oYXNDYWNoZWRFZmZlY3QpfWhhc0VmZmVjdHModCl7Zm9yKGNvbnN0IGkgb2YgdGhpcy5ib2R5KWlmKGkuaGFzRWZmZWN0cyh0KSl7aWYodGhpcy5jb250ZXh0Lm9wdGlvbnMuZXhwZXJpbWVudGFsTG9nU2lkZUVmZmVjdHMmJiF0aGlzLmhhc0xvZ2dlZEVmZmVjdCl7dGhpcy5oYXNMb2dnZWRFZmZlY3Q9ITA7Y29uc3R7Y29kZTpzLGxvZzpuLG1vZHVsZTpyfT10aGlzLmNvbnRleHQ7bihpaSxtcChzLHIuaWQsS24ocyxpLnN0YXJ0LHtvZmZzZXRMaW5lOjF9KSksaS5zdGFydCl9cmV0dXJuIHRoaXMuaGFzQ2FjaGVkRWZmZWN0PSEwfXJldHVybiExfWluY2x1ZGUodCxpKXt0aGlzLmluY2x1ZGVkPSEwO2Zvcihjb25zdCBzIG9mIHRoaXMuYm9keSkoaXx8cy5zaG91bGRCZUluY2x1ZGVkKHQpKSYmcy5pbmNsdWRlKHQsaSl9cmVuZGVyKHQsaSl7bGV0IHM9dGhpcy5zdGFydDtpZih0Lm9yaWdpbmFsLnN0YXJ0c1dpdGgoIiMhIikmJihzPU1hdGgubWluKHQub3JpZ2luYWwuaW5kZXhPZihgCmApKzEsdGhpcy5lbmQpLHQucmVtb3ZlKDAscykpLHRoaXMuYm9keS5sZW5ndGg+MCl7Zm9yKDt0Lm9yaWdpbmFsW3NdPT09Ii8iJiYvWyovXS8udGVzdCh0Lm9yaWdpbmFsW3MrMV0pOyl7Y29uc3Qgbj1ucyh0Lm9yaWdpbmFsLnNsaWNlKHMsdGhpcy5ib2R5WzBdLnN0YXJ0KSk7aWYoblswXT09PS0xKWJyZWFrO3MrPW5bMV19cnModGhpcy5ib2R5LHQscyx0aGlzLmVuZCxpKX1lbHNlIHN1cGVyLnJlbmRlcih0LGkpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7fX1jbGFzcyBPaCBleHRlbmRzIFZ7aGFzRWZmZWN0cyh0KXt2YXIgaTtpZigoaT10aGlzLnRlc3QpIT1udWxsJiZpLmhhc0VmZmVjdHModCkpcmV0dXJuITA7Zm9yKGNvbnN0IHMgb2YgdGhpcy5jb25zZXF1ZW50KXtpZih0LmJyb2tlbkZsb3cpYnJlYWs7aWYocy5oYXNFZmZlY3RzKHQpKXJldHVybiEwfXJldHVybiExfWluY2x1ZGUodCxpKXt2YXIgczt0aGlzLmluY2x1ZGVkPSEwLChzPXRoaXMudGVzdCk9PW51bGx8fHMuaW5jbHVkZSh0LGkpO2Zvcihjb25zdCBuIG9mIHRoaXMuY29uc2VxdWVudCkoaXx8bi5zaG91bGRCZUluY2x1ZGVkKHQpKSYmbi5pbmNsdWRlKHQsaSl9cmVuZGVyKHQsaSxzKXtpZih0aGlzLmNvbnNlcXVlbnQubGVuZ3RoPjApe3RoaXMudGVzdCYmdGhpcy50ZXN0LnJlbmRlcih0LGkpO2NvbnN0IG49dGhpcy50ZXN0P3RoaXMudGVzdC5lbmQ6SWUodC5vcmlnaW5hbCwiZGVmYXVsdCIsdGhpcy5zdGFydCkrNyxyPUllKHQub3JpZ2luYWwsIjoiLG4pKzE7cnModGhpcy5jb25zZXF1ZW50LHQscixzLmVuZCxpKX1lbHNlIHN1cGVyLnJlbmRlcih0LGkpfX1PaC5wcm90b3R5cGUubmVlZHNCb3VuZGFyaWVzPSEwO2NsYXNzIFZoIGV4dGVuZHMgVntkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCgpe31nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCl7cmV0dXJuIHQubGVuZ3RoPjB8fHRoaXMucXVhc2lzLmxlbmd0aCE9PTE/bWU6dGhpcy5xdWFzaXNbMF0udmFsdWUuY29va2VkfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKHQpe3JldHVybiB0Lmxlbmd0aCE9PTE/YmU6SmkoWGksdFswXSl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLHMpe3JldHVybiBpLnR5cGU9PT0wP3QubGVuZ3RoPjE6aS50eXBlIT09Mnx8dC5sZW5ndGghPT0xfHxaaShYaSx0WzBdLGkscyl9cmVuZGVyKHQsaSl7dC5pbmRlbnRFeGNsdXNpb25SYW5nZXMucHVzaChbdGhpcy5zdGFydCx0aGlzLmVuZF0pLHN1cGVyLnJlbmRlcih0LGkpfX1jbGFzcyBNaCBleHRlbmRzIHRpe2NvbnN0cnVjdG9yKCl7c3VwZXIoInVuZGVmaW5lZCIpfWdldExpdGVyYWxWYWx1ZUF0UGF0aCgpe319Y2xhc3MgZ3QgZXh0ZW5kcyBQdHtjb25zdHJ1Y3Rvcih0LGkscyl7c3VwZXIodCxpLGkuZGVjbGFyYXRpb24scyksdGhpcy5oYXNJZD0hMSx0aGlzLm9yaWdpbmFsSWQ9bnVsbCx0aGlzLm9yaWdpbmFsVmFyaWFibGU9bnVsbDtjb25zdCBuPWkuZGVjbGFyYXRpb247KG4gaW5zdGFuY2VvZiBoc3x8biBpbnN0YW5jZW9mIEpzKSYmbi5pZD8odGhpcy5oYXNJZD0hMCx0aGlzLm9yaWdpbmFsSWQ9bi5pZCk6biBpbnN0YW5jZW9mIGNlJiYodGhpcy5vcmlnaW5hbElkPW4pfWFkZFJlZmVyZW5jZSh0KXt0aGlzLmhhc0lkfHwodGhpcy5uYW1lPXQubmFtZSl9Zm9yYmlkTmFtZSh0KXtjb25zdCBpPXRoaXMuZ2V0T3JpZ2luYWxWYXJpYWJsZSgpO2k9PT10aGlzP3N1cGVyLmZvcmJpZE5hbWUodCk6aS5mb3JiaWROYW1lKHQpfWdldEFzc2lnbmVkVmFyaWFibGVOYW1lKCl7cmV0dXJuIHRoaXMub3JpZ2luYWxJZCYmdGhpcy5vcmlnaW5hbElkLm5hbWV8fG51bGx9Z2V0QmFzZVZhcmlhYmxlTmFtZSgpe2NvbnN0IHQ9dGhpcy5nZXRPcmlnaW5hbFZhcmlhYmxlKCk7cmV0dXJuIHQ9PT10aGlzP3N1cGVyLmdldEJhc2VWYXJpYWJsZU5hbWUoKTp0LmdldEJhc2VWYXJpYWJsZU5hbWUoKX1nZXREaXJlY3RPcmlnaW5hbFZhcmlhYmxlKCl7cmV0dXJuIXRoaXMub3JpZ2luYWxJZHx8IXRoaXMuaGFzSWQmJih0aGlzLm9yaWdpbmFsSWQuaXNQb3NzaWJsZVREWigpfHx0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUuaXNSZWFzc2lnbmVkfHx0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUgaW5zdGFuY2VvZiBNaHx8InN5bnRoZXRpY05hbWVzcGFjZSJpbiB0aGlzLm9yaWdpbmFsSWQudmFyaWFibGUpP251bGw6dGhpcy5vcmlnaW5hbElkLnZhcmlhYmxlfWdldE5hbWUodCl7Y29uc3QgaT10aGlzLmdldE9yaWdpbmFsVmFyaWFibGUoKTtyZXR1cm4gaT09PXRoaXM/c3VwZXIuZ2V0TmFtZSh0KTppLmdldE5hbWUodCl9Z2V0T3JpZ2luYWxWYXJpYWJsZSgpe2lmKHRoaXMub3JpZ2luYWxWYXJpYWJsZSlyZXR1cm4gdGhpcy5vcmlnaW5hbFZhcmlhYmxlO2xldCB0LGk9dGhpcztjb25zdCBzPW5ldyBTZXQ7ZG8gcy5hZGQoaSksdD1pLGk9dC5nZXREaXJlY3RPcmlnaW5hbFZhcmlhYmxlKCk7d2hpbGUoaSBpbnN0YW5jZW9mIGd0JiYhcy5oYXMoaSkpO3JldHVybiB0aGlzLm9yaWdpbmFsVmFyaWFibGU9aXx8dH19Y2xhc3MgRGggZXh0ZW5kcyBsdHtjb25zdHJ1Y3Rvcih0LGkpe3N1cGVyKHQpLHRoaXMuY29udGV4dD1pLHRoaXMudmFyaWFibGVzLnNldCgidGhpcyIsbmV3IFB0KCJ0aGlzIixudWxsLEFpLGkpKX1hZGRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24odCxpLHMpe2NvbnN0IG49bmV3IGd0KHQsaSxzKTtyZXR1cm4gdGhpcy52YXJpYWJsZXMuc2V0KCJkZWZhdWx0IixuKSxufWFkZE5hbWVzcGFjZU1lbWJlckFjY2Vzcygpe31kZWNvbmZsaWN0KHQsaSxzKXtmb3IoY29uc3QgbiBvZiB0aGlzLmNoaWxkcmVuKW4uZGVjb25mbGljdCh0LGkscyl9ZmluZExleGljYWxCb3VuZGFyeSgpe3JldHVybiB0aGlzfWZpbmRWYXJpYWJsZSh0KXtjb25zdCBpPXRoaXMudmFyaWFibGVzLmdldCh0KXx8dGhpcy5hY2Nlc3NlZE91dHNpZGVWYXJpYWJsZXMuZ2V0KHQpO2lmKGkpcmV0dXJuIGk7Y29uc3Qgcz10aGlzLmNvbnRleHQudHJhY2VWYXJpYWJsZSh0KXx8dGhpcy5wYXJlbnQuZmluZFZhcmlhYmxlKHQpO3JldHVybiBzIGluc3RhbmNlb2YgeHImJnRoaXMuYWNjZXNzZWRPdXRzaWRlVmFyaWFibGVzLnNldCh0LHMpLHN9fWNvbnN0IGFkPXsiISI6ZT0+IWUsIisiOmU9PitlLCItIjplPT4tZSxkZWxldGU6KCk9Pm1lLHR5cGVvZjplPT50eXBlb2YgZSx2b2lkOigpPT57fSwifiI6ZT0+fmV9O2NsYXNzIEJoIGV4dGVuZHMgVntkZW9wdGltaXplUGF0aCgpe2Zvcihjb25zdCB0IG9mIHRoaXMuZGVjbGFyYXRpb25zKXQuZGVvcHRpbWl6ZVBhdGgoUSl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoKXtyZXR1cm4hMX1pbmNsdWRlKHQsaSx7YXNTaW5nbGVTdGF0ZW1lbnQ6c309JGUpe3RoaXMuaW5jbHVkZWQ9ITA7Zm9yKGNvbnN0IG4gb2YgdGhpcy5kZWNsYXJhdGlvbnMpeyhpfHxuLnNob3VsZEJlSW5jbHVkZWQodCkpJiZuLmluY2x1ZGUodCxpKTtjb25zdHtpZDpyLGluaXQ6YX09bjtzJiZyLmluY2x1ZGUodCxpKSxhJiZyLmluY2x1ZGVkJiYhYS5pbmNsdWRlZCYmKHIgaW5zdGFuY2VvZiBhc3x8ciBpbnN0YW5jZW9mIEdvKSYmYS5pbmNsdWRlKHQsaSl9fWluaXRpYWxpc2UoKXtmb3IoY29uc3QgdCBvZiB0aGlzLmRlY2xhcmF0aW9ucyl0LmRlY2xhcmVEZWNsYXJhdG9yKHRoaXMua2luZCl9cmVuZGVyKHQsaSxzPSRlKXtpZihmdW5jdGlvbihuLHIpe2Zvcihjb25zdCBhIG9mIG4pe2lmKCFhLmlkLmluY2x1ZGVkKXJldHVybiExO2lmKGEuaWQudHlwZT09PU5vKXtpZihyLmhhcyhhLmlkLnZhcmlhYmxlKSlyZXR1cm4hMX1lbHNle2NvbnN0IG89W107aWYoYS5pZC5hZGRFeHBvcnRlZFZhcmlhYmxlcyhvLHIpLG8ubGVuZ3RoPjApcmV0dXJuITF9fXJldHVybiEwfSh0aGlzLmRlY2xhcmF0aW9ucyxpLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSkpe2Zvcihjb25zdCBuIG9mIHRoaXMuZGVjbGFyYXRpb25zKW4ucmVuZGVyKHQsaSk7cy5pc05vU3RhdGVtZW50fHx0Lm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQtMSk9PT01OXx8dC5hcHBlbmRMZWZ0KHRoaXMuZW5kLCI7Iil9ZWxzZSB0aGlzLnJlbmRlclJlcGxhY2VkRGVjbGFyYXRpb25zKHQsaSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9cmVuZGVyRGVjbGFyYXRpb25FbmQodCxpLHMsbixyLGEsbyl7dC5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kLTEpPT09NTkmJnQucmVtb3ZlKHRoaXMuZW5kLTEsdGhpcy5lbmQpLGkrPSI7IixzPT09bnVsbD90LmFwcGVuZExlZnQocixpKToodC5vcmlnaW5hbC5jaGFyQ29kZUF0KG4tMSkhPT0xMHx8dC5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMuZW5kKSE9PTEwJiZ0Lm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQpIT09MTN8fChuLS0sdC5vcmlnaW5hbC5jaGFyQ29kZUF0KG4pPT09MTMmJm4tLSksbj09PXMrMT90Lm92ZXJ3cml0ZShzLHIsaSk6KHQub3ZlcndyaXRlKHMscysxLGkpLHQucmVtb3ZlKG4scikpKSxhLmxlbmd0aD4wJiZ0LmFwcGVuZExlZnQocixgICR7dWkoYSxvKX07YCl9cmVuZGVyUmVwbGFjZWREZWNsYXJhdGlvbnModCxpKXtjb25zdCBzPW5oKHRoaXMuZGVjbGFyYXRpb25zLHQsdGhpcy5zdGFydCt0aGlzLmtpbmQubGVuZ3RoLHRoaXMuZW5kLSh0Lm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5lbmQtMSk9PT01OT8xOjApKTtsZXQgbixyO3I9enQodC5vcmlnaW5hbCx0aGlzLnN0YXJ0K3RoaXMua2luZC5sZW5ndGgpO2xldCBhPXItMTt0LnJlbW92ZSh0aGlzLnN0YXJ0LGEpO2xldCBvLGg9ITEsbD0hMSxjPSIiO2NvbnN0IHA9W10sbT1mdW5jdGlvbih5LEUsZyl7dmFyIHY7bGV0IHg9bnVsbDtpZihFLmZvcm1hdD09PSJzeXN0ZW0iKXtmb3IoY29uc3R7bm9kZTp3fW9mIHkpdy5pZCBpbnN0YW5jZW9mIGNlJiZ3LmluaXQmJmcubGVuZ3RoPT09MCYmKCh2PUUuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldCh3LmlkLnZhcmlhYmxlKSk9PW51bGw/dm9pZCAwOnYubGVuZ3RoKT09PTE/KHg9dy5pZC52YXJpYWJsZSxnLnB1c2goeCkpOncuaWQuYWRkRXhwb3J0ZWRWYXJpYWJsZXMoZyxFLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSk7Zy5sZW5ndGg+MT94PW51bGw6eCYmKGcubGVuZ3RoPTApfXJldHVybiB4fShzLGkscCk7Zm9yKGNvbnN0e25vZGU6eSxzdGFydDpFLHNlcGFyYXRvcjpnLGNvbnRlbnRFbmQ6eCxlbmQ6dn1vZiBzKWlmKHkuaW5jbHVkZWQpe2lmKHkucmVuZGVyKHQsaSksbz0iIiwheS5pZC5pbmNsdWRlZHx8eS5pZCBpbnN0YW5jZW9mIGNlJiZJaCh5LmlkLnZhcmlhYmxlLGkuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSlsJiYoYys9IjsiKSxoPSExO2Vsc2V7aWYobSYmbT09PXkuaWQudmFyaWFibGUpe2NvbnN0IHc9SWUodC5vcmlnaW5hbCwiPSIseS5pZC5lbmQpO2tyKG0senQodC5vcmlnaW5hbCx3KzEpLGc9PT1udWxsP3g6Zyx0LGkpfWg/Yys9IiwiOihsJiYoYys9IjsiKSxvKz1gJHt0aGlzLmtpbmR9IGAsaD0hMCl9cj09PWErMT90Lm92ZXJ3cml0ZShhLHIsYytvKToodC5vdmVyd3JpdGUoYSxhKzEsYyksdC5hcHBlbmRMZWZ0KHIsbykpLG49eCxyPXYsbD0hMCxhPWcsYz0iIn1lbHNlIHQucmVtb3ZlKEUsdik7dGhpcy5yZW5kZXJEZWNsYXJhdGlvbkVuZCh0LGMsYSxuLHIscCxpKX19Y29uc3QgRmg9e0FycmF5RXhwcmVzc2lvbjpVbyxBcnJheVBhdHRlcm46R28sQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246U3IsQXNzaWdubWVudEV4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7Y29uc3R7ZGVvcHRpbWl6ZWQ6dCxsZWZ0Omksb3BlcmF0b3I6cyxyaWdodDpufT10aGlzO3JldHVybiB0fHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCksbi5oYXNFZmZlY3RzKGUpfHxpLmhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoZSxzIT09Ij0iKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7cmV0dXJuIHRoaXMucmlnaHQuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfWluY2x1ZGUoZSx0KXtjb25zdHtkZW9wdGltaXplZDppLGxlZnQ6cyxyaWdodDpuLG9wZXJhdG9yOnJ9PXRoaXM7aXx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHRoaXMuaW5jbHVkZWQ9ITAsKHR8fHIhPT0iPSJ8fHMuaW5jbHVkZWR8fHMuaGFzRWZmZWN0c0FzQXNzaWdubWVudFRhcmdldCh6cygpLCExKSkmJnMuaW5jbHVkZUFzQXNzaWdubWVudFRhcmdldChlLHQsciE9PSI9Iiksbi5pbmNsdWRlKGUsdCl9aW5pdGlhbGlzZSgpe3RoaXMubGVmdC5zZXRBc3NpZ25lZFZhbHVlKHRoaXMucmlnaHQpfXJlbmRlcihlLHQse3ByZXZlbnRBU0k6aSxyZW5kZXJlZFBhcmVudFR5cGU6cyxyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpufT0kZSl7Y29uc3R7bGVmdDpyLHJpZ2h0OmEsc3RhcnQ6byxlbmQ6aCxwYXJlbnQ6bH09dGhpcztpZihyLmluY2x1ZGVkKXIucmVuZGVyKGUsdCksYS5yZW5kZXIoZSx0KTtlbHNle2NvbnN0IGM9enQoZS5vcmlnaW5hbCxJZShlLm9yaWdpbmFsLCI9IixyLmVuZCkrMSk7ZS5yZW1vdmUobyxjKSxpJiZYcyhlLGMsYS5zdGFydCksYS5yZW5kZXIoZSx0LHtyZW5kZXJlZFBhcmVudFR5cGU6c3x8bC50eXBlLHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50Om58fGwudHlwZX0pfWlmKHQuZm9ybWF0PT09InN5c3RlbSIpaWYociBpbnN0YW5jZW9mIGNlKXtjb25zdCBjPXIudmFyaWFibGUscD10LmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQoYyk7aWYocClyZXR1cm4gdm9pZChwLmxlbmd0aD09PTE/a3IoYyxvLGgsZSx0KTpyaChjLG8saCxsLnR5cGUhPT1ZZSxlLHQpKX1lbHNle2NvbnN0IGM9W107aWYoci5hZGRFeHBvcnRlZFZhcmlhYmxlcyhjLHQuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSxjLmxlbmd0aD4wKXJldHVybiB2b2lkIGZ1bmN0aW9uKHAsbSx5LEUsZyx4KXtjb25zdHtfOnYsZ2V0RGlyZWN0UmV0dXJuSWlmZUxlZnQ6d309eC5zbmlwcGV0cztnLnByZXBlbmRSaWdodChtLHcoWyJ2Il0sYCR7dWkocCx4KX0sJHt2fXZgLHtuZWVkc0Fycm93UmV0dXJuUGFyZW5zOiEwLG5lZWRzV3JhcHBlZEZ1bmN0aW9uOkV9KSksZy5hcHBlbmRMZWZ0KHksIikiKX0oYyxvLGgsbj09PVllLGUsdCl9ci5pbmNsdWRlZCYmciBpbnN0YW5jZW9mIGFzJiYobj09PVllfHxuPT09aHIpJiYoZS5hcHBlbmRSaWdodChvLCIoIiksZS5wcmVwZW5kTGVmdChoLCIpIikpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLmxlZnQuZGVvcHRpbWl6ZVBhdGgoUSksdGhpcy5yaWdodC5kZW9wdGltaXplUGF0aCh0ZSksdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKX19LEFzc2lnbm1lbnRQYXR0ZXJuOmNsYXNzIGV4dGVuZHMgVnthZGRFeHBvcnRlZFZhcmlhYmxlcyhlLHQpe3RoaXMubGVmdC5hZGRFeHBvcnRlZFZhcmlhYmxlcyhlLHQpfWRlY2xhcmUoZSx0KXtyZXR1cm4gdGhpcy5sZWZ0LmRlY2xhcmUoZSx0KX1kZW9wdGltaXplUGF0aChlKXtlLmxlbmd0aD09PTAmJnRoaXMubGVmdC5kZW9wdGltaXplUGF0aChlKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7cmV0dXJuIGUubGVuZ3RoPjB8fHRoaXMubGVmdC5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChRLHQsaSl9bWFya0RlY2xhcmF0aW9uUmVhY2hlZCgpe3RoaXMubGVmdC5tYXJrRGVjbGFyYXRpb25SZWFjaGVkKCl9cmVuZGVyKGUsdCx7aXNTaG9ydGhhbmRQcm9wZXJ0eTppfT0kZSl7dGhpcy5sZWZ0LnJlbmRlcihlLHQse2lzU2hvcnRoYW5kUHJvcGVydHk6aX0pLHRoaXMucmlnaHQucmVuZGVyKGUsdCl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt0aGlzLmRlb3B0aW1pemVkPSEwLHRoaXMubGVmdC5kZW9wdGltaXplUGF0aChRKSx0aGlzLnJpZ2h0LmRlb3B0aW1pemVQYXRoKHRlKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpfX0sQXdhaXRFeHByZXNzaW9uOm9oLEJpbmFyeUV4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2Rlb3B0aW1pemVDYWNoZSgpe31nZXRMaXRlcmFsVmFsdWVBdFBhdGgoZSx0LGkpe2lmKGUubGVuZ3RoPjApcmV0dXJuIG1lO2NvbnN0IHM9dGhpcy5sZWZ0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChRLHQsaSk7aWYodHlwZW9mIHM9PSJzeW1ib2wiKXJldHVybiBtZTtjb25zdCBuPXRoaXMucmlnaHQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFEsdCxpKTtpZih0eXBlb2Ygbj09InN5bWJvbCIpcmV0dXJuIG1lO2NvbnN0IHI9cXBbdGhpcy5vcGVyYXRvcl07cmV0dXJuIHI/cihzLG4pOm1lfWhhc0VmZmVjdHMoZSl7cmV0dXJuIHRoaXMub3BlcmF0b3I9PT0iKyImJnRoaXMucGFyZW50IGluc3RhbmNlb2YgbGkmJnRoaXMubGVmdC5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoUSxBZSx0aGlzKT09PSIifHxzdXBlci5oYXNFZmZlY3RzKGUpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUse3R5cGU6dH0pe3JldHVybiB0IT09MHx8ZS5sZW5ndGg+MX1yZW5kZXIoZSx0LHtyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDppfT0kZSl7dGhpcy5sZWZ0LnJlbmRlcihlLHQse3JlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50Oml9KSx0aGlzLnJpZ2h0LnJlbmRlcihlLHQpfX0sQmxvY2tTdGF0ZW1lbnQ6WnMsQnJlYWtTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7aWYodGhpcy5sYWJlbCl7aWYoIWUuaWdub3JlLmxhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSlyZXR1cm4hMDtlLmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpfWVsc2V7aWYoIWUuaWdub3JlLmJyZWFrcylyZXR1cm4hMDtlLmhhc0JyZWFrPSEwfXJldHVybiBlLmJyb2tlbkZsb3c9ITAsITF9aW5jbHVkZShlKXt0aGlzLmluY2x1ZGVkPSEwLHRoaXMubGFiZWw/KHRoaXMubGFiZWwuaW5jbHVkZSgpLGUuaW5jbHVkZWRMYWJlbHMuYWRkKHRoaXMubGFiZWwubmFtZSkpOmUuaGFzQnJlYWs9ITAsZS5icm9rZW5GbG93PSEwfX0sQ2FsbEV4cHJlc3Npb246cGgsQ2F0Y2hDbGF1c2U6Y2xhc3MgZXh0ZW5kcyBWe2NyZWF0ZVNjb3BlKGUpe3RoaXMuc2NvcGU9bmV3IEtwKGUsdGhpcy5jb250ZXh0KX1wYXJzZU5vZGUoZSl7Y29uc3R7cGFyYW06dH09ZTt0JiYodGhpcy5wYXJhbT1uZXcodGhpcy5jb250ZXh0LmdldE5vZGVDb25zdHJ1Y3Rvcih0LnR5cGUpKSh0LHRoaXMsdGhpcy5zY29wZSksdGhpcy5wYXJhbS5kZWNsYXJlKCJwYXJhbWV0ZXIiLFkpKSxzdXBlci5wYXJzZU5vZGUoZSl9fSxDaGFpbkV4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2Rlb3B0aW1pemVDYWNoZSgpe31nZXRMaXRlcmFsVmFsdWVBdFBhdGgoZSx0LGkpe2lmKCF0aGlzLmV4cHJlc3Npb24uaXNTa2lwcGVkQXNPcHRpb25hbChpKSlyZXR1cm4gdGhpcy5leHByZXNzaW9uLmdldExpdGVyYWxWYWx1ZUF0UGF0aChlLHQsaSl9aGFzRWZmZWN0cyhlKXtyZXR1cm4hdGhpcy5leHByZXNzaW9uLmlzU2tpcHBlZEFzT3B0aW9uYWwodGhpcykmJnRoaXMuZXhwcmVzc2lvbi5oYXNFZmZlY3RzKGUpfX0sQ2xhc3NCb2R5OmNsYXNzIGV4dGVuZHMgVntjcmVhdGVTY29wZShlKXt0aGlzLnNjb3BlPW5ldyBRcChlLHRoaXMucGFyZW50LHRoaXMuY29udGV4dCl9aW5jbHVkZShlLHQpe3RoaXMuaW5jbHVkZWQ9ITAsdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMuc2NvcGUudGhpc1ZhcmlhYmxlKTtmb3IoY29uc3QgaSBvZiB0aGlzLmJvZHkpaS5pbmNsdWRlKGUsdCl9cGFyc2VOb2RlKGUpe2NvbnN0IHQ9dGhpcy5ib2R5PVtdO2Zvcihjb25zdCBpIG9mIGUuYm9keSl0LnB1c2gobmV3KHRoaXMuY29udGV4dC5nZXROb2RlQ29uc3RydWN0b3IoaS50eXBlKSkoaSx0aGlzLGkuc3RhdGljP3RoaXMuc2NvcGU6dGhpcy5zY29wZS5pbnN0YW5jZVNjb3BlKSk7c3VwZXIucGFyc2VOb2RlKGUpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7fX0sQ2xhc3NEZWNsYXJhdGlvbjpKcyxDbGFzc0V4cHJlc3Npb246Q3IsQ29uZGl0aW9uYWxFeHByZXNzaW9uOmNsYXNzIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZD1bXSx0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkPSExLHRoaXMudXNlZEJyYW5jaD1udWxsfWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXt0aGlzLmNvbnNlcXVlbnQuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpLHRoaXMuYWx0ZXJuYXRlLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKX1kZW9wdGltaXplQ2FjaGUoKXtpZih0aGlzLnVzZWRCcmFuY2ghPT1udWxsKXtjb25zdCBlPXRoaXMudXNlZEJyYW5jaD09PXRoaXMuY29uc2VxdWVudD90aGlzLmFsdGVybmF0ZTp0aGlzLmNvbnNlcXVlbnQ7dGhpcy51c2VkQnJhbmNoPW51bGwsZS5kZW9wdGltaXplUGF0aCh0ZSk7Y29uc3R7ZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ6dH09dGhpczt0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkPXZlO2Zvcihjb25zdCBpIG9mIHQpaS5kZW9wdGltaXplQ2FjaGUoKX19ZGVvcHRpbWl6ZVBhdGgoZSl7Y29uc3QgdD10aGlzLmdldFVzZWRCcmFuY2goKTt0P3QuZGVvcHRpbWl6ZVBhdGgoZSk6KHRoaXMuY29uc2VxdWVudC5kZW9wdGltaXplUGF0aChlKSx0aGlzLmFsdGVybmF0ZS5kZW9wdGltaXplUGF0aChlKSl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUsdCxpKXtjb25zdCBzPXRoaXMuZ2V0VXNlZEJyYW5jaCgpO3JldHVybiBzPyh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2goaSkscy5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoZSx0LGkpKTptZX1nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlLHQsaSxzKXtjb25zdCBuPXRoaXMuZ2V0VXNlZEJyYW5jaCgpO3JldHVybiBuPyh0aGlzLmV4cHJlc3Npb25zVG9CZURlb3B0aW1pemVkLnB1c2gocyksbi5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlLHQsaSxzKSk6W25ldyBlbihbdGhpcy5jb25zZXF1ZW50LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpWzBdLHRoaXMuYWx0ZXJuYXRlLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpWzBdXSksITFdfWhhc0VmZmVjdHMoZSl7aWYodGhpcy50ZXN0Lmhhc0VmZmVjdHMoZSkpcmV0dXJuITA7Y29uc3QgdD10aGlzLmdldFVzZWRCcmFuY2goKTtyZXR1cm4gdD90Lmhhc0VmZmVjdHMoZSk6dGhpcy5jb25zZXF1ZW50Lmhhc0VmZmVjdHMoZSl8fHRoaXMuYWx0ZXJuYXRlLmhhc0VmZmVjdHMoZSl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpe2NvbnN0IHM9dGhpcy5nZXRVc2VkQnJhbmNoKCk7cmV0dXJuIHM/cy5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSk6dGhpcy5jb25zZXF1ZW50Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXx8dGhpcy5hbHRlcm5hdGUuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfWluY2x1ZGUoZSx0KXt0aGlzLmluY2x1ZGVkPSEwO2NvbnN0IGk9dGhpcy5nZXRVc2VkQnJhbmNoKCk7dHx8dGhpcy50ZXN0LnNob3VsZEJlSW5jbHVkZWQoZSl8fGk9PT1udWxsPyh0aGlzLnRlc3QuaW5jbHVkZShlLHQpLHRoaXMuY29uc2VxdWVudC5pbmNsdWRlKGUsdCksdGhpcy5hbHRlcm5hdGUuaW5jbHVkZShlLHQpKTppLmluY2x1ZGUoZSx0KX1pbmNsdWRlQ2FsbEFyZ3VtZW50cyhlLHQpe2NvbnN0IGk9dGhpcy5nZXRVc2VkQnJhbmNoKCk7aT9pLmluY2x1ZGVDYWxsQXJndW1lbnRzKGUsdCk6KHRoaXMuY29uc2VxdWVudC5pbmNsdWRlQ2FsbEFyZ3VtZW50cyhlLHQpLHRoaXMuYWx0ZXJuYXRlLmluY2x1ZGVDYWxsQXJndW1lbnRzKGUsdCkpfXJlbmRlcihlLHQse2lzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDppLHByZXZlbnRBU0k6cyxyZW5kZXJlZFBhcmVudFR5cGU6bixyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpyfT0kZSl7Y29uc3QgYT10aGlzLmdldFVzZWRCcmFuY2goKTtpZih0aGlzLnRlc3QuaW5jbHVkZWQpdGhpcy50ZXN0LnJlbmRlcihlLHQse3JlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OnJ9KSx0aGlzLmNvbnNlcXVlbnQucmVuZGVyKGUsdCksdGhpcy5hbHRlcm5hdGUucmVuZGVyKGUsdCk7ZWxzZXtjb25zdCBvPUllKGUub3JpZ2luYWwsIjoiLHRoaXMuY29uc2VxdWVudC5lbmQpLGg9enQoZS5vcmlnaW5hbCwodGhpcy5jb25zZXF1ZW50LmluY2x1ZGVkP0llKGUub3JpZ2luYWwsIj8iLHRoaXMudGVzdC5lbmQpOm8pKzEpO3MmJlhzKGUsaCxhLnN0YXJ0KSxlLnJlbW92ZSh0aGlzLnN0YXJ0LGgpLHRoaXMuY29uc2VxdWVudC5pbmNsdWRlZCYmZS5yZW1vdmUobyx0aGlzLmVuZCksaWgodGhpcyxlKSxhLnJlbmRlcihlLHQse2lzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDppLHByZXZlbnRBU0k6ITAscmVuZGVyZWRQYXJlbnRUeXBlOm58fHRoaXMucGFyZW50LnR5cGUscmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6cnx8dGhpcy5wYXJlbnQudHlwZX0pfX1nZXRVc2VkQnJhbmNoKCl7aWYodGhpcy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZClyZXR1cm4gdGhpcy51c2VkQnJhbmNoO3RoaXMuaXNCcmFuY2hSZXNvbHV0aW9uQW5hbHlzZWQ9ITA7Y29uc3QgZT10aGlzLnRlc3QuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFEsQWUsdGhpcyk7cmV0dXJuIHR5cGVvZiBlPT0ic3ltYm9sIj9udWxsOnRoaXMudXNlZEJyYW5jaD1lP3RoaXMuY29uc2VxdWVudDp0aGlzLmFsdGVybmF0ZX19LENvbnRpbnVlU3RhdGVtZW50OmNsYXNzIGV4dGVuZHMgVntoYXNFZmZlY3RzKGUpe2lmKHRoaXMubGFiZWwpe2lmKCFlLmlnbm9yZS5sYWJlbHMuaGFzKHRoaXMubGFiZWwubmFtZSkpcmV0dXJuITA7ZS5pbmNsdWRlZExhYmVscy5hZGQodGhpcy5sYWJlbC5uYW1lKX1lbHNle2lmKCFlLmlnbm9yZS5jb250aW51ZXMpcmV0dXJuITA7ZS5oYXNDb250aW51ZT0hMH1yZXR1cm4gZS5icm9rZW5GbG93PSEwLCExfWluY2x1ZGUoZSl7dGhpcy5pbmNsdWRlZD0hMCx0aGlzLmxhYmVsPyh0aGlzLmxhYmVsLmluY2x1ZGUoKSxlLmluY2x1ZGVkTGFiZWxzLmFkZCh0aGlzLmxhYmVsLm5hbWUpKTplLmhhc0NvbnRpbnVlPSEwLGUuYnJva2VuRmxvdz0hMH19LERvV2hpbGVTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7cmV0dXJuISF0aGlzLnRlc3QuaGFzRWZmZWN0cyhlKXx8dG4oZSx0aGlzLmJvZHkpfWluY2x1ZGUoZSx0KXt0aGlzLmluY2x1ZGVkPSEwLHRoaXMudGVzdC5pbmNsdWRlKGUsdCksb3MoZSx0aGlzLmJvZHksdCl9fSxFbXB0eVN0YXRlbWVudDpjbGFzcyBleHRlbmRzIFZ7aGFzRWZmZWN0cygpe3JldHVybiExfX0sRXhwb3J0QWxsRGVjbGFyYXRpb246SXIsRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uOnNuLEV4cG9ydE5hbWVkRGVjbGFyYXRpb246bWgsRXhwb3J0U3BlY2lmaWVyOmNsYXNzIGV4dGVuZHMgVnthcHBseURlb3B0aW1pemF0aW9ucygpe319LEV4cHJlc3Npb25TdGF0ZW1lbnQ6bGksRm9ySW5TdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2NyZWF0ZVNjb3BlKGUpe3RoaXMuc2NvcGU9bmV3IGhpKGUpfWhhc0VmZmVjdHMoZSl7Y29uc3R7Ym9keTp0LGRlb3B0aW1pemVkOmksbGVmdDpzLHJpZ2h0Om59PXRoaXM7cmV0dXJuIGl8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSwhKCFzLmhhc0VmZmVjdHNBc0Fzc2lnbm1lbnRUYXJnZXQoZSwhMSkmJiFuLmhhc0VmZmVjdHMoZSkpfHx0bihlLHQpfWluY2x1ZGUoZSx0KXtjb25zdHtib2R5OmksZGVvcHRpbWl6ZWQ6cyxsZWZ0Om4scmlnaHQ6cn09dGhpcztzfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCksdGhpcy5pbmNsdWRlZD0hMCxuLmluY2x1ZGVBc0Fzc2lnbm1lbnRUYXJnZXQoZSx0fHwhMCwhMSksci5pbmNsdWRlKGUsdCksb3MoZSxpLHQpfWluaXRpYWxpc2UoKXt0aGlzLmxlZnQuc2V0QXNzaWduZWRWYWx1ZShZKX1yZW5kZXIoZSx0KXt0aGlzLmxlZnQucmVuZGVyKGUsdCxvaSksdGhpcy5yaWdodC5yZW5kZXIoZSx0LG9pKSxlLm9yaWdpbmFsLmNoYXJDb2RlQXQodGhpcy5yaWdodC5zdGFydC0xKT09PTExMCYmZS5wcmVwZW5kTGVmdCh0aGlzLnJpZ2h0LnN0YXJ0LCIgIiksdGhpcy5ib2R5LnJlbmRlcihlLHQpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLmxlZnQuZGVvcHRpbWl6ZVBhdGgoUSksdGhpcy5jb250ZXh0LnJlcXVlc3RUcmVlc2hha2luZ1Bhc3MoKX19LEZvck9mU3RhdGVtZW50OmNsYXNzIGV4dGVuZHMgVntjcmVhdGVTY29wZShlKXt0aGlzLnNjb3BlPW5ldyBoaShlKX1oYXNFZmZlY3RzKCl7cmV0dXJuIHRoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSwhMH1pbmNsdWRlKGUsdCl7Y29uc3R7Ym9keTppLGRlb3B0aW1pemVkOnMsbGVmdDpuLHJpZ2h0OnJ9PXRoaXM7c3x8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHRoaXMuaW5jbHVkZWQ9ITAsbi5pbmNsdWRlQXNBc3NpZ25tZW50VGFyZ2V0KGUsdHx8ITAsITEpLHIuaW5jbHVkZShlLHQpLG9zKGUsaSx0KX1pbml0aWFsaXNlKCl7dGhpcy5sZWZ0LnNldEFzc2lnbmVkVmFsdWUoWSl9cmVuZGVyKGUsdCl7dGhpcy5sZWZ0LnJlbmRlcihlLHQsb2kpLHRoaXMucmlnaHQucmVuZGVyKGUsdCxvaSksZS5vcmlnaW5hbC5jaGFyQ29kZUF0KHRoaXMucmlnaHQuc3RhcnQtMSk9PT0xMDImJmUucHJlcGVuZExlZnQodGhpcy5yaWdodC5zdGFydCwiICIpLHRoaXMuYm9keS5yZW5kZXIoZSx0KX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITAsdGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKFEpLHRoaXMucmlnaHQuZGVvcHRpbWl6ZVBhdGgodGUpLHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCl9fSxGb3JTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2NyZWF0ZVNjb3BlKGUpe3RoaXMuc2NvcGU9bmV3IGhpKGUpfWhhc0VmZmVjdHMoZSl7dmFyIHQsaSxzO3JldHVybiEhKCh0PXRoaXMuaW5pdCkhPW51bGwmJnQuaGFzRWZmZWN0cyhlKXx8KGk9dGhpcy50ZXN0KSE9bnVsbCYmaS5oYXNFZmZlY3RzKGUpfHwocz10aGlzLnVwZGF0ZSkhPW51bGwmJnMuaGFzRWZmZWN0cyhlKSl8fHRuKGUsdGhpcy5ib2R5KX1pbmNsdWRlKGUsdCl7dmFyIGkscyxuO3RoaXMuaW5jbHVkZWQ9ITAsKGk9dGhpcy5pbml0KT09bnVsbHx8aS5pbmNsdWRlKGUsdCx7YXNTaW5nbGVTdGF0ZW1lbnQ6ITB9KSwocz10aGlzLnRlc3QpPT1udWxsfHxzLmluY2x1ZGUoZSx0KSwobj10aGlzLnVwZGF0ZSk9PW51bGx8fG4uaW5jbHVkZShlLHQpLG9zKGUsdGhpcy5ib2R5LHQpfXJlbmRlcihlLHQpe3ZhciBpLHMsbjsoaT10aGlzLmluaXQpPT1udWxsfHxpLnJlbmRlcihlLHQsb2kpLChzPXRoaXMudGVzdCk9PW51bGx8fHMucmVuZGVyKGUsdCxvaSksKG49dGhpcy51cGRhdGUpPT1udWxsfHxuLnJlbmRlcihlLHQsb2kpLHRoaXMuYm9keS5yZW5kZXIoZSx0KX19LEZ1bmN0aW9uRGVjbGFyYXRpb246aHMsRnVuY3Rpb25FeHByZXNzaW9uOmdoLElkZW50aWZpZXI6Y2UsSWZTdGF0ZW1lbnQ6UHIsSW1wb3J0QXR0cmlidXRlOmNsYXNzIGV4dGVuZHMgVnt9LEltcG9ydERlY2xhcmF0aW9uOmJoLEltcG9ydERlZmF1bHRTcGVjaWZpZXI6dmgsSW1wb3J0RXhwcmVzc2lvbjpjbGFzcyBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuaW5saW5lTmFtZXNwYWNlPW51bGwsdGhpcy5hc3NlcnRpb25zPW51bGwsdGhpcy5tZWNoYW5pc209bnVsbCx0aGlzLm5hbWVzcGFjZUV4cG9ydE5hbWU9dm9pZCAwLHRoaXMucmVzb2x1dGlvbj1udWxsLHRoaXMucmVzb2x1dGlvblN0cmluZz1udWxsfWJpbmQoKXt0aGlzLnNvdXJjZS5iaW5kKCl9Z2V0RGV0ZXJtaW5pc3RpY0ltcG9ydGVkTmFtZXMoKXtjb25zdCBlPXRoaXMucGFyZW50O2lmKGUgaW5zdGFuY2VvZiBsaSlyZXR1cm4gdmU7aWYoZSBpbnN0YW5jZW9mIG9oKXtjb25zdCB0PWUucGFyZW50O2lmKHQgaW5zdGFuY2VvZiBsaSlyZXR1cm4gdmU7aWYodCBpbnN0YW5jZW9mIFBoKXtjb25zdCBpPXQuaWQ7cmV0dXJuIGkgaW5zdGFuY2VvZiBhcz9OaChpKTp2b2lkIDB9aWYodCBpbnN0YW5jZW9mIGp0KXtjb25zdCBpPXQucHJvcGVydHk7aWYoIXQuY29tcHV0ZWQmJmkgaW5zdGFuY2VvZiBjZSlyZXR1cm5baS5uYW1lXX19ZWxzZSBpZihlIGluc3RhbmNlb2YganQpe2NvbnN0IHQ9ZS5wYXJlbnQsaT1lLnByb3BlcnR5O2lmKCEodCBpbnN0YW5jZW9mIHBoJiZpIGluc3RhbmNlb2YgY2UpKXJldHVybjtjb25zdCBzPWkubmFtZTtpZih0LnBhcmVudCBpbnN0YW5jZW9mIGxpJiZbImNhdGNoIiwiZmluYWxseSJdLmluY2x1ZGVzKHMpKXJldHVybiB2ZTtpZihzIT09InRoZW4iKXJldHVybjtpZih0LmFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB2ZTtjb25zdCBuPXQuYXJndW1lbnRzWzBdO2lmKHQuYXJndW1lbnRzLmxlbmd0aCE9PTF8fCEobiBpbnN0YW5jZW9mIFNyfHxuIGluc3RhbmNlb2YgZ2gpKXJldHVybjtpZihuLnBhcmFtcy5sZW5ndGg9PT0wKXJldHVybiB2ZTtjb25zdCByPW4ucGFyYW1zWzBdO3JldHVybiBuLnBhcmFtcy5sZW5ndGg9PT0xJiZyIGluc3RhbmNlb2YgYXM/Tmgocik6dm9pZCAwfX1oYXNFZmZlY3RzKCl7cmV0dXJuITB9aW5jbHVkZShlLHQpe3RoaXMuaW5jbHVkZWR8fCh0aGlzLmluY2x1ZGVkPSEwLHRoaXMuY29udGV4dC5pbmNsdWRlRHluYW1pY0ltcG9ydCh0aGlzKSx0aGlzLnNjb3BlLmFkZEFjY2Vzc2VkRHluYW1pY0ltcG9ydCh0aGlzKSksdGhpcy5zb3VyY2UuaW5jbHVkZShlLHQpfWluaXRpYWxpc2UoKXt0aGlzLmNvbnRleHQuYWRkRHluYW1pY0ltcG9ydCh0aGlzKX1wYXJzZU5vZGUoZSl7c3VwZXIucGFyc2VOb2RlKGUsWyJzb3VyY2UiXSl9cmVuZGVyKGUsdCl7Y29uc3R7c25pcHBldHM6e186aSxnZXREaXJlY3RSZXR1cm5GdW5jdGlvbjpzLGdldE9iamVjdDpuLGdldFByb3BlcnR5QWNjZXNzOnJ9fT10O2lmKHRoaXMuaW5saW5lTmFtZXNwYWNlKXtjb25zdFthLG9dPXMoW10se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO2Uub3ZlcndyaXRlKHRoaXMuc3RhcnQsdGhpcy5lbmQsYFByb21pc2UucmVzb2x2ZSgpLnRoZW4oJHthfSR7dGhpcy5pbmxpbmVOYW1lc3BhY2UuZ2V0TmFtZShyKX0ke299KWApfWVsc2V7aWYodGhpcy5tZWNoYW5pc20mJihlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LEllKGUub3JpZ2luYWwsIigiLHRoaXMuc3RhcnQrNikrMSx0aGlzLm1lY2hhbmlzbS5sZWZ0KSxlLm92ZXJ3cml0ZSh0aGlzLmVuZC0xLHRoaXMuZW5kLHRoaXMubWVjaGFuaXNtLnJpZ2h0KSksdGhpcy5yZXNvbHV0aW9uU3RyaW5nKXtpZihlLm92ZXJ3cml0ZSh0aGlzLnNvdXJjZS5zdGFydCx0aGlzLnNvdXJjZS5lbmQsdGhpcy5yZXNvbHV0aW9uU3RyaW5nKSx0aGlzLm5hbWVzcGFjZUV4cG9ydE5hbWUpe2NvbnN0W2Esb109cyhbIm4iXSx7ZnVuY3Rpb25SZXR1cm46ITAsbGluZUJyZWFrSW5kZW50Om51bGwsbmFtZTpudWxsfSk7ZS5wcmVwZW5kTGVmdCh0aGlzLmVuZCxgLnRoZW4oJHthfW4uJHt0aGlzLm5hbWVzcGFjZUV4cG9ydE5hbWV9JHtvfSlgKX19ZWxzZSB0aGlzLnNvdXJjZS5yZW5kZXIoZSx0KTt0aGlzLmFzc2VydGlvbnMhPT0hMCYmKHRoaXMuYXJndW1lbnRzJiZlLm92ZXJ3cml0ZSh0aGlzLnNvdXJjZS5lbmQsdGhpcy5lbmQtMSwiIix7Y29udGVudE9ubHk6ITB9KSx0aGlzLmFzc2VydGlvbnMmJmUuYXBwZW5kTGVmdCh0aGlzLmVuZC0xLGAsJHtpfSR7bihbWyJhc3NlcnQiLHRoaXMuYXNzZXJ0aW9uc11dLHtsaW5lQnJlYWtJbmRlbnQ6bnVsbH0pfWApKX19c2V0RXh0ZXJuYWxSZXNvbHV0aW9uKGUsdCxpLHMsbixyLGEsbyxoKXtjb25zdHtmb3JtYXQ6bH09aTt0aGlzLmlubGluZU5hbWVzcGFjZT1udWxsLHRoaXMucmVzb2x1dGlvbj10LHRoaXMucmVzb2x1dGlvblN0cmluZz1hLHRoaXMubmFtZXNwYWNlRXhwb3J0TmFtZT1vLHRoaXMuYXNzZXJ0aW9ucz1oO2NvbnN0IGM9Wy4uLmlkW2xdfHxbXV07bGV0IHA7KHtoZWxwZXI6cCxtZWNoYW5pc206dGhpcy5tZWNoYW5pc219PXRoaXMuZ2V0RHluYW1pY0ltcG9ydE1lY2hhbmlzbUFuZEhlbHBlcih0LGUsaSxzLG4pKSxwJiZjLnB1c2gocCksYy5sZW5ndGg+MCYmdGhpcy5zY29wZS5hZGRBY2Nlc3NlZEdsb2JhbHMoYyxyKX1zZXRJbnRlcm5hbFJlc29sdXRpb24oZSl7dGhpcy5pbmxpbmVOYW1lc3BhY2U9ZX1hcHBseURlb3B0aW1pemF0aW9ucygpe31nZXREeW5hbWljSW1wb3J0TWVjaGFuaXNtQW5kSGVscGVyKGUsdCx7Y29tcGFjdDppLGR5bmFtaWNJbXBvcnRGdW5jdGlvbjpzLGR5bmFtaWNJbXBvcnRJbkNqczpuLGZvcm1hdDpyLGdlbmVyYXRlZENvZGU6e2Fycm93RnVuY3Rpb25zOmF9LGludGVyb3A6b30se186aCxnZXREaXJlY3RSZXR1cm5GdW5jdGlvbjpsLGdldERpcmVjdFJldHVybklpZmVMZWZ0OmN9LHApe2NvbnN0IG09cC5ob29rRmlyc3RTeW5jKCJyZW5kZXJEeW5hbWljSW1wb3J0Iixbe2N1c3RvbVJlc29sdXRpb246dHlwZW9mIHRoaXMucmVzb2x1dGlvbj09InN0cmluZyI/dGhpcy5yZXNvbHV0aW9uOm51bGwsZm9ybWF0OnIsbW9kdWxlSWQ6dGhpcy5jb250ZXh0Lm1vZHVsZS5pZCx0YXJnZXRNb2R1bGVJZDp0aGlzLnJlc29sdXRpb24mJnR5cGVvZiB0aGlzLnJlc29sdXRpb24hPSJzdHJpbmciP3RoaXMucmVzb2x1dGlvbi5pZDpudWxsfV0pO2lmKG0pcmV0dXJue2hlbHBlcjpudWxsLG1lY2hhbmlzbTptfTtjb25zdCB5PSF0aGlzLnJlc29sdXRpb258fHR5cGVvZiB0aGlzLnJlc29sdXRpb249PSJzdHJpbmciO3N3aXRjaChyKXtjYXNlImNqcyI6e2lmKG4mJighZXx8dHlwZW9mIGU9PSJzdHJpbmcifHxlIGluc3RhbmNlb2YgbGUpKXJldHVybntoZWxwZXI6bnVsbCxtZWNoYW5pc206bnVsbH07Y29uc3QgRT1faChlLHQsbyk7bGV0IGc9InJlcXVpcmUoIix4PSIpIjtFJiYoZz1gLyojX19QVVJFX18qLyR7RX0oJHtnfWAseCs9IikiKTtjb25zdFt2LHddPWwoW10se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO3JldHVybiBnPWBQcm9taXNlLnJlc29sdmUoKS50aGVuKCR7dn0ke2d9YCx4Kz1gJHt3fSlgLCFhJiZ5JiYoZz1jKFsidCJdLGAke2d9dCR7eH1gLHtuZWVkc0Fycm93UmV0dXJuUGFyZW5zOiExLG5lZWRzV3JhcHBlZEZ1bmN0aW9uOiEwfSkseD0iKSIpLHtoZWxwZXI6RSxtZWNoYW5pc206e2xlZnQ6ZyxyaWdodDp4fX19Y2FzZSJhbWQiOntjb25zdCBFPWk/ImMiOiJyZXNvbHZlIixnPWk/ImUiOiJyZWplY3QiLHg9X2goZSx0LG8pLFt2LHddPWwoWyJtIl0se2Z1bmN0aW9uUmV0dXJuOiExLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pLGI9eD9gJHt2fSR7RX0oLyojX19QVVJFX18qLyR7eH0obSkpJHt3fWA6RSxbUyxrXT1sKFtFLGddLHtmdW5jdGlvblJldHVybjohMSxsaW5lQnJlYWtJbmRlbnQ6bnVsbCxuYW1lOm51bGx9KTtsZXQgQz1gbmV3IFByb21pc2UoJHtTfXJlcXVpcmUoW2AsUD1gXSwke2h9JHtifSwke2h9JHtnfSkke2t9KWA7cmV0dXJuIWEmJnkmJihDPWMoWyJ0Il0sYCR7Q310JHtQfWAse25lZWRzQXJyb3dSZXR1cm5QYXJlbnM6ITEsbmVlZHNXcmFwcGVkRnVuY3Rpb246ITB9KSxQPSIpIikse2hlbHBlcjp4LG1lY2hhbmlzbTp7bGVmdDpDLHJpZ2h0OlB9fX1jYXNlInN5c3RlbSI6cmV0dXJue2hlbHBlcjpudWxsLG1lY2hhbmlzbTp7bGVmdDoibW9kdWxlLmltcG9ydCgiLHJpZ2h0OiIpIn19O2Nhc2UiZXMiOmlmKHMpcmV0dXJue2hlbHBlcjpudWxsLG1lY2hhbmlzbTp7bGVmdDpgJHtzfShgLHJpZ2h0OiIpIn19fXJldHVybntoZWxwZXI6bnVsbCxtZWNoYW5pc206bnVsbH19fSxJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6JGgsSW1wb3J0U3BlY2lmaWVyOmNsYXNzIGV4dGVuZHMgVnthcHBseURlb3B0aW1pemF0aW9ucygpe319LExhYmVsZWRTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7Y29uc3QgdD1lLmJyb2tlbkZsb3c7cmV0dXJuIGUuaWdub3JlLmxhYmVscy5hZGQodGhpcy5sYWJlbC5uYW1lKSwhIXRoaXMuYm9keS5oYXNFZmZlY3RzKGUpfHwoZS5pZ25vcmUubGFiZWxzLmRlbGV0ZSh0aGlzLmxhYmVsLm5hbWUpLGUuaW5jbHVkZWRMYWJlbHMuaGFzKHRoaXMubGFiZWwubmFtZSkmJihlLmluY2x1ZGVkTGFiZWxzLmRlbGV0ZSh0aGlzLmxhYmVsLm5hbWUpLGUuYnJva2VuRmxvdz10KSwhMSl9aW5jbHVkZShlLHQpe3RoaXMuaW5jbHVkZWQ9ITA7Y29uc3QgaT1lLmJyb2tlbkZsb3c7dGhpcy5ib2R5LmluY2x1ZGUoZSx0KSwodHx8ZS5pbmNsdWRlZExhYmVscy5oYXModGhpcy5sYWJlbC5uYW1lKSkmJih0aGlzLmxhYmVsLmluY2x1ZGUoKSxlLmluY2x1ZGVkTGFiZWxzLmRlbGV0ZSh0aGlzLmxhYmVsLm5hbWUpLGUuYnJva2VuRmxvdz1pKX1yZW5kZXIoZSx0KXt0aGlzLmxhYmVsLmluY2x1ZGVkP3RoaXMubGFiZWwucmVuZGVyKGUsdCk6ZS5yZW1vdmUodGhpcy5zdGFydCx6dChlLm9yaWdpbmFsLEllKGUub3JpZ2luYWwsIjoiLHRoaXMubGFiZWwuZW5kKSsxKSksdGhpcy5ib2R5LnJlbmRlcihlLHQpfX0sTGl0ZXJhbDpjaSxMb2dpY2FsRXhwcmVzc2lvbjpjbGFzcyBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9W10sdGhpcy5pc0JyYW5jaFJlc29sdXRpb25BbmFseXNlZD0hMSx0aGlzLnVzZWRCcmFuY2g9bnVsbH1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7dGhpcy5sZWZ0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKSx0aGlzLnJpZ2h0LmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKX1kZW9wdGltaXplQ2FjaGUoKXtpZih0aGlzLnVzZWRCcmFuY2gpe2NvbnN0IGU9dGhpcy51c2VkQnJhbmNoPT09dGhpcy5sZWZ0P3RoaXMucmlnaHQ6dGhpcy5sZWZ0O3RoaXMudXNlZEJyYW5jaD1udWxsLGUuZGVvcHRpbWl6ZVBhdGgodGUpO2NvbnN0e2NvbnRleHQ6dCxleHByZXNzaW9uc1RvQmVEZW9wdGltaXplZDppfT10aGlzO3RoaXMuZXhwcmVzc2lvbnNUb0JlRGVvcHRpbWl6ZWQ9dmU7Zm9yKGNvbnN0IHMgb2YgaSlzLmRlb3B0aW1pemVDYWNoZSgpO3QucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpfX1kZW9wdGltaXplUGF0aChlKXtjb25zdCB0PXRoaXMuZ2V0VXNlZEJyYW5jaCgpO3Q/dC5kZW9wdGltaXplUGF0aChlKToodGhpcy5sZWZ0LmRlb3B0aW1pemVQYXRoKGUpLHRoaXMucmlnaHQuZGVvcHRpbWl6ZVBhdGgoZSkpfWdldExpdGVyYWxWYWx1ZUF0UGF0aChlLHQsaSl7Y29uc3Qgcz10aGlzLmdldFVzZWRCcmFuY2goKTtyZXR1cm4gcz8odGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKGkpLHMuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUsdCxpKSk6bWV9Z2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoZSx0LGkscyl7Y29uc3Qgbj10aGlzLmdldFVzZWRCcmFuY2goKTtyZXR1cm4gbj8odGhpcy5leHByZXNzaW9uc1RvQmVEZW9wdGltaXplZC5wdXNoKHMpLG4uZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoZSx0LGkscykpOltuZXcgZW4oW3RoaXMubGVmdC5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChlLHQsaSxzKVswXSx0aGlzLnJpZ2h0LmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpWzBdXSksITFdfWhhc0VmZmVjdHMoZSl7cmV0dXJuISF0aGlzLmxlZnQuaGFzRWZmZWN0cyhlKXx8dGhpcy5nZXRVc2VkQnJhbmNoKCkhPT10aGlzLmxlZnQmJnRoaXMucmlnaHQuaGFzRWZmZWN0cyhlKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7Y29uc3Qgcz10aGlzLmdldFVzZWRCcmFuY2goKTtyZXR1cm4gcz9zLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKTp0aGlzLmxlZnQuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfHx0aGlzLnJpZ2h0Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKX1pbmNsdWRlKGUsdCl7dGhpcy5pbmNsdWRlZD0hMDtjb25zdCBpPXRoaXMuZ2V0VXNlZEJyYW5jaCgpO3R8fGk9PT10aGlzLnJpZ2h0JiZ0aGlzLmxlZnQuc2hvdWxkQmVJbmNsdWRlZChlKXx8IWk/KHRoaXMubGVmdC5pbmNsdWRlKGUsdCksdGhpcy5yaWdodC5pbmNsdWRlKGUsdCkpOmkuaW5jbHVkZShlLHQpfXJlbmRlcihlLHQse2lzQ2FsbGVlT2ZSZW5kZXJlZFBhcmVudDppLHByZXZlbnRBU0k6cyxyZW5kZXJlZFBhcmVudFR5cGU6bixyZW5kZXJlZFN1cnJvdW5kaW5nRWxlbWVudDpyfT0kZSl7aWYodGhpcy5sZWZ0LmluY2x1ZGVkJiZ0aGlzLnJpZ2h0LmluY2x1ZGVkKXRoaXMubGVmdC5yZW5kZXIoZSx0LHtwcmV2ZW50QVNJOnMscmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6cn0pLHRoaXMucmlnaHQucmVuZGVyKGUsdCk7ZWxzZXtjb25zdCBhPUllKGUub3JpZ2luYWwsdGhpcy5vcGVyYXRvcix0aGlzLmxlZnQuZW5kKTtpZih0aGlzLnJpZ2h0LmluY2x1ZGVkKXtjb25zdCBvPXp0KGUub3JpZ2luYWwsYSsyKTtlLnJlbW92ZSh0aGlzLnN0YXJ0LG8pLHMmJlhzKGUsbyx0aGlzLnJpZ2h0LnN0YXJ0KX1lbHNlIGUucmVtb3ZlKGEsdGhpcy5lbmQpO2loKHRoaXMsZSksdGhpcy5nZXRVc2VkQnJhbmNoKCkucmVuZGVyKGUsdCx7aXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50OmkscHJldmVudEFTSTpzLHJlbmRlcmVkUGFyZW50VHlwZTpufHx0aGlzLnBhcmVudC50eXBlLHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50OnJ8fHRoaXMucGFyZW50LnR5cGV9KX19Z2V0VXNlZEJyYW5jaCgpe2lmKCF0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkKXt0aGlzLmlzQnJhbmNoUmVzb2x1dGlvbkFuYWx5c2VkPSEwO2NvbnN0IGU9dGhpcy5sZWZ0LmdldExpdGVyYWxWYWx1ZUF0UGF0aChRLEFlLHRoaXMpO2lmKHR5cGVvZiBlPT0ic3ltYm9sIilyZXR1cm4gbnVsbDt0aGlzLnVzZWRCcmFuY2g9dGhpcy5vcGVyYXRvcj09PSJ8fCImJmV8fHRoaXMub3BlcmF0b3I9PT0iJiYiJiYhZXx8dGhpcy5vcGVyYXRvcj09PSI/PyImJmUhPW51bGw/dGhpcy5sZWZ0OnRoaXMucmlnaHR9cmV0dXJuIHRoaXMudXNlZEJyYW5jaH19LE1lbWJlckV4cHJlc3Npb246anQsTWV0YVByb3BlcnR5OmNsYXNzIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5tZXRhUHJvcGVydHk9bnVsbCx0aGlzLnByZWxpbWluYXJ5Q2h1bmtJZD1udWxsLHRoaXMucmVmZXJlbmNlSWQ9bnVsbH1nZXRSZWZlcmVuY2VkRmlsZU5hbWUoZSl7Y29uc3R7bWV0YTp7bmFtZTp0fSxtZXRhUHJvcGVydHk6aX09dGhpcztyZXR1cm4gdD09PU1yJiYoaSE9bnVsbCYmaS5zdGFydHNXaXRoKFZyKSk/ZS5nZXRGaWxlTmFtZShpLnNsaWNlKDE2KSk6bnVsbH1oYXNFZmZlY3RzKCl7cmV0dXJuITF9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx7dHlwZTp0fSl7cmV0dXJuIGUubGVuZ3RoPjF8fHQhPT0wfWluY2x1ZGUoKXtpZighdGhpcy5pbmNsdWRlZCYmKHRoaXMuaW5jbHVkZWQ9ITAsdGhpcy5tZXRhLm5hbWU9PT1Ncikpe3RoaXMuY29udGV4dC5hZGRJbXBvcnRNZXRhKHRoaXMpO2NvbnN0IGU9dGhpcy5wYXJlbnQsdD10aGlzLm1ldGFQcm9wZXJ0eT1lIGluc3RhbmNlb2YganQmJnR5cGVvZiBlLnByb3BlcnR5S2V5PT0ic3RyaW5nIj9lLnByb3BlcnR5S2V5Om51bGw7dCE9bnVsbCYmdC5zdGFydHNXaXRoKFZyKSYmKHRoaXMucmVmZXJlbmNlSWQ9dC5zbGljZSgxNikpfX1yZW5kZXIoZSx0KXt2YXIgeDtjb25zdHtmb3JtYXQ6aSxwbHVnaW5Ecml2ZXI6cyxzbmlwcGV0czpufT10LHtjb250ZXh0Onttb2R1bGU6cn0sbWV0YTp7bmFtZTphfSxtZXRhUHJvcGVydHk6byxwYXJlbnQ6aCxwcmVsaW1pbmFyeUNodW5rSWQ6bCxyZWZlcmVuY2VJZDpjLHN0YXJ0OnAsZW5kOm19PXRoaXMse2lkOnl9PXI7aWYoYSE9PU1yKXJldHVybjtjb25zdCBFPWw7aWYoYyl7Y29uc3Qgdj1zLmdldEZpbGVOYW1lKGMpLHc9R2kodmkoSnQoRSksdikpLGI9cy5ob29rRmlyc3RTeW5jKCJyZXNvbHZlRmlsZVVybCIsW3tjaHVua0lkOkUsZmlsZU5hbWU6dixmb3JtYXQ6aSxtb2R1bGVJZDp5LHJlZmVyZW5jZUlkOmMscmVsYXRpdmVQYXRoOnd9XSl8fHJkW2ldKHcpO3JldHVybiB2b2lkIGUub3ZlcndyaXRlKGguc3RhcnQsaC5lbmQsYix7Y29udGVudE9ubHk6ITB9KX1sZXQgZz1zLmhvb2tGaXJzdFN5bmMoInJlc29sdmVJbXBvcnRNZXRhIixbbyx7Y2h1bmtJZDpFLGZvcm1hdDppLG1vZHVsZUlkOnl9XSk7Z3x8KGc9KHg9enJbaV0pPT1udWxsP3ZvaWQgMDp4LmNhbGwoenIsbyx7Y2h1bmtJZDpFLHNuaXBwZXRzOm59KSx0LmFjY2Vzc2VkRG9jdW1lbnRDdXJyZW50U2NyaXB0fHwodC5hY2Nlc3NlZERvY3VtZW50Q3VycmVudFNjcmlwdD1MaC5pbmNsdWRlcyhpKSYmZyE9PSJ1bmRlZmluZWQiKSksdHlwZW9mIGc9PSJzdHJpbmciJiYoaCBpbnN0YW5jZW9mIGp0P2Uub3ZlcndyaXRlKGguc3RhcnQsaC5lbmQsZyx7Y29udGVudE9ubHk6ITB9KTplLm92ZXJ3cml0ZShwLG0sZyx7Y29udGVudE9ubHk6ITB9KSl9c2V0UmVzb2x1dGlvbihlLHQsaSl7dmFyIG47dGhpcy5wcmVsaW1pbmFyeUNodW5rSWQ9aTtjb25zdCBzPSgobj10aGlzLm1ldGFQcm9wZXJ0eSkhPW51bGwmJm4uc3RhcnRzV2l0aChWcik/bmQ6c2QpW2VdO3MubGVuZ3RoPjAmJnRoaXMuc2NvcGUuYWRkQWNjZXNzZWRHbG9iYWxzKHMsdCl9fSxNZXRob2REZWZpbml0aW9uOkFyLE5ld0V4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7dHJ5e2Zvcihjb25zdCB0IG9mIHRoaXMuYXJndW1lbnRzKWlmKHQuaGFzRWZmZWN0cyhlKSlyZXR1cm4hMDtyZXR1cm4hdGhpcy5hbm5vdGF0aW9uUHVyZSYmKHRoaXMuY2FsbGVlLmhhc0VmZmVjdHMoZSl8fHRoaXMuY2FsbGVlLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFEsdGhpcy5pbnRlcmFjdGlvbixlKSl9ZmluYWxseXt0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCl9fWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUse3R5cGU6dH0pe3JldHVybiBlLmxlbmd0aD4wfHx0IT09MH1pbmNsdWRlKGUsdCl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHQ/c3VwZXIuaW5jbHVkZShlLHQpOih0aGlzLmluY2x1ZGVkPSEwLHRoaXMuY2FsbGVlLmluY2x1ZGUoZSwhMSkpLHRoaXMuY2FsbGVlLmluY2x1ZGVDYWxsQXJndW1lbnRzKGUsdGhpcy5hcmd1bWVudHMpfWluaXRpYWxpc2UoKXt0aGlzLmludGVyYWN0aW9uPXthcmdzOltudWxsLC4uLnRoaXMuYXJndW1lbnRzXSx0eXBlOjIsd2l0aE5ldzohMH19cmVuZGVyKGUsdCl7dGhpcy5jYWxsZWUucmVuZGVyKGUsdCksaGgoZSx0LHRoaXMpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLmNhbGxlZS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0aGlzLmludGVyYWN0aW9uLFEsQWUpLHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCl9fSxPYmplY3RFeHByZXNzaW9uOmNsYXNzIGV4dGVuZHMgVntjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5vYmplY3RFbnRpdHk9bnVsbH1kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7dGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl9ZGVvcHRpbWl6ZUNhY2hlKCl7dGhpcy5nZXRPYmplY3RFbnRpdHkoKS5kZW9wdGltaXplQWxsUHJvcGVydGllcygpfWRlb3B0aW1pemVQYXRoKGUpe3RoaXMuZ2V0T2JqZWN0RW50aXR5KCkuZGVvcHRpbWl6ZVBhdGgoZSl9Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUsdCxpKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoZSx0LGkpfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpe3JldHVybiB0aGlzLmdldE9iamVjdEVudGl0eSgpLmdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4gdGhpcy5nZXRPYmplY3RFbnRpdHkoKS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl9cmVuZGVyKGUsdCx7cmVuZGVyZWRTdXJyb3VuZGluZ0VsZW1lbnQ6aX09JGUpe3N1cGVyLnJlbmRlcihlLHQpLGkhPT1ZZSYmaSE9PWhyfHwoZS5hcHBlbmRSaWdodCh0aGlzLnN0YXJ0LCIoIiksZS5wcmVwZW5kTGVmdCh0aGlzLmVuZCwiKSIpKX1hcHBseURlb3B0aW1pemF0aW9ucygpe31nZXRPYmplY3RFbnRpdHkoKXtpZih0aGlzLm9iamVjdEVudGl0eSE9PW51bGwpcmV0dXJuIHRoaXMub2JqZWN0RW50aXR5O2xldCBlPUZ0O2NvbnN0IHQ9W107Zm9yKGNvbnN0IGkgb2YgdGhpcy5wcm9wZXJ0aWVzKXtpZihpIGluc3RhbmNlb2YgZXMpe3QucHVzaCh7a2V5OmhlLGtpbmQ6ImluaXQiLHByb3BlcnR5Oml9KTtjb250aW51ZX1sZXQgcztpZihpLmNvbXB1dGVkKXtjb25zdCBuPWkua2V5LmdldExpdGVyYWxWYWx1ZUF0UGF0aChRLEFlLHRoaXMpO2lmKHR5cGVvZiBuPT0ic3ltYm9sIil7dC5wdXNoKHtrZXk6aGUsa2luZDppLmtpbmQscHJvcGVydHk6aX0pO2NvbnRpbnVlfXM9U3RyaW5nKG4pfWVsc2UgaWYocz1pLmtleSBpbnN0YW5jZW9mIGNlP2kua2V5Lm5hbWU6U3RyaW5nKGkua2V5LnZhbHVlKSxzPT09Il9fcHJvdG9fXyImJmkua2luZD09PSJpbml0Iil7ZT1pLnZhbHVlIGluc3RhbmNlb2YgY2kmJmkudmFsdWUudmFsdWU9PT1udWxsP251bGw6aS52YWx1ZTtjb250aW51ZX10LnB1c2goe2tleTpzLGtpbmQ6aS5raW5kLHByb3BlcnR5Oml9KX1yZXR1cm4gdGhpcy5vYmplY3RFbnRpdHk9bmV3IEhlKHQsZSl9fSxPYmplY3RQYXR0ZXJuOmFzLFByaXZhdGVJZGVudGlmaWVyOmNsYXNzIGV4dGVuZHMgVnt9LFByb2dyYW06UmgsUHJvcGVydHk6Y2xhc3MgZXh0ZW5kcyBkaHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5kZWNsYXJhdGlvbkluaXQ9bnVsbH1kZWNsYXJlKGUsdCl7cmV0dXJuIHRoaXMuZGVjbGFyYXRpb25Jbml0PXQsdGhpcy52YWx1ZS5kZWNsYXJlKGUsWSl9aGFzRWZmZWN0cyhlKXt0aGlzLmRlb3B0aW1pemVkfHx0aGlzLmFwcGx5RGVvcHRpbWl6YXRpb25zKCk7Y29uc3QgdD10aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UucHJvcGVydHlSZWFkU2lkZUVmZmVjdHM7cmV0dXJuIHRoaXMucGFyZW50LnR5cGU9PT0iT2JqZWN0UGF0dGVybiImJnQ9PT0iYWx3YXlzInx8dGhpcy5rZXkuaGFzRWZmZWN0cyhlKXx8dGhpcy52YWx1ZS5oYXNFZmZlY3RzKGUpfW1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKXt0aGlzLnZhbHVlLm1hcmtEZWNsYXJhdGlvblJlYWNoZWQoKX1yZW5kZXIoZSx0KXt0aGlzLnNob3J0aGFuZHx8dGhpcy5rZXkucmVuZGVyKGUsdCksdGhpcy52YWx1ZS5yZW5kZXIoZSx0LHtpc1Nob3J0aGFuZFByb3BlcnR5OnRoaXMuc2hvcnRoYW5kfSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt0aGlzLmRlb3B0aW1pemVkPSEwLHRoaXMuZGVjbGFyYXRpb25Jbml0IT09bnVsbCYmKHRoaXMuZGVjbGFyYXRpb25Jbml0LmRlb3B0aW1pemVQYXRoKFtoZSxoZV0pLHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCkpfX0sUHJvcGVydHlEZWZpbml0aW9uOmNsYXNzIGV4dGVuZHMgVntkZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl7dmFyIHM7KHM9dGhpcy52YWx1ZSk9PW51bGx8fHMuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfWRlb3B0aW1pemVQYXRoKGUpe3ZhciB0Oyh0PXRoaXMudmFsdWUpPT1udWxsfHx0LmRlb3B0aW1pemVQYXRoKGUpfWdldExpdGVyYWxWYWx1ZUF0UGF0aChlLHQsaSl7cmV0dXJuIHRoaXMudmFsdWU/dGhpcy52YWx1ZS5nZXRMaXRlcmFsVmFsdWVBdFBhdGgoZSx0LGkpOm1lfWdldFJldHVybkV4cHJlc3Npb25XaGVuQ2FsbGVkQXRQYXRoKGUsdCxpLHMpe3JldHVybiB0aGlzLnZhbHVlP3RoaXMudmFsdWUuZ2V0UmV0dXJuRXhwcmVzc2lvbldoZW5DYWxsZWRBdFBhdGgoZSx0LGkscyk6YmV9aGFzRWZmZWN0cyhlKXt2YXIgdDtyZXR1cm4gdGhpcy5rZXkuaGFzRWZmZWN0cyhlKXx8dGhpcy5zdGF0aWMmJiEhKCh0PXRoaXMudmFsdWUpIT1udWxsJiZ0Lmhhc0VmZmVjdHMoZSkpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4hdGhpcy52YWx1ZXx8dGhpcy52YWx1ZS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl9YXBwbHlEZW9wdGltaXphdGlvbnMoKXt9fSxSZXN0RWxlbWVudDp2cixSZXR1cm5TdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7dmFyIHQ7cmV0dXJuIShlLmlnbm9yZS5yZXR1cm5ZaWVsZCYmISgodD10aGlzLmFyZ3VtZW50KSE9bnVsbCYmdC5oYXNFZmZlY3RzKGUpKSl8fChlLmJyb2tlbkZsb3c9ITAsITEpfWluY2x1ZGUoZSx0KXt2YXIgaTt0aGlzLmluY2x1ZGVkPSEwLChpPXRoaXMuYXJndW1lbnQpPT1udWxsfHxpLmluY2x1ZGUoZSx0KSxlLmJyb2tlbkZsb3c9ITB9aW5pdGlhbGlzZSgpe3RoaXMuc2NvcGUuYWRkUmV0dXJuRXhwcmVzc2lvbih0aGlzLmFyZ3VtZW50fHxZKX1yZW5kZXIoZSx0KXt0aGlzLmFyZ3VtZW50JiYodGhpcy5hcmd1bWVudC5yZW5kZXIoZSx0LHtwcmV2ZW50QVNJOiEwfSksdGhpcy5hcmd1bWVudC5zdGFydD09PXRoaXMuc3RhcnQrNiYmZS5wcmVwZW5kTGVmdCh0aGlzLnN0YXJ0KzYsIiAiKSl9fSxTZXF1ZW5jZUV4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2Rlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXt0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoLTFdLmRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKX1kZW9wdGltaXplUGF0aChlKXt0aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoLTFdLmRlb3B0aW1pemVQYXRoKGUpfWdldExpdGVyYWxWYWx1ZUF0UGF0aChlLHQsaSl7cmV0dXJuIHRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGgtMV0uZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUsdCxpKX1oYXNFZmZlY3RzKGUpe2Zvcihjb25zdCB0IG9mIHRoaXMuZXhwcmVzc2lvbnMpaWYodC5oYXNFZmZlY3RzKGUpKXJldHVybiEwO3JldHVybiExfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKXtyZXR1cm4gdGhpcy5leHByZXNzaW9uc1t0aGlzLmV4cHJlc3Npb25zLmxlbmd0aC0xXS5oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHQsaSl9aW5jbHVkZShlLHQpe3RoaXMuaW5jbHVkZWQ9ITA7Y29uc3QgaT10aGlzLmV4cHJlc3Npb25zW3RoaXMuZXhwcmVzc2lvbnMubGVuZ3RoLTFdO2Zvcihjb25zdCBzIG9mIHRoaXMuZXhwcmVzc2lvbnMpKHR8fHM9PT1pJiYhKHRoaXMucGFyZW50IGluc3RhbmNlb2YgbGkpfHxzLnNob3VsZEJlSW5jbHVkZWQoZSkpJiZzLmluY2x1ZGUoZSx0KX1yZW5kZXIoZSx0LHtyZW5kZXJlZFBhcmVudFR5cGU6aSxpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQ6cyxwcmV2ZW50QVNJOm59PSRlKXtsZXQgcj0wLGE9bnVsbDtjb25zdCBvPXRoaXMuZXhwcmVzc2lvbnNbdGhpcy5leHByZXNzaW9ucy5sZW5ndGgtMV07Zm9yKGNvbnN0e25vZGU6aCxzZXBhcmF0b3I6bCxzdGFydDpjLGVuZDpwfW9mIG5oKHRoaXMuZXhwcmVzc2lvbnMsZSx0aGlzLnN0YXJ0LHRoaXMuZW5kKSlpZihoLmluY2x1ZGVkKWlmKHIrKyxhPWwscj09PTEmJm4mJlhzKGUsYyxoLnN0YXJ0KSxyPT09MSl7Y29uc3QgbT1pfHx0aGlzLnBhcmVudC50eXBlO2gucmVuZGVyKGUsdCx7aXNDYWxsZWVPZlJlbmRlcmVkUGFyZW50OnMmJmg9PT1vLHJlbmRlcmVkUGFyZW50VHlwZTptLHJlbmRlcmVkU3Vycm91bmRpbmdFbGVtZW50Om19KX1lbHNlIGgucmVuZGVyKGUsdCk7ZWxzZSBicihoLGUsYyxwKTthJiZlLnJlbW92ZShhLHRoaXMuZW5kKX19LFNwcmVhZEVsZW1lbnQ6ZXMsU3RhdGljQmxvY2s6Y2xhc3MgZXh0ZW5kcyBWe2NyZWF0ZVNjb3BlKGUpe3RoaXMuc2NvcGU9bmV3IGhpKGUpfWhhc0VmZmVjdHMoZSl7Zm9yKGNvbnN0IHQgb2YgdGhpcy5ib2R5KWlmKHQuaGFzRWZmZWN0cyhlKSlyZXR1cm4hMDtyZXR1cm4hMX1pbmNsdWRlKGUsdCl7dGhpcy5pbmNsdWRlZD0hMDtmb3IoY29uc3QgaSBvZiB0aGlzLmJvZHkpKHR8fGkuc2hvdWxkQmVJbmNsdWRlZChlKSkmJmkuaW5jbHVkZShlLHQpfXJlbmRlcihlLHQpe2lmKHRoaXMuYm9keS5sZW5ndGg+MCl7Y29uc3QgaT1JZShlLm9yaWdpbmFsLnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5lbmQpLCJ7IikrMTtycyh0aGlzLmJvZHksZSx0aGlzLnN0YXJ0K2ksdGhpcy5lbmQtMSx0KX1lbHNlIHN1cGVyLnJlbmRlcihlLHQpfX0sU3VwZXI6Y2xhc3MgZXh0ZW5kcyBWe2JpbmQoKXt0aGlzLnZhcmlhYmxlPXRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKCJ0aGlzIil9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpe3RoaXMudmFyaWFibGUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfWRlb3B0aW1pemVQYXRoKGUpe3RoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgoZSl9aW5jbHVkZSgpe3RoaXMuaW5jbHVkZWR8fCh0aGlzLmluY2x1ZGVkPSEwLHRoaXMuY29udGV4dC5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZSh0aGlzLnZhcmlhYmxlKSl9fSxTd2l0Y2hDYXNlOk9oLFN3aXRjaFN0YXRlbWVudDpjbGFzcyBleHRlbmRzIFZ7Y3JlYXRlU2NvcGUoZSl7dGhpcy5wYXJlbnRTY29wZT1lLHRoaXMuc2NvcGU9bmV3IGhpKGUpfWhhc0VmZmVjdHMoZSl7aWYodGhpcy5kaXNjcmltaW5hbnQuaGFzRWZmZWN0cyhlKSlyZXR1cm4hMDtjb25zdHticm9rZW5GbG93OnQsaGFzQnJlYWs6aSxpZ25vcmU6c309ZSx7YnJlYWtzOm59PXM7cy5icmVha3M9ITAsZS5oYXNCcmVhaz0hMTtsZXQgcj0hMDtmb3IoY29uc3QgYSBvZiB0aGlzLmNhc2VzKXtpZihhLmhhc0VmZmVjdHMoZSkpcmV0dXJuITA7ciYmKHI9ZS5icm9rZW5GbG93JiYhZS5oYXNCcmVhayksZS5oYXNCcmVhaz0hMSxlLmJyb2tlbkZsb3c9dH1yZXR1cm4gdGhpcy5kZWZhdWx0Q2FzZSE9PW51bGwmJihlLmJyb2tlbkZsb3c9cikscy5icmVha3M9bixlLmhhc0JyZWFrPWksITF9aW5jbHVkZShlLHQpe3RoaXMuaW5jbHVkZWQ9ITAsdGhpcy5kaXNjcmltaW5hbnQuaW5jbHVkZShlLHQpO2NvbnN0e2Jyb2tlbkZsb3c6aSxoYXNCcmVhazpzfT1lO2UuaGFzQnJlYWs9ITE7bGV0IG49ITAscj10fHx0aGlzLmRlZmF1bHRDYXNlIT09bnVsbCYmdGhpcy5kZWZhdWx0Q2FzZTx0aGlzLmNhc2VzLmxlbmd0aC0xO2ZvcihsZXQgYT10aGlzLmNhc2VzLmxlbmd0aC0xO2E+PTA7YS0tKXtjb25zdCBvPXRoaXMuY2FzZXNbYV07aWYoby5pbmNsdWRlZCYmKHI9ITApLCFyKXtjb25zdCBoPXpzKCk7aC5pZ25vcmUuYnJlYWtzPSEwLHI9by5oYXNFZmZlY3RzKGgpfXI/KG8uaW5jbHVkZShlLHQpLG4mJihuPWUuYnJva2VuRmxvdyYmIWUuaGFzQnJlYWspLGUuaGFzQnJlYWs9ITEsZS5icm9rZW5GbG93PWkpOm49aX1yJiZ0aGlzLmRlZmF1bHRDYXNlIT09bnVsbCYmKGUuYnJva2VuRmxvdz1uKSxlLmhhc0JyZWFrPXN9aW5pdGlhbGlzZSgpe2ZvcihsZXQgZT0wO2U8dGhpcy5jYXNlcy5sZW5ndGg7ZSsrKWlmKHRoaXMuY2FzZXNbZV0udGVzdD09PW51bGwpcmV0dXJuIHZvaWQodGhpcy5kZWZhdWx0Q2FzZT1lKTt0aGlzLmRlZmF1bHRDYXNlPW51bGx9cGFyc2VOb2RlKGUpe3RoaXMuZGlzY3JpbWluYW50PW5ldyh0aGlzLmNvbnRleHQuZ2V0Tm9kZUNvbnN0cnVjdG9yKGUuZGlzY3JpbWluYW50LnR5cGUpKShlLmRpc2NyaW1pbmFudCx0aGlzLHRoaXMucGFyZW50U2NvcGUpLHN1cGVyLnBhcnNlTm9kZShlKX1yZW5kZXIoZSx0KXt0aGlzLmRpc2NyaW1pbmFudC5yZW5kZXIoZSx0KSx0aGlzLmNhc2VzLmxlbmd0aD4wJiZycyh0aGlzLmNhc2VzLGUsdGhpcy5jYXNlc1swXS5zdGFydCx0aGlzLmVuZC0xLHQpfX0sVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uOmNsYXNzIGV4dGVuZHMgY2h7YmluZCgpe2lmKHN1cGVyLmJpbmQoKSx0aGlzLnRhZy50eXBlPT09Tm8pe2NvbnN0IGU9dGhpcy50YWcubmFtZTt0aGlzLnNjb3BlLmZpbmRWYXJpYWJsZShlKS5pc05hbWVzcGFjZSYmdGhpcy5jb250ZXh0LmxvZyhLLEVvKGUpLHRoaXMuc3RhcnQpfX1oYXNFZmZlY3RzKGUpe3RyeXtmb3IoY29uc3QgdCBvZiB0aGlzLnF1YXNpLmV4cHJlc3Npb25zKWlmKHQuaGFzRWZmZWN0cyhlKSlyZXR1cm4hMDtyZXR1cm4gdGhpcy50YWcuaGFzRWZmZWN0cyhlKXx8dGhpcy50YWcuaGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoUSx0aGlzLmludGVyYWN0aW9uLGUpfWZpbmFsbHl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpfX1pbmNsdWRlKGUsdCl7dGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHQ/c3VwZXIuaW5jbHVkZShlLHQpOih0aGlzLmluY2x1ZGVkPSEwLHRoaXMudGFnLmluY2x1ZGUoZSx0KSx0aGlzLnF1YXNpLmluY2x1ZGUoZSx0KSksdGhpcy50YWcuaW5jbHVkZUNhbGxBcmd1bWVudHMoZSx0aGlzLmFyZ3MpO2NvbnN0W2ldPXRoaXMuZ2V0UmV0dXJuRXhwcmVzc2lvbigpO2kuaW5jbHVkZWR8fGkuaW5jbHVkZShlLCExKX1pbml0aWFsaXNlKCl7dGhpcy5hcmdzPVtZLC4uLnRoaXMucXVhc2kuZXhwcmVzc2lvbnNdLHRoaXMuaW50ZXJhY3Rpb249e2FyZ3M6W3RoaXMudGFnIGluc3RhbmNlb2YganQmJiF0aGlzLnRhZy52YXJpYWJsZT90aGlzLnRhZy5vYmplY3Q6bnVsbCwuLi50aGlzLmFyZ3NdLHR5cGU6Mix3aXRoTmV3OiExfX1yZW5kZXIoZSx0KXt0aGlzLnRhZy5yZW5kZXIoZSx0LHtpc0NhbGxlZU9mUmVuZGVyZWRQYXJlbnQ6ITB9KSx0aGlzLnF1YXNpLnJlbmRlcihlLHQpfWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLnRhZy5kZW9wdGltaXplQXJndW1lbnRzT25JbnRlcmFjdGlvbkF0UGF0aCh0aGlzLmludGVyYWN0aW9uLFEsQWUpLHRoaXMuY29udGV4dC5yZXF1ZXN0VHJlZXNoYWtpbmdQYXNzKCl9Z2V0UmV0dXJuRXhwcmVzc2lvbihlPUFlKXtyZXR1cm4gdGhpcy5yZXR1cm5FeHByZXNzaW9uPT09bnVsbD8odGhpcy5yZXR1cm5FeHByZXNzaW9uPWJlLHRoaXMucmV0dXJuRXhwcmVzc2lvbj10aGlzLnRhZy5nZXRSZXR1cm5FeHByZXNzaW9uV2hlbkNhbGxlZEF0UGF0aChRLHRoaXMuaW50ZXJhY3Rpb24sZSx0aGlzKSk6dGhpcy5yZXR1cm5FeHByZXNzaW9ufX0sVGVtcGxhdGVFbGVtZW50OmNsYXNzIGV4dGVuZHMgVntiaW5kKCl7fWhhc0VmZmVjdHMoKXtyZXR1cm4hMX1pbmNsdWRlKCl7dGhpcy5pbmNsdWRlZD0hMH1wYXJzZU5vZGUoZSl7dGhpcy52YWx1ZT1lLnZhbHVlLHN1cGVyLnBhcnNlTm9kZShlKX1yZW5kZXIoKXt9fSxUZW1wbGF0ZUxpdGVyYWw6VmgsVGhpc0V4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2JpbmQoKXt0aGlzLnZhcmlhYmxlPXRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKCJ0aGlzIil9ZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpe3RoaXMudmFyaWFibGUuZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpfWRlb3B0aW1pemVQYXRoKGUpe3RoaXMudmFyaWFibGUuZGVvcHRpbWl6ZVBhdGgoZSl9aGFzRWZmZWN0c09uSW50ZXJhY3Rpb25BdFBhdGgoZSx0LGkpe3JldHVybiBlLmxlbmd0aD09PTA/dC50eXBlIT09MDp0aGlzLnZhcmlhYmxlLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUsdCxpKX1pbmNsdWRlKCl7dGhpcy5pbmNsdWRlZHx8KHRoaXMuaW5jbHVkZWQ9ITAsdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMudmFyaWFibGUpKX1pbml0aWFsaXNlKCl7dGhpcy5hbGlhcz10aGlzLnNjb3BlLmZpbmRMZXhpY2FsQm91bmRhcnkoKWluc3RhbmNlb2YgRGg/dGhpcy5jb250ZXh0Lm1vZHVsZUNvbnRleHQ6bnVsbCx0aGlzLmFsaWFzPT09InVuZGVmaW5lZCImJnRoaXMuY29udGV4dC5sb2coSyx7Y29kZToiVEhJU19JU19VTkRFRklORUQiLG1lc3NhZ2U6IlRoZSAndGhpcycga2V5d29yZCBpcyBlcXVpdmFsZW50IHRvICd1bmRlZmluZWQnIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYW4gRVMgbW9kdWxlLCBhbmQgaGFzIGJlZW4gcmV3cml0dGVuIix1cmw6X2UoInRyb3VibGVzaG9vdGluZy8jZXJyb3ItdGhpcy1pcy11bmRlZmluZWQiKX0sdGhpcy5zdGFydCl9cmVuZGVyKGUpe3RoaXMuYWxpYXMhPT1udWxsJiZlLm92ZXJ3cml0ZSh0aGlzLnN0YXJ0LHRoaXMuZW5kLHRoaXMuYWxpYXMse2NvbnRlbnRPbmx5OiExLHN0b3JlTmFtZTohMH0pfX0sVGhyb3dTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoKXtyZXR1cm4hMH1pbmNsdWRlKGUsdCl7dGhpcy5pbmNsdWRlZD0hMCx0aGlzLmFyZ3VtZW50LmluY2x1ZGUoZSx0KSxlLmJyb2tlbkZsb3c9ITB9cmVuZGVyKGUsdCl7dGhpcy5hcmd1bWVudC5yZW5kZXIoZSx0LHtwcmV2ZW50QVNJOiEwfSksdGhpcy5hcmd1bWVudC5zdGFydD09PXRoaXMuc3RhcnQrNSYmZS5wcmVwZW5kTGVmdCh0aGlzLnN0YXJ0KzUsIiAiKX19LFRyeVN0YXRlbWVudDpjbGFzcyBleHRlbmRzIFZ7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuZGlyZWN0bHlJbmNsdWRlZD0hMSx0aGlzLmluY2x1ZGVkTGFiZWxzQWZ0ZXJCbG9jaz1udWxsfWhhc0VmZmVjdHMoZSl7dmFyIHQ7cmV0dXJuKHRoaXMuY29udGV4dC5vcHRpb25zLnRyZWVzaGFrZS50cnlDYXRjaERlb3B0aW1pemF0aW9uP3RoaXMuYmxvY2suYm9keS5sZW5ndGg+MDp0aGlzLmJsb2NrLmhhc0VmZmVjdHMoZSkpfHwhISgodD10aGlzLmZpbmFsaXplcikhPW51bGwmJnQuaGFzRWZmZWN0cyhlKSl9aW5jbHVkZShlLHQpe3ZhciByLGE7Y29uc3QgaT0ocj10aGlzLmNvbnRleHQub3B0aW9ucy50cmVlc2hha2UpPT1udWxsP3ZvaWQgMDpyLnRyeUNhdGNoRGVvcHRpbWl6YXRpb24se2Jyb2tlbkZsb3c6cyxpbmNsdWRlZExhYmVsczpufT1lO2lmKHRoaXMuZGlyZWN0bHlJbmNsdWRlZCYmaSl7aWYodGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2spZm9yKGNvbnN0IG8gb2YgdGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2spbi5hZGQobyl9ZWxzZSB0aGlzLmluY2x1ZGVkPSEwLHRoaXMuZGlyZWN0bHlJbmNsdWRlZD0hMCx0aGlzLmJsb2NrLmluY2x1ZGUoZSxpP1JvOnQpLG4uc2l6ZT4wJiYodGhpcy5pbmNsdWRlZExhYmVsc0FmdGVyQmxvY2s9Wy4uLm5dKSxlLmJyb2tlbkZsb3c9czt0aGlzLmhhbmRsZXIhPT1udWxsJiYodGhpcy5oYW5kbGVyLmluY2x1ZGUoZSx0KSxlLmJyb2tlbkZsb3c9cyksKGE9dGhpcy5maW5hbGl6ZXIpPT1udWxsfHxhLmluY2x1ZGUoZSx0KX19LFVuYXJ5RXhwcmVzc2lvbjpjbGFzcyBleHRlbmRzIFZ7Z2V0TGl0ZXJhbFZhbHVlQXRQYXRoKGUsdCxpKXtpZihlLmxlbmd0aD4wKXJldHVybiBtZTtjb25zdCBzPXRoaXMuYXJndW1lbnQuZ2V0TGl0ZXJhbFZhbHVlQXRQYXRoKFEsdCxpKTtyZXR1cm4gdHlwZW9mIHM9PSJzeW1ib2wiP21lOmFkW3RoaXMub3BlcmF0b3JdKHMpfWhhc0VmZmVjdHMoZSl7cmV0dXJuIHRoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSwhKHRoaXMub3BlcmF0b3I9PT0idHlwZW9mIiYmdGhpcy5hcmd1bWVudCBpbnN0YW5jZW9mIGNlKSYmKHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0cyhlKXx8dGhpcy5vcGVyYXRvcj09PSJkZWxldGUiJiZ0aGlzLmFyZ3VtZW50Lmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKFEscW4sZSkpfWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKGUse3R5cGU6dH0pe3JldHVybiB0IT09MHx8ZS5sZW5ndGg+KHRoaXMub3BlcmF0b3I9PT0idm9pZCI/MDoxKX1hcHBseURlb3B0aW1pemF0aW9ucygpe3RoaXMuZGVvcHRpbWl6ZWQ9ITAsdGhpcy5vcGVyYXRvcj09PSJkZWxldGUiJiYodGhpcy5hcmd1bWVudC5kZW9wdGltaXplUGF0aChRKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpKX19LFVua25vd25Ob2RlOmNsYXNzIGV4dGVuZHMgVntoYXNFZmZlY3RzKCl7cmV0dXJuITB9aW5jbHVkZShlKXtzdXBlci5pbmNsdWRlKGUsITApfX0sVXBkYXRlRXhwcmVzc2lvbjpjbGFzcyBleHRlbmRzIFZ7aGFzRWZmZWN0cyhlKXtyZXR1cm4gdGhpcy5kZW9wdGltaXplZHx8dGhpcy5hcHBseURlb3B0aW1pemF0aW9ucygpLHRoaXMuYXJndW1lbnQuaGFzRWZmZWN0c0FzQXNzaWdubWVudFRhcmdldChlLCEwKX1oYXNFZmZlY3RzT25JbnRlcmFjdGlvbkF0UGF0aChlLHt0eXBlOnR9KXtyZXR1cm4gZS5sZW5ndGg+MXx8dCE9PTB9aW5jbHVkZShlLHQpe3RoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSx0aGlzLmluY2x1ZGVkPSEwLHRoaXMuYXJndW1lbnQuaW5jbHVkZUFzQXNzaWdubWVudFRhcmdldChlLHQsITApfWluaXRpYWxpc2UoKXt0aGlzLmFyZ3VtZW50LnNldEFzc2lnbmVkVmFsdWUoWSl9cmVuZGVyKGUsdCl7Y29uc3R7ZXhwb3J0TmFtZXNCeVZhcmlhYmxlOmksZm9ybWF0OnMsc25pcHBldHM6e186bn19PXQ7aWYodGhpcy5hcmd1bWVudC5yZW5kZXIoZSx0KSxzPT09InN5c3RlbSIpe2NvbnN0IHI9dGhpcy5hcmd1bWVudC52YXJpYWJsZSxhPWkuZ2V0KHIpO2lmKGEpaWYodGhpcy5wcmVmaXgpYS5sZW5ndGg9PT0xP2tyKHIsdGhpcy5zdGFydCx0aGlzLmVuZCxlLHQpOnJoKHIsdGhpcy5zdGFydCx0aGlzLmVuZCx0aGlzLnBhcmVudC50eXBlIT09WWUsZSx0KTtlbHNle2NvbnN0IG89dGhpcy5vcGVyYXRvclswXTsoZnVuY3Rpb24oaCxsLGMscCxtLHksRSl7Y29uc3R7XzpnfT15LnNuaXBwZXRzO20ucHJlcGVuZFJpZ2h0KGwsYCR7dWkoW2hdLHksRSl9LCR7Z31gKSxwJiYobS5wcmVwZW5kUmlnaHQobCwiKCIpLG0uYXBwZW5kTGVmdChjLCIpIikpfSkocix0aGlzLnN0YXJ0LHRoaXMuZW5kLHRoaXMucGFyZW50LnR5cGUhPT1ZZSxlLHQsYCR7bn0ke299JHtufTFgKX19fWFwcGx5RGVvcHRpbWl6YXRpb25zKCl7dGhpcy5kZW9wdGltaXplZD0hMCx0aGlzLmFyZ3VtZW50LmRlb3B0aW1pemVQYXRoKFEpLHRoaXMuYXJndW1lbnQgaW5zdGFuY2VvZiBjZSYmKHRoaXMuc2NvcGUuZmluZFZhcmlhYmxlKHRoaXMuYXJndW1lbnQubmFtZSkuaXNSZWFzc2lnbmVkPSEwKSx0aGlzLmNvbnRleHQucmVxdWVzdFRyZWVzaGFraW5nUGFzcygpfX0sVmFyaWFibGVEZWNsYXJhdGlvbjpCaCxWYXJpYWJsZURlY2xhcmF0b3I6UGgsV2hpbGVTdGF0ZW1lbnQ6Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7cmV0dXJuISF0aGlzLnRlc3QuaGFzRWZmZWN0cyhlKXx8dG4oZSx0aGlzLmJvZHkpfWluY2x1ZGUoZSx0KXt0aGlzLmluY2x1ZGVkPSEwLHRoaXMudGVzdC5pbmNsdWRlKGUsdCksb3MoZSx0aGlzLmJvZHksdCl9fSxZaWVsZEV4cHJlc3Npb246Y2xhc3MgZXh0ZW5kcyBWe2hhc0VmZmVjdHMoZSl7dmFyIHQ7cmV0dXJuIHRoaXMuZGVvcHRpbWl6ZWR8fHRoaXMuYXBwbHlEZW9wdGltaXphdGlvbnMoKSwhKGUuaWdub3JlLnJldHVybllpZWxkJiYhKCh0PXRoaXMuYXJndW1lbnQpIT1udWxsJiZ0Lmhhc0VmZmVjdHMoZSkpKX1yZW5kZXIoZSx0KXt0aGlzLmFyZ3VtZW50JiYodGhpcy5hcmd1bWVudC5yZW5kZXIoZSx0LHtwcmV2ZW50QVNJOiEwfSksdGhpcy5hcmd1bWVudC5zdGFydD09PXRoaXMuc3RhcnQrNSYmZS5wcmVwZW5kTGVmdCh0aGlzLnN0YXJ0KzUsIiAiKSl9fX0sTmk9Il9taXNzaW5nRXhwb3J0U2hpbSI7Y2xhc3Mgb2QgZXh0ZW5kcyB0aXtjb25zdHJ1Y3Rvcih0KXtzdXBlcihOaSksdGhpcy5tb2R1bGU9dH1pbmNsdWRlKCl7c3VwZXIuaW5jbHVkZSgpLHRoaXMubW9kdWxlLm5lZWRzRXhwb3J0U2hpbT0hMH19Y2xhc3MgZHMgZXh0ZW5kcyB0aXtjb25zdHJ1Y3Rvcih0KXtzdXBlcih0LmdldE1vZHVsZU5hbWUoKSksdGhpcy5tZW1iZXJWYXJpYWJsZXM9bnVsbCx0aGlzLm1lcmdlZE5hbWVzcGFjZXM9W10sdGhpcy5yZWZlcmVuY2VkRWFybHk9ITEsdGhpcy5yZWZlcmVuY2VzPVtdLHRoaXMuY29udGV4dD10LHRoaXMubW9kdWxlPXQubW9kdWxlfWFkZFJlZmVyZW5jZSh0KXt0aGlzLnJlZmVyZW5jZXMucHVzaCh0KSx0aGlzLm5hbWU9dC5uYW1lfWRlb3B0aW1pemVBcmd1bWVudHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXt2YXIgbjtpZihpLmxlbmd0aD4xfHxpLmxlbmd0aD09PTEmJnQudHlwZT09PTIpe2NvbnN0IHI9aVswXTt0eXBlb2Ygcj09InN0cmluZyI/KG49dGhpcy5nZXRNZW1iZXJWYXJpYWJsZXMoKVtyXSk9PW51bGx8fG4uZGVvcHRpbWl6ZUFyZ3VtZW50c09uSW50ZXJhY3Rpb25BdFBhdGgodCxpLnNsaWNlKDEpLHMpOkR0KHQpfX1kZW9wdGltaXplUGF0aCh0KXt2YXIgaTtpZih0Lmxlbmd0aD4xKXtjb25zdCBzPXRbMF07dHlwZW9mIHM9PSJzdHJpbmciJiYoKGk9dGhpcy5nZXRNZW1iZXJWYXJpYWJsZXMoKVtzXSk9PW51bGx8fGkuZGVvcHRpbWl6ZVBhdGgodC5zbGljZSgxKSkpfX1nZXRMaXRlcmFsVmFsdWVBdFBhdGgodCl7cmV0dXJuIHRbMF09PT1Hbj8iTW9kdWxlIjptZX1nZXRNZW1iZXJWYXJpYWJsZXMoKXtpZih0aGlzLm1lbWJlclZhcmlhYmxlcylyZXR1cm4gdGhpcy5tZW1iZXJWYXJpYWJsZXM7Y29uc3QgdD1PYmplY3QuY3JlYXRlKG51bGwpLGk9Wy4uLnRoaXMuY29udGV4dC5nZXRFeHBvcnRzKCksLi4udGhpcy5jb250ZXh0LmdldFJlZXhwb3J0cygpXS5zb3J0KCk7Zm9yKGNvbnN0IHMgb2YgaSlpZihzWzBdIT09IioiJiZzIT09dGhpcy5tb2R1bGUuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpe2NvbnN0IG49dGhpcy5jb250ZXh0LnRyYWNlRXhwb3J0KHMpO24mJih0W3NdPW4pfXJldHVybiB0aGlzLm1lbWJlclZhcmlhYmxlcz10fWhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQsaSxzKXtjb25zdHt0eXBlOm59PWk7aWYodC5sZW5ndGg9PT0wKXJldHVybiEwO2lmKHQubGVuZ3RoPT09MSYmbiE9PTIpcmV0dXJuIG49PT0xO2NvbnN0IHI9dFswXTtpZih0eXBlb2YgciE9InN0cmluZyIpcmV0dXJuITA7Y29uc3QgYT10aGlzLmdldE1lbWJlclZhcmlhYmxlcygpW3JdO3JldHVybiFhfHxhLmhhc0VmZmVjdHNPbkludGVyYWN0aW9uQXRQYXRoKHQuc2xpY2UoMSksaSxzKX1pbmNsdWRlKCl7dGhpcy5pbmNsdWRlZD0hMCx0aGlzLmNvbnRleHQuaW5jbHVkZUFsbEV4cG9ydHMoKX1wcmVwYXJlKHQpe3RoaXMubWVyZ2VkTmFtZXNwYWNlcy5sZW5ndGg+MCYmdGhpcy5tb2R1bGUuc2NvcGUuYWRkQWNjZXNzZWRHbG9iYWxzKFthbl0sdCl9cmVuZGVyQmxvY2sodCl7Y29uc3R7ZXhwb3J0TmFtZXNCeVZhcmlhYmxlOmksZm9ybWF0OnMsZnJlZXplOm4saW5kZW50OnIsbmFtZXNwYWNlVG9TdHJpbmdUYWc6YSxzbmlwcGV0czp7XzpvLGNuc3Q6aCxnZXRPYmplY3Q6bCxnZXRQcm9wZXJ0eUFjY2VzczpjLG46cCxzOm19fT10LHk9dGhpcy5nZXRNZW1iZXJWYXJpYWJsZXMoKSxFPU9iamVjdC5lbnRyaWVzKHkpLmZpbHRlcigoW3gsdl0pPT52LmluY2x1ZGVkKS5tYXAoKFt4LHZdKT0+dGhpcy5yZWZlcmVuY2VkRWFybHl8fHYuaXNSZWFzc2lnbmVkfHx2PT09dGhpcz9bbnVsbCxgZ2V0ICR7eH0ke299KCkke299eyR7b31yZXR1cm4gJHt2LmdldE5hbWUoYyl9JHttfSR7b319YF06W3gsdi5nZXROYW1lKGMpXSk7RS51bnNoaWZ0KFtudWxsLGBfX3Byb3RvX186JHtvfW51bGxgXSk7bGV0IGc9bChFLHtsaW5lQnJlYWtJbmRlbnQ6e2Jhc2U6IiIsdDpyfX0pO2lmKHRoaXMubWVyZ2VkTmFtZXNwYWNlcy5sZW5ndGg+MCl7Y29uc3QgeD10aGlzLm1lcmdlZE5hbWVzcGFjZXMubWFwKHY9PnYuZ2V0TmFtZShjKSk7Zz1gLyojX19QVVJFX18qLyR7YW59KCR7Z30sJHtvfVske3guam9pbihgLCR7b31gKX1dKWB9ZWxzZSBhJiYoZz1gLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSgke2d9LCR7b31TeW1ib2wudG9TdHJpbmdUYWcsJHtvfSR7Y3MobCl9KWApLG4mJihnPWAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSgke2d9KWApO3JldHVybiBnPWAke2h9ICR7dGhpcy5nZXROYW1lKGMpfSR7b309JHtvfSR7Z307YCxzPT09InN5c3RlbSImJmkuaGFzKHRoaXMpJiYoZys9YCR7cH0ke3VpKFt0aGlzXSx0KX07YCksZ31yZW5kZXJGaXJzdCgpe3JldHVybiB0aGlzLnJlZmVyZW5jZWRFYXJseX1zZXRNZXJnZWROYW1lc3BhY2VzKHQpe3RoaXMubWVyZ2VkTmFtZXNwYWNlcz10O2NvbnN0IGk9dGhpcy5jb250ZXh0LmdldE1vZHVsZUV4ZWNJbmRleCgpO2Zvcihjb25zdCBzIG9mIHRoaXMucmVmZXJlbmNlcylpZihzLmNvbnRleHQuZ2V0TW9kdWxlRXhlY0luZGV4KCk8PWkpe3RoaXMucmVmZXJlbmNlZEVhcmx5PSEwO2JyZWFrfX19ZHMucHJvdG90eXBlLmlzTmFtZXNwYWNlPSEwO2NsYXNzIEZlIGV4dGVuZHMgdGl7Y29uc3RydWN0b3IodCxpLHMpe3N1cGVyKGkpLHRoaXMuYmFzZVZhcmlhYmxlPW51bGwsdGhpcy5jb250ZXh0PXQsdGhpcy5tb2R1bGU9dC5tb2R1bGUsdGhpcy5zeW50aGV0aWNOYW1lc3BhY2U9c31nZXRCYXNlVmFyaWFibGUoKXtpZih0aGlzLmJhc2VWYXJpYWJsZSlyZXR1cm4gdGhpcy5iYXNlVmFyaWFibGU7bGV0IHQ9dGhpcy5zeW50aGV0aWNOYW1lc3BhY2U7Zm9yKDt0IGluc3RhbmNlb2YgZ3R8fHQgaW5zdGFuY2VvZiBGZTspe2lmKHQgaW5zdGFuY2VvZiBndCl7Y29uc3QgaT10LmdldE9yaWdpbmFsVmFyaWFibGUoKTtpZihpPT09dClicmVhazt0PWl9dCBpbnN0YW5jZW9mIEZlJiYodD10LnN5bnRoZXRpY05hbWVzcGFjZSl9cmV0dXJuIHRoaXMuYmFzZVZhcmlhYmxlPXR9Z2V0QmFzZVZhcmlhYmxlTmFtZSgpe3JldHVybiB0aGlzLnN5bnRoZXRpY05hbWVzcGFjZS5nZXRCYXNlVmFyaWFibGVOYW1lKCl9Z2V0TmFtZSh0KXtyZXR1cm5gJHt0aGlzLnN5bnRoZXRpY05hbWVzcGFjZS5nZXROYW1lKHQpfSR7dCh0aGlzLm5hbWUpfWB9aW5jbHVkZSgpe3RoaXMuaW5jbHVkZWQ9ITAsdGhpcy5jb250ZXh0LmluY2x1ZGVWYXJpYWJsZUluTW9kdWxlKHRoaXMuc3ludGhldGljTmFtZXNwYWNlKX1zZXRSZW5kZXJOYW1lcyh0LGkpe3N1cGVyLnNldFJlbmRlck5hbWVzKHQsaSl9fXZhciBHdDsoZnVuY3Rpb24oZSl7ZVtlLkxPQURfQU5EX1BBUlNFPTBdPSJMT0FEX0FORF9QQVJTRSIsZVtlLkFOQUxZU0U9MV09IkFOQUxZU0UiLGVbZS5HRU5FUkFURT0yXT0iR0VORVJBVEUifSkoR3R8fChHdD17fSkpO2NvbnN0IHpoPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGpyKGUsdCl7aWYoZSl7Y29uc3QgaT16aC5nZXQoZSk7aSYmZnVuY3Rpb24ocyl7cy5lbmNvZGVkTWFwcGluZ3M9PT12b2lkIDAmJnMuZGVjb2RlZE1hcHBpbmdzJiYocy5lbmNvZGVkTWFwcGluZ3M9Rm4uZW5jb2RlKHMuZGVjb2RlZE1hcHBpbmdzKSkscy5kZWNvZGVkTWFwcGluZ3M9dm9pZCAwfShpKX1pZih0KWZvcihjb25zdCBpIG9mIHQpaS5taXNzaW5nfHxqcihpKX1mdW5jdGlvbiAkaShlKXtpZighZSlyZXR1cm4gbnVsbDtpZih0eXBlb2YgZT09InN0cmluZyImJihlPUpTT04ucGFyc2UoZSkpLCFlLm1hcHBpbmdzKXJldHVybnttYXBwaW5nczpbXSxuYW1lczpbXSxzb3VyY2VzOltdLHZlcnNpb246M307Y29uc3QgdD1lLm1hcHBpbmdzLGk9QXJyYXkuaXNBcnJheSh0KSxzPXtkZWNvZGVkTWFwcGluZ3M6aT90OnZvaWQgMCxlbmNvZGVkTWFwcGluZ3M6aT92b2lkIDA6dH0sbj17Li4uZSxnZXQgbWFwcGluZ3MoKXtyZXR1cm4gcy5kZWNvZGVkTWFwcGluZ3N8fChzLmRlY29kZWRNYXBwaW5ncz1zLmVuY29kZWRNYXBwaW5ncz9Gbi5kZWNvZGUocy5lbmNvZGVkTWFwcGluZ3MpOltdLHMuZW5jb2RlZE1hcHBpbmdzPXZvaWQgMCkscy5kZWNvZGVkTWFwcGluZ3N9fTtyZXR1cm4gemguc2V0KG4scyksbn1mdW5jdGlvbiBVcihlKXtyZXR1cm4gZS5pZH1jb25zdCBHcj1lPT57Y29uc3QgdD1lLmtleTtyZXR1cm4gdCYmKHQubmFtZXx8dC52YWx1ZSl9O2Z1bmN0aW9uIHVuKGUsdCl7Y29uc3QgaT1PYmplY3Qua2V5cyhlKTtyZXR1cm4gaS5sZW5ndGghPT1PYmplY3Qua2V5cyh0KS5sZW5ndGh8fGkuc29tZShzPT5lW3NdIT09dFtzXSl9dmFyIGpoPSJwZXJmb3JtYW5jZSJpbih0eXBlb2YgZ2xvYmFsVGhpcz4idSI/dHlwZW9mIHdpbmRvdz4idSI/e306d2luZG93Omdsb2JhbFRoaXMpP3BlcmZvcm1hbmNlOntub3c6KCk9PjB9LFVoPXttZW1vcnlVc2FnZTooKT0+KHtoZWFwVXNlZDowfSl9O2xldCBmcz1uZXcgTWFwO2Z1bmN0aW9uIEdoKGUsdCl7c3dpdGNoKHQpe2Nhc2UgMTpyZXR1cm5gIyAke2V9YDtjYXNlIDI6cmV0dXJuYCMjICR7ZX1gO2Nhc2UgMzpyZXR1cm4gZTtkZWZhdWx0OnJldHVybmAkeyIgICIucmVwZWF0KHQtNCl9LSAke2V9YH19ZnVuY3Rpb24gaGQoZSx0PTMpe2U9R2goZSx0KTtjb25zdCBpPVVoLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQscz1qaC5ub3coKSxuPWZzLmdldChlKTtuPT09dm9pZCAwP2ZzLnNldChlLHttZW1vcnk6MCxzdGFydE1lbW9yeTppLHN0YXJ0VGltZTpzLHRpbWU6MCx0b3RhbE1lbW9yeTowfSk6KG4uc3RhcnRNZW1vcnk9aSxuLnN0YXJ0VGltZT1zKX1mdW5jdGlvbiBsZChlLHQ9Myl7ZT1HaChlLHQpO2NvbnN0IGk9ZnMuZ2V0KGUpO2lmKGkhPT12b2lkIDApe2NvbnN0IHM9VWgubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZDtpLm1lbW9yeSs9cy1pLnN0YXJ0TWVtb3J5LGkudGltZSs9amgubm93KCktaS5zdGFydFRpbWUsaS50b3RhbE1lbW9yeT1NYXRoLm1heChpLnRvdGFsTWVtb3J5LHMpfX1mdW5jdGlvbiB1ZCgpe2NvbnN0IGU9e307Zm9yKGNvbnN0W3Qse21lbW9yeTppLHRpbWU6cyx0b3RhbE1lbW9yeTpufV1vZiBmcyllW3RdPVtzLGksbl07cmV0dXJuIGV9bGV0IENlPXV0LFNlPXV0O2NvbnN0IGNkPVsiYXVnbWVudENodW5rSGFzaCIsImJ1aWxkRW5kIiwiYnVpbGRTdGFydCIsImdlbmVyYXRlQnVuZGxlIiwibG9hZCIsIm1vZHVsZVBhcnNlZCIsIm9wdGlvbnMiLCJvdXRwdXRPcHRpb25zIiwicmVuZGVyQ2h1bmsiLCJyZW5kZXJEeW5hbWljSW1wb3J0IiwicmVuZGVyU3RhcnQiLCJyZXNvbHZlRHluYW1pY0ltcG9ydCIsInJlc29sdmVGaWxlVXJsIiwicmVzb2x2ZUlkIiwicmVzb2x2ZUltcG9ydE1ldGEiLCJzaG91bGRUcmFuc2Zvcm1DYWNoZWRNb2R1bGUiLCJ0cmFuc2Zvcm0iLCJ3cml0ZUJ1bmRsZSJdO2Z1bmN0aW9uIHBkKGUsdCl7aWYoZS5faGFzVGltZXIpcmV0dXJuIGU7ZS5faGFzVGltZXI9ITA7Zm9yKGNvbnN0IGkgb2YgY2QpaWYoaSBpbiBlKXtsZXQgcz1gcGx1Z2luICR7dH1gO2UubmFtZSYmKHMrPWAgKCR7ZS5uYW1lfSlgKSxzKz1gIC0gJHtpfWA7Y29uc3Qgbj1mdW5jdGlvbiguLi5hKXtDZShzLDQpO2NvbnN0IG89ci5hcHBseSh0aGlzLGEpO3JldHVybiBTZShzLDQpLG99O2xldCByO3R5cGVvZiBlW2ldLmhhbmRsZXI9PSJmdW5jdGlvbiI/KHI9ZVtpXS5oYW5kbGVyLGVbaV0uaGFuZGxlcj1uKToocj1lW2ldLGVbaV09bil9cmV0dXJuIGV9ZnVuY3Rpb24gbXMoZSl7ZS5pc0V4ZWN1dGVkPSEwO2NvbnN0IHQ9W2VdLGk9bmV3IFNldDtmb3IoY29uc3QgcyBvZiB0KWZvcihjb25zdCBuIG9mWy4uLnMuZGVwZW5kZW5jaWVzLC4uLnMuaW1wbGljaXRseUxvYWRlZEJlZm9yZV0pbiBpbnN0YW5jZW9mIGxlfHxuLmlzRXhlY3V0ZWR8fCFuLmluZm8ubW9kdWxlU2lkZUVmZmVjdHMmJiFzLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUuaGFzKG4pfHxpLmhhcyhuLmlkKXx8KG4uaXNFeGVjdXRlZD0hMCxpLmFkZChuLmlkKSx0LnB1c2gobikpfWNvbnN0IFdoPXtpZGVudGlmaWVyOm51bGwsbG9jYWxOYW1lOk5pfTtmdW5jdGlvbiBXcihlLHQsaSxzLG49bmV3IE1hcCl7Y29uc3Qgcj1uLmdldCh0KTtpZihyKXtpZihyLmhhcyhlKSlyZXR1cm4gcz9bbnVsbF06TCgoYT10LG89ZS5pZCx7Y29kZTpLYyxleHBvcnRlcjpvLG1lc3NhZ2U6YCIke2F9IiBjYW5ub3QgYmUgZXhwb3J0ZWQgZnJvbSAiJHtYKG8pfSIgYXMgaXQgaXMgYSByZWV4cG9ydCB0aGF0IHJlZmVyZW5jZXMgaXRzZWxmLmB9KSk7ci5hZGQoZSl9ZWxzZSBuLnNldCh0LG5ldyBTZXQoW2VdKSk7dmFyIGEsbztyZXR1cm4gZS5nZXRWYXJpYWJsZUZvckV4cG9ydE5hbWUodCx7aW1wb3J0ZXJGb3JTaWRlRWZmZWN0czppLGlzRXhwb3J0QWxsU2VhcmNoOnMsc2VhcmNoZWROYW1lc0FuZE1vZHVsZXM6bn0pfWZ1bmN0aW9uIHFoKGUsdCl7Y29uc3QgaT1HZSh0LnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlLGUsZWkpO2xldCBzPWU7Y29uc3Qgbj1uZXcgU2V0KFtzXSk7Zm9yKDs7KXtjb25zdCByPXMubW9kdWxlO2lmKHM9cyBpbnN0YW5jZW9mIGd0P3MuZ2V0RGlyZWN0T3JpZ2luYWxWYXJpYWJsZSgpOnMgaW5zdGFuY2VvZiBGZT9zLnN5bnRoZXRpY05hbWVzcGFjZTpudWxsLCFzfHxuLmhhcyhzKSlicmVhaztuLmFkZChzKSxpLmFkZChyKTtjb25zdCBhPXIuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUuZ2V0KHMpO2lmKGEpZm9yKGNvbnN0IG8gb2YgYSlpLmFkZChvKX1yZXR1cm4gaX1jbGFzcyB5ZXtjb25zdHJ1Y3Rvcih0LGkscyxuLHIsYSxvLGgpe3RoaXMuZ3JhcGg9dCx0aGlzLmlkPWksdGhpcy5vcHRpb25zPXMsdGhpcy5hbHRlcm5hdGl2ZVJlZXhwb3J0TW9kdWxlcz1uZXcgTWFwLHRoaXMuY2h1bmtGaWxlTmFtZXM9bmV3IFNldCx0aGlzLmNodW5rTmFtZXM9W10sdGhpcy5jeWNsZXM9bmV3IFNldCx0aGlzLmRlcGVuZGVuY2llcz1uZXcgU2V0LHRoaXMuZHluYW1pY0RlcGVuZGVuY2llcz1uZXcgU2V0LHRoaXMuZHluYW1pY0ltcG9ydGVycz1bXSx0aGlzLmR5bmFtaWNJbXBvcnRzPVtdLHRoaXMuZXhlY0luZGV4PTEvMCx0aGlzLmltcGxpY2l0bHlMb2FkZWRBZnRlcj1uZXcgU2V0LHRoaXMuaW1wbGljaXRseUxvYWRlZEJlZm9yZT1uZXcgU2V0LHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zPW5ldyBNYXAsdGhpcy5pbXBvcnRNZXRhcz1bXSx0aGlzLmltcG9ydGVkRnJvbU5vdFRyZWVzaGFrZW49ITEsdGhpcy5pbXBvcnRlcnM9W10sdGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnM9W10sdGhpcy5pbmNsdWRlZEltcG9ydHM9bmV3IFNldCx0aGlzLmlzRXhlY3V0ZWQ9ITEsdGhpcy5pc1VzZXJEZWZpbmVkRW50cnlQb2ludD0hMSx0aGlzLm5lZWRzRXhwb3J0U2hpbT0hMSx0aGlzLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlPW5ldyBNYXAsdGhpcy5zb3VyY2VzV2l0aEFzc2VydGlvbnM9bmV3IE1hcCx0aGlzLmFsbEV4cG9ydE5hbWVzPW51bGwsdGhpcy5hc3Q9bnVsbCx0aGlzLmV4cG9ydEFsbE1vZHVsZXM9W10sdGhpcy5leHBvcnRBbGxTb3VyY2VzPW5ldyBTZXQsdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGU9bnVsbCx0aGlzLmV4cG9ydFNoaW1WYXJpYWJsZT1uZXcgb2QodGhpcyksdGhpcy5leHBvcnRzPW5ldyBNYXAsdGhpcy5uYW1lc3BhY2VSZWV4cG9ydHNCeU5hbWU9bmV3IE1hcCx0aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zPW5ldyBNYXAsdGhpcy5yZWxldmFudERlcGVuZGVuY2llcz1udWxsLHRoaXMuc3ludGhldGljRXhwb3J0cz1uZXcgTWFwLHRoaXMuc3ludGhldGljTmFtZXNwYWNlPW51bGwsdGhpcy50cmFuc2Zvcm1EZXBlbmRlbmNpZXM9W10sdGhpcy50cmFuc2l0aXZlUmVleHBvcnRzPW51bGwsdGhpcy5leGNsdWRlRnJvbVNvdXJjZW1hcD0vXDAvLnRlc3QoaSksdGhpcy5jb250ZXh0PXMubW9kdWxlQ29udGV4dChpKSx0aGlzLnByZXNlcnZlU2lnbmF0dXJlPXRoaXMub3B0aW9ucy5wcmVzZXJ2ZUVudHJ5U2lnbmF0dXJlcztjb25zdCBsPXRoaXMse2R5bmFtaWNJbXBvcnRzOmMsZHluYW1pY0ltcG9ydGVyczpwLGV4cG9ydEFsbFNvdXJjZXM6bSxleHBvcnRzOnksaW1wbGljaXRseUxvYWRlZEFmdGVyOkUsaW1wbGljaXRseUxvYWRlZEJlZm9yZTpnLGltcG9ydGVyczp4LHJlZXhwb3J0RGVzY3JpcHRpb25zOnYsc291cmNlc1dpdGhBc3NlcnRpb25zOnd9PXRoaXM7dGhpcy5pbmZvPXthc3NlcnRpb25zOmgsYXN0Om51bGwsY29kZTpudWxsLGdldCBkeW5hbWljYWxseUltcG9ydGVkSWRSZXNvbHV0aW9ucygpe3JldHVybiBjLm1hcCgoe2FyZ3VtZW50OmJ9KT0+dHlwZW9mIGI9PSJzdHJpbmciJiZsLnJlc29sdmVkSWRzW2JdKS5maWx0ZXIoQm9vbGVhbil9LGdldCBkeW5hbWljYWxseUltcG9ydGVkSWRzKCl7cmV0dXJuIGMubWFwKCh7aWQ6Yn0pPT5iKS5maWx0ZXIoYj0+YiE9bnVsbCl9LGdldCBkeW5hbWljSW1wb3J0ZXJzKCl7cmV0dXJuIHAuc29ydCgpfSxnZXQgZXhwb3J0ZWRCaW5kaW5ncygpe2NvbnN0IGI9eyIuIjpbLi4ueS5rZXlzKCldfTtmb3IoY29uc3RbUyx7c291cmNlOmt9XW9mIHYpKGJba10/PyhiW2tdPVtdKSkucHVzaChTKTtmb3IoY29uc3QgUyBvZiBtKShiW1NdPz8oYltTXT1bXSkpLnB1c2goIioiKTtyZXR1cm4gYn0sZ2V0IGV4cG9ydHMoKXtyZXR1cm5bLi4ueS5rZXlzKCksLi4udi5rZXlzKCksLi4uWy4uLm1dLm1hcCgoKT0+IioiKV19LGdldCBoYXNEZWZhdWx0RXhwb3J0KCl7cmV0dXJuIGwuYXN0P2wuZXhwb3J0cy5oYXMoImRlZmF1bHQiKXx8di5oYXMoImRlZmF1bHQiKTpudWxsfSxnZXQgaGFzTW9kdWxlU2lkZUVmZmVjdHMoKXtyZXR1cm4gbmkoIkFjY2Vzc2luZyBNb2R1bGVJbmZvLmhhc01vZHVsZVNpZGVFZmZlY3RzIGZyb20gcGx1Z2lucyBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIE1vZHVsZUluZm8ubW9kdWxlU2lkZUVmZmVjdHMgaW5zdGVhZC4iLHVvLCEwLHMpLHRoaXMubW9kdWxlU2lkZUVmZmVjdHN9LGlkOmksZ2V0IGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mKCl7cmV0dXJuIEFycmF5LmZyb20oRSxVcikuc29ydCgpfSxnZXQgaW1wbGljaXRseUxvYWRlZEJlZm9yZSgpe3JldHVybiBBcnJheS5mcm9tKGcsVXIpLnNvcnQoKX0sZ2V0IGltcG9ydGVkSWRSZXNvbHV0aW9ucygpe3JldHVybiBBcnJheS5mcm9tKHcua2V5cygpLGI9PmwucmVzb2x2ZWRJZHNbYl0pLmZpbHRlcihCb29sZWFuKX0sZ2V0IGltcG9ydGVkSWRzKCl7cmV0dXJuIEFycmF5LmZyb20ody5rZXlzKCksYj0+e3ZhciBTO3JldHVybihTPWwucmVzb2x2ZWRJZHNbYl0pPT1udWxsP3ZvaWQgMDpTLmlkfSkuZmlsdGVyKEJvb2xlYW4pfSxnZXQgaW1wb3J0ZXJzKCl7cmV0dXJuIHguc29ydCgpfSxpc0VudHJ5Om4saXNFeHRlcm5hbDohMSxnZXQgaXNJbmNsdWRlZCgpe3JldHVybiB0LnBoYXNlIT09R3QuR0VORVJBVEU/bnVsbDpsLmlzSW5jbHVkZWQoKX0sbWV0YTp7Li4ub30sbW9kdWxlU2lkZUVmZmVjdHM6cixzeW50aGV0aWNOYW1lZEV4cG9ydHM6YX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuaW5mbywiaGFzTW9kdWxlU2lkZUVmZmVjdHMiLHtlbnVtZXJhYmxlOiExfSl9YmFzZW5hbWUoKXtjb25zdCB0PUN0KHRoaXMuaWQpLGk9TXQodGhpcy5pZCk7cmV0dXJuIEhuKGk/dC5zbGljZSgwLC1pLmxlbmd0aCk6dCl9YmluZFJlZmVyZW5jZXMoKXt0aGlzLmFzdC5iaW5kKCl9ZXJyb3IodCxpKXtyZXR1cm4gdGhpcy5hZGRMb2NhdGlvblRvTG9nUHJvcHModCxpKSxMKHQpfWVzdGltYXRlU2l6ZSgpe2xldCB0PTA7Zm9yKGNvbnN0IGkgb2YgdGhpcy5hc3QuYm9keSlpLmluY2x1ZGVkJiYodCs9aS5lbmQtaS5zdGFydCk7cmV0dXJuIHR9Z2V0QWxsRXhwb3J0TmFtZXMoKXtpZih0aGlzLmFsbEV4cG9ydE5hbWVzKXJldHVybiB0aGlzLmFsbEV4cG9ydE5hbWVzO3RoaXMuYWxsRXhwb3J0TmFtZXM9bmV3IFNldChbLi4udGhpcy5leHBvcnRzLmtleXMoKSwuLi50aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLmtleXMoKV0pO2Zvcihjb25zdCB0IG9mIHRoaXMuZXhwb3J0QWxsTW9kdWxlcylpZih0IGluc3RhbmNlb2YgbGUpdGhpcy5hbGxFeHBvcnROYW1lcy5hZGQoYCoke3QuaWR9YCk7ZWxzZSBmb3IoY29uc3QgaSBvZiB0LmdldEFsbEV4cG9ydE5hbWVzKCkpaSE9PSJkZWZhdWx0IiYmdGhpcy5hbGxFeHBvcnROYW1lcy5hZGQoaSk7cmV0dXJuIHR5cGVvZiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzPT0ic3RyaW5nIiYmdGhpcy5hbGxFeHBvcnROYW1lcy5kZWxldGUodGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyksdGhpcy5hbGxFeHBvcnROYW1lc31nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKXtpZih0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzKXJldHVybiB0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzO3RoaXMucmVsZXZhbnREZXBlbmRlbmNpZXM9bmV3IFNldDtjb25zdCB0PW5ldyBTZXQsaT1uZXcgU2V0LHM9bmV3IFNldCh0aGlzLmluY2x1ZGVkSW1wb3J0cyk7aWYodGhpcy5pbmZvLmlzRW50cnl8fHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLmxlbmd0aD4wfHx0aGlzLm5hbWVzcGFjZS5pbmNsdWRlZHx8dGhpcy5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuc2l6ZT4wKWZvcihjb25zdCBuIG9mWy4uLnRoaXMuZ2V0UmVleHBvcnRzKCksLi4udGhpcy5nZXRFeHBvcnRzKCldKXtjb25zdFtyXT10aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShuKTtyIT1udWxsJiZyLmluY2x1ZGVkJiZzLmFkZChyKX1mb3IobGV0IG4gb2Ygcyl7Y29uc3Qgcj10aGlzLnNpZGVFZmZlY3REZXBlbmRlbmNpZXNCeVZhcmlhYmxlLmdldChuKTtpZihyKWZvcihjb25zdCBhIG9mIHIpaS5hZGQoYSk7biBpbnN0YW5jZW9mIEZlP249bi5nZXRCYXNlVmFyaWFibGUoKTpuIGluc3RhbmNlb2YgZ3QmJihuPW4uZ2V0T3JpZ2luYWxWYXJpYWJsZSgpKSx0LmFkZChuLm1vZHVsZSl9aWYodGhpcy5vcHRpb25zLnRyZWVzaGFrZSYmdGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzIT09Im5vLXRyZWVzaGFrZSIpdGhpcy5hZGRSZWxldmFudFNpZGVFZmZlY3REZXBlbmRlbmNpZXModGhpcy5yZWxldmFudERlcGVuZGVuY2llcyx0LGkpO2Vsc2UgZm9yKGNvbnN0IG4gb2YgdGhpcy5kZXBlbmRlbmNpZXMpdGhpcy5yZWxldmFudERlcGVuZGVuY2llcy5hZGQobik7Zm9yKGNvbnN0IG4gb2YgdCl0aGlzLnJlbGV2YW50RGVwZW5kZW5jaWVzLmFkZChuKTtyZXR1cm4gdGhpcy5yZWxldmFudERlcGVuZGVuY2llc31nZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKXtpZih0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSlyZXR1cm4gdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGU7Y29uc3QgdD1uZXcgTWFwO2Zvcihjb25zdCBpIG9mIHRoaXMuZ2V0QWxsRXhwb3J0TmFtZXMoKSl7bGV0W3NdPXRoaXMuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKGkpO2lmKHMgaW5zdGFuY2VvZiBndCYmKHM9cy5nZXRPcmlnaW5hbFZhcmlhYmxlKCkpLCFzfHwhKHMuaW5jbHVkZWR8fHMgaW5zdGFuY2VvZiBWcykpY29udGludWU7Y29uc3Qgbj10LmdldChzKTtuP24ucHVzaChpKTp0LnNldChzLFtpXSl9cmV0dXJuIHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlPXR9Z2V0RXhwb3J0cygpe3JldHVyblsuLi50aGlzLmV4cG9ydHMua2V5cygpXX1nZXRSZWV4cG9ydHMoKXtpZih0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHMpcmV0dXJuIHRoaXMudHJhbnNpdGl2ZVJlZXhwb3J0czt0aGlzLnRyYW5zaXRpdmVSZWV4cG9ydHM9W107Y29uc3QgdD1uZXcgU2V0KHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMua2V5cygpKTtmb3IoY29uc3QgaSBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpaWYoaSBpbnN0YW5jZW9mIGxlKXQuYWRkKGAqJHtpLmlkfWApO2Vsc2UgZm9yKGNvbnN0IHMgb2ZbLi4uaS5nZXRSZWV4cG9ydHMoKSwuLi5pLmdldEV4cG9ydHMoKV0pcyE9PSJkZWZhdWx0IiYmdC5hZGQocyk7cmV0dXJuIHRoaXMudHJhbnNpdGl2ZVJlZXhwb3J0cz1bLi4udF19Z2V0UmVuZGVyZWRFeHBvcnRzKCl7Y29uc3QgdD1bXSxpPVtdO2Zvcihjb25zdCBzIG9mIHRoaXMuZXhwb3J0cy5rZXlzKCkpe2NvbnN0W25dPXRoaXMuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKHMpOyhuJiZuLmluY2x1ZGVkP3Q6aSkucHVzaChzKX1yZXR1cm57cmVtb3ZlZEV4cG9ydHM6aSxyZW5kZXJlZEV4cG9ydHM6dH19Z2V0U3ludGhldGljTmFtZXNwYWNlKCl7cmV0dXJuIHRoaXMuc3ludGhldGljTmFtZXNwYWNlPT09bnVsbCYmKHRoaXMuc3ludGhldGljTmFtZXNwYWNlPXZvaWQgMCxbdGhpcy5zeW50aGV0aWNOYW1lc3BhY2VdPXRoaXMuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKHR5cGVvZiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzPT0ic3RyaW5nIj90aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzOiJkZWZhdWx0Iix7b25seUV4cGxpY2l0OiEwfSkpLHRoaXMuc3ludGhldGljTmFtZXNwYWNlP3RoaXMuc3ludGhldGljTmFtZXNwYWNlOkwoKHQ9dGhpcy5pZCxpPXRoaXMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMse2NvZGU6IlNZTlRIRVRJQ19OQU1FRF9FWFBPUlRTX05FRURfTkFNRVNQQUNFX0VYUE9SVCIsZXhwb3J0ZXI6dCxtZXNzYWdlOmBNb2R1bGUgIiR7WCh0KX0iIHRoYXQgaXMgbWFya2VkIHdpdGggXGBzeW50aGV0aWNOYW1lZEV4cG9ydHM6ICR7SlNPTi5zdHJpbmdpZnkoaSl9XGAgbmVlZHMgJHt0eXBlb2YgaT09InN0cmluZyImJmkhPT0iZGVmYXVsdCI/YGFuIGV4cGxpY2l0IGV4cG9ydCBuYW1lZCAiJHtpfSJgOiJhIGRlZmF1bHQgZXhwb3J0In0gdGhhdCBkb2VzIG5vdCByZWV4cG9ydCBhbiB1bnJlc29sdmVkIG5hbWVkIGV4cG9ydCBvZiB0aGUgc2FtZSBtb2R1bGUuYH0pKTt2YXIgdCxpfWdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSh0LHtpbXBvcnRlckZvclNpZGVFZmZlY3RzOmksaXNFeHBvcnRBbGxTZWFyY2g6cyxvbmx5RXhwbGljaXQ6bixzZWFyY2hlZE5hbWVzQW5kTW9kdWxlczpyfT1xZSl7aWYodFswXT09PSIqIilyZXR1cm4gdC5sZW5ndGg9PT0xP1t0aGlzLm5hbWVzcGFjZV06dGhpcy5ncmFwaC5tb2R1bGVzQnlJZC5nZXQodC5zbGljZSgxKSkuZ2V0VmFyaWFibGVGb3JFeHBvcnROYW1lKCIqIik7Y29uc3QgYT10aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zLmdldCh0KTtpZihhKXtjb25zdFtoXT1XcihhLm1vZHVsZSxhLmxvY2FsTmFtZSxpLCExLHIpO3JldHVybiBoPyhpJiYoSGgoaCxpLHRoaXMpLHRoaXMuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyYmR2UoaS5zaWRlRWZmZWN0RGVwZW5kZW5jaWVzQnlWYXJpYWJsZSxoLGVpKS5hZGQodGhpcykpLFtoXSk6dGhpcy5lcnJvcihGcyhhLmxvY2FsTmFtZSx0aGlzLmlkLGEubW9kdWxlLmlkKSxhLnN0YXJ0KX1jb25zdCBvPXRoaXMuZXhwb3J0cy5nZXQodCk7aWYobyl7aWYobz09PVdoKXJldHVyblt0aGlzLmV4cG9ydFNoaW1WYXJpYWJsZV07Y29uc3QgaD1vLmxvY2FsTmFtZSxsPXRoaXMudHJhY2VWYXJpYWJsZShoLHtpbXBvcnRlckZvclNpZGVFZmZlY3RzOmksc2VhcmNoZWROYW1lc0FuZE1vZHVsZXM6cn0pO3JldHVybiBpJiYoSGgobCxpLHRoaXMpLEdlKGkuc2lkZUVmZmVjdERlcGVuZGVuY2llc0J5VmFyaWFibGUsbCxlaSkuYWRkKHRoaXMpKSxbbF19aWYobilyZXR1cm5bbnVsbF07aWYodCE9PSJkZWZhdWx0Iil7Y29uc3QgaD10aGlzLm5hbWVzcGFjZVJlZXhwb3J0c0J5TmFtZS5nZXQodCk/P3RoaXMuZ2V0VmFyaWFibGVGcm9tTmFtZXNwYWNlUmVleHBvcnRzKHQsaSxyKTtpZih0aGlzLm5hbWVzcGFjZVJlZXhwb3J0c0J5TmFtZS5zZXQodCxoKSxoWzBdKXJldHVybiBofXJldHVybiB0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzP1tHZSh0aGlzLnN5bnRoZXRpY0V4cG9ydHMsdCwoKT0+bmV3IEZlKHRoaXMuYXN0Q29udGV4dCx0LHRoaXMuZ2V0U3ludGhldGljTmFtZXNwYWNlKCkpKV06IXMmJnRoaXMub3B0aW9ucy5zaGltTWlzc2luZ0V4cG9ydHM/KHRoaXMuc2hpbU1pc3NpbmdFeHBvcnQodCksW3RoaXMuZXhwb3J0U2hpbVZhcmlhYmxlXSk6W251bGxdfWhhc0VmZmVjdHMoKXtyZXR1cm4gdGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzPT09Im5vLXRyZWVzaGFrZSJ8fHRoaXMuYXN0Lmhhc0NhY2hlZEVmZmVjdHMoKX1pbmNsdWRlKCl7Y29uc3QgdD1pcigpO3RoaXMuYXN0LnNob3VsZEJlSW5jbHVkZWQodCkmJnRoaXMuYXN0LmluY2x1ZGUodCwhMSl9aW5jbHVkZUFsbEV4cG9ydHModCl7dGhpcy5pc0V4ZWN1dGVkfHwobXModGhpcyksdGhpcy5ncmFwaC5uZWVkc1RyZWVzaGFraW5nUGFzcz0hMCk7Zm9yKGNvbnN0IGkgb2YgdGhpcy5leHBvcnRzLmtleXMoKSlpZih0fHxpIT09dGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyl7Y29uc3Qgcz10aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShpKVswXTtzLmRlb3B0aW1pemVQYXRoKHRlKSxzLmluY2x1ZGVkfHx0aGlzLmluY2x1ZGVWYXJpYWJsZShzKX1mb3IoY29uc3QgaSBvZiB0aGlzLmdldFJlZXhwb3J0cygpKXtjb25zdFtzXT10aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShpKTtzJiYocy5kZW9wdGltaXplUGF0aCh0ZSkscy5pbmNsdWRlZHx8dGhpcy5pbmNsdWRlVmFyaWFibGUocykscyBpbnN0YW5jZW9mIFZzJiYocy5tb2R1bGUucmVleHBvcnRlZD0hMCkpfXQmJnRoaXMubmFtZXNwYWNlLnNldE1lcmdlZE5hbWVzcGFjZXModGhpcy5pbmNsdWRlQW5kR2V0QWRkaXRpb25hbE1lcmdlZE5hbWVzcGFjZXMoKSl9aW5jbHVkZUFsbEluQnVuZGxlKCl7dGhpcy5hc3QuaW5jbHVkZShpcigpLCEwKSx0aGlzLmluY2x1ZGVBbGxFeHBvcnRzKCExKX1pbmNsdWRlRXhwb3J0c0J5TmFtZXModCl7dGhpcy5pc0V4ZWN1dGVkfHwobXModGhpcyksdGhpcy5ncmFwaC5uZWVkc1RyZWVzaGFraW5nUGFzcz0hMCk7bGV0IGk9ITE7Zm9yKGNvbnN0IHMgb2YgdCl7Y29uc3Qgbj10aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShzKVswXTtuJiYobi5kZW9wdGltaXplUGF0aCh0ZSksbi5pbmNsdWRlZHx8dGhpcy5pbmNsdWRlVmFyaWFibGUobikpLHRoaXMuZXhwb3J0cy5oYXMocyl8fHRoaXMucmVleHBvcnREZXNjcmlwdGlvbnMuaGFzKHMpfHwoaT0hMCl9aSYmdGhpcy5uYW1lc3BhY2Uuc2V0TWVyZ2VkTmFtZXNwYWNlcyh0aGlzLmluY2x1ZGVBbmRHZXRBZGRpdGlvbmFsTWVyZ2VkTmFtZXNwYWNlcygpKX1pc0luY2x1ZGVkKCl7cmV0dXJuIHRoaXMuYXN0JiYodGhpcy5hc3QuaW5jbHVkZWR8fHRoaXMubmFtZXNwYWNlLmluY2x1ZGVkfHx0aGlzLmltcG9ydGVkRnJvbU5vdFRyZWVzaGFrZW58fHRoaXMuZXhwb3J0U2hpbVZhcmlhYmxlLmluY2x1ZGVkKX1saW5rSW1wb3J0cygpe3RoaXMuYWRkTW9kdWxlc1RvSW1wb3J0RGVzY3JpcHRpb25zKHRoaXMuaW1wb3J0RGVzY3JpcHRpb25zKSx0aGlzLmFkZE1vZHVsZXNUb0ltcG9ydERlc2NyaXB0aW9ucyh0aGlzLnJlZXhwb3J0RGVzY3JpcHRpb25zKTtjb25zdCB0PVtdO2Zvcihjb25zdCBpIG9mIHRoaXMuZXhwb3J0QWxsU291cmNlcyl7Y29uc3Qgcz10aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmdldCh0aGlzLnJlc29sdmVkSWRzW2ldLmlkKTtzIGluc3RhbmNlb2YgbGU/dC5wdXNoKHMpOnRoaXMuZXhwb3J0QWxsTW9kdWxlcy5wdXNoKHMpfXRoaXMuZXhwb3J0QWxsTW9kdWxlcy5wdXNoKC4uLnQpfWxvZyh0LGkscyl7dGhpcy5hZGRMb2NhdGlvblRvTG9nUHJvcHMoaSxzKSx0aGlzLm9wdGlvbnMub25Mb2codCxpKX1yZW5kZXIodCl7Y29uc3QgaT10aGlzLm1hZ2ljU3RyaW5nLmNsb25lKCk7dGhpcy5hc3QucmVuZGVyKGksdCksaS50cmltKCk7Y29uc3R7dXNlc1RvcExldmVsQXdhaXQ6c309dGhpcy5hc3RDb250ZXh0O3JldHVybiBzJiZ0LmZvcm1hdCE9PSJlcyImJnQuZm9ybWF0IT09InN5c3RlbSI/TCgobj10aGlzLmlkLHI9dC5mb3JtYXQse2NvZGU6IklOVkFMSURfVExBX0ZPUk1BVCIsaWQ6bixtZXNzYWdlOmBNb2R1bGUgZm9ybWF0ICIke3J9IiBkb2VzIG5vdCBzdXBwb3J0IHRvcC1sZXZlbCBhd2FpdC4gVXNlIHRoZSAiZXMiIG9yICJzeXN0ZW0iIG91dHB1dCBmb3JtYXRzIHJhdGhlci5gfSkpOntzb3VyY2U6aSx1c2VzVG9wTGV2ZWxBd2FpdDpzfTt2YXIgbixyfXNldFNvdXJjZSh7YXN0OnQsY29kZTppLGN1c3RvbVRyYW5zZm9ybUNhY2hlOnMsb3JpZ2luYWxDb2RlOm4sb3JpZ2luYWxTb3VyY2VtYXA6cixyZXNvbHZlZElkczphLHNvdXJjZW1hcENoYWluOm8sdHJhbnNmb3JtRGVwZW5kZW5jaWVzOmgsdHJhbnNmb3JtRmlsZXM6bCwuLi5jfSl7Q2UoImdlbmVyYXRlIGFzdCIsMyksdGhpcy5pbmZvLmNvZGU9aSx0aGlzLm9yaWdpbmFsQ29kZT1uLHRoaXMub3JpZ2luYWxTb3VyY2VtYXA9JGkociksdGhpcy5zb3VyY2VtYXBDaGFpbj1vLm1hcCh5PT55Lm1pc3Npbmc/eTokaSh5KSksanIodGhpcy5vcmlnaW5hbFNvdXJjZW1hcCx0aGlzLnNvdXJjZW1hcENoYWluKSxsJiYodGhpcy50cmFuc2Zvcm1GaWxlcz1sKSx0aGlzLnRyYW5zZm9ybURlcGVuZGVuY2llcz1oLHRoaXMuY3VzdG9tVHJhbnNmb3JtQ2FjaGU9cyx0aGlzLnVwZGF0ZU9wdGlvbnMoYyk7Y29uc3QgcD10Pz90aGlzLnRyeVBhcnNlKCk7U2UoImdlbmVyYXRlIGFzdCIsMyksQ2UoImFuYWx5emUgYXN0IiwzKSx0aGlzLnJlc29sdmVkSWRzPWE/P09iamVjdC5jcmVhdGUobnVsbCk7Y29uc3QgbT10aGlzLmlkO3RoaXMubWFnaWNTdHJpbmc9bmV3IFp0KGkse2ZpbGVuYW1lOnRoaXMuZXhjbHVkZUZyb21Tb3VyY2VtYXA/bnVsbDptLGluZGVudEV4Y2x1c2lvblJhbmdlczpbXX0pLHRoaXMuYXN0Q29udGV4dD17YWRkRHluYW1pY0ltcG9ydDp0aGlzLmFkZER5bmFtaWNJbXBvcnQuYmluZCh0aGlzKSxhZGRFeHBvcnQ6dGhpcy5hZGRFeHBvcnQuYmluZCh0aGlzKSxhZGRJbXBvcnQ6dGhpcy5hZGRJbXBvcnQuYmluZCh0aGlzKSxhZGRJbXBvcnRNZXRhOnRoaXMuYWRkSW1wb3J0TWV0YS5iaW5kKHRoaXMpLGNvZGU6aSxkZW9wdGltaXphdGlvblRyYWNrZXI6dGhpcy5ncmFwaC5kZW9wdGltaXphdGlvblRyYWNrZXIsZXJyb3I6dGhpcy5lcnJvci5iaW5kKHRoaXMpLGZpbGVOYW1lOm0sZ2V0RXhwb3J0czp0aGlzLmdldEV4cG9ydHMuYmluZCh0aGlzKSxnZXRNb2R1bGVFeGVjSW5kZXg6KCk9PnRoaXMuZXhlY0luZGV4LGdldE1vZHVsZU5hbWU6dGhpcy5iYXNlbmFtZS5iaW5kKHRoaXMpLGdldE5vZGVDb25zdHJ1Y3Rvcjp5PT5GaFt5XXx8RmguVW5rbm93bk5vZGUsZ2V0UmVleHBvcnRzOnRoaXMuZ2V0UmVleHBvcnRzLmJpbmQodGhpcyksaW1wb3J0RGVzY3JpcHRpb25zOnRoaXMuaW1wb3J0RGVzY3JpcHRpb25zLGluY2x1ZGVBbGxFeHBvcnRzOigpPT50aGlzLmluY2x1ZGVBbGxFeHBvcnRzKCEwKSxpbmNsdWRlRHluYW1pY0ltcG9ydDp0aGlzLmluY2x1ZGVEeW5hbWljSW1wb3J0LmJpbmQodGhpcyksaW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGU6dGhpcy5pbmNsdWRlVmFyaWFibGVJbk1vZHVsZS5iaW5kKHRoaXMpLGxvZzp0aGlzLmxvZy5iaW5kKHRoaXMpLG1hZ2ljU3RyaW5nOnRoaXMubWFnaWNTdHJpbmcsbWFudWFsUHVyZUZ1bmN0aW9uczp0aGlzLmdyYXBoLnB1cmVGdW5jdGlvbnMsbW9kdWxlOnRoaXMsbW9kdWxlQ29udGV4dDp0aGlzLmNvbnRleHQsb3B0aW9uczp0aGlzLm9wdGlvbnMscmVxdWVzdFRyZWVzaGFraW5nUGFzczooKT0+dGhpcy5ncmFwaC5uZWVkc1RyZWVzaGFraW5nUGFzcz0hMCx0cmFjZUV4cG9ydDp5PT50aGlzLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSh5KVswXSx0cmFjZVZhcmlhYmxlOnRoaXMudHJhY2VWYXJpYWJsZS5iaW5kKHRoaXMpLHVzZXNUb3BMZXZlbEF3YWl0OiExfSx0aGlzLnNjb3BlPW5ldyBEaCh0aGlzLmdyYXBoLnNjb3BlLHRoaXMuYXN0Q29udGV4dCksdGhpcy5uYW1lc3BhY2U9bmV3IGRzKHRoaXMuYXN0Q29udGV4dCksdGhpcy5hc3Q9bmV3IFJoKHAse2NvbnRleHQ6dGhpcy5hc3RDb250ZXh0LHR5cGU6Ik1vZHVsZSJ9LHRoaXMuc2NvcGUpLHR8fHRoaXMub3B0aW9ucy5jYWNoZSE9PSExP3RoaXMuaW5mby5hc3Q9cDpPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5pbmZvLCJhc3QiLHtnZXQ6KCk9PntpZih0aGlzLmdyYXBoLmFzdExydS5oYXMobSkpcmV0dXJuIHRoaXMuZ3JhcGguYXN0THJ1LmdldChtKTt7Y29uc3QgeT10aGlzLnRyeVBhcnNlKCk7cmV0dXJuIHRoaXMuZ3JhcGguYXN0THJ1LnNldChtLHkpLHl9fX0pLFNlKCJhbmFseXplIGFzdCIsMyl9dG9KU09OKCl7cmV0dXJue2Fzc2VydGlvbnM6dGhpcy5pbmZvLmFzc2VydGlvbnMsYXN0OnRoaXMuaW5mby5hc3QsY29kZTp0aGlzLmluZm8uY29kZSxjdXN0b21UcmFuc2Zvcm1DYWNoZTp0aGlzLmN1c3RvbVRyYW5zZm9ybUNhY2hlLGRlcGVuZGVuY2llczpBcnJheS5mcm9tKHRoaXMuZGVwZW5kZW5jaWVzLFVyKSxpZDp0aGlzLmlkLG1ldGE6dGhpcy5pbmZvLm1ldGEsbW9kdWxlU2lkZUVmZmVjdHM6dGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzLG9yaWdpbmFsQ29kZTp0aGlzLm9yaWdpbmFsQ29kZSxvcmlnaW5hbFNvdXJjZW1hcDp0aGlzLm9yaWdpbmFsU291cmNlbWFwLHJlc29sdmVkSWRzOnRoaXMucmVzb2x2ZWRJZHMsc291cmNlbWFwQ2hhaW46dGhpcy5zb3VyY2VtYXBDaGFpbixzeW50aGV0aWNOYW1lZEV4cG9ydHM6dGhpcy5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyx0cmFuc2Zvcm1EZXBlbmRlbmNpZXM6dGhpcy50cmFuc2Zvcm1EZXBlbmRlbmNpZXMsdHJhbnNmb3JtRmlsZXM6dGhpcy50cmFuc2Zvcm1GaWxlc319dHJhY2VWYXJpYWJsZSh0LHtpbXBvcnRlckZvclNpZGVFZmZlY3RzOmksaXNFeHBvcnRBbGxTZWFyY2g6cyxzZWFyY2hlZE5hbWVzQW5kTW9kdWxlczpufT1xZSl7Y29uc3Qgcj10aGlzLnNjb3BlLnZhcmlhYmxlcy5nZXQodCk7aWYocilyZXR1cm4gcjtjb25zdCBhPXRoaXMuaW1wb3J0RGVzY3JpcHRpb25zLmdldCh0KTtpZihhKXtjb25zdCBvPWEubW9kdWxlO2lmKG8gaW5zdGFuY2VvZiB5ZSYmYS5uYW1lPT09IioiKXJldHVybiBvLm5hbWVzcGFjZTtjb25zdFtoXT1XcihvLGEubmFtZSxpfHx0aGlzLHMsbik7cmV0dXJuIGh8fHRoaXMuZXJyb3IoRnMoYS5uYW1lLHRoaXMuaWQsby5pZCksYS5zdGFydCl9cmV0dXJuIG51bGx9dXBkYXRlT3B0aW9ucyh7bWV0YTp0LG1vZHVsZVNpZGVFZmZlY3RzOmksc3ludGhldGljTmFtZWRFeHBvcnRzOnN9KXtpIT1udWxsJiYodGhpcy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzPWkpLHMhPW51bGwmJih0aGlzLmluZm8uc3ludGhldGljTmFtZWRFeHBvcnRzPXMpLHQhPW51bGwmJk9iamVjdC5hc3NpZ24odGhpcy5pbmZvLm1ldGEsdCl9YWRkRHluYW1pY0ltcG9ydCh0KXtsZXQgaT10LnNvdXJjZTtpIGluc3RhbmNlb2YgVmg/aS5xdWFzaXMubGVuZ3RoPT09MSYmaS5xdWFzaXNbMF0udmFsdWUuY29va2VkJiYoaT1pLnF1YXNpc1swXS52YWx1ZS5jb29rZWQpOmkgaW5zdGFuY2VvZiBjaSYmdHlwZW9mIGkudmFsdWU9PSJzdHJpbmciJiYoaT1pLnZhbHVlKSx0aGlzLmR5bmFtaWNJbXBvcnRzLnB1c2goe2FyZ3VtZW50OmksaWQ6bnVsbCxub2RlOnQscmVzb2x1dGlvbjpudWxsfSl9YWRkRXhwb3J0KHQpe2lmKHQgaW5zdGFuY2VvZiBzbil0aGlzLmV4cG9ydHMuc2V0KCJkZWZhdWx0Iix7aWRlbnRpZmllcjp0LnZhcmlhYmxlLmdldEFzc2lnbmVkVmFyaWFibGVOYW1lKCksbG9jYWxOYW1lOiJkZWZhdWx0In0pO2Vsc2UgaWYodCBpbnN0YW5jZW9mIElyKXtjb25zdCBpPXQuc291cmNlLnZhbHVlO2lmKHRoaXMuYWRkU291cmNlKGksdCksdC5leHBvcnRlZCl7Y29uc3Qgcz10LmV4cG9ydGVkLm5hbWU7dGhpcy5yZWV4cG9ydERlc2NyaXB0aW9ucy5zZXQocyx7bG9jYWxOYW1lOiIqIixtb2R1bGU6bnVsbCxzb3VyY2U6aSxzdGFydDp0LnN0YXJ0fSl9ZWxzZSB0aGlzLmV4cG9ydEFsbFNvdXJjZXMuYWRkKGkpfWVsc2UgaWYodC5zb3VyY2UgaW5zdGFuY2VvZiBjaSl7Y29uc3QgaT10LnNvdXJjZS52YWx1ZTt0aGlzLmFkZFNvdXJjZShpLHQpO2Zvcihjb25zdHtleHBvcnRlZDpzLGxvY2FsOm4sc3RhcnQ6cn1vZiB0LnNwZWNpZmllcnMpe2NvbnN0IGE9cyBpbnN0YW5jZW9mIGNpP3MudmFsdWU6cy5uYW1lO3RoaXMucmVleHBvcnREZXNjcmlwdGlvbnMuc2V0KGEse2xvY2FsTmFtZTpuIGluc3RhbmNlb2YgY2k/bi52YWx1ZTpuLm5hbWUsbW9kdWxlOm51bGwsc291cmNlOmksc3RhcnQ6cn0pfX1lbHNlIGlmKHQuZGVjbGFyYXRpb24pe2NvbnN0IGk9dC5kZWNsYXJhdGlvbjtpZihpIGluc3RhbmNlb2YgQmgpZm9yKGNvbnN0IHMgb2YgaS5kZWNsYXJhdGlvbnMpZm9yKGNvbnN0IG4gb2YgYnAocy5pZCkpdGhpcy5leHBvcnRzLnNldChuLHtpZGVudGlmaWVyOm51bGwsbG9jYWxOYW1lOm59KTtlbHNle2NvbnN0IHM9aS5pZC5uYW1lO3RoaXMuZXhwb3J0cy5zZXQocyx7aWRlbnRpZmllcjpudWxsLGxvY2FsTmFtZTpzfSl9fWVsc2UgZm9yKGNvbnN0e2xvY2FsOmksZXhwb3J0ZWQ6c31vZiB0LnNwZWNpZmllcnMpe2NvbnN0IG49aS5uYW1lLHI9cyBpbnN0YW5jZW9mIGNlP3MubmFtZTpzLnZhbHVlO3RoaXMuZXhwb3J0cy5zZXQocix7aWRlbnRpZmllcjpudWxsLGxvY2FsTmFtZTpufSl9fWFkZEltcG9ydCh0KXtjb25zdCBpPXQuc291cmNlLnZhbHVlO3RoaXMuYWRkU291cmNlKGksdCk7Zm9yKGNvbnN0IHMgb2YgdC5zcGVjaWZpZXJzKXtjb25zdCBuPXMgaW5zdGFuY2VvZiB2aD8iZGVmYXVsdCI6cyBpbnN0YW5jZW9mICRoPyIqIjpzLmltcG9ydGVkIGluc3RhbmNlb2YgY2U/cy5pbXBvcnRlZC5uYW1lOnMuaW1wb3J0ZWQudmFsdWU7dGhpcy5pbXBvcnREZXNjcmlwdGlvbnMuc2V0KHMubG9jYWwubmFtZSx7bW9kdWxlOm51bGwsbmFtZTpuLHNvdXJjZTppLHN0YXJ0OnMuc3RhcnR9KX19YWRkSW1wb3J0TWV0YSh0KXt0aGlzLmltcG9ydE1ldGFzLnB1c2godCl9YWRkTG9jYXRpb25Ub0xvZ1Byb3BzKHQsaSl7dC5pZD10aGlzLmlkLHQucG9zPWk7bGV0IHM9dGhpcy5pbmZvLmNvZGU7Y29uc3Qgbj1LbihzLGkse29mZnNldExpbmU6MX0pO2lmKG4pe2xldHtjb2x1bW46cixsaW5lOmF9PW47dHJ5eyh7Y29sdW1uOnIsbGluZTphfT1mdW5jdGlvbihvLGgpe2NvbnN0IGw9by5maWx0ZXIoYz0+IWMubWlzc2luZyk7ZTpmb3IoO2wubGVuZ3RoPjA7KXtjb25zdCBjPWwucG9wKCkubWFwcGluZ3NbaC5saW5lLTFdO2lmKGMpe2NvbnN0IHA9Yy5maWx0ZXIoeT0+eS5sZW5ndGg+MSksbT1wW3AubGVuZ3RoLTFdO2Zvcihjb25zdCB5IG9mIHApaWYoeVswXT49aC5jb2x1bW58fHk9PT1tKXtoPXtjb2x1bW46eVszXSxsaW5lOnlbMl0rMX07Y29udGludWUgZX19dGhyb3cgbmV3IEVycm9yKCJDYW4ndCByZXNvbHZlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIGVycm9yLiIpfXJldHVybiBofSh0aGlzLnNvdXJjZW1hcENoYWluLHtjb2x1bW46cixsaW5lOmF9KSkscz10aGlzLm9yaWdpbmFsQ29kZX1jYXRjaChvKXt0aGlzLm9wdGlvbnMub25Mb2coSyxmdW5jdGlvbihoLGwsYyxwLG0pe3JldHVybntjYXVzZTpoLGNvZGU6IlNPVVJDRU1BUF9FUlJPUiIsaWQ6bCxsb2M6e2NvbHVtbjpjLGZpbGU6bCxsaW5lOnB9LG1lc3NhZ2U6YEVycm9yIHdoZW4gdXNpbmcgc291cmNlbWFwIGZvciByZXBvcnRpbmcgYW4gZXJyb3I6ICR7aC5tZXNzYWdlfWAscG9zOm19fShvLHRoaXMuaWQscixhLGkpKX1Ecyh0LHtjb2x1bW46cixsaW5lOmF9LHMsdGhpcy5pZCl9fWFkZE1vZHVsZXNUb0ltcG9ydERlc2NyaXB0aW9ucyh0KXtmb3IoY29uc3QgaSBvZiB0LnZhbHVlcygpKXtjb25zdHtpZDpzfT10aGlzLnJlc29sdmVkSWRzW2kuc291cmNlXTtpLm1vZHVsZT10aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmdldChzKX19YWRkUmVsZXZhbnRTaWRlRWZmZWN0RGVwZW5kZW5jaWVzKHQsaSxzKXtjb25zdCBuPW5ldyBTZXQscj1hPT57Zm9yKGNvbnN0IG8gb2YgYSluLmhhcyhvKXx8KG4uYWRkKG8pLGkuaGFzKG8pP3QuYWRkKG8pOihvLmluZm8ubW9kdWxlU2lkZUVmZmVjdHN8fHMuaGFzKG8pKSYmKG8gaW5zdGFuY2VvZiBsZXx8by5oYXNFZmZlY3RzKCk/dC5hZGQobyk6cihvLmRlcGVuZGVuY2llcykpKX07cih0aGlzLmRlcGVuZGVuY2llcykscihzKX1hZGRTb3VyY2UodCxpKXtjb25zdCBzPShuPWkuYXNzZXJ0aW9ucyxuIT1udWxsJiZuLmxlbmd0aD9PYmplY3QuZnJvbUVudHJpZXMobi5tYXAoYT0+W0dyKGEpLGEudmFsdWUudmFsdWVdKSk6cWUpO3ZhciBuO2NvbnN0IHI9dGhpcy5zb3VyY2VzV2l0aEFzc2VydGlvbnMuZ2V0KHQpO3I/dW4ocixzKSYmdGhpcy5sb2coSyxCcyhyLHMsdCx0aGlzLmlkKSxpLnN0YXJ0KTp0aGlzLnNvdXJjZXNXaXRoQXNzZXJ0aW9ucy5zZXQodCxzKX1nZXRWYXJpYWJsZUZyb21OYW1lc3BhY2VSZWV4cG9ydHModCxpLHMpe2xldCBuPW51bGw7Y29uc3Qgcj1uZXcgTWFwLGE9bmV3IFNldDtmb3IoY29uc3QgYyBvZiB0aGlzLmV4cG9ydEFsbE1vZHVsZXMpe2lmKGMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHM9PT10KWNvbnRpbnVlO2NvbnN0W3AsbV09V3IoYyx0LGksITAsZGQocykpO2MgaW5zdGFuY2VvZiBsZXx8bT9hLmFkZChwKTpwIGluc3RhbmNlb2YgRmU/bnx8KG49cCk6cCYmci5zZXQocCxjKX1pZihyLnNpemU+MCl7Y29uc3QgYz1bLi4ucl0scD1jWzBdWzBdO3JldHVybiBjLmxlbmd0aD09PTE/W3BdOih0aGlzLm9wdGlvbnMub25Mb2coSywobz10LGg9dGhpcy5pZCxsPWMubWFwKChbLG1dKT0+bS5pZCkse2JpbmRpbmc6byxjb2RlOiJOQU1FU1BBQ0VfQ09ORkxJQ1QiLGlkczpsLG1lc3NhZ2U6YENvbmZsaWN0aW5nIG5hbWVzcGFjZXM6ICIke1goaCl9IiByZS1leHBvcnRzICIke299IiBmcm9tIG9uZSBvZiB0aGUgbW9kdWxlcyAke0l0KGwubWFwKG09PlgobSkpKX0gKHdpbGwgYmUgaWdub3JlZCkuYCxyZWV4cG9ydGVyOmh9KSksW251bGxdKX12YXIgbyxoLGw7aWYoYS5zaXplPjApe2NvbnN0IGM9Wy4uLmFdLHA9Y1swXTtyZXR1cm4gYy5sZW5ndGg+MSYmdGhpcy5vcHRpb25zLm9uTG9nKEssZnVuY3Rpb24obSx5LEUsZyl7cmV0dXJue2JpbmRpbmc6bSxjb2RlOiJBTUJJR1VPVVNfRVhURVJOQUxfTkFNRVNQQUNFUyIsaWRzOmcsbWVzc2FnZTpgQW1iaWd1b3VzIGV4dGVybmFsIG5hbWVzcGFjZSByZXNvbHV0aW9uOiAiJHtYKHkpfSIgcmUtZXhwb3J0cyAiJHttfSIgZnJvbSBvbmUgb2YgdGhlIGV4dGVybmFsIG1vZHVsZXMgJHtJdChnLm1hcCh4PT5YKHgpKSl9LCBndWVzc2luZyAiJHtYKEUpfSIuYCxyZWV4cG9ydGVyOnl9fSh0LHRoaXMuaWQscC5tb2R1bGUuaWQsYy5tYXAobT0+bS5tb2R1bGUuaWQpKSksW3AsITBdfXJldHVybiBuP1tuXTpbbnVsbF19aW5jbHVkZUFuZEdldEFkZGl0aW9uYWxNZXJnZWROYW1lc3BhY2VzKCl7Y29uc3QgdD1uZXcgU2V0LGk9bmV3IFNldDtmb3IoY29uc3QgcyBvZlt0aGlzLC4uLnRoaXMuZXhwb3J0QWxsTW9kdWxlc10paWYocyBpbnN0YW5jZW9mIGxlKXtjb25zdFtuXT1zLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZSgiKiIpO24uaW5jbHVkZSgpLHRoaXMuaW5jbHVkZWRJbXBvcnRzLmFkZChuKSx0LmFkZChuKX1lbHNlIGlmKHMuaW5mby5zeW50aGV0aWNOYW1lZEV4cG9ydHMpe2NvbnN0IG49cy5nZXRTeW50aGV0aWNOYW1lc3BhY2UoKTtuLmluY2x1ZGUoKSx0aGlzLmluY2x1ZGVkSW1wb3J0cy5hZGQobiksaS5hZGQobil9cmV0dXJuWy4uLmksLi4udF19aW5jbHVkZUR5bmFtaWNJbXBvcnQodCl7Y29uc3QgaT10aGlzLmR5bmFtaWNJbXBvcnRzLmZpbmQocz0+cy5ub2RlPT09dCkucmVzb2x1dGlvbjtpZihpIGluc3RhbmNlb2YgeWUpe2kuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzLnB1c2godGhpcyk7Y29uc3Qgcz10aGlzLm9wdGlvbnMudHJlZXNoYWtlP3QuZ2V0RGV0ZXJtaW5pc3RpY0ltcG9ydGVkTmFtZXMoKTp2b2lkIDA7cz9pLmluY2x1ZGVFeHBvcnRzQnlOYW1lcyhzKTppLmluY2x1ZGVBbGxFeHBvcnRzKCEwKX19aW5jbHVkZVZhcmlhYmxlKHQpe2NvbnN0IGk9dC5tb2R1bGU7aWYodC5pbmNsdWRlZClpIGluc3RhbmNlb2YgeWUmJmkhPT10aGlzJiZxaCh0LHRoaXMpO2Vsc2UgaWYodC5pbmNsdWRlKCksdGhpcy5ncmFwaC5uZWVkc1RyZWVzaGFraW5nUGFzcz0hMCxpIGluc3RhbmNlb2YgeWUmJihpLmlzRXhlY3V0ZWR8fG1zKGkpLGkhPT10aGlzKSl7Y29uc3Qgcz1xaCh0LHRoaXMpO2Zvcihjb25zdCBuIG9mIHMpbi5pc0V4ZWN1dGVkfHxtcyhuKX19aW5jbHVkZVZhcmlhYmxlSW5Nb2R1bGUodCl7dGhpcy5pbmNsdWRlVmFyaWFibGUodCk7Y29uc3QgaT10Lm1vZHVsZTtpJiZpIT09dGhpcyYmdGhpcy5pbmNsdWRlZEltcG9ydHMuYWRkKHQpfXNoaW1NaXNzaW5nRXhwb3J0KHQpe3ZhciBpLHM7dGhpcy5vcHRpb25zLm9uTG9nKEssKGk9dGhpcy5pZCx7YmluZGluZzpzPXQsY29kZToiU0hJTU1FRF9FWFBPUlQiLGV4cG9ydGVyOmksbWVzc2FnZTpgTWlzc2luZyBleHBvcnQgIiR7c30iIGhhcyBiZWVuIHNoaW1tZWQgaW4gbW9kdWxlICIke1goaSl9Ii5gfSkpLHRoaXMuZXhwb3J0cy5zZXQodCxXaCl9dHJ5UGFyc2UoKXt0cnl7cmV0dXJuIHRoaXMuZ3JhcGguY29udGV4dFBhcnNlKHRoaXMuaW5mby5jb2RlKX1jYXRjaCh0KXtyZXR1cm4gdGhpcy5lcnJvcihmdW5jdGlvbihpLHMpe2xldCBuPWkubWVzc2FnZS5yZXBsYWNlKC8gXChcZCs6XGQrXCkkLywiIik7cmV0dXJuIHMuZW5kc1dpdGgoIi5qc29uIik/bis9IiAoTm90ZSB0aGF0IHlvdSBuZWVkIEByb2xsdXAvcGx1Z2luLWpzb24gdG8gaW1wb3J0IEpTT04gZmlsZXMpIjpzLmVuZHNXaXRoKCIuanMiKXx8KG4rPSIgKE5vdGUgdGhhdCB5b3UgbmVlZCBwbHVnaW5zIHRvIGltcG9ydCBmaWxlcyB0aGF0IGFyZSBub3QgSmF2YVNjcmlwdCkiKSx7Y2F1c2U6aSxjb2RlOiJQQVJTRV9FUlJPUiIsaWQ6cyxtZXNzYWdlOm59fSh0LHRoaXMuaWQpLHQucG9zKX19fWZ1bmN0aW9uIEhoKGUsdCxpKXtpZihlLm1vZHVsZSBpbnN0YW5jZW9mIHllJiZlLm1vZHVsZSE9PWkpe2NvbnN0IHM9ZS5tb2R1bGUuY3ljbGVzO2lmKHMuc2l6ZT4wKXtjb25zdCBuPWkuY3ljbGVzO2Zvcihjb25zdCByIG9mIG4paWYocy5oYXMocikpe3QuYWx0ZXJuYXRpdmVSZWV4cG9ydE1vZHVsZXMuc2V0KGUsaSk7YnJlYWt9fX19Y29uc3QgZGQ9ZT0+ZSYmbmV3IE1hcChBcnJheS5mcm9tKGUsKFt0LGldKT0+W3QsbmV3IFNldChpKV0pKTtmdW5jdGlvbiBLaChlKXtyZXR1cm4gZS5lbmRzV2l0aCgiLmpzIik/ZS5zbGljZSgwLC0zKTplfWZ1bmN0aW9uIFFoKGUsdCl7cmV0dXJuIGUuYXV0b0lkP2Ake2UuYmFzZVBhdGg/ZS5iYXNlUGF0aCsiLyI6IiJ9JHtLaCh0KX1gOmUuaWQ/PyIifWZ1bmN0aW9uIGNuKGUsdCxpLHMsbixyLGEsbz0icmV0dXJuICIpe2NvbnN0e186aCxnZXREaXJlY3RSZXR1cm5GdW5jdGlvbjpsLGdldEZ1bmN0aW9uSW50cm86YyxnZXRQcm9wZXJ0eUFjY2VzczpwLG46bSxzOnl9PW47aWYoIWkpcmV0dXJuYCR7bX0ke219JHtvfSR7ZnVuY3Rpb24oZyx4LHYsdyxiKXtpZihnLmxlbmd0aD4wKXJldHVybiBnWzBdLmxvY2FsO2Zvcihjb25zdHtkZWZhdWx0VmFyaWFibGVOYW1lOlMsaW1wb3J0UGF0aDprLGlzQ2h1bms6QyxuYW1lOlAsbmFtZWRFeHBvcnRzTW9kZTpfLG5hbWVzcGFjZVZhcmlhYmxlTmFtZTpBLHJlZXhwb3J0czpOfW9mIHgpaWYoTilyZXR1cm4gWWgoUCxOWzBdLmltcG9ydGVkLF8sQyxTLEEsdixrLHcsYil9KGUsdCxzLGEscCl9O2A7bGV0IEU9IiI7Zm9yKGNvbnN0e2RlZmF1bHRWYXJpYWJsZU5hbWU6ZyxpbXBvcnRQYXRoOngsaXNDaHVuazp2LG5hbWU6dyxuYW1lZEV4cG9ydHNNb2RlOmIsbmFtZXNwYWNlVmFyaWFibGVOYW1lOlMscmVleHBvcnRzOmt9b2YgdClpZihrJiZpKXtmb3IoY29uc3QgQyBvZiBrKWlmKEMucmVleHBvcnRlZCE9PSIqIil7Y29uc3QgUD1ZaCh3LEMuaW1wb3J0ZWQsYix2LGcsUyxzLHgsYSxwKTtpZihFJiYoRSs9bSksQy5pbXBvcnRlZCE9PSIqIiYmQy5uZWVkc0xpdmVCaW5kaW5nKXtjb25zdFtfLEFdPWwoW10se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO0UrPWBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywke2h9JyR7Qy5yZWV4cG9ydGVkfScsJHtofXske219JHtyfWVudW1lcmFibGU6JHtofXRydWUsJHttfSR7cn1nZXQ6JHtofSR7X30ke1B9JHtBfSR7bX19KTtgfWVsc2UgRSs9YGV4cG9ydHMke3AoQy5yZWV4cG9ydGVkKX0ke2h9PSR7aH0ke1B9O2B9fWZvcihjb25zdHtleHBvcnRlZDpnLGxvY2FsOnh9b2YgZSl7Y29uc3Qgdj1gZXhwb3J0cyR7cChnKX1gO3YhPT14JiYoRSYmKEUrPW0pLEUrPWAke3Z9JHtofT0ke2h9JHt4fTtgKX1mb3IoY29uc3R7bmFtZTpnLHJlZXhwb3J0czp4fW9mIHQpaWYoeCYmaSl7Zm9yKGNvbnN0IHYgb2YgeClpZih2LnJlZXhwb3J0ZWQ9PT0iKiIpe0UmJihFKz1tKTtjb25zdCB3PWB7JHttfSR7cn1pZiR7aH0oayR7aH0hPT0ke2h9J2RlZmF1bHQnJHtofSYmJHtofSFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywke2h9aykpJHtofSR7ZmQoZyx2Lm5lZWRzTGl2ZUJpbmRpbmcscixuKX0ke3l9JHttfX1gO0UrPWBPYmplY3Qua2V5cygke2d9KS5mb3JFYWNoKCR7YyhbImsiXSx7aXNBc3luYzohMSxuYW1lOm51bGx9KX0ke3d9KTtgfX1yZXR1cm4gRT9gJHttfSR7bX0ke0V9YDoiIn1mdW5jdGlvbiBZaChlLHQsaSxzLG4scixhLG8saCxsKXtpZih0PT09ImRlZmF1bHQiKXtpZighcyl7Y29uc3QgYz1hKG8pLHA9b25bY10/bjplO3JldHVybiBobihjLGgpP2Ake3B9JHtsKCJkZWZhdWx0Iil9YDpwfXJldHVybiBpP2Ake2V9JHtsKCJkZWZhdWx0Iil9YDplfXJldHVybiB0PT09IioiPyhzPyFpOnVzW2EobyldKT9yOmU6YCR7ZX0ke2wodCl9YH1mdW5jdGlvbiBYaChlKXtyZXR1cm4gZShbWyJ2YWx1ZSIsInRydWUiXV0se2xpbmVCcmVha0luZGVudDpudWxsfSl9ZnVuY3Rpb24gcG4oZSx0LGkse186cyxnZXRPYmplY3Q6bn0pe2lmKGUpe2lmKHQpcmV0dXJuIGk/YE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGV4cG9ydHMsJHtzfSR7bihbWyJfX2VzTW9kdWxlIixYaChuKV0sW251bGwsYFtTeW1ib2wudG9TdHJpbmdUYWddOiR7c30ke2NzKG4pfWBdXSx7bGluZUJyZWFrSW5kZW50Om51bGx9KX0pO2A6YE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7c30nX19lc01vZHVsZScsJHtzfSR7WGgobil9KTtgO2lmKGkpcmV0dXJuYE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCR7c31TeW1ib2wudG9TdHJpbmdUYWcsJHtzfSR7Y3Mobil9KTtgfXJldHVybiIifWNvbnN0IGZkPShlLHQsaSx7XzpzLGdldERpcmVjdFJldHVybkZ1bmN0aW9uOm4sbjpyfSk9PntpZih0KXtjb25zdFthLG9dPW4oW10se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO3JldHVybmBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywke3N9aywke3N9eyR7cn0ke2l9JHtpfWVudW1lcmFibGU6JHtzfXRydWUsJHtyfSR7aX0ke2l9Z2V0OiR7c30ke2F9JHtlfVtrXSR7b30ke3J9JHtpfX0pYH1yZXR1cm5gZXhwb3J0c1trXSR7c309JHtzfSR7ZX1ba11gfTtmdW5jdGlvbiBkbihlLHQsaSxzLG4scixhLG8pe2NvbnN0e186aCxjbnN0OmwsbjpjfT1vLHA9bmV3IFNldCxtPVtdLHk9KEUsZyx4KT0+e3AuYWRkKGcpLG0ucHVzaChgJHtsfSAke0V9JHtofT0ke2h9LyojX19QVVJFX18qLyR7Z30oJHt4fSk7YCl9O2Zvcihjb25zdHtkZWZhdWx0VmFyaWFibGVOYW1lOkUsaW1wb3J0czpnLGltcG9ydFBhdGg6eCxpc0NodW5rOnYsbmFtZTp3LG5hbWVkRXhwb3J0c01vZGU6YixuYW1lc3BhY2VWYXJpYWJsZU5hbWU6UyxyZWV4cG9ydHM6a31vZiBlKWlmKHYpe2Zvcihjb25zdHtpbXBvcnRlZDpDLHJlZXhwb3J0ZWQ6UH1vZlsuLi5nfHxbXSwuLi5rfHxbXV0paWYoQz09PSIqIiYmUCE9PSIqIil7Ynx8eShTLGxzLHcpO2JyZWFrfX1lbHNle2NvbnN0IEM9dCh4KTtsZXQgUD0hMSxfPSExO2Zvcihjb25zdHtpbXBvcnRlZDpBLHJlZXhwb3J0ZWQ6Tn1vZlsuLi5nfHxbXSwuLi5rfHxbXV0pe2xldCBVLE87QT09PSJkZWZhdWx0Ij9QfHwoUD0hMCxFIT09UyYmKE89RSxVPW9uW0NdKSk6QSE9PSIqInx8Tj09PSIqInx8X3x8KF89ITAsVT11c1tDXSxPPVMpLFUmJnkoTyxVLHcpfX1yZXR1cm5gJHskcihwLHIsYSxvLGkscyxuKX0ke20ubGVuZ3RoPjA/YCR7bS5qb2luKGMpfSR7Y30ke2N9YDoiIn1gfWZ1bmN0aW9uIFpoKGUsdCl7cmV0dXJuIGVbMF0hPT0iLiI/ZTp0PyhpPWUpLmVuZHNXaXRoKCIuanMiKT9pOmkrIi5qcyI6S2goZSk7dmFyIGl9Y29uc3QgbWQ9bmV3IFNldChbLi4uV2EoWyJhc3NlcnQiLCJhc3luY19ob29rcyIsImJ1ZmZlciIsImNoaWxkX3Byb2Nlc3MiLCJjbHVzdGVyIiwiY29uc29sZSIsImNvbnN0YW50cyIsImNyeXB0byIsImRncmFtIiwiZGlhZ25vc3RpY3NfY2hhbm5lbCIsImRucyIsImRvbWFpbiIsImV2ZW50cyIsImZzIiwiaHR0cCIsImh0dHAyIiwiaHR0cHMiLCJpbnNwZWN0b3IiLCJtb2R1bGUiLCJuZXQiLCJvcyIsInBhdGgiLCJwZXJmX2hvb2tzIiwicHJvY2VzcyIsInB1bnljb2RlIiwicXVlcnlzdHJpbmciLCJyZWFkbGluZSIsInJlcGwiLCJzdHJlYW0iLCJzdHJpbmdfZGVjb2RlciIsInRpbWVycyIsInRscyIsInRyYWNlX2V2ZW50cyIsInR0eSIsInVybCIsInV0aWwiLCJ2OCIsInZtIiwid2FzaSIsIndvcmtlcl90aHJlYWRzIiwiemxpYiJdKSwiYXNzZXJ0L3N0cmljdCIsImRucy9wcm9taXNlcyIsImZzL3Byb21pc2VzIiwicGF0aC9wb3NpeCIsInBhdGgvd2luMzIiLCJyZWFkbGluZS9wcm9taXNlcyIsInN0cmVhbS9jb25zdW1lcnMiLCJzdHJlYW0vcHJvbWlzZXMiLCJzdHJlYW0vd2ViIiwidGltZXJzL3Byb21pc2VzIiwidXRpbC90eXBlcyJdKTtmdW5jdGlvbiBxcihlLHQpe2NvbnN0IGk9dC5tYXAoKHtpbXBvcnRQYXRoOnN9KT0+cykuZmlsdGVyKHM9Pm1kLmhhcyhzKXx8cy5zdGFydHNXaXRoKCJub2RlOiIpKTtpLmxlbmd0aCE9PTAmJmUoSyxmdW5jdGlvbihzKXtyZXR1cm57Y29kZTpycCxpZHM6cyxtZXNzYWdlOmBDcmVhdGluZyBhIGJyb3dzZXIgYnVuZGxlIHRoYXQgZGVwZW5kcyBvbiBOb2RlLmpzIGJ1aWx0LWluIG1vZHVsZXMgKCR7SXQocyl9KS4gWW91IG1pZ2h0IG5lZWQgdG8gaW5jbHVkZSBodHRwczovL2dpdGh1Yi5jb20vRnJlZEtTY2hvdHQvcm9sbHVwLXBsdWdpbi1wb2x5ZmlsbC1ub2RlYH19KGkpKX1jb25zdCBmbj0oZSx0KT0+ZS5zcGxpdCgiLiIpLm1hcCh0KS5qb2luKCIiKTtmdW5jdGlvbiBIcihlLHQsaSxzLHtfOm4sZ2V0UHJvcGVydHlBY2Nlc3M6cn0pe2NvbnN0IGE9ZS5zcGxpdCgiLiIpO2FbMF09KHR5cGVvZiBpPT0iZnVuY3Rpb24iP2koYVswXSk6aVthWzBdXSl8fGFbMF07Y29uc3Qgbz1hLnBvcCgpO2xldCBoPXQsbD1bLi4uYS5tYXAoYz0+KGgrPXIoYyksYCR7aH0ke259PSR7bn0ke2h9JHtufXx8JHtufXt9YCkpLGAke2h9JHtyKG8pfWBdLmpvaW4oYCwke259YCkrYCR7bn09JHtufSR7c31gO3JldHVybiBhLmxlbmd0aD4wJiYobD1gKCR7bH0pYCksbH1mdW5jdGlvbiBKaChlKXtsZXQgdD1lLmxlbmd0aDtmb3IoO3QtLTspe2NvbnN0e2ltcG9ydHM6aSxyZWV4cG9ydHM6c309ZVt0XTtpZihpfHxzKXJldHVybiBlLnNsaWNlKDAsdCsxKX1yZXR1cm5bXX1jb25zdCBnZD0oe2RlcGVuZGVuY2llczplLGV4cG9ydHM6dH0pPT57Y29uc3QgaT1uZXcgU2V0KHQubWFwKHM9PnMuZXhwb3J0ZWQpKTtpLmFkZCgiZGVmYXVsdCIpO2Zvcihjb25zdHtyZWV4cG9ydHM6c31vZiBlKWlmKHMpZm9yKGNvbnN0IG4gb2YgcyluLnJlZXhwb3J0ZWQhPT0iKiImJmkuYWRkKG4ucmVleHBvcnRlZCk7cmV0dXJuIGl9LHlkPShlLHQse186aSxjbnN0OnMsZ2V0T2JqZWN0Om4sbjpyfSk9PmU/YCR7cn0ke3R9JHtzfSBfc3RhckV4Y2x1ZGVzJHtpfT0ke2l9JHtuKFsuLi5lXS5tYXAoYT0+W2EsIjEiXSkse2xpbmVCcmVha0luZGVudDp7YmFzZTp0LHR9fSl9O2A6IiIseGQ9KGUsdCx7XzppLG46c30pPT5lLmxlbmd0aD4wP2Ake3N9JHt0fXZhciAke2Uuam9pbihgLCR7aX1gKX07YDoiIixiZD0oZSx0LGkpPT5LcihlLmZpbHRlcihzPT5zLmhvaXN0ZWQpLm1hcChzPT4oe25hbWU6cy5leHBvcnRlZCx2YWx1ZTpzLmxvY2FsfSkpLHQsaSk7ZnVuY3Rpb24gS3IoZSx0LHtfOmksbjpzfSl7cmV0dXJuIGUubGVuZ3RoPT09MD8iIjplLmxlbmd0aD09PTE/YGV4cG9ydHMoJyR7ZVswXS5uYW1lfScsJHtpfSR7ZVswXS52YWx1ZX0pOyR7c30ke3N9YDpgZXhwb3J0cyh7JHtzfWArZS5tYXAoKHtuYW1lOm4sdmFsdWU6cn0pPT5gJHt0fSR7bn06JHtpfSR7cn1gKS5qb2luKGAsJHtzfWApK2Ake3N9fSk7JHtzfSR7c31gfWNvbnN0IHZkPShlLHQsaSk9PktyKGUuZmlsdGVyKHM9PnMuZXhwcmVzc2lvbikubWFwKHM9Pih7bmFtZTpzLmV4cG9ydGVkLHZhbHVlOnMubG9jYWx9KSksdCxpKSxFZD0oZSx0LGkpPT5LcihlLmZpbHRlcihzPT5zLmxvY2FsPT09TmkpLm1hcChzPT4oe25hbWU6cy5leHBvcnRlZCx2YWx1ZTpOaX0pKSx0LGkpO2Z1bmN0aW9uIFFyKGUsdCxpKXtyZXR1cm4gZT9gJHt0fSR7Zm4oZSxpKX1gOiJudWxsIn12YXIgU2Q9e2FtZDpmdW5jdGlvbihlLHthY2Nlc3NlZEdsb2JhbHM6dCxkZXBlbmRlbmNpZXM6aSxleHBvcnRzOnMsaGFzRGVmYXVsdEV4cG9ydDpuLGhhc0V4cG9ydHM6cixpZDphLGluZGVudDpvLGludHJvOmgsaXNFbnRyeUZhY2FkZTpsLGlzTW9kdWxlRmFjYWRlOmMsbmFtZWRFeHBvcnRzTW9kZTpwLGxvZzptLG91dHJvOnksc25pcHBldHM6RX0se2FtZDpnLGVzTW9kdWxlOngsZXh0ZXJuYWxMaXZlQmluZGluZ3M6dixmcmVlemU6dyxpbnRlcm9wOmIsbmFtZXNwYWNlVG9TdHJpbmdUYWc6UyxzdHJpY3Q6a30pe3FyKG0saSk7Y29uc3QgQz1pLm1hcChqPT5gJyR7Wmgoai5pbXBvcnRQYXRoLGcuZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMpfSdgKSxQPWkubWFwKGo9PmoubmFtZSkse246XyxnZXROb25BcnJvd0Z1bmN0aW9uSW50cm86QSxfOk59PUU7cCYmciYmKFAudW5zaGlmdCgiZXhwb3J0cyIpLEMudW5zaGlmdCgiJ2V4cG9ydHMnIikpLHQuaGFzKCJyZXF1aXJlIikmJihQLnVuc2hpZnQoInJlcXVpcmUiKSxDLnVuc2hpZnQoIidyZXF1aXJlJyIpKSx0LmhhcygibW9kdWxlIikmJihQLnVuc2hpZnQoIm1vZHVsZSIpLEMudW5zaGlmdCgiJ21vZHVsZSciKSk7Y29uc3QgVT1RaChnLGEpLE89KFU/YCcke1V9Jywke059YDoiIikrKEMubGVuZ3RoPjA/YFske0Muam9pbihgLCR7Tn1gKX1dLCR7Tn1gOiIiKSxHPWs/YCR7Tn0ndXNlIHN0cmljdCc7YDoiIjtlLnByZXBlbmQoYCR7aH0ke2RuKGksYix2LHcsUyx0LG8sRSl9YCk7Y29uc3QgUj1jbihzLGkscCxiLEUsbyx2KTtsZXQgVz1wbihwJiZyLGwmJih4PT09ITB8fHg9PT0iaWYtZGVmYXVsdC1wcm9wIiYmbiksYyYmUyxFKTtXJiYoVz1fK18rVyksZS5hcHBlbmQoYCR7Un0ke1d9JHt5fWApLmluZGVudChvKS5wcmVwZW5kKGAke2cuZGVmaW5lfSgke099KCR7QShQLHtpc0FzeW5jOiExLG5hbWU6bnVsbH0pfXske0d9JHtffSR7X31gKS5hcHBlbmQoYCR7X30ke199fSkpO2ApfSxjanM6ZnVuY3Rpb24oZSx7YWNjZXNzZWRHbG9iYWxzOnQsZGVwZW5kZW5jaWVzOmksZXhwb3J0czpzLGhhc0RlZmF1bHRFeHBvcnQ6bixoYXNFeHBvcnRzOnIsaW5kZW50OmEsaW50cm86byxpc0VudHJ5RmFjYWRlOmgsaXNNb2R1bGVGYWNhZGU6bCxuYW1lZEV4cG9ydHNNb2RlOmMsb3V0cm86cCxzbmlwcGV0czptfSx7Y29tcGFjdDp5LGVzTW9kdWxlOkUsZXh0ZXJuYWxMaXZlQmluZGluZ3M6ZyxmcmVlemU6eCxpbnRlcm9wOnYsbmFtZXNwYWNlVG9TdHJpbmdUYWc6dyxzdHJpY3Q6Yn0pe2NvbnN0e186UyxuOmt9PW0sQz1iP2AndXNlIHN0cmljdCc7JHtrfSR7a31gOiIiO2xldCBQPXBuKGMmJnIsaCYmKEU9PT0hMHx8RT09PSJpZi1kZWZhdWx0LXByb3AiJiZuKSxsJiZ3LG0pO1AmJihQKz1rK2spO2NvbnN0IF89ZnVuY3Rpb24oVSx7XzpPLGNuc3Q6RyxuOlJ9LFcpe2xldCBqPSIiLEI9ITE7Zm9yKGNvbnN0e2ltcG9ydFBhdGg6YWUsbmFtZTp4ZSxyZWV4cG9ydHM6TGUsaW1wb3J0czpmZX1vZiBVKUxlfHxmZT8oais9VyYmQj8iLCI6YCR7aj9gOyR7Un1gOiIifSR7R30gYCxCPSEwLGorPWAke3hlfSR7T309JHtPfXJlcXVpcmUoJyR7YWV9JylgKTooaiYmKGorPVcmJiFCPyIsIjpgOyR7Un1gKSxCPSExLGorPWByZXF1aXJlKCcke2FlfScpYCk7cmV0dXJuIGo/YCR7an07JHtSfSR7Un1gOiIifShpLG0seSksQT1kbihpLHYsZyx4LHcsdCxhLG0pO2UucHJlcGVuZChgJHtDfSR7b30ke1B9JHtffSR7QX1gKTtjb25zdCBOPWNuKHMsaSxjLHYsbSxhLGcsYG1vZHVsZS5leHBvcnRzJHtTfT0ke1N9YCk7ZS5hcHBlbmQoYCR7Tn0ke3B9YCl9LGVzOmZ1bmN0aW9uKGUse2FjY2Vzc2VkR2xvYmFsczp0LGluZGVudDppLGludHJvOnMsb3V0cm86bixkZXBlbmRlbmNpZXM6cixleHBvcnRzOmEsc25pcHBldHM6b30se2V4dGVybmFsTGl2ZUJpbmRpbmdzOmgsZnJlZXplOmwsbmFtZXNwYWNlVG9TdHJpbmdUYWc6Y30pe2NvbnN0e246cH09byxtPWZ1bmN0aW9uKEUse186Z30pe2NvbnN0IHg9W107Zm9yKGNvbnN0e2ltcG9ydFBhdGg6dixyZWV4cG9ydHM6dyxpbXBvcnRzOmIsbmFtZTpTLGFzc2VydGlvbnM6a31vZiBFKXtjb25zdCBDPWAnJHt2fScke2s/YCR7Z31hc3NlcnQke2d9JHtrfWA6IiJ9O2A7aWYod3x8Yil7aWYoYil7bGV0IFA9bnVsbCxfPW51bGw7Y29uc3QgQT1bXTtmb3IoY29uc3QgTiBvZiBiKU4uaW1wb3J0ZWQ9PT0iZGVmYXVsdCI/UD1OOk4uaW1wb3J0ZWQ9PT0iKiI/Xz1OOkEucHVzaChOKTtfJiZ4LnB1c2goYGltcG9ydCR7Z30qJHtnfWFzICR7Xy5sb2NhbH0gZnJvbSR7Z30ke0N9YCksUCYmQS5sZW5ndGg9PT0wP3gucHVzaChgaW1wb3J0ICR7UC5sb2NhbH0gZnJvbSR7Z30ke0N9YCk6QS5sZW5ndGg+MCYmeC5wdXNoKGBpbXBvcnQgJHtQP2Ake1AubG9jYWx9LCR7Z31gOiIifXske2d9JHtBLm1hcChOPT5OLmltcG9ydGVkPT09Ti5sb2NhbD9OLmltcG9ydGVkOmAke04uaW1wb3J0ZWR9IGFzICR7Ti5sb2NhbH1gKS5qb2luKGAsJHtnfWApfSR7Z319JHtnfWZyb20ke2d9JHtDfWApfWlmKHcpe2xldCBQPW51bGw7Y29uc3QgXz1bXSxBPVtdO2Zvcihjb25zdCBOIG9mIHcpTi5yZWV4cG9ydGVkPT09IioiP1A9TjpOLmltcG9ydGVkPT09IioiP18ucHVzaChOKTpBLnB1c2goTik7aWYoUCYmeC5wdXNoKGBleHBvcnQke2d9KiR7Z31mcm9tJHtnfSR7Q31gKSxfLmxlbmd0aD4wKXtiJiZiLnNvbWUoTj0+Ti5pbXBvcnRlZD09PSIqIiYmTi5sb2NhbD09PVMpfHx4LnB1c2goYGltcG9ydCR7Z30qJHtnfWFzICR7U30gZnJvbSR7Z30ke0N9YCk7Zm9yKGNvbnN0IE4gb2YgXyl4LnB1c2goYGV4cG9ydCR7Z317JHtnfSR7Uz09PU4ucmVleHBvcnRlZD9TOmAke1N9IGFzICR7Ti5yZWV4cG9ydGVkfWB9IH07YCl9QS5sZW5ndGg+MCYmeC5wdXNoKGBleHBvcnQke2d9eyR7Z30ke0EubWFwKE49Pk4uaW1wb3J0ZWQ9PT1OLnJlZXhwb3J0ZWQ/Ti5pbXBvcnRlZDpgJHtOLmltcG9ydGVkfSBhcyAke04ucmVleHBvcnRlZH1gKS5qb2luKGAsJHtnfWApfSR7Z319JHtnfWZyb20ke2d9JHtDfWApfX1lbHNlIHgucHVzaChgaW1wb3J0JHtnfSR7Q31gKX1yZXR1cm4geH0ocixvKTttLmxlbmd0aD4wJiYocys9bS5qb2luKHApK3ArcCksKHMrPSRyKG51bGwsdCxpLG8saCxsLGMpKSYmZS5wcmVwZW5kKHMpO2NvbnN0IHk9ZnVuY3Rpb24oRSx7XzpnLGNuc3Q6eH0pe2NvbnN0IHY9W10sdz1bXTtmb3IoY29uc3QgYiBvZiBFKWIuZXhwcmVzc2lvbiYmdi5wdXNoKGAke3h9ICR7Yi5sb2NhbH0ke2d9PSR7Z30ke2IuZXhwcmVzc2lvbn07YCksdy5wdXNoKGIuZXhwb3J0ZWQ9PT1iLmxvY2FsP2IubG9jYWw6YCR7Yi5sb2NhbH0gYXMgJHtiLmV4cG9ydGVkfWApO3JldHVybiB3Lmxlbmd0aD4wJiZ2LnB1c2goYGV4cG9ydCR7Z317JHtnfSR7dy5qb2luKGAsJHtnfWApfSR7Z319O2ApLHZ9KGEsbyk7eS5sZW5ndGg+MCYmZS5hcHBlbmQocCtwK3kuam9pbihwKS50cmltKCkpLG4mJmUuYXBwZW5kKG4pLGUudHJpbSgpfSxpaWZlOmZ1bmN0aW9uKGUse2FjY2Vzc2VkR2xvYmFsczp0LGRlcGVuZGVuY2llczppLGV4cG9ydHM6cyxoYXNEZWZhdWx0RXhwb3J0Om4saGFzRXhwb3J0czpyLGluZGVudDphLGludHJvOm8sbmFtZWRFeHBvcnRzTW9kZTpoLGxvZzpsLG91dHJvOmMsc25pcHBldHM6cH0se2NvbXBhY3Q6bSxlc01vZHVsZTp5LGV4dGVuZDpFLGZyZWV6ZTpnLGV4dGVybmFsTGl2ZUJpbmRpbmdzOngsZ2xvYmFsczp2LGludGVyb3A6dyxuYW1lOmIsbmFtZXNwYWNlVG9TdHJpbmdUYWc6UyxzdHJpY3Q6a30pe2NvbnN0e186QyxnZXROb25BcnJvd0Z1bmN0aW9uSW50cm86UCxnZXRQcm9wZXJ0eUFjY2VzczpfLG46QX09cCxOPWImJmIuaW5jbHVkZXMoIi4iKSxVPSFFJiYhTjtpZihiJiZVJiYocm8oTz1iKXx8bm8udGVzdChPKSkpcmV0dXJuIEwoZnVuY3Rpb24oa2Upe3JldHVybntjb2RlOlpjLG1lc3NhZ2U6YEdpdmVuIG5hbWUgIiR7a2V9IiBpcyBub3QgYSBsZWdhbCBKUyBpZGVudGlmaWVyLiBJZiB5b3UgbmVlZCB0aGlzLCB5b3UgY2FuIHRyeSAib3V0cHV0LmV4dGVuZDogdHJ1ZSIuYCx1cmw6X2UoRGMpfX0oYikpO3ZhciBPO3FyKGwsaSk7Y29uc3QgRz1KaChpKSxSPUcubWFwKGtlPT5rZS5nbG9iYWxOYW1lfHwibnVsbCIpLFc9Ry5tYXAoa2U9PmtlLm5hbWUpO3ImJiFiJiZsKEsse2NvZGU6bW8sbWVzc2FnZTonSWYgeW91IGRvIG5vdCBzdXBwbHkgIm91dHB1dC5uYW1lIiwgeW91IG1heSBub3QgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGV4cG9ydHMgb2YgYW4gSUlGRSBidW5kbGUuJyx1cmw6X2UobG8pfSksaCYmciYmKEU/KFIudW5zaGlmdChgdGhpcyR7Zm4oYixfKX0ke0N9PSR7Q310aGlzJHtmbihiLF8pfSR7Q318fCR7Q317fWApLFcudW5zaGlmdCgiZXhwb3J0cyIpKTooUi51bnNoaWZ0KCJ7fSIpLFcudW5zaGlmdCgiZXhwb3J0cyIpKSk7Y29uc3Qgaj1rP2Ake2F9J3VzZSBzdHJpY3QnOyR7QX1gOiIiLEI9ZG4oaSx3LHgsZyxTLHQsYSxwKTtlLnByZXBlbmQoYCR7b30ke0J9YCk7bGV0IGFlPWAoJHtQKFcse2lzQXN5bmM6ITEsbmFtZTpudWxsfSl9eyR7QX0ke2p9JHtBfWA7ciYmKCFifHxFJiZofHwoYWU9KFU/YHZhciAke2J9YDpgdGhpcyR7Zm4oYixfKX1gKStgJHtDfT0ke0N9JHthZX1gKSxOJiYoYWU9ZnVuY3Rpb24oa2UsTWUsd2Use186RGUsZ2V0UHJvcGVydHlBY2Nlc3M6VWUsczp5aX0sVGUpe2NvbnN0IE5lPWtlLnNwbGl0KCIuIik7TmVbMF09KHR5cGVvZiB3ZT09ImZ1bmN0aW9uIj93ZShOZVswXSk6d2VbTmVbMF1dKXx8TmVbMF0sTmUucG9wKCk7bGV0IGppPU1lO3JldHVybiBOZS5tYXAoamE9PihqaSs9VWUoamEpLGAke2ppfSR7RGV9PSR7RGV9JHtqaX0ke0RlfXx8JHtEZX17fSR7eWl9YCkpLmpvaW4oVGU/IiwiOmAKYCkrKFRlJiZOZS5sZW5ndGg+MD8iOyI6YApgKX0oYiwidGhpcyIsdixwLG0pK2FlKSk7bGV0IHhlPWAke0F9JHtBfX0pKCR7Ui5qb2luKGAsJHtDfWApfSk7YDtyJiYhRSYmaCYmKHhlPWAke0F9JHtBfSR7YX1yZXR1cm4gZXhwb3J0czske3hlfWApO2NvbnN0IExlPWNuKHMsaSxoLHcscCxhLHgpO2xldCBmZT1wbihoJiZyLHk9PT0hMHx8eT09PSJpZi1kZWZhdWx0LXByb3AiJiZuLFMscCk7ZmUmJihmZT1BK0ErZmUpLGUuYXBwZW5kKGAke0xlfSR7ZmV9JHtjfWApLmluZGVudChhKS5wcmVwZW5kKGFlKS5hcHBlbmQoeGUpfSxzeXN0ZW06ZnVuY3Rpb24oZSx7YWNjZXNzZWRHbG9iYWxzOnQsZGVwZW5kZW5jaWVzOmksZXhwb3J0czpzLGhhc0V4cG9ydHM6bixpbmRlbnQ6cixpbnRybzphLHNuaXBwZXRzOm8sb3V0cm86aCx1c2VzVG9wTGV2ZWxBd2FpdDpsfSx7ZXh0ZXJuYWxMaXZlQmluZGluZ3M6YyxmcmVlemU6cCxuYW1lOm0sbmFtZXNwYWNlVG9TdHJpbmdUYWc6eSxzdHJpY3Q6RSxzeXN0ZW1OdWxsU2V0dGVyczpnfSl7Y29uc3R7Xzp4LGdldEZ1bmN0aW9uSW50cm86dixnZXROb25BcnJvd0Z1bmN0aW9uSW50cm86dyxuOmIsczpTfT1vLHtpbXBvcnRCaW5kaW5nczprLHNldHRlcnM6QyxzdGFyRXhjbHVkZXM6UH09ZnVuY3Rpb24oTyxHLFIse186VyxjbnN0OmosZ2V0T2JqZWN0OkIsZ2V0UHJvcGVydHlBY2Nlc3M6YWUsbjp4ZX0pe2NvbnN0IExlPVtdLGZlPVtdO2xldCBrZT1udWxsO2Zvcihjb25zdHtpbXBvcnRzOk1lLHJlZXhwb3J0czp3ZX1vZiBPKXtjb25zdCBEZT1bXTtpZihNZSlmb3IoY29uc3QgVWUgb2YgTWUpTGUucHVzaChVZS5sb2NhbCksVWUuaW1wb3J0ZWQ9PT0iKiI/RGUucHVzaChgJHtVZS5sb2NhbH0ke1d9PSR7V31tb2R1bGU7YCk6RGUucHVzaChgJHtVZS5sb2NhbH0ke1d9PSR7V31tb2R1bGUke2FlKFVlLmltcG9ydGVkKX07YCk7aWYod2Upe2NvbnN0IFVlPVtdO2xldCB5aT0hMTtmb3IoY29uc3R7aW1wb3J0ZWQ6VGUscmVleHBvcnRlZDpOZX1vZiB3ZSlOZT09PSIqIj95aT0hMDpVZS5wdXNoKFtOZSxUZT09PSIqIj8ibW9kdWxlIjpgbW9kdWxlJHthZShUZSl9YF0pO2lmKFVlLmxlbmd0aD4xfHx5aSl7Y29uc3QgVGU9QihVZSx7bGluZUJyZWFrSW5kZW50Om51bGx9KTt5aT8oa2V8fChrZT1nZCh7ZGVwZW5kZW5jaWVzOk8sZXhwb3J0czpHfSkpLERlLnB1c2goYCR7an0gc2V0dGVyJHtXfT0ke1d9JHtUZX07YCxgZm9yJHtXfSgke2p9IG5hbWUgaW4gbW9kdWxlKSR7V317YCxgJHtSfWlmJHtXfSghX3N0YXJFeGNsdWRlc1tuYW1lXSkke1d9c2V0dGVyW25hbWVdJHtXfT0ke1d9bW9kdWxlW25hbWVdO2AsIn0iLCJleHBvcnRzKHNldHRlcik7IikpOkRlLnB1c2goYGV4cG9ydHMoJHtUZX0pO2ApfWVsc2V7Y29uc3RbVGUsTmVdPVVlWzBdO0RlLnB1c2goYGV4cG9ydHMoJyR7VGV9Jywke1d9JHtOZX0pO2ApfX1mZS5wdXNoKERlLmpvaW4oYCR7eGV9JHtSfSR7Un0ke1J9YCkpfXJldHVybntpbXBvcnRCaW5kaW5nczpMZSxzZXR0ZXJzOmZlLHN0YXJFeGNsdWRlczprZX19KGkscyxyLG8pLF89bT9gJyR7bX0nLCR7eH1gOiIiLEE9dC5oYXMoIm1vZHVsZSIpP1siZXhwb3J0cyIsIm1vZHVsZSJdOm4/WyJleHBvcnRzIl06W107bGV0IE49YFN5c3RlbS5yZWdpc3Rlcigke199W2AraS5tYXAoKHtpbXBvcnRQYXRoOk99KT0+YCcke099J2ApLmpvaW4oYCwke3h9YCkrYF0sJHt4fSgke3coQSx7aXNBc3luYzohMSxuYW1lOm51bGx9KX17JHtifSR7cn0ke0U/Iid1c2Ugc3RyaWN0JzsiOiIifWAreWQoUCxyLG8pK3hkKGsscixvKStgJHtifSR7cn1yZXR1cm4ke3h9eyR7Qy5sZW5ndGg+MD9gJHtifSR7cn0ke3J9c2V0dGVyczoke3h9WyR7Qy5tYXAoTz0+Tz9gJHt2KFsibW9kdWxlIl0se2lzQXN5bmM6ITEsbmFtZTpudWxsfSl9eyR7Yn0ke3J9JHtyfSR7cn0ke099JHtifSR7cn0ke3J9fWA6Zz8ibnVsbCI6YCR7dihbXSx7aXNBc3luYzohMSxuYW1lOm51bGx9KX17fWApLmpvaW4oYCwke3h9YCl9XSxgOiIifSR7Yn1gO04rPWAke3J9JHtyfWV4ZWN1dGU6JHt4fSgke3coW10se2lzQXN5bmM6bCxuYW1lOm51bGx9KX17JHtifSR7Yn1gO2NvbnN0IFU9YCR7cn0ke3J9fSkke2J9JHtyfX0ke1N9JHtifX0pKTtgO2UucHJlcGVuZChhKyRyKG51bGwsdCxyLG8sYyxwLHkpK2JkKHMscixvKSkuYXBwZW5kKGAke2h9JHtifSR7Yn1gK3ZkKHMscixvKStFZChzLHIsbykpLmluZGVudChgJHtyfSR7cn0ke3J9YCkuYXBwZW5kKFUpLnByZXBlbmQoTil9LHVtZDpmdW5jdGlvbihlLHthY2Nlc3NlZEdsb2JhbHM6dCxkZXBlbmRlbmNpZXM6aSxleHBvcnRzOnMsaGFzRGVmYXVsdEV4cG9ydDpuLGhhc0V4cG9ydHM6cixpZDphLGluZGVudDpvLGludHJvOmgsbmFtZWRFeHBvcnRzTW9kZTpsLGxvZzpjLG91dHJvOnAsc25pcHBldHM6bX0se2FtZDp5LGNvbXBhY3Q6RSxlc01vZHVsZTpnLGV4dGVuZDp4LGV4dGVybmFsTGl2ZUJpbmRpbmdzOnYsZnJlZXplOncsaW50ZXJvcDpiLG5hbWU6UyxuYW1lc3BhY2VUb1N0cmluZ1RhZzprLGdsb2JhbHM6Qyxub0NvbmZsaWN0OlAsc3RyaWN0Ol99KXtjb25zdHtfOkEsY25zdDpOLGdldEZ1bmN0aW9uSW50cm86VSxnZXROb25BcnJvd0Z1bmN0aW9uSW50cm86TyxnZXRQcm9wZXJ0eUFjY2VzczpHLG46UixzOld9PW0saj1FPyJmIjoiZmFjdG9yeSIsQj1FPyJnIjoiZ2xvYmFsIjtpZihyJiYhUylyZXR1cm4gTCh7Y29kZTptbyxtZXNzYWdlOidZb3UgbXVzdCBzdXBwbHkgIm91dHB1dC5uYW1lIiBmb3IgVU1EIGJ1bmRsZXMgdGhhdCBoYXZlIGV4cG9ydHMgc28gdGhhdCB0aGUgZXhwb3J0cyBhcmUgYWNjZXNzaWJsZSBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBhIG1vZHVsZSBsb2FkZXIuJyx1cmw6X2UobG8pfSk7cXIoYyxpKTtjb25zdCBhZT1pLm1hcChRZT0+YCcke1poKFFlLmltcG9ydFBhdGgseS5mb3JjZUpzRXh0ZW5zaW9uRm9ySW1wb3J0cyl9J2ApLHhlPWkubWFwKFFlPT5gcmVxdWlyZSgnJHtRZS5pbXBvcnRQYXRofScpYCksTGU9SmgoaSksZmU9TGUubWFwKFFlPT5RcihRZS5nbG9iYWxOYW1lLEIsRykpLGtlPUxlLm1hcChRZT0+UWUubmFtZSk7bCYmKHJ8fFApJiYoYWUudW5zaGlmdCgiJ2V4cG9ydHMnIikseGUudW5zaGlmdCgiZXhwb3J0cyIpLGZlLnVuc2hpZnQoSHIoUyxCLEMsKHg/YCR7UXIoUyxCLEcpfSR7QX18fCR7QX1gOiIiKSsie30iLG0pKSxrZS51bnNoaWZ0KCJleHBvcnRzIikpO2NvbnN0IE1lPVFoKHksYSksd2U9KE1lP2AnJHtNZX0nLCR7QX1gOiIiKSsoYWUubGVuZ3RoPjA/YFske2FlLmpvaW4oYCwke0F9YCl9XSwke0F9YDoiIiksRGU9eS5kZWZpbmUsVWU9IWwmJnI/YG1vZHVsZS5leHBvcnRzJHtBfT0ke0F9YDoiIix5aT1fP2Ake0F9J3VzZSBzdHJpY3QnOyR7Un1gOiIiO2xldCBUZTtpZihQKXtjb25zdCBRZT1FPyJlIjoiZXhwb3J0cyI7bGV0IFVhOyFsJiZyP1VhPWAke059ICR7UWV9JHtBfT0ke0F9JHtIcihTLEIsQyxgJHtqfSgke2ZlLmpvaW4oYCwke0F9YCl9KWAsbSl9O2A6VWE9YCR7Tn0gJHtRZX0ke0F9PSR7QX0ke2ZlLnNoaWZ0KCl9OyR7Un0ke299JHtvfSR7an0oJHtbUWUsLi4uZmVdLmpvaW4oYCwke0F9YCl9KTtgLFRlPWAoJHtVKFtdLHtpc0FzeW5jOiExLG5hbWU6bnVsbH0pfXske1J9JHtvfSR7b30ke059IGN1cnJlbnQke0F9PSR7QX0ke2Z1bmN0aW9uKFFnLFlnLHtfOm1jLGdldFByb3BlcnR5QWNjZXNzOlhnfSl7bGV0IFpnPVlnO3JldHVybiBRZy5zcGxpdCgiLiIpLm1hcChKZz0+WmcrPVhnKEpnKSkuam9pbihgJHttY30mJiR7bWN9YCl9KFMsQixtKX07JHtSfSR7b30ke299JHtVYX0ke1J9JHtvfSR7b30ke1FlfS5ub0NvbmZsaWN0JHtBfT0ke0F9JHtVKFtdLHtpc0FzeW5jOiExLG5hbWU6bnVsbH0pfXske0F9JHtRcihTLEIsRyl9JHtBfT0ke0F9Y3VycmVudDske0F9cmV0dXJuICR7UWV9JHtXfSR7QX19OyR7Un0ke299fSkoKWB9ZWxzZSBUZT1gJHtqfSgke2ZlLmpvaW4oYCwke0F9YCl9KWAsIWwmJnImJihUZT1IcihTLEIsQyxUZSxtKSk7Y29uc3QgTmU9cnx8UCYmbHx8ZmUubGVuZ3RoPjAsamk9W2pdO05lJiZqaS51bnNoaWZ0KEIpO2NvbnN0IGphPU5lP2B0aGlzLCR7QX1gOiIiLFVnPU5lP2AoJHtCfSR7QX09JHtBfXR5cGVvZiBnbG9iYWxUaGlzJHtBfSE9PSR7QX0ndW5kZWZpbmVkJyR7QX0/JHtBfWdsb2JhbFRoaXMke0F9OiR7QX0ke0J9JHtBfXx8JHtBfXNlbGYsJHtBfWA6IiIsR2c9TmU/IikiOiIiLFdnPU5lP2Ake299dHlwZW9mIGV4cG9ydHMke0F9PT09JHtBfSdvYmplY3QnJHtBfSYmJHtBfXR5cGVvZiBtb2R1bGUke0F9IT09JHtBfSd1bmRlZmluZWQnJHtBfT8ke0F9JHtVZX0ke2p9KCR7eGUuam9pbihgLCR7QX1gKX0pJHtBfToke1J9YDoiIixxZz1gKCR7TyhqaSx7aXNBc3luYzohMSxuYW1lOm51bGx9KX17JHtSfWArV2crYCR7b310eXBlb2YgJHtEZX0ke0F9PT09JHtBfSdmdW5jdGlvbicke0F9JiYke0F9JHtEZX0uYW1kJHtBfT8ke0F9JHtEZX0oJHt3ZX0ke2p9KSR7QX06JHtSfSR7b30ke1VnfSR7VGV9JHtHZ307JHtSfX0pKCR7amF9KCR7TyhrZSx7aXNBc3luYzohMSxuYW1lOm51bGx9KX17JHt5aX0ke1J9YCxIZz1SK1IrIn0pKTsiO2UucHJlcGVuZChgJHtofSR7ZG4oaSxiLHYsdyxrLHQsbyxtKX1gKTtjb25zdCBLZz1jbihzLGksbCxiLG0sbyx2KTtsZXQgRG49cG4obCYmcixnPT09ITB8fGc9PT0iaWYtZGVmYXVsdC1wcm9wIiYmbixrLG0pO0RuJiYoRG49UitSK0RuKSxlLmFwcGVuZChgJHtLZ30ke0RufSR7cH1gKS50cmltKCkuaW5kZW50KG8pLmFwcGVuZChIZykucHJlcGVuZChxZyl9fTtjb25zdCBlbD0oZSx0KT0+dD9gJHtlfQoke3R9YDplLHRsPShlLHQpPT50P2Ake2V9Cgoke3R9YDplO2FzeW5jIGZ1bmN0aW9uIGtkKGUsdCxpKXt0cnl7bGV0W2EsbyxoLGxdPWF3YWl0IFByb21pc2UuYWxsKFt0Lmhvb2tSZWR1Y2VWYWx1ZSgiYmFubmVyIixlLmJhbm5lcihpKSxbaV0sZWwpLHQuaG9va1JlZHVjZVZhbHVlKCJmb290ZXIiLGUuZm9vdGVyKGkpLFtpXSxlbCksdC5ob29rUmVkdWNlVmFsdWUoImludHJvIixlLmludHJvKGkpLFtpXSx0bCksdC5ob29rUmVkdWNlVmFsdWUoIm91dHJvIixlLm91dHJvKGkpLFtpXSx0bCldKTtyZXR1cm4gaCYmKGgrPWAKCmApLGwmJihsPWAKCiR7bH1gKSxhJiYoYSs9YApgKSxvJiYobz1gCmArbykse2Jhbm5lcjphLGZvb3RlcjpvLGludHJvOmgsb3V0cm86bH19Y2F0Y2goYSl7cmV0dXJuIEwoKHM9YS5tZXNzYWdlLG49YS5ob29rLHI9YS5wbHVnaW4se2NvZGU6amMsbWVzc2FnZTpgQ291bGQgbm90IHJldHJpZXZlICIke259Ii4gQ2hlY2sgY29uZmlndXJhdGlvbiBvZiBwbHVnaW4gIiR7cn0iLgoJRXJyb3IgTWVzc2FnZTogJHtzfWB9KSl9dmFyIHMsbixyfWNvbnN0IHdkPXthbWQ6bW4sY2pzOm1uLGVzOmlsLGlpZmU6bW4sc3lzdGVtOmlsLHVtZDptbn07ZnVuY3Rpb24gQWQoZSx0LGkscyxuLHIsYSxvLGgsbCxjLHAsbSx5KXtjb25zdCBFPVsuLi5lXS5yZXZlcnNlKCk7Zm9yKGNvbnN0IGcgb2YgRSlnLnNjb3BlLmFkZFVzZWRPdXRzaWRlTmFtZXMocyxuLHAsbSk7KGZ1bmN0aW9uKGcseCx2KXtmb3IoY29uc3QgdyBvZiB4KXtmb3IoY29uc3QgYiBvZiB3LnNjb3BlLnZhcmlhYmxlcy52YWx1ZXMoKSliLmluY2x1ZGVkJiYhKGIucmVuZGVyQmFzZU5hbWV8fGIgaW5zdGFuY2VvZiBndCYmYi5nZXRPcmlnaW5hbFZhcmlhYmxlKCkhPT1iKSYmYi5zZXRSZW5kZXJOYW1lcyhudWxsLGZ0KGIubmFtZSxnLGIuZm9yYmlkZGVuTmFtZXMpKTtpZih2Lmhhcyh3KSl7Y29uc3QgYj13Lm5hbWVzcGFjZTtiLnNldFJlbmRlck5hbWVzKG51bGwsZnQoYi5uYW1lLGcsYi5mb3JiaWRkZW5OYW1lcykpfX19KShzLEUseSksd2Rbbl0ocyxpLHQscixhLG8saCxsLGMpO2Zvcihjb25zdCBnIG9mIEUpZy5zY29wZS5kZWNvbmZsaWN0KG4scCxtKX1mdW5jdGlvbiBpbChlLHQsaSxzLG4scixhLG8saCl7Zm9yKGNvbnN0IGwgb2YgaS5kZXBlbmRlbmNpZXMpKG58fGwgaW5zdGFuY2VvZiBFaSkmJihsLnZhcmlhYmxlTmFtZT1mdChsLnN1Z2dlc3RlZFZhcmlhYmxlTmFtZSxlLG51bGwpKTtmb3IoY29uc3QgbCBvZiB0KXtjb25zdCBjPWwubW9kdWxlLHA9bC5uYW1lO2wuaXNOYW1lc3BhY2UmJihufHxjIGluc3RhbmNlb2YgbGUpP2wuc2V0UmVuZGVyTmFtZXMobnVsbCwoYyBpbnN0YW5jZW9mIGxlP28uZ2V0KGMpOmEuZ2V0KGMpKS52YXJpYWJsZU5hbWUpOmMgaW5zdGFuY2VvZiBsZSYmcD09PSJkZWZhdWx0Ij9sLnNldFJlbmRlck5hbWVzKG51bGwsZnQoWy4uLmMuZXhwb3J0ZWRWYXJpYWJsZXNdLnNvbWUoKFttLHldKT0+eT09PSIqIiYmbS5pbmNsdWRlZCk/Yy5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUrIl9fZGVmYXVsdCI6Yy5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUsZSxsLmZvcmJpZGRlbk5hbWVzKSk6bC5zZXRSZW5kZXJOYW1lcyhudWxsLGZ0KHAsZSxsLmZvcmJpZGRlbk5hbWVzKSl9Zm9yKGNvbnN0IGwgb2YgaClsLnNldFJlbmRlck5hbWVzKG51bGwsZnQobC5uYW1lLGUsbC5mb3JiaWRkZW5OYW1lcykpfWZ1bmN0aW9uIG1uKGUsdCx7ZGVjb25mbGljdGVkRGVmYXVsdDppLGRlY29uZmxpY3RlZE5hbWVzcGFjZTpzLGRlcGVuZGVuY2llczpufSxyLGEsbyxoLGwpe2Zvcihjb25zdCBjIG9mIG4pYy52YXJpYWJsZU5hbWU9ZnQoYy5zdWdnZXN0ZWRWYXJpYWJsZU5hbWUsZSxudWxsKTtmb3IoY29uc3QgYyBvZiBzKWMubmFtZXNwYWNlVmFyaWFibGVOYW1lPWZ0KGAke2Muc3VnZ2VzdGVkVmFyaWFibGVOYW1lfV9fbmFtZXNwYWNlYCxlLG51bGwpO2Zvcihjb25zdCBjIG9mIGkpYy5kZWZhdWx0VmFyaWFibGVOYW1lPXMuaGFzKGMpJiZYcChyKGMuaWQpLG8pP2MubmFtZXNwYWNlVmFyaWFibGVOYW1lOmZ0KGAke2Muc3VnZ2VzdGVkVmFyaWFibGVOYW1lfV9fZGVmYXVsdGAsZSxudWxsKTtmb3IoY29uc3QgYyBvZiB0KXtjb25zdCBwPWMubW9kdWxlO2lmKHAgaW5zdGFuY2VvZiBsZSl7Y29uc3QgbT1sLmdldChwKSx5PWMubmFtZTtpZih5PT09ImRlZmF1bHQiKXtjb25zdCBFPXIocC5pZCksZz1vbltFXT9tLmRlZmF1bHRWYXJpYWJsZU5hbWU6bS52YXJpYWJsZU5hbWU7aG4oRSxvKT9jLnNldFJlbmRlck5hbWVzKGcsImRlZmF1bHQiKTpjLnNldFJlbmRlck5hbWVzKG51bGwsZyl9ZWxzZSB5PT09IioiP2Muc2V0UmVuZGVyTmFtZXMobnVsbCx1c1tyKHAuaWQpXT9tLm5hbWVzcGFjZVZhcmlhYmxlTmFtZTptLnZhcmlhYmxlTmFtZSk6Yy5zZXRSZW5kZXJOYW1lcyhtLnZhcmlhYmxlTmFtZSxudWxsKX1lbHNle2NvbnN0IG09aC5nZXQocCk7YSYmYy5pc05hbWVzcGFjZT9jLnNldFJlbmRlck5hbWVzKG51bGwsbS5leHBvcnRNb2RlPT09ImRlZmF1bHQiP20ubmFtZXNwYWNlVmFyaWFibGVOYW1lOm0udmFyaWFibGVOYW1lKTptLmV4cG9ydE1vZGU9PT0iZGVmYXVsdCI/Yy5zZXRSZW5kZXJOYW1lcyhudWxsLG0udmFyaWFibGVOYW1lKTpjLnNldFJlbmRlck5hbWVzKG0udmFyaWFibGVOYW1lLG0uZ2V0VmFyaWFibGVFeHBvcnROYW1lKGMpKX19fWZ1bmN0aW9uIENkKGUse2V4cG9ydHM6dCxuYW1lOmksZm9ybWF0OnN9LG4scil7Y29uc3QgYT1lLmdldEV4cG9ydE5hbWVzKCk7aWYodD09PSJkZWZhdWx0Iil7aWYoYS5sZW5ndGghPT0xfHxhWzBdIT09ImRlZmF1bHQiKXJldHVybiBMKHdvKCJkZWZhdWx0IixhLG4pKX1lbHNlIGlmKHQ9PT0ibm9uZSImJmEubGVuZ3RoPjApcmV0dXJuIEwod28oIm5vbmUiLGEsbikpO3JldHVybiB0PT09ImF1dG8iJiYoYS5sZW5ndGg9PT0wP3Q9Im5vbmUiOmEubGVuZ3RoPT09MSYmYVswXT09PSJkZWZhdWx0Ij90PSJkZWZhdWx0IjoocyE9PSJlcyImJnMhPT0ic3lzdGVtIiYmYS5pbmNsdWRlcygiZGVmYXVsdCIpJiZyKEssZnVuY3Rpb24obyxoKXtyZXR1cm57Y29kZTpvcCxpZDpvLG1lc3NhZ2U6YEVudHJ5IG1vZHVsZSAiJHtYKG8pfSIgaXMgdXNpbmcgbmFtZWQgYW5kIGRlZmF1bHQgZXhwb3J0cyB0b2dldGhlci4gQ29uc3VtZXJzIG9mIHlvdXIgYnVuZGxlIHdpbGwgaGF2ZSB0byB1c2UgXGAke2h8fCJjaHVuayJ9LmRlZmF1bHRcYCB0byBhY2Nlc3MgdGhlIGRlZmF1bHQgZXhwb3J0LCB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnQuIFVzZSBcYG91dHB1dC5leHBvcnRzOiAibmFtZWQiXGAgdG8gZGlzYWJsZSB0aGlzIHdhcm5pbmcuYCx1cmw6X2UoWG4pfX0obixpKSksdD0ibmFtZWQiKSksdH1mdW5jdGlvbiBJZChlKXtjb25zdCB0PWUuc3BsaXQoYApgKSxpPXQuZmlsdGVyKHI9Pi9eXHQrLy50ZXN0KHIpKSxzPXQuZmlsdGVyKHI9Pi9eIHsyLH0vLnRlc3QocikpO2lmKGkubGVuZ3RoPT09MCYmcy5sZW5ndGg9PT0wKXJldHVybiBudWxsO2lmKGkubGVuZ3RoPj1zLmxlbmd0aClyZXR1cm4iCSI7Y29uc3Qgbj1zLnJlZHVjZSgocixhKT0+e2NvbnN0IG89L14gKy8uZXhlYyhhKVswXS5sZW5ndGg7cmV0dXJuIE1hdGgubWluKG8scil9LDEvMCk7cmV0dXJuIiAiLnJlcGVhdChuKX1mdW5jdGlvbiBzbChlLHQsaSxzLG4scil7Y29uc3QgYT1lLmdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpO2Zvcihjb25zdCBvIG9mIGEpe2lmKG8gaW5zdGFuY2VvZiBsZSl7dC5wdXNoKHIuZ2V0KG8pKTtjb250aW51ZX1jb25zdCBoPW4uZ2V0KG8pO2g9PT1zP2kuaGFzKG8pfHwoaS5hZGQobyksc2wobyx0LGkscyxuLHIpKTp0LnB1c2goaCl9fWNvbnN0IFlyPSIhfnsiLFhyPSJ9fiIsWnI9bmV3IFJlZ0V4cChgJHtZcn1bMC05YS16QS1aXyRdezEsNTl9JHtYcn1gLCJnIiksZGk9KGUsdCk9PmUucmVwbGFjZShacixpPT50LmdldChpKXx8aSksUGQ9KGUsdCxpKT0+ZS5yZXBsYWNlKFpyLHM9PnM9PT10P2k6cyksX2Q9KGUsdCk9Pntjb25zdCBpPW5ldyBTZXQscz1lLnJlcGxhY2UoWnIsbj0+dC5oYXMobik/KGkuYWRkKG4pLGAke1lyfSR7IjAiLnJlcGVhdChuLmxlbmd0aC01KX0ke1hyfWApOm4pO3JldHVybntjb250YWluZWRQbGFjZWhvbGRlcnM6aSx0cmFuc2Zvcm1lZENvZGU6c319LGduPVN5bWJvbCgiYnVuZGxlS2V5cyIpLEpyPXt0eXBlOiJwbGFjZWhvbGRlciJ9O2Z1bmN0aW9uIGVhKGUsdCxpKXtyZXR1cm4gTHMoZSk/TChCZShgSW52YWxpZCBwYXR0ZXJuICIke2V9IiBmb3IgIiR7dH0iLCBwYXR0ZXJucyBjYW4gYmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aHMuIElmIHlvdSB3YW50IHlvdXIgZmlsZXMgdG8gYmUgc3RvcmVkIGluIGEgc3ViZGlyZWN0b3J5LCB3cml0ZSBpdHMgbmFtZSB3aXRob3V0IGEgbGVhZGluZyBzbGFzaCBsaWtlIHRoaXM6IHN1YmRpcmVjdG9yeS9wYXR0ZXJuLmApKTplLnJlcGxhY2UoL1xbKFx3KykoOlxkKyk/XS9nLChzLG4scik9PntpZighaS5oYXNPd25Qcm9wZXJ0eShuKXx8ciYmbiE9PSJoYXNoIilyZXR1cm4gTChCZShgIlske259JHtyfHwiIn1dIiBpcyBub3QgYSB2YWxpZCBwbGFjZWhvbGRlciBpbiB0aGUgIiR7dH0iIHBhdHRlcm4uYCkpO2NvbnN0IGE9aVtuXShyJiZOdW1iZXIucGFyc2VJbnQoci5zbGljZSgxKSkpO3JldHVybiBMcyhhKT9MKEJlKGBJbnZhbGlkIHN1YnN0aXR1dGlvbiAiJHthfSIgZm9yIHBsYWNlaG9sZGVyICJbJHtufV0iIGluICIke3R9IiBwYXR0ZXJuLCBjYW4gYmUgbmVpdGhlciBhYnNvbHV0ZSBub3IgcmVsYXRpdmUgcGF0aC5gKSk6YX0pfWZ1bmN0aW9uIHRhKGUse1tnbl06dH0pe2lmKCF0LmhhcyhlLnRvTG93ZXJDYXNlKCkpKXJldHVybiBlO2NvbnN0IGk9TXQoZSk7ZT1lLnNsaWNlKDAsTWF0aC5tYXgoMCxlLmxlbmd0aC1pLmxlbmd0aCkpO2xldCBzLG49MTtmb3IoO3QuaGFzKChzPWUrICsrbitpKS50b0xvd2VyQ2FzZSgpKTspO3JldHVybiBzfWNvbnN0IE5kPW5ldyBTZXQoWyIuanMiLCIuanN4IiwiLnRzIiwiLnRzeCIsIi5tanMiLCIubXRzIiwiLmNqcyIsIi5jdHMiXSk7ZnVuY3Rpb24gJGQoZSx0LGkscyl7cmV0dXJuKHR5cGVvZiB0PT0iZnVuY3Rpb24iP3QoZS5pZCk6dFtlLmlkXSl8fChpPyhzKEssKHI9ZS5pZCxhPWUudmFyaWFibGVOYW1lLHtjb2RlOm5wLGlkOnIsbWVzc2FnZTpgTm8gbmFtZSB3YXMgcHJvdmlkZWQgZm9yIGV4dGVybmFsIG1vZHVsZSAiJHtyfSIgaW4gIm91dHB1dC5nbG9iYWxzIiDigJMgZ3Vlc3NpbmcgIiR7YX0iLmAsbmFtZXM6W2FdLHVybDpfZShGYyl9KSksZS52YXJpYWJsZU5hbWUpOnZvaWQgMCk7dmFyIHIsYX1jbGFzcyBXdHtjb25zdHJ1Y3Rvcih0LGkscyxuLHIsYSxvLGgsbCxjLHAsbSx5LEUsZyl7dGhpcy5vcmRlcmVkTW9kdWxlcz10LHRoaXMuaW5wdXRPcHRpb25zPWksdGhpcy5vdXRwdXRPcHRpb25zPXMsdGhpcy51bnNldE9wdGlvbnM9bix0aGlzLnBsdWdpbkRyaXZlcj1yLHRoaXMubW9kdWxlc0J5SWQ9YSx0aGlzLmNodW5rQnlNb2R1bGU9byx0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZT1oLHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZT1sLHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzPWMsdGhpcy5tYW51YWxDaHVua0FsaWFzPXAsdGhpcy5nZXRQbGFjZWhvbGRlcj1tLHRoaXMuYnVuZGxlPXksdGhpcy5pbnB1dEJhc2U9RSx0aGlzLnNuaXBwZXRzPWcsdGhpcy5lbnRyeU1vZHVsZXM9W10sdGhpcy5leHBvcnRNb2RlPSJuYW1lZCIsdGhpcy5mYWNhZGVNb2R1bGU9bnVsbCx0aGlzLm5hbWVzcGFjZVZhcmlhYmxlTmFtZT0iIix0aGlzLnZhcmlhYmxlTmFtZT0iIix0aGlzLmFjY2Vzc2VkR2xvYmFsc0J5U2NvcGU9bmV3IE1hcCx0aGlzLmRlcGVuZGVuY2llcz1uZXcgU2V0LHRoaXMuZHluYW1pY0VudHJ5TW9kdWxlcz1bXSx0aGlzLmR5bmFtaWNOYW1lPW51bGwsdGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGU9bmV3IE1hcCx0aGlzLmV4cG9ydHM9bmV3IFNldCx0aGlzLmV4cG9ydHNCeU5hbWU9bmV3IE1hcCx0aGlzLmZpbGVOYW1lPW51bGwsdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcz1bXSx0aGlzLmltcGxpY2l0bHlMb2FkZWRCZWZvcmU9bmV3IFNldCx0aGlzLmltcG9ydHM9bmV3IFNldCx0aGlzLmluY2x1ZGVkRHluYW1pY0ltcG9ydHM9bnVsbCx0aGlzLmluY2x1ZGVkUmVleHBvcnRzQnlNb2R1bGU9bmV3IE1hcCx0aGlzLmlzRW1wdHk9ITAsdGhpcy5uYW1lPW51bGwsdGhpcy5uZWVkc0V4cG9ydHNTaGltPSExLHRoaXMucHJlUmVuZGVyZWRDaHVua0luZm89bnVsbCx0aGlzLnByZWxpbWluYXJ5RmlsZU5hbWU9bnVsbCx0aGlzLnByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWU9bnVsbCx0aGlzLnJlbmRlcmVkQ2h1bmtJbmZvPW51bGwsdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcz1udWxsLHRoaXMucmVuZGVyZWRNb2R1bGVzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5zb3J0ZWRFeHBvcnROYW1lcz1udWxsLHRoaXMuc3RyaWN0RmFjYWRlPSExLHRoaXMuZXhlY0luZGV4PXQubGVuZ3RoPjA/dFswXS5leGVjSW5kZXg6MS8wO2NvbnN0IHg9bmV3IFNldCh0KTtmb3IoY29uc3QgdiBvZiB0KXtvLnNldCh2LHRoaXMpLHYubmFtZXNwYWNlLmluY2x1ZGVkJiYhcy5wcmVzZXJ2ZU1vZHVsZXMmJmMuYWRkKHYpLHRoaXMuaXNFbXB0eSYmdi5pc0luY2x1ZGVkKCkmJih0aGlzLmlzRW1wdHk9ITEpLCh2LmluZm8uaXNFbnRyeXx8cy5wcmVzZXJ2ZU1vZHVsZXMpJiZ0aGlzLmVudHJ5TW9kdWxlcy5wdXNoKHYpO2Zvcihjb25zdCB3IG9mIHYuaW5jbHVkZWREeW5hbWljSW1wb3J0ZXJzKXguaGFzKHcpfHwodGhpcy5keW5hbWljRW50cnlNb2R1bGVzLnB1c2godiksdi5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0cyYmKGMuYWRkKHYpLHRoaXMuZXhwb3J0cy5hZGQodi5uYW1lc3BhY2UpKSk7di5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIuc2l6ZT4wJiZ0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzLnB1c2godil9dGhpcy5zdWdnZXN0ZWRWYXJpYWJsZU5hbWU9SG4odGhpcy5nZW5lcmF0ZVZhcmlhYmxlTmFtZSgpKX1zdGF0aWMgZ2VuZXJhdGVGYWNhZGUodCxpLHMsbixyLGEsbyxoLGwsYyxwLG0seSxFLGcpe2NvbnN0IHg9bmV3IFd0KFtdLHQsaSxzLG4scixhLG8saCxsLG51bGwsbSx5LEUsZyk7eC5hc3NpZ25GYWNhZGVOYW1lKHAsYyksaC5oYXMoYyl8fGguc2V0KGMseCk7Zm9yKGNvbnN0IHYgb2YgYy5nZXREZXBlbmRlbmNpZXNUb0JlSW5jbHVkZWQoKSl4LmRlcGVuZGVuY2llcy5hZGQodiBpbnN0YW5jZW9mIHllP2EuZ2V0KHYpOm8uZ2V0KHYpKTtyZXR1cm4heC5kZXBlbmRlbmNpZXMuaGFzKGEuZ2V0KGMpKSYmYy5pbmZvLm1vZHVsZVNpZGVFZmZlY3RzJiZjLmhhc0VmZmVjdHMoKSYmeC5kZXBlbmRlbmNpZXMuYWRkKGEuZ2V0KGMpKSx4LmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShjKSx4LmZhY2FkZU1vZHVsZT1jLHguc3RyaWN0RmFjYWRlPSEwLHh9Y2FuTW9kdWxlQmVGYWNhZGUodCxpKXtjb25zdCBzPXQuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCk7Zm9yKGNvbnN0IG4gb2YgdGhpcy5leHBvcnRzKWlmKCFzLmhhcyhuKSlyZXR1cm4hMTtmb3IoY29uc3QgbiBvZiBpKWlmKCEobi5tb2R1bGU9PT10fHxzLmhhcyhuKXx8biBpbnN0YW5jZW9mIEZlJiZzLmhhcyhuLmdldEJhc2VWYXJpYWJsZSgpKSkpcmV0dXJuITE7cmV0dXJuITB9ZmluYWxpemVDaHVuayh0LGkscyxuKXtjb25zdCByPXRoaXMuZ2V0UmVuZGVyZWRDaHVua0luZm8oKSxhPWw9PmRpKGwsbiksbz1yLmZpbGVOYW1lLGg9dGhpcy5maWxlTmFtZT1hKG8pO3JldHVybnsuLi5yLGNvZGU6dCxkeW5hbWljSW1wb3J0czpyLmR5bmFtaWNJbXBvcnRzLm1hcChhKSxmaWxlTmFtZTpoLGltcGxpY2l0bHlMb2FkZWRCZWZvcmU6ci5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlLm1hcChhKSxpbXBvcnRlZEJpbmRpbmdzOk9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyLmltcG9ydGVkQmluZGluZ3MpLm1hcCgoW2wsY10pPT5bYShsKSxjXSkpLGltcG9ydHM6ci5pbXBvcnRzLm1hcChhKSxtYXA6aSxwcmVsaW1pbmFyeUZpbGVOYW1lOm8scmVmZXJlbmNlZEZpbGVzOnIucmVmZXJlbmNlZEZpbGVzLm1hcChhKSxzb3VyY2VtYXBGaWxlTmFtZTpzfX1nZW5lcmF0ZUV4cG9ydHMoKXt0aGlzLnNvcnRlZEV4cG9ydE5hbWVzPW51bGw7Y29uc3QgdD1uZXcgU2V0KHRoaXMuZXhwb3J0cyk7aWYodGhpcy5mYWNhZGVNb2R1bGUhPT1udWxsJiYodGhpcy5mYWNhZGVNb2R1bGUucHJlc2VydmVTaWduYXR1cmUhPT0hMXx8dGhpcy5zdHJpY3RGYWNhZGUpKXtjb25zdCBpPXRoaXMuZmFjYWRlTW9kdWxlLmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpO2Zvcihjb25zdFtzLG5db2YgaSl7dGhpcy5leHBvcnROYW1lc0J5VmFyaWFibGUuc2V0KHMsWy4uLm5dKTtmb3IoY29uc3QgciBvZiBuKXRoaXMuZXhwb3J0c0J5TmFtZS5zZXQocixzKTt0LmRlbGV0ZShzKX19dGhpcy5vdXRwdXRPcHRpb25zLm1pbmlmeUludGVybmFsRXhwb3J0cz9mdW5jdGlvbihpLHMsbil7bGV0IHI9MDtmb3IoY29uc3QgYSBvZiBpKXtsZXRbb109YS5uYW1lO2lmKHMuaGFzKG8pKWRvIG89UXMoKytyKSxvLmNoYXJDb2RlQXQoMCk9PT00OSYmKHIrPTkqNjQqKihvLmxlbmd0aC0xKSxvPVFzKHIpKTt3aGlsZShNcy5oYXMobyl8fHMuaGFzKG8pKTtzLnNldChvLGEpLG4uc2V0KGEsW29dKX19KHQsdGhpcy5leHBvcnRzQnlOYW1lLHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKTpmdW5jdGlvbihpLHMsbil7Zm9yKGNvbnN0IHIgb2YgaSl7bGV0IGE9MCxvPXIubmFtZTtmb3IoO3MuaGFzKG8pOylvPXIubmFtZSsiJCIrICsrYTtzLnNldChvLHIpLG4uc2V0KHIsW29dKX19KHQsdGhpcy5leHBvcnRzQnlOYW1lLHRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlKSwodGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlc3x8dGhpcy5mYWNhZGVNb2R1bGUmJnRoaXMuZmFjYWRlTW9kdWxlLmluZm8uaXNFbnRyeSkmJih0aGlzLmV4cG9ydE1vZGU9Q2QodGhpcyx0aGlzLm91dHB1dE9wdGlvbnMsdGhpcy5mYWNhZGVNb2R1bGUuaWQsdGhpcy5pbnB1dE9wdGlvbnMub25Mb2cpKX1nZW5lcmF0ZUZhY2FkZXMoKXt2YXIgbjtjb25zdCB0PVtdLGk9bmV3IFNldChbLi4udGhpcy5lbnRyeU1vZHVsZXMsLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc10pLHM9bmV3IFNldCh0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMubWFwKCh7bmFtZXNwYWNlOnJ9KT0+cikpO2Zvcihjb25zdCByIG9mIGkpaWYoci5wcmVzZXJ2ZVNpZ25hdHVyZSlmb3IoY29uc3QgYSBvZiByLmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpLmtleXMoKSl0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KGEubW9kdWxlKT09PXRoaXMmJnMuYWRkKGEpO2Zvcihjb25zdCByIG9mIGkpe2NvbnN0IGE9QXJyYXkuZnJvbShuZXcgU2V0KHIuY2h1bmtOYW1lcy5maWx0ZXIoKHtpc1VzZXJEZWZpbmVkOm99KT0+bykubWFwKCh7bmFtZTpvfSk9Pm8pKSxvPT4oe25hbWU6b30pKTtpZihhLmxlbmd0aD09PTAmJnIuaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnQmJmEucHVzaCh7fSksYS5wdXNoKC4uLkFycmF5LmZyb20oci5jaHVua0ZpbGVOYW1lcyxvPT4oe2ZpbGVOYW1lOm99KSkpLGEubGVuZ3RoPT09MCYmYS5wdXNoKHt9KSwhdGhpcy5mYWNhZGVNb2R1bGUpe2NvbnN0IG89IXRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMmJihyLnByZXNlcnZlU2lnbmF0dXJlPT09InN0cmljdCJ8fHIucHJlc2VydmVTaWduYXR1cmU9PT0iZXhwb3J0cy1vbmx5IiYmci5nZXRFeHBvcnROYW1lc0J5VmFyaWFibGUoKS5zaXplPjApO28mJiF0aGlzLmNhbk1vZHVsZUJlRmFjYWRlKHIscyl8fCh0aGlzLmZhY2FkZU1vZHVsZT1yLHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5zZXQocix0aGlzKSxyLnByZXNlcnZlU2lnbmF0dXJlJiYodGhpcy5zdHJpY3RGYWNhZGU9byksdGhpcy5hc3NpZ25GYWNhZGVOYW1lKGEuc2hpZnQoKSxyLHRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMpKX1mb3IoY29uc3QgbyBvZiBhKXQucHVzaChXdC5nZW5lcmF0ZUZhY2FkZSh0aGlzLmlucHV0T3B0aW9ucyx0aGlzLm91dHB1dE9wdGlvbnMsdGhpcy51bnNldE9wdGlvbnMsdGhpcy5wbHVnaW5Ecml2ZXIsdGhpcy5tb2R1bGVzQnlJZCx0aGlzLmNodW5rQnlNb2R1bGUsdGhpcy5leHRlcm5hbENodW5rQnlNb2R1bGUsdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLHIsbyx0aGlzLmdldFBsYWNlaG9sZGVyLHRoaXMuYnVuZGxlLHRoaXMuaW5wdXRCYXNlLHRoaXMuc25pcHBldHMpKX1mb3IoY29uc3QgciBvZiB0aGlzLmR5bmFtaWNFbnRyeU1vZHVsZXMpci5pbmZvLnN5bnRoZXRpY05hbWVkRXhwb3J0c3x8KCF0aGlzLmZhY2FkZU1vZHVsZSYmdGhpcy5jYW5Nb2R1bGVCZUZhY2FkZShyLHMpPyh0aGlzLmZhY2FkZU1vZHVsZT1yLHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5zZXQocix0aGlzKSx0aGlzLnN0cmljdEZhY2FkZT0hMCx0aGlzLmR5bmFtaWNOYW1lPWlhKHIpKTp0aGlzLmZhY2FkZU1vZHVsZT09PXImJiF0aGlzLnN0cmljdEZhY2FkZSYmdGhpcy5jYW5Nb2R1bGVCZUZhY2FkZShyLHMpP3RoaXMuc3RyaWN0RmFjYWRlPSEwOihuPXRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZS5nZXQocikpIT1udWxsJiZuLnN0cmljdEZhY2FkZXx8KHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmFkZChyKSx0aGlzLmV4cG9ydHMuYWRkKHIubmFtZXNwYWNlKSkpO3JldHVybiB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzfHx0aGlzLmFkZE5lY2Vzc2FyeUltcG9ydHNGb3JGYWNhZGVzKCksdH1nZXRDaHVua05hbWUoKXtyZXR1cm4gdGhpcy5uYW1lPz8odGhpcy5uYW1lPXRoaXMub3V0cHV0T3B0aW9ucy5zYW5pdGl6ZUZpbGVOYW1lKHRoaXMuZ2V0RmFsbGJhY2tDaHVua05hbWUoKSkpfWdldEV4cG9ydE5hbWVzKCl7cmV0dXJuIHRoaXMuc29ydGVkRXhwb3J0TmFtZXM/Pyh0aGlzLnNvcnRlZEV4cG9ydE5hbWVzPVsuLi50aGlzLmV4cG9ydHNCeU5hbWUua2V5cygpXS5zb3J0KCkpfWdldEZpbGVOYW1lKCl7cmV0dXJuIHRoaXMuZmlsZU5hbWV8fHRoaXMuZ2V0UHJlbGltaW5hcnlGaWxlTmFtZSgpLmZpbGVOYW1lfWdldEltcG9ydFBhdGgodCl7cmV0dXJuICRzKEphKHQsdGhpcy5nZXRGaWxlTmFtZSgpLHRoaXMub3V0cHV0T3B0aW9ucy5mb3JtYXQ9PT0iYW1kIiYmIXRoaXMub3V0cHV0T3B0aW9ucy5hbWQuZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMsITApKX1nZXRQcmVsaW1pbmFyeUZpbGVOYW1lKCl7dmFyIGg7aWYodGhpcy5wcmVsaW1pbmFyeUZpbGVOYW1lKXJldHVybiB0aGlzLnByZWxpbWluYXJ5RmlsZU5hbWU7bGV0IHQsaT1udWxsO2NvbnN0e2NodW5rRmlsZU5hbWVzOnMsZW50cnlGaWxlTmFtZXM6bixmaWxlOnIsZm9ybWF0OmEscHJlc2VydmVNb2R1bGVzOm99PXRoaXMub3V0cHV0T3B0aW9ucztpZihyKXQ9Q3Qocik7ZWxzZSBpZih0aGlzLmZpbGVOYW1lPT09bnVsbCl7Y29uc3RbbCxjXT1vfHwoaD10aGlzLmZhY2FkZU1vZHVsZSkhPW51bGwmJmguaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnQ/W24sIm91dHB1dC5lbnRyeUZpbGVOYW1lcyJdOltzLCJvdXRwdXQuY2h1bmtGaWxlTmFtZXMiXTt0PWVhKHR5cGVvZiBsPT0iZnVuY3Rpb24iP2wodGhpcy5nZXRQcmVSZW5kZXJlZENodW5rSW5mbygpKTpsLGMse2Zvcm1hdDooKT0+YSxoYXNoOnA9Pml8fChpPXRoaXMuZ2V0UGxhY2Vob2xkZXIoYyxwKSksbmFtZTooKT0+dGhpcy5nZXRDaHVua05hbWUoKX0pLGl8fCh0PXRhKHQsdGhpcy5idW5kbGUpKX1lbHNlIHQ9dGhpcy5maWxlTmFtZTtyZXR1cm4gaXx8KHRoaXMuYnVuZGxlW3RdPUpyKSx0aGlzLnByZWxpbWluYXJ5RmlsZU5hbWU9e2ZpbGVOYW1lOnQsaGFzaFBsYWNlaG9sZGVyOml9fWdldFByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWUoKXtpZih0aGlzLnByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWUpcmV0dXJuIHRoaXMucHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZTtsZXQgdD1udWxsLGk9bnVsbDtjb25zdHtzb3VyY2VtYXBGaWxlTmFtZXM6cyxmb3JtYXQ6bn09dGhpcy5vdXRwdXRPcHRpb25zO2lmKCFzKXJldHVybiBudWxsO3tjb25zdFtyLGFdPVtzLCJvdXRwdXQuc291cmNlbWFwRmlsZU5hbWVzIl07dD1lYSh0eXBlb2Ygcj09ImZ1bmN0aW9uIj9yKHRoaXMuZ2V0UHJlUmVuZGVyZWRDaHVua0luZm8oKSk6cixhLHtjaHVua2hhc2g6KCk9PnRoaXMuZ2V0UHJlbGltaW5hcnlGaWxlTmFtZSgpLmhhc2hQbGFjZWhvbGRlcnx8IiIsZm9ybWF0OigpPT5uLGhhc2g6bz0+aXx8KGk9dGhpcy5nZXRQbGFjZWhvbGRlcihhLG8pKSxuYW1lOigpPT50aGlzLmdldENodW5rTmFtZSgpfSksaXx8KHQ9dGEodCx0aGlzLmJ1bmRsZSkpfXJldHVybiB0aGlzLnByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWU9e2ZpbGVOYW1lOnQsaGFzaFBsYWNlaG9sZGVyOml9fWdldFJlbmRlcmVkQ2h1bmtJbmZvKCl7cmV0dXJuIHRoaXMucmVuZGVyZWRDaHVua0luZm8/dGhpcy5yZW5kZXJlZENodW5rSW5mbzp0aGlzLnJlbmRlcmVkQ2h1bmtJbmZvPXsuLi50aGlzLmdldFByZVJlbmRlcmVkQ2h1bmtJbmZvKCksZHluYW1pY0ltcG9ydHM6dGhpcy5nZXREeW5hbWljRGVwZW5kZW5jaWVzKCkubWFwKHluKSxmaWxlTmFtZTp0aGlzLmdldEZpbGVOYW1lKCksaW1wbGljaXRseUxvYWRlZEJlZm9yZTpBcnJheS5mcm9tKHRoaXMuaW1wbGljaXRseUxvYWRlZEJlZm9yZSx5biksaW1wb3J0ZWRCaW5kaW5nczpMZCh0aGlzLmdldFJlbmRlcmVkRGVwZW5kZW5jaWVzKCkseW4pLGltcG9ydHM6QXJyYXkuZnJvbSh0aGlzLmRlcGVuZGVuY2llcyx5biksbW9kdWxlczp0aGlzLnJlbmRlcmVkTW9kdWxlcyxyZWZlcmVuY2VkRmlsZXM6dGhpcy5nZXRSZWZlcmVuY2VkRmlsZXMoKX19Z2V0VmFyaWFibGVFeHBvcnROYW1lKHQpe3JldHVybiB0aGlzLm91dHB1dE9wdGlvbnMucHJlc2VydmVNb2R1bGVzJiZ0IGluc3RhbmNlb2YgZHM/IioiOnRoaXMuZXhwb3J0TmFtZXNCeVZhcmlhYmxlLmdldCh0KVswXX1saW5rKCl7dGhpcy5kZXBlbmRlbmNpZXM9ZnVuY3Rpb24odCxpLHMsbil7Y29uc3Qgcj1bXSxhPW5ldyBTZXQ7Zm9yKGxldCBoPWkubGVuZ3RoLTE7aD49MDtoLS0pe2NvbnN0IGw9aVtoXTtpZighYS5oYXMobCkpe2NvbnN0IGM9W107c2wobCxjLGEsdCxzLG4pLHIudW5zaGlmdChjKX19Y29uc3Qgbz1uZXcgU2V0O2Zvcihjb25zdCBoIG9mIHIpZm9yKGNvbnN0IGwgb2YgaClvLmFkZChsKTtyZXR1cm4gb30odGhpcyx0aGlzLm9yZGVyZWRNb2R1bGVzLHRoaXMuY2h1bmtCeU1vZHVsZSx0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZSk7Zm9yKGNvbnN0IHQgb2YgdGhpcy5vcmRlcmVkTW9kdWxlcyl0aGlzLmFkZEltcGxpY2l0bHlMb2FkZWRCZWZvcmVGcm9tTW9kdWxlKHQpLHRoaXMuc2V0VXBDaHVua0ltcG9ydHNBbmRFeHBvcnRzRm9yTW9kdWxlKHQpfWFzeW5jIHJlbmRlcigpe2NvbnN0e2RlcGVuZGVuY2llczp0LGV4cG9ydE1vZGU6aSxmYWNhZGVNb2R1bGU6cyxpbnB1dE9wdGlvbnM6e29uTG9nOm59LG91dHB1dE9wdGlvbnM6cixwbHVnaW5Ecml2ZXI6YSxzbmlwcGV0czpvfT10aGlzLHtmb3JtYXQ6aCxob2lzdFRyYW5zaXRpdmVJbXBvcnRzOmwscHJlc2VydmVNb2R1bGVzOmN9PXI7aWYobCYmIWMmJnMhPT1udWxsKWZvcihjb25zdCBVIG9mIHQpVSBpbnN0YW5jZW9mIFd0JiZ0aGlzLmlubGluZUNodW5rRGVwZW5kZW5jaWVzKFUpO2NvbnN0IHA9dGhpcy5nZXRQcmVsaW1pbmFyeUZpbGVOYW1lKCksbT10aGlzLmdldFByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWUoKSx7YWNjZXNzZWRHbG9iYWxzOnksaW5kZW50OkUsbWFnaWNTdHJpbmc6ZyxyZW5kZXJlZFNvdXJjZTp4LHVzZWRNb2R1bGVzOnYsdXNlc1RvcExldmVsQXdhaXQ6d309dGhpcy5yZW5kZXJNb2R1bGVzKHAuZmlsZU5hbWUpLGI9Wy4uLnRoaXMuZ2V0UmVuZGVyZWREZXBlbmRlbmNpZXMoKS52YWx1ZXMoKV0sUz1pPT09Im5vbmUiP1tdOnRoaXMuZ2V0Q2h1bmtFeHBvcnREZWNsYXJhdGlvbnMoaCk7bGV0IGs9Uy5sZW5ndGg+MCxDPSExO2Zvcihjb25zdCBVIG9mIGIpe2NvbnN0e3JlZXhwb3J0czpPfT1VO08hPW51bGwmJk8ubGVuZ3RoJiYoaz0hMCwhQyYmTy5zb21lKEc9PkcucmVleHBvcnRlZD09PSJkZWZhdWx0IikmJihDPSEwKSxoPT09ImVzIiYmKFUucmVleHBvcnRzPU8uZmlsdGVyKCh7cmVleHBvcnRlZDpHfSk9PiFTLmZpbmQoKHtleHBvcnRlZDpSfSk9PlI9PT1HKSkpKX1pZighQyl7Zm9yKGNvbnN0e2V4cG9ydGVkOlV9b2YgUylpZihVPT09ImRlZmF1bHQiKXtDPSEwO2JyZWFrfX1jb25zdHtpbnRybzpQLG91dHJvOl8sYmFubmVyOkEsZm9vdGVyOk59PWF3YWl0IGtkKHIsYSx0aGlzLmdldFJlbmRlcmVkQ2h1bmtJbmZvKCkpO3JldHVybiBTZFtoXSh4LHthY2Nlc3NlZEdsb2JhbHM6eSxkZXBlbmRlbmNpZXM6YixleHBvcnRzOlMsaGFzRGVmYXVsdEV4cG9ydDpDLGhhc0V4cG9ydHM6ayxpZDpwLmZpbGVOYW1lLGluZGVudDpFLGludHJvOlAsaXNFbnRyeUZhY2FkZTpjfHxzIT09bnVsbCYmcy5pbmZvLmlzRW50cnksaXNNb2R1bGVGYWNhZGU6cyE9PW51bGwsbG9nOm4sbmFtZWRFeHBvcnRzTW9kZTppIT09ImRlZmF1bHQiLG91dHJvOl8sc25pcHBldHM6byx1c2VzVG9wTGV2ZWxBd2FpdDp3fSxyKSxBJiZnLnByZXBlbmQoQSksTiYmZy5hcHBlbmQoTikse2NodW5rOnRoaXMsbWFnaWNTdHJpbmc6ZyxwcmVsaW1pbmFyeUZpbGVOYW1lOnAscHJlbGltaW5hcnlTb3VyY2VtYXBGaWxlTmFtZTptLHVzZWRNb2R1bGVzOnZ9fWFkZEltcGxpY2l0bHlMb2FkZWRCZWZvcmVGcm9tTW9kdWxlKHQpe2NvbnN0e2NodW5rQnlNb2R1bGU6aSxpbXBsaWNpdGx5TG9hZGVkQmVmb3JlOnN9PXRoaXM7Zm9yKGNvbnN0IG4gb2YgdC5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlKXtjb25zdCByPWkuZ2V0KG4pO3ImJnIhPT10aGlzJiZzLmFkZChyKX19YWRkTmVjZXNzYXJ5SW1wb3J0c0ZvckZhY2FkZXMoKXtmb3IoY29uc3RbdCxpXW9mIHRoaXMuaW5jbHVkZWRSZWV4cG9ydHNCeU1vZHVsZSlpZih0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcy5oYXModCkpZm9yKGNvbnN0IHMgb2YgaSl0aGlzLmltcG9ydHMuYWRkKHMpfWFzc2lnbkZhY2FkZU5hbWUoe2ZpbGVOYW1lOnQsbmFtZTppfSxzLG4pe3Q/dGhpcy5maWxlTmFtZT10OnRoaXMubmFtZT10aGlzLm91dHB1dE9wdGlvbnMuc2FuaXRpemVGaWxlTmFtZShpfHwobj90aGlzLmdldFByZXNlcnZlTW9kdWxlc0NodW5rTmFtZUZyb21Nb2R1bGUocyk6aWEocykpKX1jaGVja0NpcmN1bGFyRGVwZW5kZW5jeUltcG9ydCh0LGkpe3ZhciBsO2NvbnN0IHM9dC5tb2R1bGU7aWYocyBpbnN0YW5jZW9mIHllKXtjb25zdCBjPXRoaXMuY2h1bmtCeU1vZHVsZS5nZXQocyk7bGV0IHA7ZG8gcD1pLmFsdGVybmF0aXZlUmVleHBvcnRNb2R1bGVzLmdldCh0KSxwJiYodGhpcy5jaHVua0J5TW9kdWxlLmdldChwKSE9PWMmJnRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKEssKG49KChsPXMuZ2V0RXhwb3J0TmFtZXNCeVZhcmlhYmxlKCkuZ2V0KHQpKT09bnVsbD92b2lkIDA6bFswXSl8fCIqIixyPXMuaWQsYT1wLmlkLG89aS5pZCxoPXRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXMse2NvZGU6IkNZQ0xJQ19DUk9TU19DSFVOS19SRUVYUE9SVCIsZXhwb3J0ZXI6cixpZDpvLG1lc3NhZ2U6YEV4cG9ydCAiJHtufSIgb2YgbW9kdWxlICIke1gocil9IiB3YXMgcmVleHBvcnRlZCB0aHJvdWdoIG1vZHVsZSAiJHtYKGEpfSIgd2hpbGUgYm90aCBtb2R1bGVzIGFyZSBkZXBlbmRlbmNpZXMgb2YgZWFjaCBvdGhlciBhbmQgd2lsbCBlbmQgdXAgaW4gZGlmZmVyZW50IGNodW5rcyBieSBjdXJyZW50IFJvbGx1cCBzZXR0aW5ncy4gVGhpcyBzY2VuYXJpbyBpcyBub3Qgd2VsbCBzdXBwb3J0ZWQgYXQgdGhlIG1vbWVudCBhcyBpdCB3aWxsIHByb2R1Y2UgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gY2h1bmtzIGFuZCB3aWxsIGxpa2VseSBsZWFkIHRvIGJyb2tlbiBleGVjdXRpb24gb3JkZXIuCkVpdGhlciBjaGFuZ2UgdGhlIGltcG9ydCBpbiAiJHtYKG8pfSIgdG8gcG9pbnQgZGlyZWN0bHkgdG8gdGhlIGV4cG9ydGluZyBtb2R1bGUgb3IgJHtoPydkbyBub3QgdXNlICJvdXRwdXQucHJlc2VydmVNb2R1bGVzIic6J3JlY29uZmlndXJlICJvdXRwdXQubWFudWFsQ2h1bmtzIid9IHRvIGVuc3VyZSB0aGVzZSBtb2R1bGVzIGVuZCB1cCBpbiB0aGUgc2FtZSBjaHVuay5gLHJlZXhwb3J0ZXI6YX0pKSxpPXApO3doaWxlKHApfXZhciBuLHIsYSxvLGh9ZW5zdXJlUmVleHBvcnRzQXJlQXZhaWxhYmxlRm9yTW9kdWxlKHQpe2NvbnN0IGk9W10scz10LmdldEV4cG9ydE5hbWVzQnlWYXJpYWJsZSgpO2Zvcihjb25zdCBuIG9mIHMua2V5cygpKXtjb25zdCByPW4gaW5zdGFuY2VvZiBGZSxhPXI/bi5nZXRCYXNlVmFyaWFibGUoKTpuO2lmKHRoaXMuY2hlY2tDaXJjdWxhckRlcGVuZGVuY3lJbXBvcnQoYSx0KSwhKGEgaW5zdGFuY2VvZiBkcyYmdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcykpe2NvbnN0IG89YS5tb2R1bGU7aWYobyBpbnN0YW5jZW9mIHllKXtjb25zdCBoPXRoaXMuY2h1bmtCeU1vZHVsZS5nZXQobyk7aCYmaCE9PXRoaXMmJihoLmV4cG9ydHMuYWRkKGEpLGkucHVzaChhKSxyJiZ0aGlzLmltcG9ydHMuYWRkKGEpKX19fWkubGVuZ3RoPjAmJnRoaXMuaW5jbHVkZWRSZWV4cG9ydHNCeU1vZHVsZS5zZXQodCxpKX1nZW5lcmF0ZVZhcmlhYmxlTmFtZSgpe2lmKHRoaXMubWFudWFsQ2h1bmtBbGlhcylyZXR1cm4gdGhpcy5tYW51YWxDaHVua0FsaWFzO2NvbnN0IHQ9dGhpcy5lbnRyeU1vZHVsZXNbMF18fHRoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXNbMF18fHRoaXMuZHluYW1pY0VudHJ5TW9kdWxlc1swXXx8dGhpcy5vcmRlcmVkTW9kdWxlc1t0aGlzLm9yZGVyZWRNb2R1bGVzLmxlbmd0aC0xXTtyZXR1cm4gdD9pYSh0KToiY2h1bmsifWdldENodW5rRXhwb3J0RGVjbGFyYXRpb25zKHQpe2NvbnN0IGk9W107Zm9yKGNvbnN0IHMgb2YgdGhpcy5nZXRFeHBvcnROYW1lcygpKXtpZihzWzBdPT09IioiKWNvbnRpbnVlO2NvbnN0IG49dGhpcy5leHBvcnRzQnlOYW1lLmdldChzKTtpZighKG4gaW5zdGFuY2VvZiBGZSkpe2NvbnN0IGg9bi5tb2R1bGU7aWYoaCl7Y29uc3QgbD10aGlzLmNodW5rQnlNb2R1bGUuZ2V0KGgpO2lmKGwhPT10aGlzKXtpZighbHx8dCE9PSJlcyIpY29udGludWU7Y29uc3QgYz10aGlzLnJlbmRlcmVkRGVwZW5kZW5jaWVzLmdldChsKTtpZighYyljb250aW51ZTtjb25zdHtpbXBvcnRzOnAscmVleHBvcnRzOm19PWMseT1tPT1udWxsP3ZvaWQgMDptLmZpbmQoKHtyZWV4cG9ydGVkOmd9KT0+Zz09PXMpO2lmKCEocD09bnVsbD92b2lkIDA6cC5maW5kKCh7aW1wb3J0ZWQ6Z30pPT5nPT09KHk9PW51bGw/dm9pZCAwOnkuaW1wb3J0ZWQpKSkpY29udGludWV9fX1sZXQgcj1udWxsLGE9ITEsbz1uLmdldE5hbWUodGhpcy5zbmlwcGV0cy5nZXRQcm9wZXJ0eUFjY2Vzcyk7aWYobiBpbnN0YW5jZW9mIFB0KXtmb3IoY29uc3QgaCBvZiBuLmRlY2xhcmF0aW9ucylpZihoLnBhcmVudCBpbnN0YW5jZW9mIGhzfHxoIGluc3RhbmNlb2Ygc24mJmguZGVjbGFyYXRpb24gaW5zdGFuY2VvZiBocyl7YT0hMDticmVha319ZWxzZSBuIGluc3RhbmNlb2YgRmUmJihyPW8sdD09PSJlcyImJihvPW4ucmVuZGVyTmFtZSkpO2kucHVzaCh7ZXhwb3J0ZWQ6cyxleHByZXNzaW9uOnIsaG9pc3RlZDphLGxvY2FsOm99KX1yZXR1cm4gaX1nZXREZXBlbmRlbmNpZXNUb0JlRGVjb25mbGljdGVkKHQsaSxzKXtjb25zdCBuPW5ldyBTZXQscj1uZXcgU2V0LGE9bmV3IFNldDtmb3IoY29uc3QgbyBvZlsuLi50aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5rZXlzKCksLi4udGhpcy5pbXBvcnRzXSlpZih0fHxvLmlzTmFtZXNwYWNlKXtjb25zdCBoPW8ubW9kdWxlO2lmKGggaW5zdGFuY2VvZiBsZSl7Y29uc3QgbD10aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQoaCk7bi5hZGQobCksdCYmKG8ubmFtZT09PSJkZWZhdWx0Ij9vbltzKGguaWQpXSYmci5hZGQobCk6by5uYW1lPT09IioiJiZ1c1tzKGguaWQpXSYmYS5hZGQobCkpfWVsc2V7Y29uc3QgbD10aGlzLmNodW5rQnlNb2R1bGUuZ2V0KGgpO2whPT10aGlzJiYobi5hZGQobCksdCYmbC5leHBvcnRNb2RlPT09ImRlZmF1bHQiJiZvLmlzTmFtZXNwYWNlJiZhLmFkZChsKSl9fWlmKGkpZm9yKGNvbnN0IG8gb2YgdGhpcy5kZXBlbmRlbmNpZXMpbi5hZGQobyk7cmV0dXJue2RlY29uZmxpY3RlZERlZmF1bHQ6cixkZWNvbmZsaWN0ZWROYW1lc3BhY2U6YSxkZXBlbmRlbmNpZXM6bn19Z2V0RHluYW1pY0RlcGVuZGVuY2llcygpe3JldHVybiB0aGlzLmdldEluY2x1ZGVkRHluYW1pY0ltcG9ydHMoKS5tYXAodD0+dC5mYWNhZGVDaHVua3x8dC5jaHVua3x8dC5leHRlcm5hbENodW5rfHx0LnJlc29sdXRpb24pLmZpbHRlcih0PT50IT09dGhpcyYmKHQgaW5zdGFuY2VvZiBXdHx8dCBpbnN0YW5jZW9mIEVpKSl9Z2V0RHluYW1pY0ltcG9ydFN0cmluZ0FuZEFzc2VydGlvbnModCxpKXtpZih0IGluc3RhbmNlb2YgbGUpe2NvbnN0IHM9dGhpcy5leHRlcm5hbENodW5rQnlNb2R1bGUuZ2V0KHQpO3JldHVybltgJyR7cy5nZXRJbXBvcnRQYXRoKGkpfSdgLHMuZ2V0SW1wb3J0QXNzZXJ0aW9ucyh0aGlzLnNuaXBwZXRzKV19cmV0dXJuW3R8fCIiLHRoaXMub3V0cHV0T3B0aW9ucy5mb3JtYXQ9PT0iZXMiJiZ0aGlzLm91dHB1dE9wdGlvbnMuZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zfHxudWxsXX1nZXRGYWxsYmFja0NodW5rTmFtZSgpe3JldHVybiB0aGlzLm1hbnVhbENodW5rQWxpYXM/dGhpcy5tYW51YWxDaHVua0FsaWFzOnRoaXMuZHluYW1pY05hbWU/dGhpcy5keW5hbWljTmFtZTp0aGlzLmZpbGVOYW1lP1VuKHRoaXMuZmlsZU5hbWUpOlVuKHRoaXMub3JkZXJlZE1vZHVsZXNbdGhpcy5vcmRlcmVkTW9kdWxlcy5sZW5ndGgtMV0uaWQpfWdldEltcG9ydFNwZWNpZmllcnMoKXtjb25zdHtpbnRlcm9wOnR9PXRoaXMub3V0cHV0T3B0aW9ucyxpPW5ldyBNYXA7Zm9yKGNvbnN0IHMgb2YgdGhpcy5pbXBvcnRzKXtjb25zdCBuPXMubW9kdWxlO2xldCByLGE7aWYobiBpbnN0YW5jZW9mIGxlKXtpZihyPXRoaXMuZXh0ZXJuYWxDaHVua0J5TW9kdWxlLmdldChuKSxhPXMubmFtZSxhIT09ImRlZmF1bHQiJiZhIT09IioiJiZ0KG4uaWQpPT09ImRlZmF1bHRPbmx5IilyZXR1cm4gTChDbyhuLmlkLGEsITEpKX1lbHNlIHI9dGhpcy5jaHVua0J5TW9kdWxlLmdldChuKSxhPXIuZ2V0VmFyaWFibGVFeHBvcnROYW1lKHMpO0dlKGkscixlbykucHVzaCh7aW1wb3J0ZWQ6YSxsb2NhbDpzLmdldE5hbWUodGhpcy5zbmlwcGV0cy5nZXRQcm9wZXJ0eUFjY2Vzcyl9KX1yZXR1cm4gaX1nZXRJbmNsdWRlZER5bmFtaWNJbXBvcnRzKCl7aWYodGhpcy5pbmNsdWRlZER5bmFtaWNJbXBvcnRzKXJldHVybiB0aGlzLmluY2x1ZGVkRHluYW1pY0ltcG9ydHM7Y29uc3QgdD1bXTtmb3IoY29uc3QgaSBvZiB0aGlzLm9yZGVyZWRNb2R1bGVzKWZvcihjb25zdHtub2RlOnMscmVzb2x1dGlvbjpufW9mIGkuZHluYW1pY0ltcG9ydHMpcy5pbmNsdWRlZCYmdC5wdXNoKG4gaW5zdGFuY2VvZiB5ZT97Y2h1bms6dGhpcy5jaHVua0J5TW9kdWxlLmdldChuKSxleHRlcm5hbENodW5rOm51bGwsZmFjYWRlQ2h1bms6dGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlLmdldChuKSxub2RlOnMscmVzb2x1dGlvbjpufTpuIGluc3RhbmNlb2YgbGU/e2NodW5rOm51bGwsZXh0ZXJuYWxDaHVuazp0aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQobiksZmFjYWRlQ2h1bms6bnVsbCxub2RlOnMscmVzb2x1dGlvbjpufTp7Y2h1bms6bnVsbCxleHRlcm5hbENodW5rOm51bGwsZmFjYWRlQ2h1bms6bnVsbCxub2RlOnMscmVzb2x1dGlvbjpufSk7cmV0dXJuIHRoaXMuaW5jbHVkZWREeW5hbWljSW1wb3J0cz10fWdldFByZVJlbmRlcmVkQ2h1bmtJbmZvKCl7aWYodGhpcy5wcmVSZW5kZXJlZENodW5rSW5mbylyZXR1cm4gdGhpcy5wcmVSZW5kZXJlZENodW5rSW5mbztjb25zdHtkeW5hbWljRW50cnlNb2R1bGVzOnQsZmFjYWRlTW9kdWxlOmksaW1wbGljaXRFbnRyeU1vZHVsZXM6cyxvcmRlcmVkTW9kdWxlczpufT10aGlzO3JldHVybiB0aGlzLnByZVJlbmRlcmVkQ2h1bmtJbmZvPXtleHBvcnRzOnRoaXMuZ2V0RXhwb3J0TmFtZXMoKSxmYWNhZGVNb2R1bGVJZDppJiZpLmlkLGlzRHluYW1pY0VudHJ5OnQubGVuZ3RoPjAsaXNFbnRyeTohIShpIT1udWxsJiZpLmluZm8uaXNFbnRyeSksaXNJbXBsaWNpdEVudHJ5OnMubGVuZ3RoPjAsbW9kdWxlSWRzOm4ubWFwKCh7aWQ6cn0pPT5yKSxuYW1lOnRoaXMuZ2V0Q2h1bmtOYW1lKCksdHlwZToiY2h1bmsifX1nZXRQcmVzZXJ2ZU1vZHVsZXNDaHVua05hbWVGcm9tTW9kdWxlKHQpe2NvbnN0IGk9bmwodCk7aWYoaSlyZXR1cm4gaTtjb25zdHtwcmVzZXJ2ZU1vZHVsZXNSb290OnMsc2FuaXRpemVGaWxlTmFtZTpufT10aGlzLm91dHB1dE9wdGlvbnMscj1uKEdpKHQuaWQuc3BsaXQoVGQsMSlbMF0pKSxhPU10KHIpLG89TmQuaGFzKGEpP3Iuc2xpY2UoMCwtYS5sZW5ndGgpOnI7cmV0dXJuIFZ0KG8pP3MmJmh0KG8pLnN0YXJ0c1dpdGgocyk/by5zbGljZShzLmxlbmd0aCkucmVwbGFjZSgvXlsvXFxdLywiIik6dmkodGhpcy5pbnB1dEJhc2Usbyk6YF92aXJ0dWFsLyR7Q3Qobyl9YH1nZXRSZWV4cG9ydFNwZWNpZmllcnMoKXtjb25zdHtleHRlcm5hbExpdmVCaW5kaW5nczp0LGludGVyb3A6aX09dGhpcy5vdXRwdXRPcHRpb25zLHM9bmV3IE1hcDtmb3IobGV0IG4gb2YgdGhpcy5nZXRFeHBvcnROYW1lcygpKXtsZXQgcixhLG89ITE7aWYoblswXT09PSIqIil7Y29uc3QgaD1uLnNsaWNlKDEpO2koaCk9PT0iZGVmYXVsdE9ubHkiJiZ0aGlzLmlucHV0T3B0aW9ucy5vbkxvZyhLLHhwKGgpKSxvPXQscj10aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQodGhpcy5tb2R1bGVzQnlJZC5nZXQoaCkpLGE9bj0iKiJ9ZWxzZXtjb25zdCBoPXRoaXMuZXhwb3J0c0J5TmFtZS5nZXQobik7aWYoaCBpbnN0YW5jZW9mIEZlKWNvbnRpbnVlO2NvbnN0IGw9aC5tb2R1bGU7aWYobCBpbnN0YW5jZW9mIHllKXtpZihyPXRoaXMuY2h1bmtCeU1vZHVsZS5nZXQobCkscj09PXRoaXMpY29udGludWU7YT1yLmdldFZhcmlhYmxlRXhwb3J0TmFtZShoKSxvPWguaXNSZWFzc2lnbmVkfWVsc2V7aWYocj10aGlzLmV4dGVybmFsQ2h1bmtCeU1vZHVsZS5nZXQobCksYT1oLm5hbWUsYSE9PSJkZWZhdWx0IiYmYSE9PSIqIiYmaShsLmlkKT09PSJkZWZhdWx0T25seSIpcmV0dXJuIEwoQ28obC5pZCxhLCEwKSk7bz10JiYoYSE9PSJkZWZhdWx0Inx8aG4oaShsLmlkKSwhMCkpfX1HZShzLHIsZW8pLnB1c2goe2ltcG9ydGVkOmEsbmVlZHNMaXZlQmluZGluZzpvLHJlZXhwb3J0ZWQ6bn0pfXJldHVybiBzfWdldFJlZmVyZW5jZWRGaWxlcygpe2NvbnN0IHQ9bmV3IFNldDtmb3IoY29uc3QgaSBvZiB0aGlzLm9yZGVyZWRNb2R1bGVzKWZvcihjb25zdCBzIG9mIGkuaW1wb3J0TWV0YXMpe2NvbnN0IG49cy5nZXRSZWZlcmVuY2VkRmlsZU5hbWUodGhpcy5wbHVnaW5Ecml2ZXIpO24mJnQuYWRkKG4pfXJldHVyblsuLi50XX1nZXRSZW5kZXJlZERlcGVuZGVuY2llcygpe2lmKHRoaXMucmVuZGVyZWREZXBlbmRlbmNpZXMpcmV0dXJuIHRoaXMucmVuZGVyZWREZXBlbmRlbmNpZXM7Y29uc3QgdD10aGlzLmdldEltcG9ydFNwZWNpZmllcnMoKSxpPXRoaXMuZ2V0UmVleHBvcnRTcGVjaWZpZXJzKCkscz1uZXcgTWFwLG49dGhpcy5nZXRGaWxlTmFtZSgpO2Zvcihjb25zdCByIG9mIHRoaXMuZGVwZW5kZW5jaWVzKXtjb25zdCBhPXQuZ2V0KHIpfHxudWxsLG89aS5nZXQocil8fG51bGwsaD1yIGluc3RhbmNlb2YgRWl8fHIuZXhwb3J0TW9kZSE9PSJkZWZhdWx0IixsPXIuZ2V0SW1wb3J0UGF0aChuKTtzLnNldChyLHthc3NlcnRpb25zOnIgaW5zdGFuY2VvZiBFaT9yLmdldEltcG9ydEFzc2VydGlvbnModGhpcy5zbmlwcGV0cyk6bnVsbCxkZWZhdWx0VmFyaWFibGVOYW1lOnIuZGVmYXVsdFZhcmlhYmxlTmFtZSxnbG9iYWxOYW1lOnIgaW5zdGFuY2VvZiBFaSYmKHRoaXMub3V0cHV0T3B0aW9ucy5mb3JtYXQ9PT0idW1kInx8dGhpcy5vdXRwdXRPcHRpb25zLmZvcm1hdD09PSJpaWZlIikmJiRkKHIsdGhpcy5vdXRwdXRPcHRpb25zLmdsb2JhbHMsKGF8fG8pIT09bnVsbCx0aGlzLmlucHV0T3B0aW9ucy5vbkxvZyksaW1wb3J0UGF0aDpsLGltcG9ydHM6YSxpc0NodW5rOnIgaW5zdGFuY2VvZiBXdCxuYW1lOnIudmFyaWFibGVOYW1lLG5hbWVkRXhwb3J0c01vZGU6aCxuYW1lc3BhY2VWYXJpYWJsZU5hbWU6ci5uYW1lc3BhY2VWYXJpYWJsZU5hbWUscmVleHBvcnRzOm99KX1yZXR1cm4gdGhpcy5yZW5kZXJlZERlcGVuZGVuY2llcz1zfWlubGluZUNodW5rRGVwZW5kZW5jaWVzKHQpe2Zvcihjb25zdCBpIG9mIHQuZGVwZW5kZW5jaWVzKXRoaXMuZGVwZW5kZW5jaWVzLmhhcyhpKXx8KHRoaXMuZGVwZW5kZW5jaWVzLmFkZChpKSxpIGluc3RhbmNlb2YgV3QmJnRoaXMuaW5saW5lQ2h1bmtEZXBlbmRlbmNpZXMoaSkpfXJlbmRlck1vZHVsZXModCl7dmFyIFc7Y29uc3R7YWNjZXNzZWRHbG9iYWxzQnlTY29wZTppLGRlcGVuZGVuY2llczpzLGV4cG9ydE5hbWVzQnlWYXJpYWJsZTpuLGluY2x1ZGVkTmFtZXNwYWNlczpyLGlucHV0T3B0aW9uczp7b25Mb2c6YX0saXNFbXB0eTpvLG9yZGVyZWRNb2R1bGVzOmgsb3V0cHV0T3B0aW9uczpsLHBsdWdpbkRyaXZlcjpjLHJlbmRlcmVkTW9kdWxlczpwLHNuaXBwZXRzOm19PXRoaXMse2NvbXBhY3Q6eSxkeW5hbWljSW1wb3J0RnVuY3Rpb246RSxmb3JtYXQ6ZyxmcmVlemU6eCxuYW1lc3BhY2VUb1N0cmluZ1RhZzp2fT1sLHtfOncsY25zdDpiLG46U309bTt0aGlzLnNldER5bmFtaWNJbXBvcnRSZXNvbHV0aW9ucyh0KSx0aGlzLnNldEltcG9ydE1ldGFSZXNvbHV0aW9ucyh0KSx0aGlzLnNldElkZW50aWZpZXJSZW5kZXJSZXNvbHV0aW9ucygpO2NvbnN0IGs9bmV3IGtjKHtzZXBhcmF0b3I6YCR7U30ke1N9YH0pLEM9ZnVuY3Rpb24oaixCKXtpZihCLmluZGVudCE9PSEwKXJldHVybiBCLmluZGVudDtmb3IoY29uc3QgYWUgb2Ygail7Y29uc3QgeGU9SWQoYWUub3JpZ2luYWxDb2RlKTtpZih4ZSE9PW51bGwpcmV0dXJuIHhlfXJldHVybiIJIn0oaCxsKSxQPVtdO2xldCBfPSIiO2NvbnN0IEE9bmV3IFNldCxOPW5ldyBNYXAsVT17YWNjZXNzZWREb2N1bWVudEN1cnJlbnRTY3JpcHQ6ITEsZHluYW1pY0ltcG9ydEZ1bmN0aW9uOkUsZXhwb3J0TmFtZXNCeVZhcmlhYmxlOm4sZm9ybWF0OmcsZnJlZXplOngsaW5kZW50OkMsbmFtZXNwYWNlVG9TdHJpbmdUYWc6dixwbHVnaW5Ecml2ZXI6YyxzbmlwcGV0czptLHVzZU9yaWdpbmFsTmFtZTpudWxsfTtsZXQgTz0hMTtmb3IoY29uc3QgaiBvZiBoKXtsZXQgQixhZT0wO2lmKGouaXNJbmNsdWRlZCgpfHxyLmhhcyhqKSl7Y29uc3QgZmU9ai5yZW5kZXIoVSk7IVUuYWNjZXNzZWREb2N1bWVudEN1cnJlbnRTY3JpcHQmJkxoLmluY2x1ZGVzKGcpJiYoKFc9dGhpcy5hY2Nlc3NlZEdsb2JhbHNCeVNjb3BlLmdldChqLnNjb3BlKSk9PW51bGx8fFcuZGVsZXRlKFV0KSksVS5hY2Nlc3NlZERvY3VtZW50Q3VycmVudFNjcmlwdD0hMSx7c291cmNlOkJ9PWZlLE98fChPPWZlLnVzZXNUb3BMZXZlbEF3YWl0KSxhZT1CLmxlbmd0aCgpLGFlJiYoeSYmQi5sYXN0TGluZSgpLmluY2x1ZGVzKCIvLyIpJiZCLmFwcGVuZChgCmApLE4uc2V0KGosQiksay5hZGRTb3VyY2UoQiksUC5wdXNoKGopKTtjb25zdCBrZT1qLm5hbWVzcGFjZTtpZihyLmhhcyhqKSl7Y29uc3Qgd2U9a2UucmVuZGVyQmxvY2soVSk7a2UucmVuZGVyRmlyc3QoKT9fKz1TK3dlOmsuYWRkU291cmNlKG5ldyBadCh3ZSkpfWNvbnN0IE1lPWkuZ2V0KGouc2NvcGUpO2lmKE1lKWZvcihjb25zdCB3ZSBvZiBNZSlBLmFkZCh3ZSl9Y29uc3R7cmVuZGVyZWRFeHBvcnRzOnhlLHJlbW92ZWRFeHBvcnRzOkxlfT1qLmdldFJlbmRlcmVkRXhwb3J0cygpO3Bbai5pZF09e2dldCBjb2RlKCl7cmV0dXJuKEI9PW51bGw/dm9pZCAwOkIudG9TdHJpbmcoKSk/P251bGx9LG9yaWdpbmFsTGVuZ3RoOmoub3JpZ2luYWxDb2RlLmxlbmd0aCxyZW1vdmVkRXhwb3J0czpMZSxyZW5kZXJlZEV4cG9ydHM6eGUscmVuZGVyZWRMZW5ndGg6YWV9fV8mJmsucHJlcGVuZChfK1MrUyksdGhpcy5uZWVkc0V4cG9ydHNTaGltJiZrLnByZXBlbmQoYCR7U30ke2J9ICR7Tml9JHt3fT0ke3d9dm9pZCAwOyR7U30ke1N9YCk7Y29uc3QgRz15P2s6ay50cmltKCk7dmFyIFI7cmV0dXJuIG8mJnRoaXMuZ2V0RXhwb3J0TmFtZXMoKS5sZW5ndGg9PT0wJiZzLnNpemU9PT0wJiZhKEsse2NvZGU6IkVNUFRZX0JVTkRMRSIsbWVzc2FnZTpgR2VuZXJhdGVkIGFuIGVtcHR5IGNodW5rOiAiJHtSPXRoaXMuZ2V0Q2h1bmtOYW1lKCl9Ii5gLG5hbWVzOltSXX0pLHthY2Nlc3NlZEdsb2JhbHM6QSxpbmRlbnQ6QyxtYWdpY1N0cmluZzprLHJlbmRlcmVkU291cmNlOkcsdXNlZE1vZHVsZXM6UCx1c2VzVG9wTGV2ZWxBd2FpdDpPfX1zZXREeW5hbWljSW1wb3J0UmVzb2x1dGlvbnModCl7Y29uc3R7YWNjZXNzZWRHbG9iYWxzQnlTY29wZTppLG91dHB1dE9wdGlvbnM6cyxwbHVnaW5Ecml2ZXI6bixzbmlwcGV0czpyfT10aGlzO2Zvcihjb25zdCBhIG9mIHRoaXMuZ2V0SW5jbHVkZWREeW5hbWljSW1wb3J0cygpKWlmKGEuY2h1bmspe2NvbnN0e2NodW5rOm8sZmFjYWRlQ2h1bms6aCxub2RlOmwscmVzb2x1dGlvbjpjfT1hO289PT10aGlzP2wuc2V0SW50ZXJuYWxSZXNvbHV0aW9uKGMubmFtZXNwYWNlKTpsLnNldEV4dGVybmFsUmVzb2x1dGlvbigoaHx8bykuZXhwb3J0TW9kZSxjLHMscixuLGksYCckeyhofHxvKS5nZXRJbXBvcnRQYXRoKHQpfSdgLCEoaCE9bnVsbCYmaC5zdHJpY3RGYWNhZGUpJiZvLmV4cG9ydE5hbWVzQnlWYXJpYWJsZS5nZXQoYy5uYW1lc3BhY2UpWzBdLG51bGwpfWVsc2V7Y29uc3R7bm9kZTpvLHJlc29sdXRpb246aH09YSxbbCxjXT10aGlzLmdldER5bmFtaWNJbXBvcnRTdHJpbmdBbmRBc3NlcnRpb25zKGgsdCk7by5zZXRFeHRlcm5hbFJlc29sdXRpb24oImV4dGVybmFsIixoLHMscixuLGksbCwhMSxjKX19c2V0SWRlbnRpZmllclJlbmRlclJlc29sdXRpb25zKCl7Y29uc3R7Zm9ybWF0OnQsaW50ZXJvcDppLG5hbWVzcGFjZVRvU3RyaW5nVGFnOnMscHJlc2VydmVNb2R1bGVzOm4sZXh0ZXJuYWxMaXZlQmluZGluZ3M6cn09dGhpcy5vdXRwdXRPcHRpb25zLGE9bmV3IFNldDtmb3IoY29uc3QgaCBvZiB0aGlzLmdldEV4cG9ydE5hbWVzKCkpe2NvbnN0IGw9dGhpcy5leHBvcnRzQnlOYW1lLmdldChoKTt0IT09ImVzIiYmdCE9PSJzeXN0ZW0iJiZsLmlzUmVhc3NpZ25lZCYmIWwuaXNJZD9sLnNldFJlbmRlck5hbWVzKCJleHBvcnRzIixoKTpsIGluc3RhbmNlb2YgRmU/YS5hZGQobCk6bC5zZXRSZW5kZXJOYW1lcyhudWxsLG51bGwpfWZvcihjb25zdCBoIG9mIHRoaXMub3JkZXJlZE1vZHVsZXMpaWYoaC5uZWVkc0V4cG9ydFNoaW0pe3RoaXMubmVlZHNFeHBvcnRzU2hpbT0hMDticmVha31jb25zdCBvPW5ldyBTZXQoWyJPYmplY3QiLCJQcm9taXNlIl0pO3N3aXRjaCh0aGlzLm5lZWRzRXhwb3J0c1NoaW0mJm8uYWRkKE5pKSxzJiZvLmFkZCgiU3ltYm9sIiksdCl7Y2FzZSJzeXN0ZW0iOm8uYWRkKCJtb2R1bGUiKS5hZGQoImV4cG9ydHMiKTticmVhaztjYXNlImVzIjpicmVhaztjYXNlImNqcyI6by5hZGQoIm1vZHVsZSIpLmFkZCgicmVxdWlyZSIpLmFkZCgiX19maWxlbmFtZSIpLmFkZCgiX19kaXJuYW1lIik7ZGVmYXVsdDpvLmFkZCgiZXhwb3J0cyIpO2Zvcihjb25zdCBoIG9mIE9yKW8uYWRkKGgpfUFkKHRoaXMub3JkZXJlZE1vZHVsZXMsdGhpcy5nZXREZXBlbmRlbmNpZXNUb0JlRGVjb25mbGljdGVkKHQhPT0iZXMiJiZ0IT09InN5c3RlbSIsdD09PSJhbWQifHx0PT09InVtZCJ8fHQ9PT0iaWlmZSIsaSksdGhpcy5pbXBvcnRzLG8sdCxpLG4scix0aGlzLmNodW5rQnlNb2R1bGUsdGhpcy5leHRlcm5hbENodW5rQnlNb2R1bGUsYSx0aGlzLmV4cG9ydE5hbWVzQnlWYXJpYWJsZSx0aGlzLmFjY2Vzc2VkR2xvYmFsc0J5U2NvcGUsdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMpfXNldEltcG9ydE1ldGFSZXNvbHV0aW9ucyh0KXtjb25zdHthY2Nlc3NlZEdsb2JhbHNCeVNjb3BlOmksaW5jbHVkZWROYW1lc3BhY2VzOnMsb3JkZXJlZE1vZHVsZXM6bixvdXRwdXRPcHRpb25zOntmb3JtYXQ6cn19PXRoaXM7Zm9yKGNvbnN0IGEgb2Ygbil7Zm9yKGNvbnN0IG8gb2YgYS5pbXBvcnRNZXRhcylvLnNldFJlc29sdXRpb24ocixpLHQpO3MuaGFzKGEpJiZhLm5hbWVzcGFjZS5wcmVwYXJlKGkpfX1zZXRVcENodW5rSW1wb3J0c0FuZEV4cG9ydHNGb3JNb2R1bGUodCl7Y29uc3QgaT1uZXcgU2V0KHQuaW5jbHVkZWRJbXBvcnRzKTtpZighdGhpcy5vdXRwdXRPcHRpb25zLnByZXNlcnZlTW9kdWxlcyYmdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKHQpKXtjb25zdCBzPXQubmFtZXNwYWNlLmdldE1lbWJlclZhcmlhYmxlcygpO2Zvcihjb25zdCBuIG9mIE9iamVjdC52YWx1ZXMocykpbi5pbmNsdWRlZCYmaS5hZGQobil9Zm9yKGxldCBzIG9mIGkpe3MgaW5zdGFuY2VvZiBndCYmKHM9cy5nZXRPcmlnaW5hbFZhcmlhYmxlKCkpLHMgaW5zdGFuY2VvZiBGZSYmKHM9cy5nZXRCYXNlVmFyaWFibGUoKSk7Y29uc3Qgbj10aGlzLmNodW5rQnlNb2R1bGUuZ2V0KHMubW9kdWxlKTtuIT09dGhpcyYmKHRoaXMuaW1wb3J0cy5hZGQocykscy5tb2R1bGUgaW5zdGFuY2VvZiB5ZSYmKHRoaXMuY2hlY2tDaXJjdWxhckRlcGVuZGVuY3lJbXBvcnQocyx0KSxzIGluc3RhbmNlb2YgZHMmJnRoaXMub3V0cHV0T3B0aW9ucy5wcmVzZXJ2ZU1vZHVsZXN8fG4uZXhwb3J0cy5hZGQocykpKX0odGhpcy5pbmNsdWRlZE5hbWVzcGFjZXMuaGFzKHQpfHx0LmluZm8uaXNFbnRyeSYmdC5wcmVzZXJ2ZVNpZ25hdHVyZSE9PSExfHx0LmluY2x1ZGVkRHluYW1pY0ltcG9ydGVycy5zb21lKHM9PnRoaXMuY2h1bmtCeU1vZHVsZS5nZXQocykhPT10aGlzKSkmJnRoaXMuZW5zdXJlUmVleHBvcnRzQXJlQXZhaWxhYmxlRm9yTW9kdWxlKHQpO2Zvcihjb25zdHtub2RlOnMscmVzb2x1dGlvbjpufW9mIHQuZHluYW1pY0ltcG9ydHMpcy5pbmNsdWRlZCYmbiBpbnN0YW5jZW9mIHllJiZ0aGlzLmNodW5rQnlNb2R1bGUuZ2V0KG4pPT09dGhpcyYmIXRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmhhcyhuKSYmKHRoaXMuaW5jbHVkZWROYW1lc3BhY2VzLmFkZChuKSx0aGlzLmVuc3VyZVJlZXhwb3J0c0FyZUF2YWlsYWJsZUZvck1vZHVsZShuKSl9fWZ1bmN0aW9uIGlhKGUpe3JldHVybiBubChlKT8/VW4oZS5pZCl9ZnVuY3Rpb24gbmwoZSl7dmFyIHQsaTtyZXR1cm4oKHQ9ZS5jaHVua05hbWVzLmZpbmQoKHtpc1VzZXJEZWZpbmVkOnN9KT0+cykpPT1udWxsP3ZvaWQgMDp0Lm5hbWUpPz8oKGk9ZS5jaHVua05hbWVzWzBdKT09bnVsbD92b2lkIDA6aS5uYW1lKX1mdW5jdGlvbiBMZChlLHQpe2NvbnN0IGk9e307Zm9yKGNvbnN0W3Msbl1vZiBlKXtjb25zdCByPW5ldyBTZXQ7aWYobi5pbXBvcnRzKWZvcihjb25zdHtpbXBvcnRlZDphfW9mIG4uaW1wb3J0cylyLmFkZChhKTtpZihuLnJlZXhwb3J0cylmb3IoY29uc3R7aW1wb3J0ZWQ6YX1vZiBuLnJlZXhwb3J0cylyLmFkZChhKTtpW3QocyldPVsuLi5yXX1yZXR1cm4gaX1jb25zdCBUZD0vWyM/XS8seW49ZT0+ZS5nZXRGaWxlTmFtZSgpO2Z1bmN0aW9uKnJsKGUpe2Zvcihjb25zdCB0IG9mIGUpeWllbGQqdH1mdW5jdGlvbiBSZChlLHQsaSxzKXtjb25zdHtjaHVua0RlZmluaXRpb25zOm4sbW9kdWxlc0luTWFudWFsQ2h1bmtzOnJ9PWZ1bmN0aW9uKHApe2NvbnN0IG09W10seT1uZXcgU2V0KHAua2V5cygpKSxFPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0W2cseF1vZiBwKU9kKGcsRVt4XXx8KEVbeF09W10pLHkpO2Zvcihjb25zdFtnLHhdb2YgT2JqZWN0LmVudHJpZXMoRSkpbS5wdXNoKHthbGlhczpnLG1vZHVsZXM6eH0pO3JldHVybntjaHVua0RlZmluaXRpb25zOm0sbW9kdWxlc0luTWFudWFsQ2h1bmtzOnl9fSh0KSx7YWxsRW50cmllczphLGRlcGVuZGVudEVudHJpZXNCeU1vZHVsZTpvLGR5bmFtaWNhbGx5RGVwZW5kZW50RW50cmllc0J5RHluYW1pY0VudHJ5OmgsZHluYW1pY0ltcG9ydHNCeUVudHJ5Omx9PWZ1bmN0aW9uKHApe2NvbnN0IG09bmV3IFNldCx5PW5ldyBNYXAsRT1bXSxnPW5ldyBTZXQocCk7bGV0IHg9MDtmb3IoY29uc3QgUyBvZiBnKXtjb25zdCBrPW5ldyBTZXQ7RS5wdXNoKGspO2NvbnN0IEM9bmV3IFNldChbU10pO2Zvcihjb25zdCBQIG9mIEMpe0dlKHksUCxlaSkuYWRkKHgpO2Zvcihjb25zdCBfIG9mIFAuZ2V0RGVwZW5kZW5jaWVzVG9CZUluY2x1ZGVkKCkpXyBpbnN0YW5jZW9mIGxlfHxDLmFkZChfKTtmb3IoY29uc3R7cmVzb2x1dGlvbjpffW9mIFAuZHluYW1pY0ltcG9ydHMpXyBpbnN0YW5jZW9mIHllJiZfLmluY2x1ZGVkRHluYW1pY0ltcG9ydGVycy5sZW5ndGg+MCYmIWcuaGFzKF8pJiYobS5hZGQoXyksZy5hZGQoXyksay5hZGQoXykpO2Zvcihjb25zdCBfIG9mIFAuaW1wbGljaXRseUxvYWRlZEJlZm9yZSlnLmhhcyhfKXx8KG0uYWRkKF8pLGcuYWRkKF8pKX14Kyt9Y29uc3Qgdj1bLi4uZ10se2R5bmFtaWNFbnRyaWVzOncsZHluYW1pY0ltcG9ydHNCeUVudHJ5OmJ9PWZ1bmN0aW9uKFMsayxDKXtjb25zdCBQPW5ldyBNYXAsXz1uZXcgU2V0O2Zvcihjb25zdFtOLFVdb2YgUy5lbnRyaWVzKCkpUC5zZXQoVSxOKSxrLmhhcyhVKSYmXy5hZGQoTik7Y29uc3QgQT1bXTtmb3IoY29uc3QgTiBvZiBDKXtjb25zdCBVPW5ldyBTZXQ7Zm9yKGNvbnN0IE8gb2YgTilVLmFkZChQLmdldChPKSk7QS5wdXNoKFUpfXJldHVybntkeW5hbWljRW50cmllczpfLGR5bmFtaWNJbXBvcnRzQnlFbnRyeTpBfX0odixtLEUpO3JldHVybnthbGxFbnRyaWVzOnYsZGVwZW5kZW50RW50cmllc0J5TW9kdWxlOnksZHluYW1pY2FsbHlEZXBlbmRlbnRFbnRyaWVzQnlEeW5hbWljRW50cnk6VmQoeSx3LHYpLGR5bmFtaWNJbXBvcnRzQnlFbnRyeTpifX0oZSksYz1hbChmdW5jdGlvbioocCxtKXtmb3IoY29uc3RbeSxFXW9mIHApbS5oYXMoeSl8fCh5aWVsZHtkZXBlbmRlbnRFbnRyaWVzOkUsbW9kdWxlczpbeV19KX0obyxyKSk7cmV0dXJuIGZ1bmN0aW9uKHAsbSx5LEUpe2NvbnN0IGc9RS5tYXAoKCk9PjBuKSx4PUUubWFwKChiLFMpPT5tLmhhcyhTKT8tMW46MG4pO2xldCB2PTFuO2Zvcihjb25zdHtkZXBlbmRlbnRFbnRyaWVzOmJ9b2YgcCl7Zm9yKGNvbnN0IFMgb2YgYilnW1NdfD12O3Y8PD0xbn1jb25zdCB3PW07Zm9yKGNvbnN0W2IsU11vZiB3KXt3LmRlbGV0ZShiKTtjb25zdCBrPXhbYl07bGV0IEM9aztmb3IoY29uc3QgUCBvZiBTKUMmPWdbUF18eFtQXTtpZihDIT09ayl7eFtiXT1DO2Zvcihjb25zdCBQIG9mIHlbYl0pR2UodyxQLGVpKS5hZGQoYil9fXY9MW47Zm9yKGNvbnN0e2RlcGVuZGVudEVudHJpZXM6Yn1vZiBwKXtmb3IoY29uc3QgUyBvZiBiKSh4W1NdJnYpPT09diYmYi5kZWxldGUoUyk7djw8PTFufX0oYyxoLGwsYSksbi5wdXNoKC4uLmZ1bmN0aW9uKHAsbSx5LEUpe0NlKCJvcHRpbWl6ZSBjaHVua3MiLDMpO2NvbnN0IGc9ZnVuY3Rpb24oeCx2LHcpe2NvbnN0IGI9W10sUz1bXSxrPW5ldyBNYXAsQz1bXTtsZXQgUD0wbixfPTFuO2Zvcihjb25zdHtkZXBlbmRlbnRFbnRyaWVzOkEsbW9kdWxlczpOfW9mIHgpe2NvbnN0IFU9e2NvbnRhaW5lZEF0b21zOl8sY29ycmVsYXRlZEF0b21zOjBuLGRlcGVuZGVuY2llczpuZXcgU2V0LGRlcGVuZGVudENodW5rczpuZXcgU2V0LGRlcGVuZGVudEVudHJpZXM6QSxtb2R1bGVzOk4scHVyZTohMCxzaXplOjB9O2xldCBPPTAsRz0hMDtmb3IoY29uc3QgUiBvZiBOKWsuc2V0KFIsVSksUi5pc0luY2x1ZGVkKCkmJihHJiYoRz0hUi5oYXNFZmZlY3RzKCkpLE8rPXc+MT9SLmVzdGltYXRlU2l6ZSgpOjEpO1UucHVyZT1HLFUuc2l6ZT1PLEMucHVzaChPKSxHfHwoUHw9XyksKE88dz9iOlMpLnB1c2goVSksXzw8PTFufXJldHVybiBiLmxlbmd0aD09PTA/bnVsbDooUHw9ZnVuY3Rpb24oQSxOLFUsTyl7Y29uc3QgRz1uZXcgTWFwO2xldCBSPTBuO2NvbnN0IFc9W107Zm9yKGxldCBqPTA7ajxVO2orKylXLnB1c2goMG4pO2Zvcihjb25zdCBqIG9mIEEpe2ouc29ydChEZCk7Zm9yKGNvbnN0IEIgb2Ygail7Y29uc3R7ZGVwZW5kZW5jaWVzOmFlLGRlcGVuZGVudEVudHJpZXM6eGUsbW9kdWxlczpMZX09Qjtmb3IoY29uc3Qga2Ugb2YgTGUpZm9yKGNvbnN0IE1lIG9mIGtlLmdldERlcGVuZGVuY2llc1RvQmVJbmNsdWRlZCgpKWlmKE1lIGluc3RhbmNlb2YgbGUpTWUuaW5mby5tb2R1bGVTaWRlRWZmZWN0cyYmKEIuY29udGFpbmVkQXRvbXN8PUdlKEcsTWUsKCk9Pntjb25zdCB3ZT1PO3JldHVybiBPPDw9MW4sUnw9d2Usd2V9KSk7ZWxzZXtjb25zdCB3ZT1OLmdldChNZSk7d2UmJndlIT09QiYmKGFlLmFkZCh3ZSksd2UuZGVwZW5kZW50Q2h1bmtzLmFkZChCKSl9Y29uc3R7Y29udGFpbmVkQXRvbXM6ZmV9PUI7Zm9yKGNvbnN0IGtlIG9mIHhlKVdba2VdfD1mZX19Zm9yKGNvbnN0IGogb2YgQSlmb3IoY29uc3QgQiBvZiBqKXtjb25zdHtkZXBlbmRlbnRFbnRyaWVzOmFlfT1CO0IuY29ycmVsYXRlZEF0b21zPS0xbjtmb3IoY29uc3QgeGUgb2YgYWUpQi5jb3JyZWxhdGVkQXRvbXMmPVdbeGVdfXJldHVybiBSfShbUyxiXSxrLHYsXykse2JpZzpuZXcgU2V0KFMpLHNpZGVFZmZlY3RBdG9tczpQLHNpemVCeUF0b206QyxzbWFsbDpuZXcgU2V0KGIpfSl9KHAsbSx5KTtyZXR1cm4gZz8oeT4xJiZFKCJpbmZvIixBbyhwLmxlbmd0aCxnLnNtYWxsLnNpemUsIkluaXRpYWxseSIpKSxmdW5jdGlvbih4LHYpe2NvbnN0e3NtYWxsOnd9PXg7Zm9yKGNvbnN0IGIgb2Ygdyl7Y29uc3QgUz1NZChiLHgsdjw9MT8xOjEvMCk7aWYoUyl7Y29uc3R7Y29udGFpbmVkQXRvbXM6ayxjb3JyZWxhdGVkQXRvbXM6Qyxtb2R1bGVzOlAscHVyZTpfLHNpemU6QX09Yjt3LmRlbGV0ZShiKSxvbChTLHYseCkuZGVsZXRlKFMpLFMubW9kdWxlcy5wdXNoKC4uLlApLFMuc2l6ZSs9QSxTLnB1cmUmJihTLnB1cmU9Xyk7Y29uc3R7ZGVwZW5kZW5jaWVzOk4sZGVwZW5kZW50Q2h1bmtzOlUsZGVwZW5kZW50RW50cmllczpPfT1TO1MuY29ycmVsYXRlZEF0b21zJj1DLFMuY29udGFpbmVkQXRvbXN8PWs7Zm9yKGNvbnN0IEcgb2YgYi5kZXBlbmRlbnRFbnRyaWVzKU8uYWRkKEcpO2Zvcihjb25zdCBHIG9mIGIuZGVwZW5kZW5jaWVzKU4uYWRkKEcpLEcuZGVwZW5kZW50Q2h1bmtzLmRlbGV0ZShiKSxHLmRlcGVuZGVudENodW5rcy5hZGQoUyk7Zm9yKGNvbnN0IEcgb2YgYi5kZXBlbmRlbnRDaHVua3MpVS5hZGQoRyksRy5kZXBlbmRlbmNpZXMuZGVsZXRlKGIpLEcuZGVwZW5kZW5jaWVzLmFkZChTKTtOLmRlbGV0ZShTKSxVLmRlbGV0ZShTKSxvbChTLHYseCkuYWRkKFMpfX19KGcseSkseT4xJiZFKCJpbmZvIixBbyhnLnNtYWxsLnNpemUrZy5iaWcuc2l6ZSxnLnNtYWxsLnNpemUsIkFmdGVyIG1lcmdpbmcgY2h1bmtzIikpLFNlKCJvcHRpbWl6ZSBjaHVua3MiLDMpLFsuLi5nLnNtYWxsLC4uLmcuYmlnXSk6KFNlKCJvcHRpbWl6ZSBjaHVua3MiLDMpLHApfShhbChjKSxhLmxlbmd0aCxpLHMpLm1hcCgoe21vZHVsZXM6cH0pPT4oe2FsaWFzOm51bGwsbW9kdWxlczpwfSkpKSxufWZ1bmN0aW9uIE9kKGUsdCxpKXtjb25zdCBzPW5ldyBTZXQoW2VdKTtmb3IoY29uc3QgbiBvZiBzKXtpLmFkZChuKSx0LnB1c2gobik7Zm9yKGNvbnN0IHIgb2Ygbi5kZXBlbmRlbmNpZXMpciBpbnN0YW5jZW9mIGxlfHxpLmhhcyhyKXx8cy5hZGQocil9fWZ1bmN0aW9uIFZkKGUsdCxpKXtjb25zdCBzPW5ldyBNYXA7Zm9yKGNvbnN0IG4gb2YgdCl7Y29uc3Qgcj1HZShzLG4sZWkpLGE9aVtuXTtmb3IoY29uc3QgbyBvZiBybChbYS5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMsYS5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXJdKSlmb3IoY29uc3QgaCBvZiBlLmdldChvKSlyLmFkZChoKX1yZXR1cm4gc31mdW5jdGlvbiBhbChlKXt2YXIgdDtjb25zdCBpPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0e2RlcGVuZGVudEVudHJpZXM6cyxtb2R1bGVzOm59b2YgZSl7bGV0IHI9MG47Zm9yKGNvbnN0IGEgb2YgcylyfD0xbjw8QmlnSW50KGEpOyhpW3Q9U3RyaW5nKHIpXXx8KGlbdF09e2RlcGVuZGVudEVudHJpZXM6bmV3IFNldChzKSxtb2R1bGVzOltdfSkpLm1vZHVsZXMucHVzaCguLi5uKX1yZXR1cm4gT2JqZWN0LnZhbHVlcyhpKX1mdW5jdGlvbiBNZChlLHtiaWc6dCxzaWRlRWZmZWN0QXRvbXM6aSxzaXplQnlBdG9tOnMsc21hbGw6bn0scil7bGV0IGE9bnVsbDtmb3IoY29uc3QgbyBvZiBybChbbix0XSkpe2lmKGU9PT1vKWNvbnRpbnVlO2NvbnN0IGg9QmQoZSxvLHIsaSxzKTtpZihoPHIpe2lmKGE9byxoPT09MClicmVhaztyPWh9fXJldHVybiBhfWZ1bmN0aW9uIG9sKGUsdCxpKXtyZXR1cm4gZS5zaXplPHQ/aS5zbWFsbDppLmJpZ31mdW5jdGlvbiBEZCh7c2l6ZTplfSx7c2l6ZTp0fSl7cmV0dXJuIGUtdH1mdW5jdGlvbiBCZChlLHQsaSxzLG4pe2NvbnN0IHI9aGwoZSx0LGkscyxuKTtyZXR1cm4gcjxpP3IraGwodCxlLGktcixzLG4pOjEvMH1mdW5jdGlvbiBobChlLHQsaSxzLG4pe2NvbnN0e2NvcnJlbGF0ZWRBdG9tczpyfT10O2xldCBhPWUuY29udGFpbmVkQXRvbXM7Y29uc3Qgbz1hJnM7aWYoKHImbykhPT1vKXJldHVybiAxLzA7Y29uc3QgaD1uZXcgU2V0KGUuZGVwZW5kZW5jaWVzKTtmb3IoY29uc3R7ZGVwZW5kZW5jaWVzOmwsY29udGFpbmVkQXRvbXM6Y31vZiBoKXthfD1jO2NvbnN0IHA9YyZzO2lmKChyJnApIT09cClyZXR1cm4gMS8wO2Zvcihjb25zdCBtIG9mIGwpe2lmKG09PT10KXJldHVybiAxLzA7aC5hZGQobSl9fXJldHVybiBmdW5jdGlvbihsLGMscCl7bGV0IG09MCx5PTAsRT0xbjtjb25zdHtsZW5ndGg6Z309cDtmb3IoO3k8Zzt5KyspaWYoKGwmRSk9PT1FJiYobSs9cFt5XSksRTw8PTFuLG0+PWMpcmV0dXJuIDEvMDtyZXR1cm4gbX0oYSZ+cixpLG4pfWNvbnN0IEZkPShlLHQpPT5lLmV4ZWNJbmRleD50LmV4ZWNJbmRleD8xOi0xO2Z1bmN0aW9uIHpkKGUsdCxpKXtjb25zdCBzPVN5bWJvbChlLmlkKSxuPVtlLmlkXTtsZXQgcj10O2ZvcihlLmN5Y2xlcy5hZGQocyk7ciE9PWU7KXIuY3ljbGVzLmFkZChzKSxuLnB1c2goci5pZCkscj1pLmdldChyKTtyZXR1cm4gbi5wdXNoKG5bMF0pLG4ucmV2ZXJzZSgpLG59Y29uc3QgbGw9KGUsdCk9PnQ/YCgke2V9KWA6ZSx1bD0vXig/IVxkKVtcdyRdKyQvO2NsYXNzIGNse2NvbnN0cnVjdG9yKHQsaSl7dGhpcy5pc09yaWdpbmFsPSEwLHRoaXMuZmlsZW5hbWU9dCx0aGlzLmNvbnRlbnQ9aX10cmFjZVNlZ21lbnQodCxpLHMpe3JldHVybntjb2x1bW46aSxsaW5lOnQsbmFtZTpzLHNvdXJjZTp0aGlzfX19Y2xhc3MgeG57Y29uc3RydWN0b3IodCxpKXt0aGlzLnNvdXJjZXM9aSx0aGlzLm5hbWVzPXQubmFtZXMsdGhpcy5tYXBwaW5ncz10Lm1hcHBpbmdzfXRyYWNlTWFwcGluZ3MoKXtjb25zdCB0PVtdLGk9bmV3IE1hcCxzPVtdLG49W10scj1uZXcgTWFwLGE9W107Zm9yKGNvbnN0IG8gb2YgdGhpcy5tYXBwaW5ncyl7Y29uc3QgaD1bXTtmb3IoY29uc3QgbCBvZiBvKXtpZihsLmxlbmd0aD09PTEpY29udGludWU7Y29uc3QgYz10aGlzLnNvdXJjZXNbbFsxXV07aWYoIWMpY29udGludWU7Y29uc3QgcD1jLnRyYWNlU2VnbWVudChsWzJdLGxbM10sbC5sZW5ndGg9PT01P3RoaXMubmFtZXNbbFs0XV06IiIpO2lmKHApe2NvbnN0e2NvbHVtbjptLGxpbmU6eSxuYW1lOkUsc291cmNlOntjb250ZW50OmcsZmlsZW5hbWU6eH19PXA7bGV0IHY9aS5nZXQoeCk7aWYodj09PXZvaWQgMCl2PXQubGVuZ3RoLHQucHVzaCh4KSxpLnNldCh4LHYpLHNbdl09ZztlbHNlIGlmKHNbdl09PW51bGwpc1t2XT1nO2Vsc2UgaWYoZyE9bnVsbCYmc1t2XSE9PWcpcmV0dXJuIEwoeXAoeCkpO2NvbnN0IHc9W2xbMF0sdix5LG1dO2lmKEUpe2xldCBiPXIuZ2V0KEUpO2I9PT12b2lkIDAmJihiPW4ubGVuZ3RoLG4ucHVzaChFKSxyLnNldChFLGIpKSx3WzRdPWJ9aC5wdXNoKHcpfX1hLnB1c2goaCl9cmV0dXJue21hcHBpbmdzOmEsbmFtZXM6bixzb3VyY2VzOnQsc291cmNlc0NvbnRlbnQ6c319dHJhY2VTZWdtZW50KHQsaSxzKXtjb25zdCBuPXRoaXMubWFwcGluZ3NbdF07aWYoIW4pcmV0dXJuIG51bGw7bGV0IHI9MCxhPW4ubGVuZ3RoLTE7Zm9yKDtyPD1hOyl7Y29uc3Qgbz1yK2E+PjEsaD1uW29dO2lmKGhbMF09PT1pfHxyPT09YSl7aWYoaC5sZW5ndGg9PTEpcmV0dXJuIG51bGw7Y29uc3QgbD10aGlzLnNvdXJjZXNbaFsxXV07cmV0dXJuIGw/bC50cmFjZVNlZ21lbnQoaFsyXSxoWzNdLGgubGVuZ3RoPT09NT90aGlzLm5hbWVzW2hbNF1dOnMpOm51bGx9aFswXT5pP2E9by0xOnI9bysxfXJldHVybiBudWxsfX1mdW5jdGlvbiBwbChlKXtyZXR1cm4gZnVuY3Rpb24odCxpKXtyZXR1cm4gaS5taXNzaW5nPyhlKEssKHM9aS5wbHVnaW4se2NvZGU6Z28sbWVzc2FnZTpgU291cmNlbWFwIGlzIGxpa2VseSB0byBiZSBpbmNvcnJlY3Q6IGEgcGx1Z2luICgke3N9KSB3YXMgdXNlZCB0byB0cmFuc2Zvcm0gZmlsZXMsIGJ1dCBkaWRuJ3QgZ2VuZXJhdGUgYSBzb3VyY2VtYXAgZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbi4gQ29uc3VsdCB0aGUgcGx1Z2luIGRvY3VtZW50YXRpb24gZm9yIGhlbHBgLHBsdWdpbjpzLHVybDpfZShNYyl9KSksbmV3IHhuKHttYXBwaW5nczpbXSxuYW1lczpbXX0sW3RdKSk6bmV3IHhuKGksW3RdKTt2YXIgc319ZnVuY3Rpb24gZGwoZSx0LGkscyxuKXtsZXQgcjtpZihpKXtjb25zdCBhPWkuc291cmNlcyxvPWkuc291cmNlc0NvbnRlbnR8fFtdLGg9SnQoZSl8fCIuIixsPWkuc291cmNlUm9vdHx8Ii4iLGM9YS5tYXAoKHAsbSk9Pm5ldyBjbChodChoLGwscCksb1ttXSkpO3I9bmV3IHhuKGksYyl9ZWxzZSByPW5ldyBjbChlLHQpO3JldHVybiBzLnJlZHVjZShuLHIpfXZhciBvZT17fSxzYT1mbDtmdW5jdGlvbiBmbChlLHQpe2lmKCFlKXRocm93IG5ldyBFcnJvcih0fHwiQXNzZXJ0aW9uIGZhaWxlZCIpfWZsLmVxdWFsPWZ1bmN0aW9uKGUsdCxpKXtpZihlIT10KXRocm93IG5ldyBFcnJvcihpfHwiQXNzZXJ0aW9uIGZhaWxlZDogIitlKyIgIT0gIit0KX07dmFyIG5hPXtleHBvcnRzOnt9fTt0eXBlb2YgT2JqZWN0LmNyZWF0ZT09ImZ1bmN0aW9uIj9uYS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dCYmKGUuc3VwZXJfPXQsZS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh0LnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOmUsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSkpfTpuYS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7aWYodCl7ZS5zdXBlcl89dDt2YXIgaT1mdW5jdGlvbigpe307aS5wcm90b3R5cGU9dC5wcm90b3R5cGUsZS5wcm90b3R5cGU9bmV3IGksZS5wcm90b3R5cGUuY29uc3RydWN0b3I9ZX19O3ZhciBqZD1uYS5leHBvcnRzLFVkPXNhLEdkPWpkO2Z1bmN0aW9uIFdkKGUsdCl7cmV0dXJuKDY0NTEyJmUuY2hhckNvZGVBdCh0KSk9PTU1Mjk2JiYhKHQ8MHx8dCsxPj1lLmxlbmd0aCkmJig2NDUxMiZlLmNoYXJDb2RlQXQodCsxKSk9PTU2MzIwfWZ1bmN0aW9uIG1sKGUpe3JldHVybihlPj4+MjR8ZT4+PjgmNjUyODB8ZTw8OCYxNjcxMTY4MHwoMjU1JmUpPDwyNCk+Pj4wfWZ1bmN0aW9uIGdsKGUpe3JldHVybiBlLmxlbmd0aD09PTE/IjAiK2U6ZX1mdW5jdGlvbiB5bChlKXtyZXR1cm4gZS5sZW5ndGg9PT03PyIwIitlOmUubGVuZ3RoPT09Nj8iMDAiK2U6ZS5sZW5ndGg9PT01PyIwMDAiK2U6ZS5sZW5ndGg9PT00PyIwMDAwIitlOmUubGVuZ3RoPT09Mz8iMDAwMDAiK2U6ZS5sZW5ndGg9PT0yPyIwMDAwMDAiK2U6ZS5sZW5ndGg9PT0xPyIwMDAwMDAwIitlOmV9b2UuaW5oZXJpdHM9R2Qsb2UudG9BcnJheT1mdW5jdGlvbihlLHQpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUuc2xpY2UoKTtpZighZSlyZXR1cm5bXTt2YXIgaT1bXTtpZih0eXBlb2YgZT09InN0cmluZyIpaWYodCl7aWYodD09PSJoZXgiKWZvcigoZT1lLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIiIpKS5sZW5ndGglMiE9MCYmKGU9IjAiK2UpLG49MDtuPGUubGVuZ3RoO24rPTIpaS5wdXNoKHBhcnNlSW50KGVbbl0rZVtuKzFdLDE2KSl9ZWxzZSBmb3IodmFyIHM9MCxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciByPWUuY2hhckNvZGVBdChuKTtyPDEyOD9pW3MrK109cjpyPDIwNDg/KGlbcysrXT1yPj42fDE5MixpW3MrK109NjMmcnwxMjgpOldkKGUsbik/KHI9NjU1MzYrKCgxMDIzJnIpPDwxMCkrKDEwMjMmZS5jaGFyQ29kZUF0KCsrbikpLGlbcysrXT1yPj4xOHwyNDAsaVtzKytdPXI+PjEyJjYzfDEyOCxpW3MrK109cj4+NiY2M3wxMjgsaVtzKytdPTYzJnJ8MTI4KTooaVtzKytdPXI+PjEyfDIyNCxpW3MrK109cj4+NiY2M3wxMjgsaVtzKytdPTYzJnJ8MTI4KX1lbHNlIGZvcihuPTA7bjxlLmxlbmd0aDtuKyspaVtuXT0wfGVbbl07cmV0dXJuIGl9LG9lLnRvSGV4PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0iIixpPTA7aTxlLmxlbmd0aDtpKyspdCs9Z2woZVtpXS50b1N0cmluZygxNikpO3JldHVybiB0fSxvZS5odG9ubD1tbCxvZS50b0hleDMyPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPSIiLHM9MDtzPGUubGVuZ3RoO3MrKyl7dmFyIG49ZVtzXTt0PT09ImxpdHRsZSImJihuPW1sKG4pKSxpKz15bChuLnRvU3RyaW5nKDE2KSl9cmV0dXJuIGl9LG9lLnplcm8yPWdsLG9lLnplcm84PXlsLG9lLmpvaW4zMj1mdW5jdGlvbihlLHQsaSxzKXt2YXIgbj1pLXQ7VWQobiU0PT0wKTtmb3IodmFyIHI9bmV3IEFycmF5KG4vNCksYT0wLG89dDthPHIubGVuZ3RoO2ErKyxvKz00KXt2YXIgaDtoPXM9PT0iYmlnIj9lW29dPDwyNHxlW28rMV08PDE2fGVbbysyXTw8OHxlW28rM106ZVtvKzNdPDwyNHxlW28rMl08PDE2fGVbbysxXTw8OHxlW29dLHJbYV09aD4+PjB9cmV0dXJuIHJ9LG9lLnNwbGl0MzI9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGk9bmV3IEFycmF5KDQqZS5sZW5ndGgpLHM9MCxuPTA7czxlLmxlbmd0aDtzKyssbis9NCl7dmFyIHI9ZVtzXTt0PT09ImJpZyI/KGlbbl09cj4+PjI0LGlbbisxXT1yPj4+MTYmMjU1LGlbbisyXT1yPj4+OCYyNTUsaVtuKzNdPTI1NSZyKTooaVtuKzNdPXI+Pj4yNCxpW24rMl09cj4+PjE2JjI1NSxpW24rMV09cj4+PjgmMjU1LGlbbl09MjU1JnIpfXJldHVybiBpfSxvZS5yb3RyMzI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+PnR8ZTw8MzItdH0sb2Uucm90bDMyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU8PHR8ZT4+PjMyLXR9LG9lLnN1bTMyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUrdD4+PjB9LG9lLnN1bTMyXzM9ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBlK3QraT4+PjB9LG9lLnN1bTMyXzQ9ZnVuY3Rpb24oZSx0LGkscyl7cmV0dXJuIGUrdCtpK3M+Pj4wfSxvZS5zdW0zMl81PWZ1bmN0aW9uKGUsdCxpLHMsbil7cmV0dXJuIGUrdCtpK3Mrbj4+PjB9LG9lLnN1bTY0PWZ1bmN0aW9uKGUsdCxpLHMpe3ZhciBuPWVbdF0scj1zK2VbdCsxXT4+PjAsYT0ocjxzPzE6MCkraStuO2VbdF09YT4+PjAsZVt0KzFdPXJ9LG9lLnN1bTY0X2hpPWZ1bmN0aW9uKGUsdCxpLHMpe3JldHVybih0K3M+Pj4wPHQ/MTowKStlK2k+Pj4wfSxvZS5zdW02NF9sbz1mdW5jdGlvbihlLHQsaSxzKXtyZXR1cm4gdCtzPj4+MH0sb2Uuc3VtNjRfNF9oaT1mdW5jdGlvbihlLHQsaSxzLG4scixhLG8pe3ZhciBoPTAsbD10O3JldHVybiBoKz0obD1sK3M+Pj4wKTx0PzE6MCxoKz0obD1sK3I+Pj4wKTxyPzE6MCxlK2krbithKyhoKz0obD1sK28+Pj4wKTxvPzE6MCk+Pj4wfSxvZS5zdW02NF80X2xvPWZ1bmN0aW9uKGUsdCxpLHMsbixyLGEsbyl7cmV0dXJuIHQrcytyK28+Pj4wfSxvZS5zdW02NF81X2hpPWZ1bmN0aW9uKGUsdCxpLHMsbixyLGEsbyxoLGwpe3ZhciBjPTAscD10O3JldHVybiBjKz0ocD1wK3M+Pj4wKTx0PzE6MCxjKz0ocD1wK3I+Pj4wKTxyPzE6MCxjKz0ocD1wK28+Pj4wKTxvPzE6MCxlK2krbithK2grKGMrPShwPXArbD4+PjApPGw/MTowKT4+PjB9LG9lLnN1bTY0XzVfbG89ZnVuY3Rpb24oZSx0LGkscyxuLHIsYSxvLGgsbCl7cmV0dXJuIHQrcytyK28rbD4+PjB9LG9lLnJvdHI2NF9oaT1mdW5jdGlvbihlLHQsaSl7cmV0dXJuKHQ8PDMyLWl8ZT4+PmkpPj4+MH0sb2Uucm90cjY0X2xvPWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4oZTw8MzItaXx0Pj4+aSk+Pj4wfSxvZS5zaHI2NF9oaT1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIGU+Pj5pfSxvZS5zaHI2NF9sbz1mdW5jdGlvbihlLHQsaSl7cmV0dXJuKGU8PDMyLWl8dD4+PmkpPj4+MH07dmFyIHhsPXt9LGJsPW9lLHFkPXNhO2Z1bmN0aW9uIGJuKCl7dGhpcy5wZW5kaW5nPW51bGwsdGhpcy5wZW5kaW5nVG90YWw9MCx0aGlzLmJsb2NrU2l6ZT10aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZSx0aGlzLm91dFNpemU9dGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplLHRoaXMuaG1hY1N0cmVuZ3RoPXRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoLHRoaXMucGFkTGVuZ3RoPXRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoLzgsdGhpcy5lbmRpYW49ImJpZyIsdGhpcy5fZGVsdGE4PXRoaXMuYmxvY2tTaXplLzgsdGhpcy5fZGVsdGEzMj10aGlzLmJsb2NrU2l6ZS8zMn14bC5CbG9ja0hhc2g9Ym4sYm4ucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihlLHQpe2lmKGU9YmwudG9BcnJheShlLHQpLHRoaXMucGVuZGluZz90aGlzLnBlbmRpbmc9dGhpcy5wZW5kaW5nLmNvbmNhdChlKTp0aGlzLnBlbmRpbmc9ZSx0aGlzLnBlbmRpbmdUb3RhbCs9ZS5sZW5ndGgsdGhpcy5wZW5kaW5nLmxlbmd0aD49dGhpcy5fZGVsdGE4KXt2YXIgaT0oZT10aGlzLnBlbmRpbmcpLmxlbmd0aCV0aGlzLl9kZWx0YTg7dGhpcy5wZW5kaW5nPWUuc2xpY2UoZS5sZW5ndGgtaSxlLmxlbmd0aCksdGhpcy5wZW5kaW5nLmxlbmd0aD09PTAmJih0aGlzLnBlbmRpbmc9bnVsbCksZT1ibC5qb2luMzIoZSwwLGUubGVuZ3RoLWksdGhpcy5lbmRpYW4pO2Zvcih2YXIgcz0wO3M8ZS5sZW5ndGg7cys9dGhpcy5fZGVsdGEzMil0aGlzLl91cGRhdGUoZSxzLHMrdGhpcy5fZGVsdGEzMil9cmV0dXJuIHRoaXN9LGJuLnByb3RvdHlwZS5kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKSxxZCh0aGlzLnBlbmRpbmc9PT1udWxsKSx0aGlzLl9kaWdlc3QoZSl9LGJuLnByb3RvdHlwZS5fcGFkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wZW5kaW5nVG90YWwsdD10aGlzLl9kZWx0YTgsaT10LShlK3RoaXMucGFkTGVuZ3RoKSV0LHM9bmV3IEFycmF5KGkrdGhpcy5wYWRMZW5ndGgpO3NbMF09MTI4O2Zvcih2YXIgbj0xO248aTtuKyspc1tuXT0wO2lmKGU8PD0zLHRoaXMuZW5kaWFuPT09ImJpZyIpe2Zvcih2YXIgcj04O3I8dGhpcy5wYWRMZW5ndGg7cisrKXNbbisrXT0wO3NbbisrXT0wLHNbbisrXT0wLHNbbisrXT0wLHNbbisrXT0wLHNbbisrXT1lPj4+MjQmMjU1LHNbbisrXT1lPj4+MTYmMjU1LHNbbisrXT1lPj4+OCYyNTUsc1tuKytdPTI1NSZlfWVsc2UgZm9yKHNbbisrXT0yNTUmZSxzW24rK109ZT4+PjgmMjU1LHNbbisrXT1lPj4+MTYmMjU1LHNbbisrXT1lPj4+MjQmMjU1LHNbbisrXT0wLHNbbisrXT0wLHNbbisrXT0wLHNbbisrXT0wLHI9ODtyPHRoaXMucGFkTGVuZ3RoO3IrKylzW24rK109MDtyZXR1cm4gc307dmFyIEx0PXt9LHl0PW9lLnJvdHIzMjtmdW5jdGlvbiB2bChlLHQsaSl7cmV0dXJuIGUmdF5+ZSZpfWZ1bmN0aW9uIEVsKGUsdCxpKXtyZXR1cm4gZSZ0XmUmaV50Jml9ZnVuY3Rpb24gU2woZSx0LGkpe3JldHVybiBlXnReaX1MdC5mdF8xPWZ1bmN0aW9uKGUsdCxpLHMpe3JldHVybiBlPT09MD92bCh0LGkscyk6ZT09PTF8fGU9PT0zP1NsKHQsaSxzKTplPT09Mj9FbCh0LGkscyk6dm9pZCAwfSxMdC5jaDMyPXZsLEx0Lm1hajMyPUVsLEx0LnAzMj1TbCxMdC5zMF8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHl0KGUsMileeXQoZSwxMyleeXQoZSwyMil9LEx0LnMxXzI1Nj1mdW5jdGlvbihlKXtyZXR1cm4geXQoZSw2KV55dChlLDExKV55dChlLDI1KX0sTHQuZzBfMjU2PWZ1bmN0aW9uKGUpe3JldHVybiB5dChlLDcpXnl0KGUsMTgpXmU+Pj4zfSxMdC5nMV8yNTY9ZnVuY3Rpb24oZSl7cmV0dXJuIHl0KGUsMTcpXnl0KGUsMTkpXmU+Pj4xMH07dmFyIExpPW9lLEhkPXhsLFRpPUx0LEtkPXNhLHB0PUxpLnN1bTMyLFFkPUxpLnN1bTMyXzQsWWQ9TGkuc3VtMzJfNSxYZD1UaS5jaDMyLFpkPVRpLm1hajMyLEpkPVRpLnMwXzI1NixlZj1UaS5zMV8yNTYsdGY9VGkuZzBfMjU2LHNmPVRpLmcxXzI1NixrbD1IZC5CbG9ja0hhc2gsbmY9WzExMTYzNTI0MDgsMTg5OTQ0NzQ0MSwzMDQ5MzIzNDcxLDM5MjEwMDk1NzMsOTYxOTg3MTYzLDE1MDg5NzA5OTMsMjQ1MzYzNTc0OCwyODcwNzYzMjIxLDM2MjQzODEwODAsMzEwNTk4NDAxLDYwNzIyNTI3OCwxNDI2ODgxOTg3LDE5MjUwNzgzODgsMjE2MjA3ODIwNiwyNjE0ODg4MTAzLDMyNDgyMjI1ODAsMzgzNTM5MDQwMSw0MDIyMjI0Nzc0LDI2NDM0NzA3OCw2MDQ4MDc2MjgsNzcwMjU1OTgzLDEyNDkxNTAxMjIsMTU1NTA4MTY5MiwxOTk2MDY0OTg2LDI1NTQyMjA4ODIsMjgyMTgzNDM0OSwyOTUyOTk2ODA4LDMyMTAzMTM2NzEsMzMzNjU3MTg5MSwzNTg0NTI4NzExLDExMzkyNjk5MywzMzgyNDE4OTUsNjY2MzA3MjA1LDc3MzUyOTkxMiwxMjk0NzU3MzcyLDEzOTYxODIyOTEsMTY5NTE4MzcwMCwxOTg2NjYxMDUxLDIxNzcwMjYzNTAsMjQ1Njk1NjAzNywyNzMwNDg1OTIxLDI4MjAzMDI0MTEsMzI1OTczMDgwMCwzMzQ1NzY0NzcxLDM1MTYwNjU4MTcsMzYwMDM1MjgwNCw0MDk0NTcxOTA5LDI3NTQyMzM0NCw0MzAyMjc3MzQsNTA2OTQ4NjE2LDY1OTA2MDU1Niw4ODM5OTc4NzcsOTU4MTM5NTcxLDEzMjI4MjIyMTgsMTUzNzAwMjA2MywxNzQ3ODczNzc5LDE5NTU1NjIyMjIsMjAyNDEwNDgxNSwyMjI3NzMwNDUyLDIzNjE4NTI0MjQsMjQyODQzNjQ3NCwyNzU2NzM0MTg3LDMyMDQwMzE0NzksMzMyOTMyNTI5OF07ZnVuY3Rpb24geHQoKXtpZighKHRoaXMgaW5zdGFuY2VvZiB4dCkpcmV0dXJuIG5ldyB4dDtrbC5jYWxsKHRoaXMpLHRoaXMuaD1bMTc3OTAzMzcwMywzMTQ0MTM0Mjc3LDEwMTM5MDQyNDIsMjc3MzQ4MDc2MiwxMzU5ODkzMTE5LDI2MDA4MjI5MjQsNTI4NzM0NjM1LDE1NDE0NTkyMjVdLHRoaXMuaz1uZix0aGlzLlc9bmV3IEFycmF5KDY0KX1MaS5pbmhlcml0cyh4dCxrbCk7dmFyIHJmPXh0O3h0LmJsb2NrU2l6ZT01MTIseHQub3V0U2l6ZT0yNTYseHQuaG1hY1N0cmVuZ3RoPTE5Mix4dC5wYWRMZW5ndGg9NjQseHQucHJvdG90eXBlLl91cGRhdGU9ZnVuY3Rpb24oZSx0KXtmb3IodmFyIGk9dGhpcy5XLHM9MDtzPDE2O3MrKylpW3NdPWVbdCtzXTtmb3IoO3M8aS5sZW5ndGg7cysrKWlbc109UWQoc2YoaVtzLTJdKSxpW3MtN10sdGYoaVtzLTE1XSksaVtzLTE2XSk7dmFyIG49dGhpcy5oWzBdLHI9dGhpcy5oWzFdLGE9dGhpcy5oWzJdLG89dGhpcy5oWzNdLGg9dGhpcy5oWzRdLGw9dGhpcy5oWzVdLGM9dGhpcy5oWzZdLHA9dGhpcy5oWzddO2ZvcihLZCh0aGlzLmsubGVuZ3RoPT09aS5sZW5ndGgpLHM9MDtzPGkubGVuZ3RoO3MrKyl7dmFyIG09WWQocCxlZihoKSxYZChoLGwsYyksdGhpcy5rW3NdLGlbc10pLHk9cHQoSmQobiksWmQobixyLGEpKTtwPWMsYz1sLGw9aCxoPXB0KG8sbSksbz1hLGE9cixyPW4sbj1wdChtLHkpfXRoaXMuaFswXT1wdCh0aGlzLmhbMF0sbiksdGhpcy5oWzFdPXB0KHRoaXMuaFsxXSxyKSx0aGlzLmhbMl09cHQodGhpcy5oWzJdLGEpLHRoaXMuaFszXT1wdCh0aGlzLmhbM10sbyksdGhpcy5oWzRdPXB0KHRoaXMuaFs0XSxoKSx0aGlzLmhbNV09cHQodGhpcy5oWzVdLGwpLHRoaXMuaFs2XT1wdCh0aGlzLmhbNl0sYyksdGhpcy5oWzddPXB0KHRoaXMuaFs3XSxwKX0seHQucHJvdG90eXBlLl9kaWdlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT0iaGV4Ij9MaS50b0hleDMyKHRoaXMuaCwiYmlnIik6TGkuc3BsaXQzMih0aGlzLmgsImJpZyIpfTt2YXIgYWY9V2EocmYpO2NvbnN0IFJpPSgpPT5hZigpO2FzeW5jIGZ1bmN0aW9uIG9mKGUsdCxpLHMsbil7Q2UoInJlbmRlciBjaHVua3MiLDIpLGZ1bmN0aW9uKG0pe2Zvcihjb25zdCB5IG9mIG0peS5mYWNhZGVNb2R1bGUmJnkuZmFjYWRlTW9kdWxlLmlzVXNlckRlZmluZWRFbnRyeVBvaW50JiZ5LmdldFByZWxpbWluYXJ5RmlsZU5hbWUoKX0oZSk7Y29uc3Qgcj1hd2FpdCBQcm9taXNlLmFsbChlLm1hcChtPT5tLnJlbmRlcigpKSk7U2UoInJlbmRlciBjaHVua3MiLDIpLENlKCJ0cmFuc2Zvcm0gY2h1bmtzIiwyKTtjb25zdCBhPWZ1bmN0aW9uKG0pe3JldHVybiBPYmplY3QuZnJvbUVudHJpZXMobS5tYXAoeT0+e2NvbnN0IEU9eS5nZXRSZW5kZXJlZENodW5rSW5mbygpO3JldHVybltFLmZpbGVOYW1lLEVdfSkpfShlKSx7aW5pdGlhbEhhc2hlc0J5UGxhY2Vob2xkZXI6byxub25IYXNoZWRDaHVua3NXaXRoUGxhY2Vob2xkZXJzOmgscmVuZGVyZWRDaHVua3NCeVBsYWNlaG9sZGVyOmwsaGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXI6Y309YXdhaXQgYXN5bmMgZnVuY3Rpb24obSx5LEUsZyx4KXtjb25zdCB2PVtdLHc9bmV3IE1hcCxiPW5ldyBNYXAsUz1uZXcgTWFwLGs9bmV3IFNldDtmb3IoY29uc3R7cHJlbGltaW5hcnlGaWxlTmFtZTp7aGFzaFBsYWNlaG9sZGVyOkN9fW9mIG0pQyYmay5hZGQoQyk7cmV0dXJuIGF3YWl0IFByb21pc2UuYWxsKG0ubWFwKGFzeW5jKHtjaHVuazpDLHByZWxpbWluYXJ5RmlsZU5hbWU6e2ZpbGVOYW1lOlAsaGFzaFBsYWNlaG9sZGVyOl99LHByZWxpbWluYXJ5U291cmNlbWFwRmlsZU5hbWU6QSxtYWdpY1N0cmluZzpOLHVzZWRNb2R1bGVzOlV9KT0+e2NvbnN0IE89e2NodW5rOkMsZmlsZU5hbWU6UCxzb3VyY2VtYXBGaWxlTmFtZTooQT09bnVsbD92b2lkIDA6QS5maWxlTmFtZSk/P251bGwsLi4uYXdhaXQgaGYoTixQLFUseSxFLGcseCl9LHtjb2RlOkcsbWFwOlJ9PU87aWYoXyl7Y29uc3R7Y29udGFpbmVkUGxhY2Vob2xkZXJzOmosdHJhbnNmb3JtZWRDb2RlOkJ9PV9kKEcsayksYWU9UmkoKS51cGRhdGUoQikseGU9Zy5ob29rUmVkdWNlVmFsdWVTeW5jKCJhdWdtZW50Q2h1bmtIYXNoIiwiIixbQy5nZXRSZW5kZXJlZENodW5rSW5mbygpXSwoTGUsZmUpPT4oZmUmJihMZSs9ZmUpLExlKSk7eGUmJmFlLnVwZGF0ZSh4ZSksdy5zZXQoXyxPKSxiLnNldChfLHtjb250YWluZWRQbGFjZWhvbGRlcnM6aixjb250ZW50SGFzaDphZS5kaWdlc3QoImhleCIpfSl9ZWxzZSB2LnB1c2goTyk7Y29uc3QgVz1BPT1udWxsP3ZvaWQgMDpBLmhhc2hQbGFjZWhvbGRlcjtSJiZXJiZTLnNldChBLmhhc2hQbGFjZWhvbGRlcixSaSgpLnVwZGF0ZShSLnRvU3RyaW5nKCkpLmRpZ2VzdCgiaGV4Iikuc2xpY2UoMCxBLmhhc2hQbGFjZWhvbGRlci5sZW5ndGgpKX0pKSx7aGFzaERlcGVuZGVuY2llc0J5UGxhY2Vob2xkZXI6Yixpbml0aWFsSGFzaGVzQnlQbGFjZWhvbGRlcjpTLG5vbkhhc2hlZENodW5rc1dpdGhQbGFjZWhvbGRlcnM6dixyZW5kZXJlZENodW5rc0J5UGxhY2Vob2xkZXI6d319KHIsYSxzLGksbikscD1mdW5jdGlvbihtLHksRSxnKXtjb25zdCB4PW5ldyBNYXAoRSk7Zm9yKGNvbnN0W3Yse2ZpbGVOYW1lOnd9XW9mIG0pe2xldCBiPVJpKCk7Y29uc3QgUz1uZXcgU2V0KFt2XSk7Zm9yKGNvbnN0IFAgb2YgUyl7Y29uc3R7Y29udGFpbmVkUGxhY2Vob2xkZXJzOl8sY29udGVudEhhc2g6QX09eS5nZXQoUCk7Yi51cGRhdGUoQSk7Zm9yKGNvbnN0IE4gb2YgXylTLmFkZChOKX1sZXQgayxDO2RvIEMmJihiPVJpKCkudXBkYXRlKEMpKSxDPWIuZGlnZXN0KCJoZXgiKS5zbGljZSgwLHYubGVuZ3RoKSxrPVBkKHcsdixDKTt3aGlsZShnW2duXS5oYXMoay50b0xvd2VyQ2FzZSgpKSk7Z1trXT1Kcix4LnNldCh2LEMpfXJldHVybiB4fShsLGMsbyx0KTsoZnVuY3Rpb24obSx5LEUsZyx4LHYpe2Zvcihjb25zdHtjaHVuazp3LGNvZGU6YixmaWxlTmFtZTpTLHNvdXJjZW1hcEZpbGVOYW1lOmssbWFwOkN9b2YgbS52YWx1ZXMoKSl7bGV0IFA9ZGkoYix5KTtjb25zdCBfPWRpKFMseSk7bGV0IEE9bnVsbDtDJiYoQT1rP2RpKGsseSk6YCR7X30ubWFwYCxDLmZpbGU9ZGkoQy5maWxlLHkpLFArPXdsKEEsQyx4LHYpKSxFW19dPXcuZmluYWxpemVDaHVuayhQLEMsQSx5KX1mb3IoY29uc3R7Y2h1bms6dyxjb2RlOmIsZmlsZU5hbWU6Uyxzb3VyY2VtYXBGaWxlTmFtZTprLG1hcDpDfW9mIGcpe2xldCBQPXkuc2l6ZT4wP2RpKGIseSk6YixfPW51bGw7QyYmKF89az9kaShrLHkpOmAke1N9Lm1hcGAsUCs9d2woXyxDLHgsdikpLEVbU109dy5maW5hbGl6ZUNodW5rKFAsQyxfLHkpfX0pKGwscCx0LGgsaSxzKSxTZSgidHJhbnNmb3JtIGNodW5rcyIsMil9YXN5bmMgZnVuY3Rpb24gaGYoZSx0LGkscyxuLHIsYSl7bGV0IG89bnVsbDtjb25zdCBoPVtdO2xldCBsPWF3YWl0IHIuaG9va1JlZHVjZUFyZzAoInJlbmRlckNodW5rIixbZS50b1N0cmluZygpLHNbdF0sbix7Y2h1bmtzOnN9XSwodyxiLFMpPT57aWYoYj09bnVsbClyZXR1cm4gdztpZih0eXBlb2YgYj09InN0cmluZyImJihiPXtjb2RlOmIsbWFwOnZvaWQgMH0pLGIubWFwIT09bnVsbCl7Y29uc3Qgaz0kaShiLm1hcCk7aC5wdXNoKGt8fHttaXNzaW5nOiEwLHBsdWdpbjpTLm5hbWV9KX1yZXR1cm4gYi5jb2RlfSk7Y29uc3R7Y29tcGFjdDpjLGRpcjpwLGZpbGU6bSxzb3VyY2VtYXA6eSxzb3VyY2VtYXBFeGNsdWRlU291cmNlczpFLHNvdXJjZW1hcEZpbGU6Zyxzb3VyY2VtYXBQYXRoVHJhbnNmb3JtOngsc291cmNlbWFwSWdub3JlTGlzdDp2fT1uO2lmKGN8fGxbbC5sZW5ndGgtMV09PT1gCmB8fChsKz1gCmApLHkpe2xldCB3O0NlKCJzb3VyY2VtYXBzIiwzKSx3PW0/aHQoZ3x8bSk6cD9odChwLHQpOmh0KHQpLG89ZnVuY3Rpb24oYixTLGssQyxQLF8pe2NvbnN0IEE9cGwoXyksTj1rLmZpbHRlcihCPT4hQi5leGNsdWRlRnJvbVNvdXJjZW1hcCkubWFwKEI9PmRsKEIuaWQsQi5vcmlnaW5hbENvZGUsQi5vcmlnaW5hbFNvdXJjZW1hcCxCLnNvdXJjZW1hcENoYWluLEEpKSxVPW5ldyB4bihTLE4pLE89Qy5yZWR1Y2UoQSxVKTtsZXR7c291cmNlczpHLHNvdXJjZXNDb250ZW50OlIsbmFtZXM6VyxtYXBwaW5nczpqfT1PLnRyYWNlTWFwcGluZ3MoKTtpZihiKXtjb25zdCBCPUp0KGIpO0c9Ry5tYXAoYWU9PnZpKEIsYWUpKSxiPUN0KGIpfVI9UD9udWxsOlI7Zm9yKGNvbnN0IEIgb2YgaylqcihCLm9yaWdpbmFsU291cmNlbWFwLEIuc291cmNlbWFwQ2hhaW4pO3JldHVybiBuZXcgTnMoe2ZpbGU6YixtYXBwaW5nczpqLG5hbWVzOlcsc291cmNlczpHLHNvdXJjZXNDb250ZW50OlJ9KX0odyxlLmdlbmVyYXRlRGVjb2RlZE1hcCh7fSksaSxoLEUsYSk7Zm9yKGxldCBiPTA7YjxvLnNvdXJjZXMubGVuZ3RoOysrYil7bGV0IFM9by5zb3VyY2VzW2JdO2NvbnN0IGs9YCR7d30ubWFwYCxDPXYoUyxrKTt0eXBlb2YgQyE9ImJvb2xlYW4iJiZMKEJlKCJzb3VyY2VtYXBJZ25vcmVMaXN0IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgYm9vbGVhbi4iKSksQyYmKG8ueF9nb29nbGVfaWdub3JlTGlzdD09PXZvaWQgMCYmKG8ueF9nb29nbGVfaWdub3JlTGlzdD1bXSksby54X2dvb2dsZV9pZ25vcmVMaXN0LmluY2x1ZGVzKGIpfHxvLnhfZ29vZ2xlX2lnbm9yZUxpc3QucHVzaChiKSkseCYmKFM9eChTLGspLHR5cGVvZiBTIT0ic3RyaW5nIiYmTChCZSgic291cmNlbWFwUGF0aFRyYW5zZm9ybSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy4iKSkpLG8uc291cmNlc1tiXT1HaShTKX1TZSgic291cmNlbWFwcyIsMyl9cmV0dXJue2NvZGU6bCxtYXA6b319ZnVuY3Rpb24gd2woZSx0LGkse3NvdXJjZW1hcDpzLHNvdXJjZW1hcEJhc2VVcmw6bn0pe2xldCByO2lmKHM9PT0iaW5saW5lIilyPXQudG9VcmwoKTtlbHNle2NvbnN0IGE9Q3QoZSk7cj1uP25ldyBVUkwoYSxuKS50b1N0cmluZygpOmEsaS5lbWl0RmlsZSh7ZmlsZU5hbWU6ZSxzb3VyY2U6dC50b1N0cmluZygpLHR5cGU6ImFzc2V0In0pfXJldHVybiBzPT09ImhpZGRlbiI/IiI6YC8vIyAke2xyfT0ke3J9CmB9Y2xhc3MgbGZ7Y29uc3RydWN0b3IodCxpLHMsbixyKXt0aGlzLm91dHB1dE9wdGlvbnM9dCx0aGlzLnVuc2V0T3B0aW9ucz1pLHRoaXMuaW5wdXRPcHRpb25zPXMsdGhpcy5wbHVnaW5Ecml2ZXI9bix0aGlzLmdyYXBoPXIsdGhpcy5mYWNhZGVDaHVua0J5TW9kdWxlPW5ldyBNYXAsdGhpcy5pbmNsdWRlZE5hbWVzcGFjZXM9bmV3IFNldH1hc3luYyBnZW5lcmF0ZSh0KXtDZSgiR0VORVJBVEUiLDEpO2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKSxzPShuPT57Y29uc3Qgcj1uZXcgU2V0O3JldHVybiBuZXcgUHJveHkobix7ZGVsZXRlUHJvcGVydHk6KGEsbyk9Pih0eXBlb2Ygbz09InN0cmluZyImJnIuZGVsZXRlKG8udG9Mb3dlckNhc2UoKSksUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShhLG8pKSxnZXQ6KGEsbyk9Pm89PT1nbj9yOlJlZmxlY3QuZ2V0KGEsbyksc2V0OihhLG8saCk9Pih0eXBlb2Ygbz09InN0cmluZyImJnIuYWRkKG8udG9Mb3dlckNhc2UoKSksUmVmbGVjdC5zZXQoYSxvLGgpKX0pfSkoaSk7dGhpcy5wbHVnaW5Ecml2ZXIuc2V0T3V0cHV0QnVuZGxlKHMsdGhpcy5vdXRwdXRPcHRpb25zKTt0cnl7Q2UoImluaXRpYWxpemUgcmVuZGVyIiwyKSxhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoInJlbmRlclN0YXJ0IixbdGhpcy5vdXRwdXRPcHRpb25zLHRoaXMuaW5wdXRPcHRpb25zXSksU2UoImluaXRpYWxpemUgcmVuZGVyIiwyKSxDZSgiZ2VuZXJhdGUgY2h1bmtzIiwyKTtjb25zdCBuPSgoKT0+e2xldCBhPTA7cmV0dXJuKG8saD04KT0+e2lmKGg+NjQpcmV0dXJuIEwoQmUoYEhhc2hlcyBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gNjQgY2hhcmFjdGVycywgcmVjZWl2ZWQgJHtofS4gQ2hlY2sgdGhlICIke299IiBvcHRpb24uYCkpO2NvbnN0IGw9YCR7WXJ9JHtRcygrK2EpLnBhZFN0YXJ0KGgtNSwiMCIpfSR7WHJ9YDtyZXR1cm4gbC5sZW5ndGg+aD9MKEJlKGBUbyBnZW5lcmF0ZSBoYXNoZXMgZm9yIHRoaXMgbnVtYmVyIG9mIGNodW5rcyAoY3VycmVudGx5ICR7YX0pLCB5b3UgbmVlZCBhIG1pbmltdW0gaGFzaCBzaXplIG9mICR7bC5sZW5ndGh9LCByZWNlaXZlZCAke2h9LiBDaGVjayB0aGUgIiR7b30iIG9wdGlvbi5gKSk6bH19KSgpLHI9YXdhaXQgdGhpcy5nZW5lcmF0ZUNodW5rcyhzLG4pO3IubGVuZ3RoPjEmJmZ1bmN0aW9uKGEsbyl7aWYoYS5mb3JtYXQ9PT0idW1kInx8YS5mb3JtYXQ9PT0iaWlmZSIpcmV0dXJuIEwoRWUoIm91dHB1dC5mb3JtYXQiLGhvLCJVTUQgYW5kIElJRkUgb3V0cHV0IGZvcm1hdHMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIGNvZGUtc3BsaXR0aW5nIGJ1aWxkcyIsYS5mb3JtYXQpKTtpZih0eXBlb2YgYS5maWxlPT0ic3RyaW5nIilyZXR1cm4gTChFZSgib3V0cHV0LmZpbGUiLEhpLCd3aGVuIGJ1aWxkaW5nIG11bHRpcGxlIGNodW5rcywgdGhlICJvdXRwdXQuZGlyIiBvcHRpb24gbXVzdCBiZSB1c2VkLCBub3QgIm91dHB1dC5maWxlIi4gVG8gaW5saW5lIGR5bmFtaWMgaW1wb3J0cywgc2V0IHRoZSAiaW5saW5lRHluYW1pY0ltcG9ydHMiIG9wdGlvbicpKTtpZihhLnNvdXJjZW1hcEZpbGUpcmV0dXJuIEwoRWUoIm91dHB1dC5zb3VyY2VtYXBGaWxlIix6YywnIm91dHB1dC5zb3VyY2VtYXBGaWxlIiBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc2luZ2xlLWZpbGUgYnVpbGRzJykpOyFhLmFtZC5hdXRvSWQmJmEuYW1kLmlkJiZvKEssRWUoIm91dHB1dC5hbWQuaWQiLG9vLCd0aGlzIG9wdGlvbiBpcyBvbmx5IHByb3Blcmx5IHN1cHBvcnRlZCBmb3Igc2luZ2xlLWZpbGUgYnVpbGRzLiBVc2UgIm91dHB1dC5hbWQuYXV0b0lkIiBhbmQgIm91dHB1dC5hbWQuYmFzZVBhdGgiIGluc3RlYWQnKSl9KHRoaXMub3V0cHV0T3B0aW9ucyx0aGlzLmlucHV0T3B0aW9ucy5vbkxvZyksdGhpcy5wbHVnaW5Ecml2ZXIuc2V0Q2h1bmtJbmZvcm1hdGlvbih0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUpO2Zvcihjb25zdCBhIG9mIHIpYS5nZW5lcmF0ZUV4cG9ydHMoKTtTZSgiZ2VuZXJhdGUgY2h1bmtzIiwyKSxhd2FpdCBvZihyLHMsdGhpcy5wbHVnaW5Ecml2ZXIsdGhpcy5vdXRwdXRPcHRpb25zLHRoaXMuaW5wdXRPcHRpb25zLm9uTG9nKX1jYXRjaChuKXt0aHJvdyBhd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoInJlbmRlckVycm9yIixbbl0pLG59cmV0dXJuKG49Pntjb25zdCByPW5ldyBTZXQsYT1PYmplY3QudmFsdWVzKG4pO2Zvcihjb25zdCBvIG9mIGEpby50eXBlPT09ImFzc2V0IiYmby5uZWVkc0NvZGVSZWZlcmVuY2UmJnIuYWRkKG8uZmlsZU5hbWUpO2Zvcihjb25zdCBvIG9mIGEpaWYoby50eXBlPT09ImNodW5rIilmb3IoY29uc3QgaCBvZiBvLnJlZmVyZW5jZWRGaWxlcylyLmhhcyhoKSYmci5kZWxldGUoaCk7Zm9yKGNvbnN0IG8gb2YgcilkZWxldGUgbltvXX0pKHMpLENlKCJnZW5lcmF0ZSBidW5kbGUiLDIpLGF3YWl0IHRoaXMucGx1Z2luRHJpdmVyLmhvb2tTZXEoImdlbmVyYXRlQnVuZGxlIixbdGhpcy5vdXRwdXRPcHRpb25zLHMsdF0pLHRoaXMuZmluYWxpc2VBc3NldHMocyksU2UoImdlbmVyYXRlIGJ1bmRsZSIsMiksU2UoIkdFTkVSQVRFIiwxKSxpfWFzeW5jIGFkZE1hbnVhbENodW5rcyh0KXtjb25zdCBpPW5ldyBNYXAscz1hd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyh0KS5tYXAoYXN5bmMoW24scl0pPT4oe2FsaWFzOm4sZW50cmllczphd2FpdCB0aGlzLmdyYXBoLm1vZHVsZUxvYWRlci5hZGRBZGRpdGlvbmFsTW9kdWxlcyhyLCEwKX0pKSk7Zm9yKGNvbnN0e2FsaWFzOm4sZW50cmllczpyfW9mIHMpZm9yKGNvbnN0IGEgb2YgcilBbChuLGEsaSk7cmV0dXJuIGl9YXNzaWduTWFudWFsQ2h1bmtzKHQpe2NvbnN0IGk9W10scz17Z2V0TW9kdWxlSWRzOigpPT50aGlzLmdyYXBoLm1vZHVsZXNCeUlkLmtleXMoKSxnZXRNb2R1bGVJbmZvOnRoaXMuZ3JhcGguZ2V0TW9kdWxlSW5mb307Zm9yKGNvbnN0IHIgb2YgdGhpcy5ncmFwaC5tb2R1bGVzQnlJZC52YWx1ZXMoKSlpZihyIGluc3RhbmNlb2YgeWUpe2NvbnN0IGE9dChyLmlkLHMpO3R5cGVvZiBhPT0ic3RyaW5nIiYmaS5wdXNoKFthLHJdKX1pLnNvcnQoKFtyXSxbYV0pPT5yPmE/MTpyPGE/LTE6MCk7Y29uc3Qgbj1uZXcgTWFwO2Zvcihjb25zdFtyLGFdb2YgaSlBbChyLGEsbik7cmV0dXJuIG59ZmluYWxpc2VBc3NldHModCl7aWYodGhpcy5vdXRwdXRPcHRpb25zLnZhbGlkYXRlKXtmb3IoY29uc3QgaSBvZiBPYmplY3QudmFsdWVzKHQpKWlmKCJjb2RlImluIGkpdHJ5e3RoaXMuZ3JhcGguY29udGV4dFBhcnNlKGkuY29kZSx7ZWNtYVZlcnNpb246ImxhdGVzdCJ9KX1jYXRjaChzKXt0aGlzLmlucHV0T3B0aW9ucy5vbkxvZyhLLGRwKGkscykpfX10aGlzLnBsdWdpbkRyaXZlci5maW5hbGlzZUFzc2V0cygpfWFzeW5jIGdlbmVyYXRlQ2h1bmtzKHQsaSl7Y29uc3R7ZXhwZXJpbWVudGFsTWluQ2h1bmtTaXplOnMsaW5saW5lRHluYW1pY0ltcG9ydHM6bixtYW51YWxDaHVua3M6cixwcmVzZXJ2ZU1vZHVsZXM6YX09dGhpcy5vdXRwdXRPcHRpb25zLG89dHlwZW9mIHI9PSJvYmplY3QiP2F3YWl0IHRoaXMuYWRkTWFudWFsQ2h1bmtzKHIpOnRoaXMuYXNzaWduTWFudWFsQ2h1bmtzKHIpLGg9ZnVuY3Rpb24oe2NvbXBhY3Q6ZyxnZW5lcmF0ZWRDb2RlOnthcnJvd0Z1bmN0aW9uczp4LGNvbnN0QmluZGluZ3M6dixvYmplY3RTaG9ydGhhbmQ6dyxyZXNlcnZlZE5hbWVzQXNQcm9wczpifX0pe2NvbnN0e186UyxuOmssczpDfT1nP3tfOiIiLG46IiIsczoiIn06e186IiAiLG46YApgLHM6IjsifSxQPXY/ImNvbnN0IjoidmFyIixfPShPLHtpc0FzeW5jOkcsbmFtZTpSfSk9PmAke0c/ImFzeW5jICI6IiJ9ZnVuY3Rpb24ke1I/YCAke1J9YDoiIn0ke1N9KCR7Ty5qb2luKGAsJHtTfWApfSkke1N9YCxBPXg/KE8se2lzQXN5bmM6RyxuYW1lOlJ9KT0+e2NvbnN0IFc9Ty5sZW5ndGg9PT0xO3JldHVybmAke1I/YCR7UH0gJHtSfSR7U309JHtTfWA6IiJ9JHtHP2Bhc3luYyR7Vz8iICI6U31gOiIifSR7Vz9PWzBdOmAoJHtPLmpvaW4oYCwke1N9YCl9KWB9JHtTfT0+JHtTfWB9Ol8sTj0oTyx7ZnVuY3Rpb25SZXR1cm46RyxsaW5lQnJlYWtJbmRlbnQ6UixuYW1lOld9KT0+W2Ake0EoTyx7aXNBc3luYzohMSxuYW1lOld9KX0ke3g/Uj9gJHtrfSR7Ui5iYXNlfSR7Ui50fWA6IiI6YHske1I/YCR7a30ke1IuYmFzZX0ke1IudH1gOlN9JHtHPyJyZXR1cm4gIjoiIn1gfWAseD9gJHtXPyI7IjoiIn0ke1I/YCR7a30ke1IuYmFzZX1gOiIifWA6YCR7Q30ke1I/YCR7a30ke1IuYmFzZX1gOlN9fWBdLFU9Yj9PPT51bC50ZXN0KE8pOk89PiFNcy5oYXMoTykmJnVsLnRlc3QoTyk7cmV0dXJue186UyxjbnN0OlAsZ2V0RGlyZWN0UmV0dXJuRnVuY3Rpb246TixnZXREaXJlY3RSZXR1cm5JaWZlTGVmdDooTyxHLHtuZWVkc0Fycm93UmV0dXJuUGFyZW5zOlIsbmVlZHNXcmFwcGVkRnVuY3Rpb246V30pPT57Y29uc3RbaixCXT1OKE8se2Z1bmN0aW9uUmV0dXJuOiEwLGxpbmVCcmVha0luZGVudDpudWxsLG5hbWU6bnVsbH0pO3JldHVybmAke2xsKGAke2p9JHtsbChHLHgmJlIpfSR7Qn1gLHh8fFcpfShgfSxnZXRGdW5jdGlvbkludHJvOkEsZ2V0Tm9uQXJyb3dGdW5jdGlvbkludHJvOl8sZ2V0T2JqZWN0KE8se2xpbmVCcmVha0luZGVudDpHfSl7Y29uc3QgUj1HP2Ake2t9JHtHLmJhc2V9JHtHLnR9YDpTO3JldHVybmB7JHtPLm1hcCgoW1csal0pPT57aWYoVz09PW51bGwpcmV0dXJuYCR7Un0ke2p9YDtjb25zdCBCPSFVKFcpO3JldHVybiBXPT09aiYmdyYmIUI/UitXOmAke1J9JHtCP2AnJHtXfSdgOld9OiR7U30ke2p9YH0pLmpvaW4oIiwiKX0ke08ubGVuZ3RoPT09MD8iIjpHP2Ake2t9JHtHLmJhc2V9YDpTfX1gfSxnZXRQcm9wZXJ0eUFjY2VzczpPPT5VKE8pP2AuJHtPfWA6YFske0pTT04uc3RyaW5naWZ5KE8pfV1gLG46ayxzOkN9fSh0aGlzLm91dHB1dE9wdGlvbnMpLGw9ZnVuY3Rpb24oZyl7Y29uc3QgeD1bXTtmb3IoY29uc3QgdiBvZiBnLnZhbHVlcygpKXYgaW5zdGFuY2VvZiB5ZSYmKHYuaXNJbmNsdWRlZCgpfHx2LmluZm8uaXNFbnRyeXx8di5pbmNsdWRlZER5bmFtaWNJbXBvcnRlcnMubGVuZ3RoPjApJiZ4LnB1c2godik7cmV0dXJuIHh9KHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQpLGM9ZnVuY3Rpb24oZyl7aWYoZy5sZW5ndGg9PT0wKXJldHVybiIvIjtpZihnLmxlbmd0aD09PTEpcmV0dXJuIEp0KGdbMF0pO2NvbnN0IHg9Zy5zbGljZSgxKS5yZWR1Y2UoKHYsdyk9Pntjb25zdCBiPXcuc3BsaXQoL1wvK3xcXCsvKTtsZXQgUztmb3IoUz0wO3ZbU109PT1iW1NdJiZTPE1hdGgubWluKHYubGVuZ3RoLGIubGVuZ3RoKTtTKyspO3JldHVybiB2LnNsaWNlKDAsUyl9LGdbMF0uc3BsaXQoL1wvK3xcXCsvKSk7cmV0dXJuIHgubGVuZ3RoPjE/eC5qb2luKCIvIik6Ii8ifShmdW5jdGlvbihnLHgpe2NvbnN0IHY9W107Zm9yKGNvbnN0IHcgb2YgZykody5pbmZvLmlzRW50cnl8fHgpJiZWdCh3LmlkKSYmdi5wdXNoKHcuaWQpO3JldHVybiB2fShsLGEpKSxwPWZ1bmN0aW9uKGcseCx2KXtjb25zdCB3PW5ldyBNYXA7Zm9yKGNvbnN0IGIgb2YgZy52YWx1ZXMoKSliIGluc3RhbmNlb2YgbGUmJncuc2V0KGIsbmV3IEVpKGIseCx2KSk7cmV0dXJuIHd9KHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQsdGhpcy5vdXRwdXRPcHRpb25zLGMpLG09W10seT1uZXcgTWFwO2Zvcihjb25zdHthbGlhczpnLG1vZHVsZXM6eH1vZiBuP1t7YWxpYXM6bnVsbCxtb2R1bGVzOmx9XTphP2wubWFwKHY9Pih7YWxpYXM6bnVsbCxtb2R1bGVzOlt2XX0pKTpSZCh0aGlzLmdyYXBoLmVudHJ5TW9kdWxlcyxvLHMsdGhpcy5pbnB1dE9wdGlvbnMub25Mb2cpKXt4LnNvcnQoRmQpO2NvbnN0IHY9bmV3IFd0KHgsdGhpcy5pbnB1dE9wdGlvbnMsdGhpcy5vdXRwdXRPcHRpb25zLHRoaXMudW5zZXRPcHRpb25zLHRoaXMucGx1Z2luRHJpdmVyLHRoaXMuZ3JhcGgubW9kdWxlc0J5SWQseSxwLHRoaXMuZmFjYWRlQ2h1bmtCeU1vZHVsZSx0aGlzLmluY2x1ZGVkTmFtZXNwYWNlcyxnLGksdCxjLGgpO20ucHVzaCh2KX1mb3IoY29uc3QgZyBvZiBtKWcubGluaygpO2NvbnN0IEU9W107Zm9yKGNvbnN0IGcgb2YgbSlFLnB1c2goLi4uZy5nZW5lcmF0ZUZhY2FkZXMoKSk7cmV0dXJuWy4uLm0sLi4uRV19fWZ1bmN0aW9uIEFsKGUsdCxpKXtjb25zdCBzPWkuZ2V0KHQpO2lmKHR5cGVvZiBzPT0ic3RyaW5nIiYmcyE9PWUpcmV0dXJuIEwoKG49dC5pZCxyPWUsYT1zLHtjb2RlOkpjLG1lc3NhZ2U6YENhbm5vdCBhc3NpZ24gIiR7WChuKX0iIHRvIHRoZSAiJHtyfSIgY2h1bmsgYXMgaXQgaXMgYWxyZWFkeSBpbiB0aGUgIiR7YX0iIGNodW5rLmB9KSk7dmFyIG4scixhO2kuc2V0KHQsZSl9dmFyIHVmPVs1MDksMCwyMjcsMCwxNTAsNCwyOTQsOSwxMzY4LDIsMiwxLDYsMyw0MSwyLDUsMCwxNjYsMSw1NzQsMyw5LDksMzcwLDEsODEsMiw3MSwxMCw1MCwzLDEyMywyLDU0LDE0LDMyLDEwLDMsMSwxMSwzLDQ2LDEwLDgsMCw0Niw5LDcsMiwzNywxMywyLDksNiwxLDQ1LDAsMTMsMiw0OSwxMyw5LDMsMiwxMSw4MywxMSw3LDAsMywwLDE1OCwxMSw2LDksNywzLDU2LDEsMiw2LDMsMSwzLDIsMTAsMCwxMSwxLDMsNiw0LDQsMTkzLDE3LDEwLDksNSwwLDgyLDE5LDEzLDksMjE0LDYsMyw4LDI4LDEsODMsMTYsMTYsOSw4MiwxMiw5LDksODQsMTQsNSw5LDI0MywxNCwxNjYsOSw3MSw1LDIsMSwzLDMsMiwwLDIsMSwxMyw5LDEyMCw2LDMsNiw0LDAsMjksOSw0MSw2LDIsMyw5LDAsMTAsMTAsNDcsMTUsNDA2LDcsMiw3LDE3LDksNTcsMjEsMiwxMywxMjMsNSw0LDAsMiwxLDIsNiwyLDAsOSw5LDQ5LDQsMiwxLDIsNCw5LDksMzMwLDMsMTAsMSwyLDAsNDksNiw0LDQsMTQsOSw1MzUxLDAsNywxNCwxMzgzNSw5LDg3LDksMzksNCw2MCw2LDI2LDksMTAxNCwwLDIsNTQsOCwzLDgyLDAsMTIsMSwxOTYyOCwxLDQ3MDYsNDUsMywyMiw1NDMsNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDEwMSwwLDE2MSw2LDEwLDksMzU3LDAsNjIsMTMsNDk5LDEzLDk4Myw2LDExMCw2LDYsOSw0NzU5LDksNzg3NzE5LDIzOV0sQ2w9WzAsMTEsMiwyNSwyLDE4LDIsMSwyLDE0LDMsMTMsMzUsMTIyLDcwLDUyLDI2OCwyOCw0LDQ4LDQ4LDMxLDE0LDI5LDYsMzcsMTEsMjksMywzNSw1LDcsMiw0LDQzLDE1NywxOSwzNSw1LDM1LDUsMzksOSw1MSwxMywxMCwyLDE0LDIsNiwyLDEsMiwxMCwyLDE0LDIsNiwyLDEsNjgsMzEwLDEwLDIxLDExLDcsMjUsNSwyLDQxLDIsOCw3MCw1LDMsMCwyLDQzLDIsMSw0LDAsMywyMiwxMSwyMiwxMCwzMCw2NiwxOCwyLDEsMTEsMjEsMTEsMjUsNzEsNTUsNywxLDY1LDAsMTYsMywyLDIsMiwyOCw0MywyOCw0LDI4LDM2LDcsMiwyNywyOCw1MywxMSwyMSwxMSwxOCwxNCwxNywxMTEsNzIsNTYsNTAsMTQsNTAsMTQsMzUsMzQ5LDQxLDcsMSw3OSwyOCwxMSwwLDksMjEsNDMsMTcsNDcsMjAsMjgsMjIsMTMsNTIsNTgsMSwzLDAsMTQsNDQsMzMsMjQsMjcsMzUsMzAsMCwzLDAsOSwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDIwLDEsNjQsNiwyLDAsMiwzLDIsMTQsMiw5LDgsNDYsMzksNywzLDEsMywyMSwyLDYsMiwxLDIsNCw0LDAsMTksMCwxMyw0LDE1OSw1MiwxOSwzLDIxLDIsMzEsNDcsMjEsMSwyLDAsMTg1LDQ2LDQyLDMsMzcsNDcsMjEsMCw2MCw0MiwxNCwwLDcyLDI2LDM4LDYsMTg2LDQzLDExNyw2MywzMiw3LDMsMCwzLDcsMiwxLDIsMjMsMTYsMCwyLDAsOTUsNywzLDM4LDE3LDAsMiwwLDI5LDAsMTEsMzksOCwwLDIyLDAsMTIsNDUsMjAsMCwxOSw3MiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksMTEzLDYsMiwxLDIsMzcsMjIsMCwyNiw1LDIsMSwyLDMxLDE1LDAsMzI4LDE4LDE2LDAsMiwxMiwyLDMzLDEyNSwwLDgwLDkyMSwxMDMsMTEwLDE4LDE5NSwyNjM3LDk2LDE2LDEwNzEsMTgsNSw0MDI2LDU4Miw4NjM0LDU2OCw4LDMwLDE4LDc4LDE4LDI5LDE5LDQ3LDE3LDMsMzIsMjAsNiwxOCw2ODksNjMsMTI5LDc0LDYsMCw2NywxMiw2NSwxLDIsMCwyOSw2MTM1LDksMTIzNyw0Myw4LDg5MzYsMywyLDYsMiwxLDIsMjkwLDE2LDAsMzAsMiwzLDAsMTUsMyw5LDM5NSwyMzA5LDEwNiw2LDEyLDQsOCw4LDksNTk5MSw4NCwyLDcwLDIsMSwzLDAsMywxLDMsMywyLDExLDIsMCwyLDYsMiw2NCwyLDMsMyw3LDIsNiwyLDI3LDIsMywyLDQsMiwwLDQsNiwyLDMzOSwzLDI0LDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsNywxODQ1LDMwLDcsNSwyNjIsNjEsMTQ3LDQ0LDExLDYsMTcsMCwzMjIsMjksMTksNDMsNDg1LDI3LDc1Nyw2LDIsMywyLDEsMiwxNCwyLDE5Niw2MCw2Nyw4LDAsMTIwNSwzLDIsMjYsMiwxLDIsMCwzLDAsMiw5LDIsMywyLDAsMiwwLDcsMCw1LDAsMiwwLDIsMCwyLDIsMiwxLDIsMCwzLDAsMiwwLDIsMCwyLDAsMiwwLDIsMSwyLDAsMywzLDIsNiwyLDMsMiwzLDIsMCwyLDksMiwxNiw2LDIsMiw0LDIsMTYsNDQyMSw0MjcxOSwzMyw0MTUzLDcsMjIxLDMsNTc2MSwxNSw3NDcyLDMxMDQsNTQxLDE1MDcsNDkzOCw2LDQxOTFdLElsPSLCqsK1wrrDgC3DlsOYLcO2w7gty4HLhi3LkcugLcuky6zLrs2wLc20zbbNt826Lc29zb/Ohs6ILc6KzozOji3Ooc6jLc+1z7ct0oHSii3Ur9SxLdWW1ZnVoC3WiNeQLdeq168t17LYoC3Zitmu2a/ZsS3bk9uV26Xbptuu26/bui3bvNu/3JDcki3cr92NLd6l3rHfii3fqt+037XfuuCggC3goJXgoJrgoKTgoKjgoYAt4KGY4KGgLeChquChsC3goofgookt4KKO4KKgLeCjieCkhC3gpLngpL3gpZDgpZgt4KWh4KWxLeCmgOCmhS3gpozgpo/gppDgppMt4Kao4KaqLeCmsOCmsuCmti3gprngpr3gp47gp5zgp53gp58t4Keh4Kew4Kex4Ke84KiFLeCoiuCoj+CokOCoky3gqKjgqKot4Kiw4Kiy4Kiz4Ki14Ki24Ki44Ki54KmZLeCpnOCpnuCpsi3gqbTgqoUt4KqN4KqPLeCqkeCqky3gqqjgqqot4Kqw4Kqy4Kqz4Kq1LeCqueCqveCrkOCroOCroeCrueCshS3grIzgrI/grJDgrJMt4Kyo4KyqLeCssOCssuCss+CstS3grLngrL3grZzgrZ3grZ8t4K2h4K2x4K6D4K6FLeCuiuCuji3grpDgrpIt4K6V4K6Z4K6a4K6c4K6e4K6f4K6j4K6k4K6oLeCuquCuri3grrngr5DgsIUt4LCM4LCOLeCwkOCwki3gsKjgsKot4LC54LC94LGYLeCxmuCxneCxoOCxoeCygOCyhS3gsozgso4t4LKQ4LKSLeCyqOCyqi3gsrPgsrUt4LK54LK94LOd4LOe4LOg4LOh4LOx4LOy4LSELeC0jOC0ji3gtJDgtJIt4LS64LS94LWO4LWULeC1luC1ny3gtaHgtbot4LW/4LaFLeC2luC2mi3gtrHgtrMt4La74La94LeALeC3huC4gS3guLDguLLguLPguYAt4LmG4LqB4LqC4LqE4LqGLeC6iuC6jC3guqPguqXguqct4Lqw4Lqy4Lqz4Lq94LuALeC7hOC7huC7nC3gu5/gvIDgvYAt4L2H4L2JLeC9rOC+iC3gvozhgIAt4YCq4YC/4YGQLeGBleGBmi3hgZ3hgaHhgaXhgabhga4t4YGw4YG1LeGCgeGCjuGCoC3hg4Xhg4fhg43hg5At4YO64YO8LeGJiOGJii3hiY3hiZAt4YmW4YmY4YmaLeGJneGJoC3hiojhioot4YqN4YqQLeGKsOGKsi3hirXhirgt4Yq+4YuA4YuCLeGLheGLiC3hi5bhi5gt4YyQ4YySLeGMleGMmC3hjZrhjoAt4Y6P4Y6gLeGPteGPuC3hj73hkIEt4Zms4ZmvLeGZv+GagS3hmprhmqAt4Zuq4ZuuLeGbuOGcgC3hnJHhnJ8t4Zyx4Z2ALeGdkeGdoC3hnazhna4t4Z2w4Z6ALeGes+Gfl+GfnOGgoC3hobjhooAt4aKo4aKq4aKwLeGjteGkgC3hpJ7hpZAt4aWt4aWwLeGltOGmgC3hpqvhprAt4aeJ4aiALeGoluGooC3hqZThqqfhrIUt4ayz4a2FLeGtjOGugy3hrqDhrq7hrq/hrrot4a+l4bCALeGwo+GxjS3hsY/hsZot4bG94bKALeGyiOGykC3hsrrhsr0t4bK/4bOpLeGzrOGzri3hs7Phs7Xhs7bhs7rhtIAt4ba/4biALeG8leG8mC3hvJ3hvKAt4b2F4b2ILeG9jeG9kC3hvZfhvZnhvZvhvZ3hvZ8t4b294b6ALeG+tOG+ti3hvrzhvr7hv4It4b+E4b+GLeG/jOG/kC3hv5Phv5Yt4b+b4b+gLeG/rOG/si3hv7Thv7Yt4b+84oGx4oG/4oKQLeKCnOKEguKEh+KEii3ihJPihJXihJgt4oSd4oSk4oSm4oSo4oSqLeKEueKEvC3ihL/ihYUt4oWJ4oWO4oWgLeKGiOKwgC3is6Tis6st4rOu4rOy4rOz4rSALeK0peK0p+K0reK0sC3itafita/itoAt4raW4ragLeK2puK2qC3itq7itrAt4ra24ra4LeK2vuK3gC3it4bit4gt4reO4reQLeK3luK3mC3it57jgIUt44CH44ChLeOAqeOAsS3jgLXjgLgt44C844GBLeOCluOCmy3jgp/jgqEt44O644O8LeODv+OEhS3jhK/jhLEt44aO44agLeOGv+OHsC3jh7/jkIAt5La/5LiALeqSjOqTkC3qk73qlIAt6piM6piQLeqYn+qYquqYq+qZgC3qma7qmb8t6pqd6pqgLeqbr+qcly3qnJ/qnKIt6p6I6p6LLeqfiuqfkOqfkeqfk+qflS3qn5nqn7It6qCB6qCDLeqgheqghy3qoIrqoIwt6qCi6qGALeqhs+qigi3qorPqo7It6qO36qO76qO96qO+6qSKLeqkpeqksC3qpYbqpaAt6qW86qaELeqmsuqnj+qnoC3qp6Tqp6Yt6qev6qe6LeqnvuqogC3qqKjqqYAt6qmC6qmELeqpi+qpoC3qqbbqqbrqqb4t6qqv6qqx6qq16qq26qq5LeqqveqrgOqrguqrmy3qq53qq6At6quq6quyLeqrtOqsgS3qrIbqrIkt6qyO6qyRLeqsluqsoC3qrKbqrKgt6qyu6qywLeqtmuqtnC3qranqrbAt6q+i6rCALe2eo+2esC3tn4btn4st7Z+776SALe+pre+psC3vq5nvrIAt76yG76yTLe+sl++sne+sny3vrKjvrKot76y276y4Le+svO+svu+tgO+tge+tg++thO+thi3vrrHvr5Mt77S977WQLe+2j++2ki3vt4fvt7At77e777mwLe+5tO+5ti3vu7zvvKEt77y6772BLe+9mu+9pi3vvr7vv4It77+H77+KLe+/j++/ki3vv5fvv5ot77+cIixyYT17MzoiYWJzdHJhY3QgYm9vbGVhbiBieXRlIGNoYXIgY2xhc3MgZG91YmxlIGVudW0gZXhwb3J0IGV4dGVuZHMgZmluYWwgZmxvYXQgZ290byBpbXBsZW1lbnRzIGltcG9ydCBpbnQgaW50ZXJmYWNlIGxvbmcgbmF0aXZlIHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHNob3J0IHN0YXRpYyBzdXBlciBzeW5jaHJvbml6ZWQgdGhyb3dzIHRyYW5zaWVudCB2b2xhdGlsZSIsNToiY2xhc3MgZW51bSBleHRlbmRzIHN1cGVyIGNvbnN0IGV4cG9ydCBpbXBvcnQiLDY6ImVudW0iLHN0cmljdDoiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZCIsc3RyaWN0QmluZDoiZXZhbCBhcmd1bWVudHMifSxhYT0iYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzIixjZj17NTphYSwiNW1vZHVsZSI6YWErIiBleHBvcnQgaW1wb3J0Iiw2OmFhKyIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyIn0scGY9L15pbihzdGFuY2VvZik/JC8sZGY9bmV3IFJlZ0V4cCgiWyIrSWwrIl0iKSxmZj1uZXcgUmVnRXhwKCJbIitJbCsi4oCM4oCNwrfMgC3Nr86H0oMt0ofWkS3Wvda/14HXgteE14XXh9iQLdia2Yst2anZsNuWLduc258t26Tbp9uo26ot263bsC3budyR3LAt3Yrepi3esN+ALd+J36st37PfveCgli3goJngoJst4KCj4KClLeCgp+CgqS3goK3goZkt4KGb4KKYLeCin+Cjii3go6Hgo6Mt4KSD4KS6LeCkvOCkvi3gpY/gpZEt4KWX4KWi4KWj4KWmLeClr+CmgS3gpoPgprzgpr4t4KeE4KeH4KeI4KeLLeCnjeCnl+CnouCno+Cnpi3gp6/gp77gqIEt4KiD4Ki84Ki+LeCpguCph+CpiOCpiy3gqY3gqZHgqaYt4Kmx4Km14KqBLeCqg+CqvOCqvi3gq4Xgq4ct4KuJ4KuLLeCrjeCrouCro+Crpi3gq6/gq7ot4Ku/4KyBLeCsg+CsvOCsvi3grYTgrYfgrYjgrYst4K2N4K2VLeCtl+CtouCto+Ctpi3gra/groLgrr4t4K+C4K+GLeCviOCvii3gr43gr5fgr6Yt4K+v4LCALeCwhOCwvOCwvi3gsYTgsYYt4LGI4LGKLeCxjeCxleCxluCxouCxo+Cxpi3gsa/gsoEt4LKD4LK84LK+LeCzhOCzhi3gs4jgs4ot4LON4LOV4LOW4LOi4LOj4LOmLeCzr+Czs+C0gC3gtIPgtLvgtLzgtL4t4LWE4LWGLeC1iOC1ii3gtY3gtZfgtaLgtaPgtaYt4LWv4LaBLeC2g+C3iuC3jy3gt5Tgt5bgt5gt4Lef4LemLeC3r+C3suC3s+C4seC4tC3guLrguYct4LmO4LmQLeC5meC6seC6tC3gurzgu4gt4LuO4LuQLeC7meC8mOC8meC8oC3gvKngvLXgvLfgvLngvL7gvL/gvbEt4L6E4L6G4L6H4L6NLeC+l+C+mS3gvrzgv4bhgKst4YC+4YGALeGBieGBli3hgZnhgZ4t4YGg4YGiLeGBpOGBpy3hga3hgbEt4YG04YKCLeGCjeGCjy3hgp3hjZ0t4Y2f4Y2pLeGNseGcki3hnJXhnLIt4Zy04Z2S4Z2T4Z2y4Z2z4Z60LeGfk+GfneGfoC3hn6nhoIst4aCN4aCPLeGgmeGiqeGkoC3hpKvhpLAt4aS74aWGLeGlj+GnkC3hp5rhqJct4aib4amVLeGpnuGpoC3hqbzhqb8t4aqJ4aqQLeGqmeGqsC3hqr3hqr8t4auO4ayALeGshOGstC3hrYThrZAt4a2Z4a2rLeGts+GugC3hroLhrqEt4a6t4a6wLeGuueGvpi3hr7PhsKQt4bC34bGALeGxieGxkC3hsZnhs5At4bOS4bOULeGzqOGzreGztOGzty3hs7nht4At4be/4oC/4oGA4oGU4oOQLeKDnOKDoeKDpS3ig7Dis68t4rOx4rW/4regLeK3v+OAqi3jgK/jgpnjgprqmKAt6pip6pmv6pm0LeqZveqanuqan+qbsOqbseqgguqghuqgi+qgoy3qoKfqoKzqooDqooHqorQt6qOF6qOQLeqjmeqjoC3qo7Hqo78t6qSJ6qSmLeqkreqlhy3qpZPqpoAt6qaD6qazLeqngOqnkC3qp5nqp6Xqp7At6qe56qipLeqotuqpg+qpjOqpjeqpkC3qqZnqqbst6qm96qqw6qqyLeqqtOqqt+qquOqqvuqqv+qrgeqrqy3qq6/qq7Xqq7bqr6Mt6q+q6q+s6q+t6q+wLeqvue+snu+4gC3vuI/vuKAt77iv77iz77i077mNLe+5j++8kC3vvJnvvL9dIik7ZnVuY3Rpb24gb2EoZSx0KXtmb3IodmFyIGk9NjU1MzYscz0wO3M8dC5sZW5ndGg7cys9Mil7aWYoKGkrPXRbc10pPmUpcmV0dXJuITE7aWYoKGkrPXRbcysxXSk+PWUpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gYnQoZSx0KXtyZXR1cm4gZTw2NT9lPT09MzY6ZTw5MXx8KGU8OTc/ZT09PTk1OmU8MTIzfHwoZTw9NjU1MzU/ZT49MTcwJiZkZi50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpOnQhPT0hMSYmb2EoZSxDbCkpKX1mdW5jdGlvbiBmaShlLHQpe3JldHVybiBlPDQ4P2U9PT0zNjplPDU4fHwhKGU8NjUpJiYoZTw5MXx8KGU8OTc/ZT09PTk1OmU8MTIzfHwoZTw9NjU1MzU/ZT49MTcwJiZmZi50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpOnQhPT0hMSYmKG9hKGUsQ2wpfHxvYShlLHVmKSkpKSl9dmFyIG5lPWZ1bmN0aW9uKGUsdCl7dD09PXZvaWQgMCYmKHQ9e30pLHRoaXMubGFiZWw9ZSx0aGlzLmtleXdvcmQ9dC5rZXl3b3JkLHRoaXMuYmVmb3JlRXhwcj0hIXQuYmVmb3JlRXhwcix0aGlzLnN0YXJ0c0V4cHI9ISF0LnN0YXJ0c0V4cHIsdGhpcy5pc0xvb3A9ISF0LmlzTG9vcCx0aGlzLmlzQXNzaWduPSEhdC5pc0Fzc2lnbix0aGlzLnByZWZpeD0hIXQucHJlZml4LHRoaXMucG9zdGZpeD0hIXQucG9zdGZpeCx0aGlzLmJpbm9wPXQuYmlub3B8fG51bGwsdGhpcy51cGRhdGVDb250ZXh0PW51bGx9O2Z1bmN0aW9uIFhlKGUsdCl7cmV0dXJuIG5ldyBuZShlLHtiZWZvcmVFeHByOiEwLGJpbm9wOnR9KX12YXIgWmU9e2JlZm9yZUV4cHI6ITB9LHplPXtzdGFydHNFeHByOiEwfSx2bj17fTtmdW5jdGlvbiBpZShlLHQpe3JldHVybiB0PT09dm9pZCAwJiYodD17fSksdC5rZXl3b3JkPWUsdm5bZV09bmV3IG5lKGUsdCl9dmFyIGY9e251bTpuZXcgbmUoIm51bSIsemUpLHJlZ2V4cDpuZXcgbmUoInJlZ2V4cCIsemUpLHN0cmluZzpuZXcgbmUoInN0cmluZyIsemUpLG5hbWU6bmV3IG5lKCJuYW1lIix6ZSkscHJpdmF0ZUlkOm5ldyBuZSgicHJpdmF0ZUlkIix6ZSksZW9mOm5ldyBuZSgiZW9mIiksYnJhY2tldEw6bmV3IG5lKCJbIix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSksYnJhY2tldFI6bmV3IG5lKCJdIiksYnJhY2VMOm5ldyBuZSgieyIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGJyYWNlUjpuZXcgbmUoIn0iKSxwYXJlbkw6bmV3IG5lKCIoIix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSkscGFyZW5SOm5ldyBuZSgiKSIpLGNvbW1hOm5ldyBuZSgiLCIsWmUpLHNlbWk6bmV3IG5lKCI7IixaZSksY29sb246bmV3IG5lKCI6IixaZSksZG90Om5ldyBuZSgiLiIpLHF1ZXN0aW9uOm5ldyBuZSgiPyIsWmUpLHF1ZXN0aW9uRG90Om5ldyBuZSgiPy4iKSxhcnJvdzpuZXcgbmUoIj0+IixaZSksdGVtcGxhdGU6bmV3IG5lKCJ0ZW1wbGF0ZSIpLGludmFsaWRUZW1wbGF0ZTpuZXcgbmUoImludmFsaWRUZW1wbGF0ZSIpLGVsbGlwc2lzOm5ldyBuZSgiLi4uIixaZSksYmFja1F1b3RlOm5ldyBuZSgiYCIsemUpLGRvbGxhckJyYWNlTDpuZXcgbmUoIiR7Iix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSksZXE6bmV3IG5lKCI9Iix7YmVmb3JlRXhwcjohMCxpc0Fzc2lnbjohMH0pLGFzc2lnbjpuZXcgbmUoIl89Iix7YmVmb3JlRXhwcjohMCxpc0Fzc2lnbjohMH0pLGluY0RlYzpuZXcgbmUoIisrLy0tIix7cHJlZml4OiEwLHBvc3RmaXg6ITAsc3RhcnRzRXhwcjohMH0pLHByZWZpeDpuZXcgbmUoIiEvfiIse2JlZm9yZUV4cHI6ITAscHJlZml4OiEwLHN0YXJ0c0V4cHI6ITB9KSxsb2dpY2FsT1I6WGUoInx8IiwxKSxsb2dpY2FsQU5EOlhlKCImJiIsMiksYml0d2lzZU9SOlhlKCJ8IiwzKSxiaXR3aXNlWE9SOlhlKCJeIiw0KSxiaXR3aXNlQU5EOlhlKCImIiw1KSxlcXVhbGl0eTpYZSgiPT0vIT0vPT09LyE9PSIsNikscmVsYXRpb25hbDpYZSgiPC8+Lzw9Lz49Iiw3KSxiaXRTaGlmdDpYZSgiPDwvPj4vPj4+Iiw4KSxwbHVzTWluOm5ldyBuZSgiKy8tIix7YmVmb3JlRXhwcjohMCxiaW5vcDo5LHByZWZpeDohMCxzdGFydHNFeHByOiEwfSksbW9kdWxvOlhlKCIlIiwxMCksc3RhcjpYZSgiKiIsMTApLHNsYXNoOlhlKCIvIiwxMCksc3RhcnN0YXI6bmV3IG5lKCIqKiIse2JlZm9yZUV4cHI6ITB9KSxjb2FsZXNjZTpYZSgiPz8iLDEpLF9icmVhazppZSgiYnJlYWsiKSxfY2FzZTppZSgiY2FzZSIsWmUpLF9jYXRjaDppZSgiY2F0Y2giKSxfY29udGludWU6aWUoImNvbnRpbnVlIiksX2RlYnVnZ2VyOmllKCJkZWJ1Z2dlciIpLF9kZWZhdWx0OmllKCJkZWZhdWx0IixaZSksX2RvOmllKCJkbyIse2lzTG9vcDohMCxiZWZvcmVFeHByOiEwfSksX2Vsc2U6aWUoImVsc2UiLFplKSxfZmluYWxseTppZSgiZmluYWxseSIpLF9mb3I6aWUoImZvciIse2lzTG9vcDohMH0pLF9mdW5jdGlvbjppZSgiZnVuY3Rpb24iLHplKSxfaWY6aWUoImlmIiksX3JldHVybjppZSgicmV0dXJuIixaZSksX3N3aXRjaDppZSgic3dpdGNoIiksX3Rocm93OmllKCJ0aHJvdyIsWmUpLF90cnk6aWUoInRyeSIpLF92YXI6aWUoInZhciIpLF9jb25zdDppZSgiY29uc3QiKSxfd2hpbGU6aWUoIndoaWxlIix7aXNMb29wOiEwfSksX3dpdGg6aWUoIndpdGgiKSxfbmV3OmllKCJuZXciLHtiZWZvcmVFeHByOiEwLHN0YXJ0c0V4cHI6ITB9KSxfdGhpczppZSgidGhpcyIsemUpLF9zdXBlcjppZSgic3VwZXIiLHplKSxfY2xhc3M6aWUoImNsYXNzIix6ZSksX2V4dGVuZHM6aWUoImV4dGVuZHMiLFplKSxfZXhwb3J0OmllKCJleHBvcnQiKSxfaW1wb3J0OmllKCJpbXBvcnQiLHplKSxfbnVsbDppZSgibnVsbCIsemUpLF90cnVlOmllKCJ0cnVlIix6ZSksX2ZhbHNlOmllKCJmYWxzZSIsemUpLF9pbjppZSgiaW4iLHtiZWZvcmVFeHByOiEwLGJpbm9wOjd9KSxfaW5zdGFuY2VvZjppZSgiaW5zdGFuY2VvZiIse2JlZm9yZUV4cHI6ITAsYmlub3A6N30pLF90eXBlb2Y6aWUoInR5cGVvZiIse2JlZm9yZUV4cHI6ITAscHJlZml4OiEwLHN0YXJ0c0V4cHI6ITB9KSxfdm9pZDppZSgidm9pZCIse2JlZm9yZUV4cHI6ITAscHJlZml4OiEwLHN0YXJ0c0V4cHI6ITB9KSxfZGVsZXRlOmllKCJkZWxldGUiLHtiZWZvcmVFeHByOiEwLHByZWZpeDohMCxzdGFydHNFeHByOiEwfSl9LEtlPS9cclxuP3xcbnxcdTIwMjh8XHUyMDI5LyxQbD1uZXcgUmVnRXhwKEtlLnNvdXJjZSwiZyIpO2Z1bmN0aW9uIG1pKGUpe3JldHVybiBlPT09MTB8fGU9PT0xM3x8ZT09PTgyMzJ8fGU9PT04MjMzfWZ1bmN0aW9uIF9sKGUsdCxpKXtpPT09dm9pZCAwJiYoaT1lLmxlbmd0aCk7Zm9yKHZhciBzPXQ7czxpO3MrKyl7dmFyIG49ZS5jaGFyQ29kZUF0KHMpO2lmKG1pKG4pKXJldHVybiBzPGktMSYmbj09PTEzJiZlLmNoYXJDb2RlQXQocysxKT09PTEwP3MrMjpzKzF9cmV0dXJuLTF9dmFyIGhhPS9bXHUxNjgwXHUyMDAwLVx1MjAwYVx1MjAyZlx1MjA1Zlx1MzAwMFx1ZmVmZl0vLEplPS8oPzpcc3xcL1wvLip8XC9cKlteXSo/XCpcLykqL2csTmw9T2JqZWN0LnByb3RvdHlwZSxtZj1ObC5oYXNPd25Qcm9wZXJ0eSxnZj1ObC50b1N0cmluZyxncz1PYmplY3QuaGFzT3dufHxmdW5jdGlvbihlLHQpe3JldHVybiBtZi5jYWxsKGUsdCl9LCRsPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGUpe3JldHVybiBnZi5jYWxsKGUpPT09IltvYmplY3QgQXJyYXldIn07ZnVuY3Rpb24gcXQoZSl7cmV0dXJuIG5ldyBSZWdFeHAoIl4oPzoiK2UucmVwbGFjZSgvIC9nLCJ8IikrIikkIil9ZnVuY3Rpb24gSHQoZSl7cmV0dXJuIGU8PTY1NTM1P1N0cmluZy5mcm9tQ2hhckNvZGUoZSk6KGUtPTY1NTM2LFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYrKGU+PjEwKSw1NjMyMCsoMTAyMyZlKSkpfXZhciB5Zj0vKD86W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS8sT2k9ZnVuY3Rpb24oZSx0KXt0aGlzLmxpbmU9ZSx0aGlzLmNvbHVtbj10fTtPaS5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgT2kodGhpcy5saW5lLHRoaXMuY29sdW1uK2UpfTt2YXIgeXM9ZnVuY3Rpb24oZSx0LGkpe3RoaXMuc3RhcnQ9dCx0aGlzLmVuZD1pLGUuc291cmNlRmlsZSE9PW51bGwmJih0aGlzLnNvdXJjZT1lLnNvdXJjZUZpbGUpfTtmdW5jdGlvbiBsYShlLHQpe2Zvcih2YXIgaT0xLHM9MDs7KXt2YXIgbj1fbChlLHMsdCk7aWYobjwwKXJldHVybiBuZXcgT2koaSx0LXMpOysraSxzPW59fXZhciBFbj17ZWNtYVZlcnNpb246bnVsbCxzb3VyY2VUeXBlOiJzY3JpcHQiLG9uSW5zZXJ0ZWRTZW1pY29sb246bnVsbCxvblRyYWlsaW5nQ29tbWE6bnVsbCxhbGxvd1Jlc2VydmVkOm51bGwsYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246ITEsYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiExLGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246bnVsbCxhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDpudWxsLGFsbG93SGFzaEJhbmc6ITEsY2hlY2tQcml2YXRlRmllbGRzOiEwLGxvY2F0aW9uczohMSxvblRva2VuOm51bGwsb25Db21tZW50Om51bGwscmFuZ2VzOiExLHByb2dyYW06bnVsbCxzb3VyY2VGaWxlOm51bGwsZGlyZWN0U291cmNlRmlsZTpudWxsLHByZXNlcnZlUGFyZW5zOiExfSxMbD0hMTtmdW5jdGlvbiB4ZihlKXt2YXIgdD17fTtmb3IodmFyIGkgaW4gRW4pdFtpXT1lJiZncyhlLGkpP2VbaV06RW5baV07aWYodC5lY21hVmVyc2lvbj09PSJsYXRlc3QiP3QuZWNtYVZlcnNpb249MWU4OnQuZWNtYVZlcnNpb249PW51bGw/KCFMbCYmdHlwZW9mIGNvbnNvbGU9PSJvYmplY3QiJiZjb25zb2xlLndhcm4mJihMbD0hMCxjb25zb2xlLndhcm4oYFNpbmNlIEFjb3JuIDguMC4wLCBvcHRpb25zLmVjbWFWZXJzaW9uIGlzIHJlcXVpcmVkLgpEZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuYCkpLHQuZWNtYVZlcnNpb249MTEpOnQuZWNtYVZlcnNpb24+PTIwMTUmJih0LmVjbWFWZXJzaW9uLT0yMDA5KSx0LmFsbG93UmVzZXJ2ZWQ9PW51bGwmJih0LmFsbG93UmVzZXJ2ZWQ9dC5lY21hVmVyc2lvbjw1KSxlJiZlLmFsbG93SGFzaEJhbmchPW51bGx8fCh0LmFsbG93SGFzaEJhbmc9dC5lY21hVmVyc2lvbj49MTQpLCRsKHQub25Ub2tlbikpe3ZhciBzPXQub25Ub2tlbjt0Lm9uVG9rZW49ZnVuY3Rpb24obil7cmV0dXJuIHMucHVzaChuKX19cmV0dXJuICRsKHQub25Db21tZW50KSYmKHQub25Db21tZW50PWZ1bmN0aW9uKG4scil7cmV0dXJuIGZ1bmN0aW9uKGEsbyxoLGwsYyxwKXt2YXIgbT17dHlwZTphPyJCbG9jayI6IkxpbmUiLHZhbHVlOm8sc3RhcnQ6aCxlbmQ6bH07bi5sb2NhdGlvbnMmJihtLmxvYz1uZXcgeXModGhpcyxjLHApKSxuLnJhbmdlcyYmKG0ucmFuZ2U9W2gsbF0pLHIucHVzaChtKX19KHQsdC5vbkNvbW1lbnQpKSx0fXZhciBUbD0yNTY7ZnVuY3Rpb24gdWEoZSx0KXtyZXR1cm4gMnwoZT80OjApfCh0Pzg6MCl9dmFyIGdlPWZ1bmN0aW9uKGUsdCxpKXt0aGlzLm9wdGlvbnM9ZT14ZihlKSx0aGlzLnNvdXJjZUZpbGU9ZS5zb3VyY2VGaWxlLHRoaXMua2V5d29yZHM9cXQoY2ZbZS5lY21hVmVyc2lvbj49Nj82OmUuc291cmNlVHlwZT09PSJtb2R1bGUiPyI1bW9kdWxlIjo1XSk7dmFyIHM9IiI7ZS5hbGxvd1Jlc2VydmVkIT09ITAmJihzPXJhW2UuZWNtYVZlcnNpb24+PTY/NjplLmVjbWFWZXJzaW9uPT09NT81OjNdLGUuc291cmNlVHlwZT09PSJtb2R1bGUiJiYocys9IiBhd2FpdCIpKSx0aGlzLnJlc2VydmVkV29yZHM9cXQocyk7dmFyIG49KHM/cysiICI6IiIpK3JhLnN0cmljdDt0aGlzLnJlc2VydmVkV29yZHNTdHJpY3Q9cXQobiksdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZD1xdChuKyIgIityYS5zdHJpY3RCaW5kKSx0aGlzLmlucHV0PVN0cmluZyh0KSx0aGlzLmNvbnRhaW5zRXNjPSExLGk/KHRoaXMucG9zPWksdGhpcy5saW5lU3RhcnQ9dGhpcy5pbnB1dC5sYXN0SW5kZXhPZihgCmAsaS0xKSsxLHRoaXMuY3VyTGluZT10aGlzLmlucHV0LnNsaWNlKDAsdGhpcy5saW5lU3RhcnQpLnNwbGl0KEtlKS5sZW5ndGgpOih0aGlzLnBvcz10aGlzLmxpbmVTdGFydD0wLHRoaXMuY3VyTGluZT0xKSx0aGlzLnR5cGU9Zi5lb2YsdGhpcy52YWx1ZT1udWxsLHRoaXMuc3RhcnQ9dGhpcy5lbmQ9dGhpcy5wb3MsdGhpcy5zdGFydExvYz10aGlzLmVuZExvYz10aGlzLmN1clBvc2l0aW9uKCksdGhpcy5sYXN0VG9rRW5kTG9jPXRoaXMubGFzdFRva1N0YXJ0TG9jPW51bGwsdGhpcy5sYXN0VG9rU3RhcnQ9dGhpcy5sYXN0VG9rRW5kPXRoaXMucG9zLHRoaXMuY29udGV4dD10aGlzLmluaXRpYWxDb250ZXh0KCksdGhpcy5leHByQWxsb3dlZD0hMCx0aGlzLmluTW9kdWxlPWUuc291cmNlVHlwZT09PSJtb2R1bGUiLHRoaXMuc3RyaWN0PXRoaXMuaW5Nb2R1bGV8fHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKSx0aGlzLnBvdGVudGlhbEFycm93QXQ9LTEsdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQ9ITEsdGhpcy55aWVsZFBvcz10aGlzLmF3YWl0UG9zPXRoaXMuYXdhaXRJZGVudFBvcz0wLHRoaXMubGFiZWxzPVtdLHRoaXMudW5kZWZpbmVkRXhwb3J0cz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMucG9zPT09MCYmZS5hbGxvd0hhc2hCYW5nJiZ0aGlzLmlucHV0LnNsaWNlKDAsMik9PT0iIyEiJiZ0aGlzLnNraXBMaW5lQ29tbWVudCgyKSx0aGlzLnNjb3BlU3RhY2s9W10sdGhpcy5lbnRlclNjb3BlKDEpLHRoaXMucmVnZXhwU3RhdGU9bnVsbCx0aGlzLnByaXZhdGVOYW1lU3RhY2s9W119LHZ0PXtpbkZ1bmN0aW9uOntjb25maWd1cmFibGU6ITB9LGluR2VuZXJhdG9yOntjb25maWd1cmFibGU6ITB9LGluQXN5bmM6e2NvbmZpZ3VyYWJsZTohMH0sY2FuQXdhaXQ6e2NvbmZpZ3VyYWJsZTohMH0sYWxsb3dTdXBlcjp7Y29uZmlndXJhYmxlOiEwfSxhbGxvd0RpcmVjdFN1cGVyOntjb25maWd1cmFibGU6ITB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6e2NvbmZpZ3VyYWJsZTohMH0sYWxsb3dOZXdEb3RUYXJnZXQ6e2NvbmZpZ3VyYWJsZTohMH0saW5DbGFzc1N0YXRpY0Jsb2NrOntjb25maWd1cmFibGU6ITB9fTtnZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnMucHJvZ3JhbXx8dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0VG9rZW4oKSx0aGlzLnBhcnNlVG9wTGV2ZWwoZSl9LHZ0LmluRnVuY3Rpb24uZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuKDImdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyk+MH0sdnQuaW5HZW5lcmF0b3IuZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuKDgmdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyk+MCYmIXRoaXMuY3VycmVudFZhclNjb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdH0sdnQuaW5Bc3luYy5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4oNCZ0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzKT4wJiYhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0fSx2dC5jYW5Bd2FpdC5nZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xO2U+PTA7ZS0tKXt2YXIgdD10aGlzLnNjb3BlU3RhY2tbZV07aWYodC5pbkNsYXNzRmllbGRJbml0fHx0LmZsYWdzJlRsKXJldHVybiExO2lmKDImdC5mbGFncylyZXR1cm4oNCZ0LmZsYWdzKT4wfXJldHVybiB0aGlzLmluTW9kdWxlJiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTEzfHx0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbn0sdnQuYWxsb3dTdXBlci5nZXQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmN1cnJlbnRUaGlzU2NvcGUoKSx0PWUuZmxhZ3MsaT1lLmluQ2xhc3NGaWVsZEluaXQ7cmV0dXJuKDY0JnQpPjB8fGl8fHRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZH0sdnQuYWxsb3dEaXJlY3RTdXBlci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4oMTI4JnRoaXMuY3VycmVudFRoaXNTY29wZSgpLmZsYWdzKT4wfSx2dC50cmVhdEZ1bmN0aW9uc0FzVmFyLmdldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKHRoaXMuY3VycmVudFNjb3BlKCkpfSx2dC5hbGxvd05ld0RvdFRhcmdldC5nZXQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmN1cnJlbnRUaGlzU2NvcGUoKSx0PWUuZmxhZ3MsaT1lLmluQ2xhc3NGaWVsZEluaXQ7cmV0dXJuKDI1OCZ0KT4wfHxpfSx2dC5pbkNsYXNzU3RhdGljQmxvY2suZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MmVGwpPjB9LGdlLmV4dGVuZD1mdW5jdGlvbigpe2Zvcih2YXIgZT1bXSx0PWFyZ3VtZW50cy5sZW5ndGg7dC0tOyllW3RdPWFyZ3VtZW50c1t0XTtmb3IodmFyIGk9dGhpcyxzPTA7czxlLmxlbmd0aDtzKyspaT1lW3NdKGkpO3JldHVybiBpfSxnZS5wYXJzZT1mdW5jdGlvbihlLHQpe3JldHVybiBuZXcgdGhpcyh0LGUpLnBhcnNlKCl9LGdlLnBhcnNlRXhwcmVzc2lvbkF0PWZ1bmN0aW9uKGUsdCxpKXt2YXIgcz1uZXcgdGhpcyhpLGUsdCk7cmV0dXJuIHMubmV4dFRva2VuKCkscy5wYXJzZUV4cHJlc3Npb24oKX0sZ2UudG9rZW5pemVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyB0aGlzKHQsZSl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdlLnByb3RvdHlwZSx2dCk7dmFyIE9lPWdlLnByb3RvdHlwZSxiZj0vXig/OicoKD86XFwufFteJ1xcXSkqPyknfCIoKD86XFwufFteIlxcXSkqPykiKS87T2Uuc3RyaWN0RGlyZWN0aXZlPWZ1bmN0aW9uKGUpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjw1KXJldHVybiExO2Zvcig7Oyl7SmUubGFzdEluZGV4PWUsZSs9SmUuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGg7dmFyIHQ9YmYuZXhlYyh0aGlzLmlucHV0LnNsaWNlKGUpKTtpZighdClyZXR1cm4hMTtpZigodFsxXXx8dFsyXSk9PT0idXNlIHN0cmljdCIpe0plLmxhc3RJbmRleD1lK3RbMF0ubGVuZ3RoO3ZhciBpPUplLmV4ZWModGhpcy5pbnB1dCkscz1pLmluZGV4K2lbMF0ubGVuZ3RoLG49dGhpcy5pbnB1dC5jaGFyQXQocyk7cmV0dXJuIG49PT0iOyJ8fG49PT0ifSJ8fEtlLnRlc3QoaVswXSkmJiEoL1soYC5bK1wtLyolPD49LD9eJl0vLnRlc3Qobil8fG49PT0iISImJnRoaXMuaW5wdXQuY2hhckF0KHMrMSk9PT0iPSIpfWUrPXRbMF0ubGVuZ3RoLEplLmxhc3RJbmRleD1lLGUrPUplLmV4ZWModGhpcy5pbnB1dClbMF0ubGVuZ3RoLHRoaXMuaW5wdXRbZV09PT0iOyImJmUrK319LE9lLmVhdD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50eXBlPT09ZSYmKHRoaXMubmV4dCgpLCEwKX0sT2UuaXNDb250ZXh0dWFsPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnR5cGU9PT1mLm5hbWUmJnRoaXMudmFsdWU9PT1lJiYhdGhpcy5jb250YWluc0VzY30sT2UuZWF0Q29udGV4dHVhbD1mdW5jdGlvbihlKXtyZXR1cm4hIXRoaXMuaXNDb250ZXh0dWFsKGUpJiYodGhpcy5uZXh0KCksITApfSxPZS5leHBlY3RDb250ZXh0dWFsPWZ1bmN0aW9uKGUpe3RoaXMuZWF0Q29udGV4dHVhbChlKXx8dGhpcy51bmV4cGVjdGVkKCl9LE9lLmNhbkluc2VydFNlbWljb2xvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR5cGU9PT1mLmVvZnx8dGhpcy50eXBlPT09Zi5icmFjZVJ8fEtlLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsdGhpcy5zdGFydCkpfSxPZS5pbnNlcnRTZW1pY29sb249ZnVuY3Rpb24oKXtpZih0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKXJldHVybiB0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbiYmdGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24odGhpcy5sYXN0VG9rRW5kLHRoaXMubGFzdFRva0VuZExvYyksITB9LE9lLnNlbWljb2xvbj1mdW5jdGlvbigpe3RoaXMuZWF0KGYuc2VtaSl8fHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCl8fHRoaXMudW5leHBlY3RlZCgpfSxPZS5hZnRlclRyYWlsaW5nQ29tbWE9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLnR5cGU9PT1lKXJldHVybiB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hJiZ0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LHRoaXMubGFzdFRva1N0YXJ0TG9jKSx0fHx0aGlzLm5leHQoKSwhMH0sT2UuZXhwZWN0PWZ1bmN0aW9uKGUpe3RoaXMuZWF0KGUpfHx0aGlzLnVuZXhwZWN0ZWQoKX0sT2UudW5leHBlY3RlZD1mdW5jdGlvbihlKXt0aGlzLnJhaXNlKGU/P3RoaXMuc3RhcnQsIlVuZXhwZWN0ZWQgdG9rZW4iKX07dmFyIFNuPWZ1bmN0aW9uKCl7dGhpcy5zaG9ydGhhbmRBc3NpZ249dGhpcy50cmFpbGluZ0NvbW1hPXRoaXMucGFyZW50aGVzaXplZEFzc2lnbj10aGlzLnBhcmVudGhlc2l6ZWRCaW5kPXRoaXMuZG91YmxlUHJvdG89LTF9O09lLmNoZWNrUGF0dGVybkVycm9ycz1mdW5jdGlvbihlLHQpe2lmKGUpe2UudHJhaWxpbmdDb21tYT4tMSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUudHJhaWxpbmdDb21tYSwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50Iik7dmFyIGk9dD9lLnBhcmVudGhlc2l6ZWRBc3NpZ246ZS5wYXJlbnRoZXNpemVkQmluZDtpPi0xJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoaSx0PyJBc3NpZ25pbmcgdG8gcnZhbHVlIjoiUGFyZW50aGVzaXplZCBwYXR0ZXJuIil9fSxPZS5jaGVja0V4cHJlc3Npb25FcnJvcnM9ZnVuY3Rpb24oZSx0KXtpZighZSlyZXR1cm4hMTt2YXIgaT1lLnNob3J0aGFuZEFzc2lnbixzPWUuZG91YmxlUHJvdG87aWYoIXQpcmV0dXJuIGk+PTB8fHM+PTA7aT49MCYmdGhpcy5yYWlzZShpLCJTaG9ydGhhbmQgcHJvcGVydHkgYXNzaWdubWVudHMgYXJlIHZhbGlkIG9ubHkgaW4gZGVzdHJ1Y3R1cmluZyBwYXR0ZXJucyIpLHM+PTAmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShzLCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5Iil9LE9lLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcz1mdW5jdGlvbigpe3RoaXMueWllbGRQb3MmJighdGhpcy5hd2FpdFBvc3x8dGhpcy55aWVsZFBvczx0aGlzLmF3YWl0UG9zKSYmdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCJZaWVsZCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWUiKSx0aGlzLmF3YWl0UG9zJiZ0aGlzLnJhaXNlKHRoaXMuYXdhaXRQb3MsIkF3YWl0IGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZSIpfSxPZS5pc1NpbXBsZUFzc2lnblRhcmdldD1mdW5jdGlvbihlKXtyZXR1cm4gZS50eXBlPT09IlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIj90aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KGUuZXhwcmVzc2lvbik6ZS50eXBlPT09IklkZW50aWZpZXIifHxlLnR5cGU9PT0iTWVtYmVyRXhwcmVzc2lvbiJ9O3ZhciBGPWdlLnByb3RvdHlwZTtGLnBhcnNlVG9wTGV2ZWw9ZnVuY3Rpb24oZSl7dmFyIHQ9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IoZS5ib2R5fHwoZS5ib2R5PVtdKTt0aGlzLnR5cGUhPT1mLmVvZjspe3ZhciBpPXRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCwhMCx0KTtlLmJvZHkucHVzaChpKX1pZih0aGlzLmluTW9kdWxlKWZvcih2YXIgcz0wLG49T2JqZWN0LmtleXModGhpcy51bmRlZmluZWRFeHBvcnRzKTtzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc107dGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMudW5kZWZpbmVkRXhwb3J0c1tyXS5zdGFydCwiRXhwb3J0ICciK3IrIicgaXMgbm90IGRlZmluZWQiKX1yZXR1cm4gdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKGUuYm9keSksdGhpcy5uZXh0KCksZS5zb3VyY2VUeXBlPXRoaXMub3B0aW9ucy5zb3VyY2VUeXBlLHRoaXMuZmluaXNoTm9kZShlLCJQcm9ncmFtIil9O3ZhciBjYT17a2luZDoibG9vcCJ9LHZmPXtraW5kOiJzd2l0Y2gifTtGLmlzTGV0PWZ1bmN0aW9uKGUpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjw2fHwhdGhpcy5pc0NvbnRleHR1YWwoImxldCIpKXJldHVybiExO0plLmxhc3RJbmRleD10aGlzLnBvczt2YXIgdD1KZS5leGVjKHRoaXMuaW5wdXQpLGk9dGhpcy5wb3MrdFswXS5sZW5ndGgscz10aGlzLmlucHV0LmNoYXJDb2RlQXQoaSk7aWYocz09PTkxfHxzPT09OTIpcmV0dXJuITA7aWYoZSlyZXR1cm4hMTtpZihzPT09MTIzfHxzPjU1Mjk1JiZzPDU2MzIwKXJldHVybiEwO2lmKGJ0KHMsITApKXtmb3IodmFyIG49aSsxO2ZpKHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KG4pLCEwKTspKytuO2lmKHM9PT05Mnx8cz41NTI5NSYmczw1NjMyMClyZXR1cm4hMDt2YXIgcj10aGlzLmlucHV0LnNsaWNlKGksbik7aWYoIXBmLnRlc3QocikpcmV0dXJuITB9cmV0dXJuITF9LEYuaXNBc3luY0Z1bmN0aW9uPWZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDh8fCF0aGlzLmlzQ29udGV4dHVhbCgiYXN5bmMiKSlyZXR1cm4hMTtKZS5sYXN0SW5kZXg9dGhpcy5wb3M7dmFyIGUsdD1KZS5leGVjKHRoaXMuaW5wdXQpLGk9dGhpcy5wb3MrdFswXS5sZW5ndGg7cmV0dXJuIShLZS50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsaSkpfHx0aGlzLmlucHV0LnNsaWNlKGksaSs4KSE9PSJmdW5jdGlvbiJ8fGkrOCE9PXRoaXMuaW5wdXQubGVuZ3RoJiYoZmkoZT10aGlzLmlucHV0LmNoYXJDb2RlQXQoaSs4KSl8fGU+NTUyOTUmJmU8NTYzMjApKX0sRi5wYXJzZVN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSl7dmFyIHMsbj10aGlzLnR5cGUscj10aGlzLnN0YXJ0Tm9kZSgpO3N3aXRjaCh0aGlzLmlzTGV0KGUpJiYobj1mLl92YXIscz0ibGV0Iiksbil7Y2FzZSBmLl9icmVhazpjYXNlIGYuX2NvbnRpbnVlOnJldHVybiB0aGlzLnBhcnNlQnJlYWtDb250aW51ZVN0YXRlbWVudChyLG4ua2V5d29yZCk7Y2FzZSBmLl9kZWJ1Z2dlcjpyZXR1cm4gdGhpcy5wYXJzZURlYnVnZ2VyU3RhdGVtZW50KHIpO2Nhc2UgZi5fZG86cmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChyKTtjYXNlIGYuX2ZvcjpyZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChyKTtjYXNlIGYuX2Z1bmN0aW9uOnJldHVybiBlJiYodGhpcy5zdHJpY3R8fGUhPT0iaWYiJiZlIT09ImxhYmVsIikmJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KHIsITEsIWUpO2Nhc2UgZi5fY2xhc3M6cmV0dXJuIGUmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMucGFyc2VDbGFzcyhyLCEwKTtjYXNlIGYuX2lmOnJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQocik7Y2FzZSBmLl9yZXR1cm46cmV0dXJuIHRoaXMucGFyc2VSZXR1cm5TdGF0ZW1lbnQocik7Y2FzZSBmLl9zd2l0Y2g6cmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQocik7Y2FzZSBmLl90aHJvdzpyZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KHIpO2Nhc2UgZi5fdHJ5OnJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KHIpO2Nhc2UgZi5fY29uc3Q6Y2FzZSBmLl92YXI6cmV0dXJuIHM9c3x8dGhpcy52YWx1ZSxlJiZzIT09InZhciImJnRoaXMudW5leHBlY3RlZCgpLHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQocixzKTtjYXNlIGYuX3doaWxlOnJldHVybiB0aGlzLnBhcnNlV2hpbGVTdGF0ZW1lbnQocik7Y2FzZSBmLl93aXRoOnJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChyKTtjYXNlIGYuYnJhY2VMOnJldHVybiB0aGlzLnBhcnNlQmxvY2soITAscik7Y2FzZSBmLnNlbWk6cmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChyKTtjYXNlIGYuX2V4cG9ydDpjYXNlIGYuX2ltcG9ydDppZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+MTAmJm49PT1mLl9pbXBvcnQpe0plLmxhc3RJbmRleD10aGlzLnBvczt2YXIgYT1KZS5leGVjKHRoaXMuaW5wdXQpLG89dGhpcy5wb3MrYVswXS5sZW5ndGgsaD10aGlzLmlucHV0LmNoYXJDb2RlQXQobyk7aWYoaD09PTQwfHxoPT09NDYpcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KHIsdGhpcy5wYXJzZUV4cHJlc3Npb24oKSl9cmV0dXJuIHRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmV8fCh0fHx0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbCIpLHRoaXMuaW5Nb2R1bGV8fHRoaXMucmFpc2UodGhpcy5zdGFydCwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnIikpLG49PT1mLl9pbXBvcnQ/dGhpcy5wYXJzZUltcG9ydChyKTp0aGlzLnBhcnNlRXhwb3J0KHIsaSk7ZGVmYXVsdDppZih0aGlzLmlzQXN5bmNGdW5jdGlvbigpKXJldHVybiBlJiZ0aGlzLnVuZXhwZWN0ZWQoKSx0aGlzLm5leHQoKSx0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQociwhMCwhZSk7dmFyIGw9dGhpcy52YWx1ZSxjPXRoaXMucGFyc2VFeHByZXNzaW9uKCk7cmV0dXJuIG49PT1mLm5hbWUmJmMudHlwZT09PSJJZGVudGlmaWVyIiYmdGhpcy5lYXQoZi5jb2xvbik/dGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQocixsLGMsZSk6dGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQocixjKX19LEYucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCl7dmFyIGk9dD09PSJicmVhayI7dGhpcy5uZXh0KCksdGhpcy5lYXQoZi5zZW1pKXx8dGhpcy5pbnNlcnRTZW1pY29sb24oKT9lLmxhYmVsPW51bGw6dGhpcy50eXBlIT09Zi5uYW1lP3RoaXMudW5leHBlY3RlZCgpOihlLmxhYmVsPXRoaXMucGFyc2VJZGVudCgpLHRoaXMuc2VtaWNvbG9uKCkpO2Zvcih2YXIgcz0wO3M8dGhpcy5sYWJlbHMubGVuZ3RoOysrcyl7dmFyIG49dGhpcy5sYWJlbHNbc107aWYoKGUubGFiZWw9PW51bGx8fG4ubmFtZT09PWUubGFiZWwubmFtZSkmJihuLmtpbmQhPW51bGwmJihpfHxuLmtpbmQ9PT0ibG9vcCIpfHxlLmxhYmVsJiZpKSlicmVha31yZXR1cm4gcz09PXRoaXMubGFiZWxzLmxlbmd0aCYmdGhpcy5yYWlzZShlLnN0YXJ0LCJVbnN5bnRhY3RpYyAiK3QpLHRoaXMuZmluaXNoTm9kZShlLGk/IkJyZWFrU3RhdGVtZW50IjoiQ29udGludWVTdGF0ZW1lbnQiKX0sRi5wYXJzZURlYnVnZ2VyU3RhdGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLCJEZWJ1Z2dlclN0YXRlbWVudCIpfSxGLnBhcnNlRG9TdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMubGFiZWxzLnB1c2goY2EpLGUuYm9keT10aGlzLnBhcnNlU3RhdGVtZW50KCJkbyIpLHRoaXMubGFiZWxzLnBvcCgpLHRoaXMuZXhwZWN0KGYuX3doaWxlKSxlLnRlc3Q9dGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49Nj90aGlzLmVhdChmLnNlbWkpOnRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkRvV2hpbGVTdGF0ZW1lbnQiKX0sRi5wYXJzZUZvclN0YXRlbWVudD1mdW5jdGlvbihlKXt0aGlzLm5leHQoKTt2YXIgdD10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJnRoaXMuY2FuQXdhaXQmJnRoaXMuZWF0Q29udGV4dHVhbCgiYXdhaXQiKT90aGlzLmxhc3RUb2tTdGFydDotMTtpZih0aGlzLmxhYmVscy5wdXNoKGNhKSx0aGlzLmVudGVyU2NvcGUoMCksdGhpcy5leHBlY3QoZi5wYXJlbkwpLHRoaXMudHlwZT09PWYuc2VtaSlyZXR1cm4gdD4tMSYmdGhpcy51bmV4cGVjdGVkKHQpLHRoaXMucGFyc2VGb3IoZSxudWxsKTt2YXIgaT10aGlzLmlzTGV0KCk7aWYodGhpcy50eXBlPT09Zi5fdmFyfHx0aGlzLnR5cGU9PT1mLl9jb25zdHx8aSl7dmFyIHM9dGhpcy5zdGFydE5vZGUoKSxuPWk/ImxldCI6dGhpcy52YWx1ZTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5wYXJzZVZhcihzLCEwLG4pLHRoaXMuZmluaXNoTm9kZShzLCJWYXJpYWJsZURlY2xhcmF0aW9uIiksKHRoaXMudHlwZT09PWYuX2lufHx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJnRoaXMuaXNDb250ZXh0dWFsKCJvZiIpKSYmcy5kZWNsYXJhdGlvbnMubGVuZ3RoPT09MT8odGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiYodGhpcy50eXBlPT09Zi5faW4/dD4tMSYmdGhpcy51bmV4cGVjdGVkKHQpOmUuYXdhaXQ9dD4tMSksdGhpcy5wYXJzZUZvckluKGUscykpOih0Pi0xJiZ0aGlzLnVuZXhwZWN0ZWQodCksdGhpcy5wYXJzZUZvcihlLHMpKX12YXIgcj10aGlzLmlzQ29udGV4dHVhbCgibGV0IiksYT0hMSxvPW5ldyBTbixoPXRoaXMucGFyc2VFeHByZXNzaW9uKCEodD4tMSl8fCJhd2FpdCIsbyk7cmV0dXJuIHRoaXMudHlwZT09PWYuX2lufHwoYT10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJnRoaXMuaXNDb250ZXh0dWFsKCJvZiIpKT8odGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiYodGhpcy50eXBlPT09Zi5faW4/dD4tMSYmdGhpcy51bmV4cGVjdGVkKHQpOmUuYXdhaXQ9dD4tMSksciYmYSYmdGhpcy5yYWlzZShoLnN0YXJ0LCJUaGUgbGVmdC1oYW5kIHNpZGUgb2YgYSBmb3Itb2YgbG9vcCBtYXkgbm90IHN0YXJ0IHdpdGggJ2xldCcuIiksdGhpcy50b0Fzc2lnbmFibGUoaCwhMSxvKSx0aGlzLmNoZWNrTFZhbFBhdHRlcm4oaCksdGhpcy5wYXJzZUZvckluKGUsaCkpOih0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhvLCEwKSx0Pi0xJiZ0aGlzLnVuZXhwZWN0ZWQodCksdGhpcy5wYXJzZUZvcihlLGgpKX0sRi5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5wYXJzZUZ1bmN0aW9uKGUseHN8KGk/MDpwYSksITEsdCl9LEYucGFyc2VJZlN0YXRlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksZS50ZXN0PXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKSxlLmNvbnNlcXVlbnQ9dGhpcy5wYXJzZVN0YXRlbWVudCgiaWYiKSxlLmFsdGVybmF0ZT10aGlzLmVhdChmLl9lbHNlKT90aGlzLnBhcnNlU3RhdGVtZW50KCJpZiIpOm51bGwsdGhpcy5maW5pc2hOb2RlKGUsIklmU3RhdGVtZW50Iil9LEYucGFyc2VSZXR1cm5TdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaW5GdW5jdGlvbnx8dGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9ufHx0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb24iKSx0aGlzLm5leHQoKSx0aGlzLmVhdChmLnNlbWkpfHx0aGlzLmluc2VydFNlbWljb2xvbigpP2UuYXJndW1lbnQ9bnVsbDooZS5hcmd1bWVudD10aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuc2VtaWNvbG9uKCkpLHRoaXMuZmluaXNoTm9kZShlLCJSZXR1cm5TdGF0ZW1lbnQiKX0sRi5wYXJzZVN3aXRjaFN0YXRlbWVudD1mdW5jdGlvbihlKXt2YXIgdDt0aGlzLm5leHQoKSxlLmRpc2NyaW1pbmFudD10aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCksZS5jYXNlcz1bXSx0aGlzLmV4cGVjdChmLmJyYWNlTCksdGhpcy5sYWJlbHMucHVzaCh2ZiksdGhpcy5lbnRlclNjb3BlKDApO2Zvcih2YXIgaT0hMTt0aGlzLnR5cGUhPT1mLmJyYWNlUjspaWYodGhpcy50eXBlPT09Zi5fY2FzZXx8dGhpcy50eXBlPT09Zi5fZGVmYXVsdCl7dmFyIHM9dGhpcy50eXBlPT09Zi5fY2FzZTt0JiZ0aGlzLmZpbmlzaE5vZGUodCwiU3dpdGNoQ2FzZSIpLGUuY2FzZXMucHVzaCh0PXRoaXMuc3RhcnROb2RlKCkpLHQuY29uc2VxdWVudD1bXSx0aGlzLm5leHQoKSxzP3QudGVzdD10aGlzLnBhcnNlRXhwcmVzc2lvbigpOihpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5sYXN0VG9rU3RhcnQsIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlcyIpLGk9ITAsdC50ZXN0PW51bGwpLHRoaXMuZXhwZWN0KGYuY29sb24pfWVsc2UgdHx8dGhpcy51bmV4cGVjdGVkKCksdC5jb25zZXF1ZW50LnB1c2godGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSk7cmV0dXJuIHRoaXMuZXhpdFNjb3BlKCksdCYmdGhpcy5maW5pc2hOb2RlKHQsIlN3aXRjaENhc2UiKSx0aGlzLm5leHQoKSx0aGlzLmxhYmVscy5wb3AoKSx0aGlzLmZpbmlzaE5vZGUoZSwiU3dpdGNoU3RhdGVtZW50Iil9LEYucGFyc2VUaHJvd1N0YXRlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksS2UudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCx0aGlzLnN0YXJ0KSkmJnRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3ciKSxlLmFyZ3VtZW50PXRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUoZSwiVGhyb3dTdGF0ZW1lbnQiKX07dmFyIEVmPVtdO0YucGFyc2VDYXRjaENsYXVzZVBhcmFtPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wYXJzZUJpbmRpbmdBdG9tKCksdD1lLnR5cGU9PT0iSWRlbnRpZmllciI7cmV0dXJuIHRoaXMuZW50ZXJTY29wZSh0PzMyOjApLHRoaXMuY2hlY2tMVmFsUGF0dGVybihlLHQ/NDoyKSx0aGlzLmV4cGVjdChmLnBhcmVuUiksZX0sRi5wYXJzZVRyeVN0YXRlbWVudD1mdW5jdGlvbihlKXtpZih0aGlzLm5leHQoKSxlLmJsb2NrPXRoaXMucGFyc2VCbG9jaygpLGUuaGFuZGxlcj1udWxsLHRoaXMudHlwZT09PWYuX2NhdGNoKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMubmV4dCgpLHRoaXMuZWF0KGYucGFyZW5MKT90LnBhcmFtPXRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk6KHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjwxMCYmdGhpcy51bmV4cGVjdGVkKCksdC5wYXJhbT1udWxsLHRoaXMuZW50ZXJTY29wZSgwKSksdC5ib2R5PXRoaXMucGFyc2VCbG9jayghMSksdGhpcy5leGl0U2NvcGUoKSxlLmhhbmRsZXI9dGhpcy5maW5pc2hOb2RlKHQsIkNhdGNoQ2xhdXNlIil9cmV0dXJuIGUuZmluYWxpemVyPXRoaXMuZWF0KGYuX2ZpbmFsbHkpP3RoaXMucGFyc2VCbG9jaygpOm51bGwsZS5oYW5kbGVyfHxlLmZpbmFsaXplcnx8dGhpcy5yYWlzZShlLnN0YXJ0LCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlIiksdGhpcy5maW5pc2hOb2RlKGUsIlRyeVN0YXRlbWVudCIpfSxGLnBhcnNlVmFyU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5wYXJzZVZhcihlLCExLHQsaSksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUoZSwiVmFyaWFibGVEZWNsYXJhdGlvbiIpfSxGLnBhcnNlV2hpbGVTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLGUudGVzdD10aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCksdGhpcy5sYWJlbHMucHVzaChjYSksZS5ib2R5PXRoaXMucGFyc2VTdGF0ZW1lbnQoIndoaWxlIiksdGhpcy5sYWJlbHMucG9wKCksdGhpcy5maW5pc2hOb2RlKGUsIldoaWxlU3RhdGVtZW50Iil9LEYucGFyc2VXaXRoU3RhdGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnN0cmljdCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCInd2l0aCcgaW4gc3RyaWN0IG1vZGUiKSx0aGlzLm5leHQoKSxlLm9iamVjdD10aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCksZS5ib2R5PXRoaXMucGFyc2VTdGF0ZW1lbnQoIndpdGgiKSx0aGlzLmZpbmlzaE5vZGUoZSwiV2l0aFN0YXRlbWVudCIpfSxGLnBhcnNlRW1wdHlTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZShlLCJFbXB0eVN0YXRlbWVudCIpfSxGLnBhcnNlTGFiZWxlZFN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSxzKXtmb3IodmFyIG49MCxyPXRoaXMubGFiZWxzO248ci5sZW5ndGg7bis9MSlyW25dLm5hbWU9PT10JiZ0aGlzLnJhaXNlKGkuc3RhcnQsIkxhYmVsICciK3QrIicgaXMgYWxyZWFkeSBkZWNsYXJlZCIpO2Zvcih2YXIgYT10aGlzLnR5cGUuaXNMb29wPyJsb29wIjp0aGlzLnR5cGU9PT1mLl9zd2l0Y2g/InN3aXRjaCI6bnVsbCxvPXRoaXMubGFiZWxzLmxlbmd0aC0xO28+PTA7by0tKXt2YXIgaD10aGlzLmxhYmVsc1tvXTtpZihoLnN0YXRlbWVudFN0YXJ0IT09ZS5zdGFydClicmVhaztoLnN0YXRlbWVudFN0YXJ0PXRoaXMuc3RhcnQsaC5raW5kPWF9cmV0dXJuIHRoaXMubGFiZWxzLnB1c2goe25hbWU6dCxraW5kOmEsc3RhdGVtZW50U3RhcnQ6dGhpcy5zdGFydH0pLGUuYm9keT10aGlzLnBhcnNlU3RhdGVtZW50KHM/cy5pbmRleE9mKCJsYWJlbCIpPT09LTE/cysibGFiZWwiOnM6ImxhYmVsIiksdGhpcy5sYWJlbHMucG9wKCksZS5sYWJlbD1pLHRoaXMuZmluaXNoTm9kZShlLCJMYWJlbGVkU3RhdGVtZW50Iil9LEYucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZXhwcmVzc2lvbj10LHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkV4cHJlc3Npb25TdGF0ZW1lbnQiKX0sRi5wYXJzZUJsb2NrPWZ1bmN0aW9uKGUsdCxpKXtmb3IoZT09PXZvaWQgMCYmKGU9ITApLHQ9PT12b2lkIDAmJih0PXRoaXMuc3RhcnROb2RlKCkpLHQuYm9keT1bXSx0aGlzLmV4cGVjdChmLmJyYWNlTCksZSYmdGhpcy5lbnRlclNjb3BlKDApO3RoaXMudHlwZSE9PWYuYnJhY2VSOyl7dmFyIHM9dGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTt0LmJvZHkucHVzaChzKX1yZXR1cm4gaSYmKHRoaXMuc3RyaWN0PSExKSx0aGlzLm5leHQoKSxlJiZ0aGlzLmV4aXRTY29wZSgpLHRoaXMuZmluaXNoTm9kZSh0LCJCbG9ja1N0YXRlbWVudCIpfSxGLnBhcnNlRm9yPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuaW5pdD10LHRoaXMuZXhwZWN0KGYuc2VtaSksZS50ZXN0PXRoaXMudHlwZT09PWYuc2VtaT9udWxsOnRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5leHBlY3QoZi5zZW1pKSxlLnVwZGF0ZT10aGlzLnR5cGU9PT1mLnBhcmVuUj9udWxsOnRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5leHBlY3QoZi5wYXJlblIpLGUuYm9keT10aGlzLnBhcnNlU3RhdGVtZW50KCJmb3IiKSx0aGlzLmV4aXRTY29wZSgpLHRoaXMubGFiZWxzLnBvcCgpLHRoaXMuZmluaXNoTm9kZShlLCJGb3JTdGF0ZW1lbnQiKX0sRi5wYXJzZUZvckluPWZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcy50eXBlPT09Zi5faW47cmV0dXJuIHRoaXMubmV4dCgpLHQudHlwZT09PSJWYXJpYWJsZURlY2xhcmF0aW9uIiYmdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCE9bnVsbCYmKCFpfHx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248OHx8dGhpcy5zdHJpY3R8fHQua2luZCE9PSJ2YXIifHx0LmRlY2xhcmF0aW9uc1swXS5pZC50eXBlIT09IklkZW50aWZpZXIiKSYmdGhpcy5yYWlzZSh0LnN0YXJ0LChpPyJmb3ItaW4iOiJmb3Itb2YiKSsiIGxvb3AgdmFyaWFibGUgZGVjbGFyYXRpb24gbWF5IG5vdCBoYXZlIGFuIGluaXRpYWxpemVyIiksZS5sZWZ0PXQsZS5yaWdodD1pP3RoaXMucGFyc2VFeHByZXNzaW9uKCk6dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdGhpcy5leHBlY3QoZi5wYXJlblIpLGUuYm9keT10aGlzLnBhcnNlU3RhdGVtZW50KCJmb3IiKSx0aGlzLmV4aXRTY29wZSgpLHRoaXMubGFiZWxzLnBvcCgpLHRoaXMuZmluaXNoTm9kZShlLGk/IkZvckluU3RhdGVtZW50IjoiRm9yT2ZTdGF0ZW1lbnQiKX0sRi5wYXJzZVZhcj1mdW5jdGlvbihlLHQsaSxzKXtmb3IoZS5kZWNsYXJhdGlvbnM9W10sZS5raW5kPWk7Oyl7dmFyIG49dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLnBhcnNlVmFySWQobixpKSx0aGlzLmVhdChmLmVxKT9uLmluaXQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKHQpOnN8fGkhPT0iY29uc3QifHx0aGlzLnR5cGU9PT1mLl9pbnx8dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiZ0aGlzLmlzQ29udGV4dHVhbCgib2YiKT9zfHxuLmlkLnR5cGU9PT0iSWRlbnRpZmllciJ8fHQmJih0aGlzLnR5cGU9PT1mLl9pbnx8dGhpcy5pc0NvbnRleHR1YWwoIm9mIikpP24uaW5pdD1udWxsOnRoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZSIpOnRoaXMudW5leHBlY3RlZCgpLGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKG4sIlZhcmlhYmxlRGVjbGFyYXRvciIpKSwhdGhpcy5lYXQoZi5jb21tYSkpYnJlYWt9cmV0dXJuIGV9LEYucGFyc2VWYXJJZD1mdW5jdGlvbihlLHQpe2UuaWQ9dGhpcy5wYXJzZUJpbmRpbmdBdG9tKCksdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGUuaWQsdD09PSJ2YXIiPzE6MiwhMSl9O3ZhciB4cz0xLHBhPTI7ZnVuY3Rpb24gU2YoZSx0KXt2YXIgaT10LmtleS5uYW1lLHM9ZVtpXSxuPSJ0cnVlIjtyZXR1cm4gdC50eXBlIT09Ik1ldGhvZERlZmluaXRpb24ifHx0LmtpbmQhPT0iZ2V0IiYmdC5raW5kIT09InNldCJ8fChuPSh0LnN0YXRpYz8icyI6ImkiKSt0LmtpbmQpLHM9PT0iaWdldCImJm49PT0iaXNldCJ8fHM9PT0iaXNldCImJm49PT0iaWdldCJ8fHM9PT0ic2dldCImJm49PT0ic3NldCJ8fHM9PT0ic3NldCImJm49PT0ic2dldCI/KGVbaV09InRydWUiLCExKTohIXN8fChlW2ldPW4sITEpfWZ1bmN0aW9uIGtuKGUsdCl7dmFyIGk9ZS5jb21wdXRlZCxzPWUua2V5O3JldHVybiFpJiYocy50eXBlPT09IklkZW50aWZpZXIiJiZzLm5hbWU9PT10fHxzLnR5cGU9PT0iTGl0ZXJhbCImJnMudmFsdWU9PT10KX1GLnBhcnNlRnVuY3Rpb249ZnVuY3Rpb24oZSx0LGkscyxuKXt0aGlzLmluaXRGdW5jdGlvbihlKSwodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05fHx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJiFzKSYmKHRoaXMudHlwZT09PWYuc3RhciYmdCZwYSYmdGhpcy51bmV4cGVjdGVkKCksZS5nZW5lcmF0b3I9dGhpcy5lYXQoZi5zdGFyKSksdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04JiYoZS5hc3luYz0hIXMpLHQmeHMmJihlLmlkPTQmdCYmdGhpcy50eXBlIT09Zi5uYW1lP251bGw6dGhpcy5wYXJzZUlkZW50KCksIWUuaWR8fHQmcGF8fHRoaXMuY2hlY2tMVmFsU2ltcGxlKGUuaWQsdGhpcy5zdHJpY3R8fGUuZ2VuZXJhdG9yfHxlLmFzeW5jP3RoaXMudHJlYXRGdW5jdGlvbnNBc1Zhcj8xOjI6MykpO3ZhciByPXRoaXMueWllbGRQb3MsYT10aGlzLmF3YWl0UG9zLG89dGhpcy5hd2FpdElkZW50UG9zO3JldHVybiB0aGlzLnlpZWxkUG9zPTAsdGhpcy5hd2FpdFBvcz0wLHRoaXMuYXdhaXRJZGVudFBvcz0wLHRoaXMuZW50ZXJTY29wZSh1YShlLmFzeW5jLGUuZ2VuZXJhdG9yKSksdCZ4c3x8KGUuaWQ9dGhpcy50eXBlPT09Zi5uYW1lP3RoaXMucGFyc2VJZGVudCgpOm51bGwpLHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhlKSx0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KGUsaSwhMSxuKSx0aGlzLnlpZWxkUG9zPXIsdGhpcy5hd2FpdFBvcz1hLHRoaXMuYXdhaXRJZGVudFBvcz1vLHRoaXMuZmluaXNoTm9kZShlLHQmeHM/IkZ1bmN0aW9uRGVjbGFyYXRpb24iOiJGdW5jdGlvbkV4cHJlc3Npb24iKX0sRi5wYXJzZUZ1bmN0aW9uUGFyYW1zPWZ1bmN0aW9uKGUpe3RoaXMuZXhwZWN0KGYucGFyZW5MKSxlLnBhcmFtcz10aGlzLnBhcnNlQmluZGluZ0xpc3QoZi5wYXJlblIsITEsdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04KSx0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpfSxGLnBhcnNlQ2xhc3M9ZnVuY3Rpb24oZSx0KXt0aGlzLm5leHQoKTt2YXIgaT10aGlzLnN0cmljdDt0aGlzLnN0cmljdD0hMCx0aGlzLnBhcnNlQ2xhc3NJZChlLHQpLHRoaXMucGFyc2VDbGFzc1N1cGVyKGUpO3ZhciBzPXRoaXMuZW50ZXJDbGFzc0JvZHkoKSxuPXRoaXMuc3RhcnROb2RlKCkscj0hMTtmb3Iobi5ib2R5PVtdLHRoaXMuZXhwZWN0KGYuYnJhY2VMKTt0aGlzLnR5cGUhPT1mLmJyYWNlUjspe3ZhciBhPXRoaXMucGFyc2VDbGFzc0VsZW1lbnQoZS5zdXBlckNsYXNzIT09bnVsbCk7YSYmKG4uYm9keS5wdXNoKGEpLGEudHlwZT09PSJNZXRob2REZWZpbml0aW9uIiYmYS5raW5kPT09ImNvbnN0cnVjdG9yIj8ociYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGEuc3RhcnQsIkR1cGxpY2F0ZSBjb25zdHJ1Y3RvciBpbiB0aGUgc2FtZSBjbGFzcyIpLHI9ITApOmEua2V5JiZhLmtleS50eXBlPT09IlByaXZhdGVJZGVudGlmaWVyIiYmU2YocyxhKSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGEua2V5LnN0YXJ0LCJJZGVudGlmaWVyICcjIithLmtleS5uYW1lKyInIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQiKSl9cmV0dXJuIHRoaXMuc3RyaWN0PWksdGhpcy5uZXh0KCksZS5ib2R5PXRoaXMuZmluaXNoTm9kZShuLCJDbGFzc0JvZHkiKSx0aGlzLmV4aXRDbGFzc0JvZHkoKSx0aGlzLmZpbmlzaE5vZGUoZSx0PyJDbGFzc0RlY2xhcmF0aW9uIjoiQ2xhc3NFeHByZXNzaW9uIil9LEYucGFyc2VDbGFzc0VsZW1lbnQ9ZnVuY3Rpb24oZSl7aWYodGhpcy5lYXQoZi5zZW1pKSlyZXR1cm4gbnVsbDt2YXIgdD10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24saT10aGlzLnN0YXJ0Tm9kZSgpLHM9IiIsbj0hMSxyPSExLGE9Im1ldGhvZCIsbz0hMTtpZih0aGlzLmVhdENvbnRleHR1YWwoInN0YXRpYyIpKXtpZih0Pj0xMyYmdGhpcy5lYXQoZi5icmFjZUwpKXJldHVybiB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhpKSxpO3RoaXMuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQoKXx8dGhpcy50eXBlPT09Zi5zdGFyP289ITA6cz0ic3RhdGljIn1pZihpLnN0YXRpYz1vLCFzJiZ0Pj04JiZ0aGlzLmVhdENvbnRleHR1YWwoImFzeW5jIikmJighdGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpJiZ0aGlzLnR5cGUhPT1mLnN0YXJ8fHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk/cz0iYXN5bmMiOnI9ITApLCFzJiYodD49OXx8IXIpJiZ0aGlzLmVhdChmLnN0YXIpJiYobj0hMCksIXMmJiFyJiYhbil7dmFyIGg9dGhpcy52YWx1ZTsodGhpcy5lYXRDb250ZXh0dWFsKCJnZXQiKXx8dGhpcy5lYXRDb250ZXh0dWFsKCJzZXQiKSkmJih0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCk/YT1oOnM9aCl9aWYocz8oaS5jb21wdXRlZD0hMSxpLmtleT10aGlzLnN0YXJ0Tm9kZUF0KHRoaXMubGFzdFRva1N0YXJ0LHRoaXMubGFzdFRva1N0YXJ0TG9jKSxpLmtleS5uYW1lPXMsdGhpcy5maW5pc2hOb2RlKGkua2V5LCJJZGVudGlmaWVyIikpOnRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKGkpLHQ8MTN8fHRoaXMudHlwZT09PWYucGFyZW5MfHxhIT09Im1ldGhvZCJ8fG58fHIpe3ZhciBsPSFpLnN0YXRpYyYma24oaSwiY29uc3RydWN0b3IiKSxjPWwmJmU7bCYmYSE9PSJtZXRob2QiJiZ0aGlzLnJhaXNlKGkua2V5LnN0YXJ0LCJDb25zdHJ1Y3RvciBjYW4ndCBoYXZlIGdldC9zZXQgbW9kaWZpZXIiKSxpLmtpbmQ9bD8iY29uc3RydWN0b3IiOmEsdGhpcy5wYXJzZUNsYXNzTWV0aG9kKGksbixyLGMpfWVsc2UgdGhpcy5wYXJzZUNsYXNzRmllbGQoaSk7cmV0dXJuIGl9LEYuaXNDbGFzc0VsZW1lbnROYW1lU3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50eXBlPT09Zi5uYW1lfHx0aGlzLnR5cGU9PT1mLnByaXZhdGVJZHx8dGhpcy50eXBlPT09Zi5udW18fHRoaXMudHlwZT09PWYuc3RyaW5nfHx0aGlzLnR5cGU9PT1mLmJyYWNrZXRMfHx0aGlzLnR5cGUua2V5d29yZH0sRi5wYXJzZUNsYXNzRWxlbWVudE5hbWU9ZnVuY3Rpb24oZSl7dGhpcy50eXBlPT09Zi5wcml2YXRlSWQ/KHRoaXMudmFsdWU9PT0iY29uc3RydWN0b3IiJiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIkNsYXNzZXMgY2FuJ3QgaGF2ZSBhbiBlbGVtZW50IG5hbWVkICcjY29uc3RydWN0b3InIiksZS5jb21wdXRlZD0hMSxlLmtleT10aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCkpOnRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoZSl9LEYucGFyc2VDbGFzc01ldGhvZD1mdW5jdGlvbihlLHQsaSxzKXt2YXIgbj1lLmtleTtlLmtpbmQ9PT0iY29uc3RydWN0b3IiPyh0JiZ0aGlzLnJhaXNlKG4uc3RhcnQsIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yIiksaSYmdGhpcy5yYWlzZShuLnN0YXJ0LCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhbiBhc3luYyBtZXRob2QiKSk6ZS5zdGF0aWMmJmtuKGUsInByb3RvdHlwZSIpJiZ0aGlzLnJhaXNlKG4uc3RhcnQsIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIHByb3RvdHlwZSIpO3ZhciByPWUudmFsdWU9dGhpcy5wYXJzZU1ldGhvZCh0LGkscyk7cmV0dXJuIGUua2luZD09PSJnZXQiJiZyLnBhcmFtcy5sZW5ndGghPT0wJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoci5zdGFydCwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtcyIpLGUua2luZD09PSJzZXQiJiZyLnBhcmFtcy5sZW5ndGghPT0xJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoci5zdGFydCwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtIiksZS5raW5kPT09InNldCImJnIucGFyYW1zWzBdLnR5cGU9PT0iUmVzdEVsZW1lbnQiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoci5wYXJhbXNbMF0uc3RhcnQsIlNldHRlciBjYW5ub3QgdXNlIHJlc3QgcGFyYW1zIiksdGhpcy5maW5pc2hOb2RlKGUsIk1ldGhvZERlZmluaXRpb24iKX0sRi5wYXJzZUNsYXNzRmllbGQ9ZnVuY3Rpb24oZSl7aWYoa24oZSwiY29uc3RydWN0b3IiKT90aGlzLnJhaXNlKGUua2V5LnN0YXJ0LCJDbGFzc2VzIGNhbid0IGhhdmUgYSBmaWVsZCBuYW1lZCAnY29uc3RydWN0b3InIik6ZS5zdGF0aWMmJmtuKGUsInByb3RvdHlwZSIpJiZ0aGlzLnJhaXNlKGUua2V5LnN0YXJ0LCJDbGFzc2VzIGNhbid0IGhhdmUgYSBzdGF0aWMgZmllbGQgbmFtZWQgJ3Byb3RvdHlwZSciKSx0aGlzLmVhdChmLmVxKSl7dmFyIHQ9dGhpcy5jdXJyZW50VGhpc1Njb3BlKCksaT10LmluQ2xhc3NGaWVsZEluaXQ7dC5pbkNsYXNzRmllbGRJbml0PSEwLGUudmFsdWU9dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdC5pbkNsYXNzRmllbGRJbml0PWl9ZWxzZSBlLnZhbHVlPW51bGw7cmV0dXJuIHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIlByb3BlcnR5RGVmaW5pdGlvbiIpfSxGLnBhcnNlQ2xhc3NTdGF0aWNCbG9jaz1mdW5jdGlvbihlKXtlLmJvZHk9W107dmFyIHQ9dGhpcy5sYWJlbHM7Zm9yKHRoaXMubGFiZWxzPVtdLHRoaXMuZW50ZXJTY29wZSgzMjApO3RoaXMudHlwZSE9PWYuYnJhY2VSOyl7dmFyIGk9dGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtlLmJvZHkucHVzaChpKX1yZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5leGl0U2NvcGUoKSx0aGlzLmxhYmVscz10LHRoaXMuZmluaXNoTm9kZShlLCJTdGF0aWNCbG9jayIpfSxGLnBhcnNlQ2xhc3NJZD1mdW5jdGlvbihlLHQpe3RoaXMudHlwZT09PWYubmFtZT8oZS5pZD10aGlzLnBhcnNlSWRlbnQoKSx0JiZ0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmlkLDIsITEpKToodD09PSEwJiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLmlkPW51bGwpfSxGLnBhcnNlQ2xhc3NTdXBlcj1mdW5jdGlvbihlKXtlLnN1cGVyQ2xhc3M9dGhpcy5lYXQoZi5fZXh0ZW5kcyk/dGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKG51bGwsITEpOm51bGx9LEYuZW50ZXJDbGFzc0JvZHk9ZnVuY3Rpb24oKXt2YXIgZT17ZGVjbGFyZWQ6T2JqZWN0LmNyZWF0ZShudWxsKSx1c2VkOltdfTtyZXR1cm4gdGhpcy5wcml2YXRlTmFtZVN0YWNrLnB1c2goZSksZS5kZWNsYXJlZH0sRi5leGl0Q2xhc3NCb2R5PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5wcml2YXRlTmFtZVN0YWNrLnBvcCgpLHQ9ZS5kZWNsYXJlZCxpPWUudXNlZDtpZih0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzKWZvcih2YXIgcz10aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoLG49cz09PTA/bnVsbDp0aGlzLnByaXZhdGVOYW1lU3RhY2tbcy0xXSxyPTA7cjxpLmxlbmd0aDsrK3Ipe3ZhciBhPWlbcl07Z3ModCxhLm5hbWUpfHwobj9uLnVzZWQucHVzaChhKTp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoYS5zdGFydCwiUHJpdmF0ZSBmaWVsZCAnIyIrYS5uYW1lKyInIG11c3QgYmUgZGVjbGFyZWQgaW4gYW4gZW5jbG9zaW5nIGNsYXNzIikpfX0sRi5wYXJzZUV4cG9ydEFsbERlY2xhcmF0aW9uPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEmJih0aGlzLmVhdENvbnRleHR1YWwoImFzIik/KGUuZXhwb3J0ZWQ9dGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKSx0aGlzLmNoZWNrRXhwb3J0KHQsZS5leHBvcnRlZCx0aGlzLmxhc3RUb2tTdGFydCkpOmUuZXhwb3J0ZWQ9bnVsbCksdGhpcy5leHBlY3RDb250ZXh0dWFsKCJmcm9tIiksdGhpcy50eXBlIT09Zi5zdHJpbmcmJnRoaXMudW5leHBlY3RlZCgpLGUuc291cmNlPXRoaXMucGFyc2VFeHByQXRvbSgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkV4cG9ydEFsbERlY2xhcmF0aW9uIil9LEYucGFyc2VFeHBvcnQ9ZnVuY3Rpb24oZSx0KXtpZih0aGlzLm5leHQoKSx0aGlzLmVhdChmLnN0YXIpKXJldHVybiB0aGlzLnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb24oZSx0KTtpZih0aGlzLmVhdChmLl9kZWZhdWx0KSlyZXR1cm4gdGhpcy5jaGVja0V4cG9ydCh0LCJkZWZhdWx0Iix0aGlzLmxhc3RUb2tTdGFydCksZS5kZWNsYXJhdGlvbj10aGlzLnBhcnNlRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiIpO2lmKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQoKSllLmRlY2xhcmF0aW9uPXRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihlKSxlLmRlY2xhcmF0aW9uLnR5cGU9PT0iVmFyaWFibGVEZWNsYXJhdGlvbiI/dGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KHQsZS5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOnRoaXMuY2hlY2tFeHBvcnQodCxlLmRlY2xhcmF0aW9uLmlkLGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpLGUuc3BlY2lmaWVycz1bXSxlLnNvdXJjZT1udWxsO2Vsc2V7aWYoZS5kZWNsYXJhdGlvbj1udWxsLGUuc3BlY2lmaWVycz10aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0KSx0aGlzLmVhdENvbnRleHR1YWwoImZyb20iKSl0aGlzLnR5cGUhPT1mLnN0cmluZyYmdGhpcy51bmV4cGVjdGVkKCksZS5zb3VyY2U9dGhpcy5wYXJzZUV4cHJBdG9tKCk7ZWxzZXtmb3IodmFyIGk9MCxzPWUuc3BlY2lmaWVycztpPHMubGVuZ3RoO2krPTEpe3ZhciBuPXNbaV07dGhpcy5jaGVja1VucmVzZXJ2ZWQobi5sb2NhbCksdGhpcy5jaGVja0xvY2FsRXhwb3J0KG4ubG9jYWwpLG4ubG9jYWwudHlwZT09PSJMaXRlcmFsIiYmdGhpcy5yYWlzZShuLmxvY2FsLnN0YXJ0LCJBIHN0cmluZyBsaXRlcmFsIGNhbm5vdCBiZSB1c2VkIGFzIGFuIGV4cG9ydGVkIGJpbmRpbmcgd2l0aG91dCBgZnJvbWAuIil9ZS5zb3VyY2U9bnVsbH10aGlzLnNlbWljb2xvbigpfXJldHVybiB0aGlzLmZpbmlzaE5vZGUoZSwiRXhwb3J0TmFtZWREZWNsYXJhdGlvbiIpfSxGLnBhcnNlRXhwb3J0RGVjbGFyYXRpb249ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCl9LEYucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb249ZnVuY3Rpb24oKXt2YXIgZTtpZih0aGlzLnR5cGU9PT1mLl9mdW5jdGlvbnx8KGU9dGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpe3ZhciB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLGUmJnRoaXMubmV4dCgpLHRoaXMucGFyc2VGdW5jdGlvbih0LDR8eHMsITEsZSl9aWYodGhpcy50eXBlPT09Zi5fY2xhc3Mpe3ZhciBpPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMucGFyc2VDbGFzcyhpLCJudWxsYWJsZUlEIil9dmFyIHM9dGhpcy5wYXJzZU1heWJlQXNzaWduKCk7cmV0dXJuIHRoaXMuc2VtaWNvbG9uKCksc30sRi5jaGVja0V4cG9ydD1mdW5jdGlvbihlLHQsaSl7ZSYmKHR5cGVvZiB0IT0ic3RyaW5nIiYmKHQ9dC50eXBlPT09IklkZW50aWZpZXIiP3QubmFtZTp0LnZhbHVlKSxncyhlLHQpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoaSwiRHVwbGljYXRlIGV4cG9ydCAnIit0KyInIiksZVt0XT0hMCl9LEYuY2hlY2tQYXR0ZXJuRXhwb3J0PWZ1bmN0aW9uKGUsdCl7dmFyIGk9dC50eXBlO2lmKGk9PT0iSWRlbnRpZmllciIpdGhpcy5jaGVja0V4cG9ydChlLHQsdC5zdGFydCk7ZWxzZSBpZihpPT09Ik9iamVjdFBhdHRlcm4iKWZvcih2YXIgcz0wLG49dC5wcm9wZXJ0aWVzO3M8bi5sZW5ndGg7cys9MSl7dmFyIHI9bltzXTt0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChlLHIpfWVsc2UgaWYoaT09PSJBcnJheVBhdHRlcm4iKWZvcih2YXIgYT0wLG89dC5lbGVtZW50czthPG8ubGVuZ3RoO2ErPTEpe3ZhciBoPW9bYV07aCYmdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZSxoKX1lbHNlIGk9PT0iUHJvcGVydHkiP3RoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUsdC52YWx1ZSk6aT09PSJBc3NpZ25tZW50UGF0dGVybiI/dGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZSx0LmxlZnQpOmk9PT0iUmVzdEVsZW1lbnQiP3RoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUsdC5hcmd1bWVudCk6aT09PSJQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiImJnRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUsdC5leHByZXNzaW9uKX0sRi5jaGVja1ZhcmlhYmxlRXhwb3J0PWZ1bmN0aW9uKGUsdCl7aWYoZSlmb3IodmFyIGk9MCxzPXQ7aTxzLmxlbmd0aDtpKz0xKXt2YXIgbj1zW2ldO3RoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUsbi5pZCl9fSxGLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkPT09InZhciJ8fHRoaXMudHlwZS5rZXl3b3JkPT09ImNvbnN0Inx8dGhpcy50eXBlLmtleXdvcmQ9PT0iY2xhc3MifHx0aGlzLnR5cGUua2V5d29yZD09PSJmdW5jdGlvbiJ8fHRoaXMuaXNMZXQoKXx8dGhpcy5pc0FzeW5jRnVuY3Rpb24oKX0sRi5wYXJzZUV4cG9ydFNwZWNpZmllcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0LmxvY2FsPXRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCksdC5leHBvcnRlZD10aGlzLmVhdENvbnRleHR1YWwoImFzIik/dGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTp0LmxvY2FsLHRoaXMuY2hlY2tFeHBvcnQoZSx0LmV4cG9ydGVkLHQuZXhwb3J0ZWQuc3RhcnQpLHRoaXMuZmluaXNoTm9kZSh0LCJFeHBvcnRTcGVjaWZpZXIiKX0sRi5wYXJzZUV4cG9ydFNwZWNpZmllcnM9ZnVuY3Rpb24oZSl7dmFyIHQ9W10saT0hMDtmb3IodGhpcy5leHBlY3QoZi5icmFjZUwpOyF0aGlzLmVhdChmLmJyYWNlUik7KXtpZihpKWk9ITE7ZWxzZSBpZih0aGlzLmV4cGVjdChmLmNvbW1hKSx0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShmLmJyYWNlUikpYnJlYWs7dC5wdXNoKHRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXIoZSkpfXJldHVybiB0fSxGLnBhcnNlSW1wb3J0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnR5cGU9PT1mLnN0cmluZz8oZS5zcGVjaWZpZXJzPUVmLGUuc291cmNlPXRoaXMucGFyc2VFeHByQXRvbSgpKTooZS5zcGVjaWZpZXJzPXRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJzKCksdGhpcy5leHBlY3RDb250ZXh0dWFsKCJmcm9tIiksZS5zb3VyY2U9dGhpcy50eXBlPT09Zi5zdHJpbmc/dGhpcy5wYXJzZUV4cHJBdG9tKCk6dGhpcy51bmV4cGVjdGVkKCkpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkltcG9ydERlY2xhcmF0aW9uIil9LEYucGFyc2VJbXBvcnRTcGVjaWZpZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiBlLmltcG9ydGVkPXRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCksdGhpcy5lYXRDb250ZXh0dWFsKCJhcyIpP2UubG9jYWw9dGhpcy5wYXJzZUlkZW50KCk6KHRoaXMuY2hlY2tVbnJlc2VydmVkKGUuaW1wb3J0ZWQpLGUubG9jYWw9ZS5pbXBvcnRlZCksdGhpcy5jaGVja0xWYWxTaW1wbGUoZS5sb2NhbCwyKSx0aGlzLmZpbmlzaE5vZGUoZSwiSW1wb3J0U3BlY2lmaWVyIil9LEYucGFyc2VJbXBvcnREZWZhdWx0U3BlY2lmaWVyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gZS5sb2NhbD10aGlzLnBhcnNlSWRlbnQoKSx0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmxvY2FsLDIpLHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIil9LEYucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmV4cGVjdENvbnRleHR1YWwoImFzIiksZS5sb2NhbD10aGlzLnBhcnNlSWRlbnQoKSx0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmxvY2FsLDIpLHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIiKX0sRi5wYXJzZUltcG9ydFNwZWNpZmllcnM9ZnVuY3Rpb24oKXt2YXIgZT1bXSx0PSEwO2lmKHRoaXMudHlwZT09PWYubmFtZSYmKGUucHVzaCh0aGlzLnBhcnNlSW1wb3J0RGVmYXVsdFNwZWNpZmllcigpKSwhdGhpcy5lYXQoZi5jb21tYSkpKXJldHVybiBlO2lmKHRoaXMudHlwZT09PWYuc3RhcilyZXR1cm4gZS5wdXNoKHRoaXMucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoKSksZTtmb3IodGhpcy5leHBlY3QoZi5icmFjZUwpOyF0aGlzLmVhdChmLmJyYWNlUik7KXtpZih0KXQ9ITE7ZWxzZSBpZih0aGlzLmV4cGVjdChmLmNvbW1hKSx0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShmLmJyYWNlUikpYnJlYWs7ZS5wdXNoKHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXIoKSl9cmV0dXJuIGV9LEYucGFyc2VNb2R1bGVFeHBvcnROYW1lPWZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMyYmdGhpcy50eXBlPT09Zi5zdHJpbmcpe3ZhciBlPXRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpO3JldHVybiB5Zi50ZXN0KGUudmFsdWUpJiZ0aGlzLnJhaXNlKGUuc3RhcnQsIkFuIGV4cG9ydCBuYW1lIGNhbm5vdCBpbmNsdWRlIGEgbG9uZSBzdXJyb2dhdGUuIiksZX1yZXR1cm4gdGhpcy5wYXJzZUlkZW50KCEwKX0sRi5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGgmJnRoaXMuaXNEaXJlY3RpdmVDYW5kaWRhdGUoZVt0XSk7Kyt0KWVbdF0uZGlyZWN0aXZlPWVbdF0uZXhwcmVzc2lvbi5yYXcuc2xpY2UoMSwtMSl9LEYuaXNEaXJlY3RpdmVDYW5kaWRhdGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NSYmZS50eXBlPT09IkV4cHJlc3Npb25TdGF0ZW1lbnQiJiZlLmV4cHJlc3Npb24udHlwZT09PSJMaXRlcmFsIiYmdHlwZW9mIGUuZXhwcmVzc2lvbi52YWx1ZT09InN0cmluZyImJih0aGlzLmlucHV0W2Uuc3RhcnRdPT09JyInfHx0aGlzLmlucHV0W2Uuc3RhcnRdPT09IiciKX07dmFyIGV0PWdlLnByb3RvdHlwZTtldC50b0Fzc2lnbmFibGU9ZnVuY3Rpb24oZSx0LGkpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmZSlzd2l0Y2goZS50eXBlKXtjYXNlIklkZW50aWZpZXIiOnRoaXMuaW5Bc3luYyYmZS5uYW1lPT09ImF3YWl0IiYmdGhpcy5yYWlzZShlLnN0YXJ0LCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb24iKTticmVhaztjYXNlIk9iamVjdFBhdHRlcm4iOmNhc2UiQXJyYXlQYXR0ZXJuIjpjYXNlIkFzc2lnbm1lbnRQYXR0ZXJuIjpjYXNlIlJlc3RFbGVtZW50IjpicmVhaztjYXNlIk9iamVjdEV4cHJlc3Npb24iOmUudHlwZT0iT2JqZWN0UGF0dGVybiIsaSYmdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMoaSwhMCk7Zm9yKHZhciBzPTAsbj1lLnByb3BlcnRpZXM7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMudG9Bc3NpZ25hYmxlKHIsdCksci50eXBlIT09IlJlc3RFbGVtZW50Inx8ci5hcmd1bWVudC50eXBlIT09IkFycmF5UGF0dGVybiImJnIuYXJndW1lbnQudHlwZSE9PSJPYmplY3RQYXR0ZXJuInx8dGhpcy5yYWlzZShyLmFyZ3VtZW50LnN0YXJ0LCJVbmV4cGVjdGVkIHRva2VuIil9YnJlYWs7Y2FzZSJQcm9wZXJ0eSI6ZS5raW5kIT09ImluaXQiJiZ0aGlzLnJhaXNlKGUua2V5LnN0YXJ0LCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXIiKSx0aGlzLnRvQXNzaWduYWJsZShlLnZhbHVlLHQpO2JyZWFrO2Nhc2UiQXJyYXlFeHByZXNzaW9uIjplLnR5cGU9IkFycmF5UGF0dGVybiIsaSYmdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMoaSwhMCksdGhpcy50b0Fzc2lnbmFibGVMaXN0KGUuZWxlbWVudHMsdCk7YnJlYWs7Y2FzZSJTcHJlYWRFbGVtZW50IjplLnR5cGU9IlJlc3RFbGVtZW50Iix0aGlzLnRvQXNzaWduYWJsZShlLmFyZ3VtZW50LHQpLGUuYXJndW1lbnQudHlwZT09PSJBc3NpZ25tZW50UGF0dGVybiImJnRoaXMucmFpc2UoZS5hcmd1bWVudC5zdGFydCwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUiKTticmVhaztjYXNlIkFzc2lnbm1lbnRFeHByZXNzaW9uIjplLm9wZXJhdG9yIT09Ij0iJiZ0aGlzLnJhaXNlKGUubGVmdC5lbmQsIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuIiksZS50eXBlPSJBc3NpZ25tZW50UGF0dGVybiIsZGVsZXRlIGUub3BlcmF0b3IsdGhpcy50b0Fzc2lnbmFibGUoZS5sZWZ0LHQpO2JyZWFrO2Nhc2UiUGFyZW50aGVzaXplZEV4cHJlc3Npb24iOnRoaXMudG9Bc3NpZ25hYmxlKGUuZXhwcmVzc2lvbix0LGkpO2JyZWFrO2Nhc2UiQ2hhaW5FeHByZXNzaW9uIjp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZSIpO2JyZWFrO2Nhc2UiTWVtYmVyRXhwcmVzc2lvbiI6aWYoIXQpYnJlYWs7ZGVmYXVsdDp0aGlzLnJhaXNlKGUuc3RhcnQsIkFzc2lnbmluZyB0byBydmFsdWUiKX1lbHNlIGkmJnRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKGksITApO3JldHVybiBlfSxldC50b0Fzc2lnbmFibGVMaXN0PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPWUubGVuZ3RoLHM9MDtzPGk7cysrKXt2YXIgbj1lW3NdO24mJnRoaXMudG9Bc3NpZ25hYmxlKG4sdCl9aWYoaSl7dmFyIHI9ZVtpLTFdO3RoaXMub3B0aW9ucy5lY21hVmVyc2lvbj09PTYmJnQmJnImJnIudHlwZT09PSJSZXN0RWxlbWVudCImJnIuYXJndW1lbnQudHlwZSE9PSJJZGVudGlmaWVyIiYmdGhpcy51bmV4cGVjdGVkKHIuYXJndW1lbnQuc3RhcnQpfXJldHVybiBlfSxldC5wYXJzZVNwcmVhZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0LmFyZ3VtZW50PXRoaXMucGFyc2VNYXliZUFzc2lnbighMSxlKSx0aGlzLmZpbmlzaE5vZGUodCwiU3ByZWFkRWxlbWVudCIpfSxldC5wYXJzZVJlc3RCaW5kaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPT09NiYmdGhpcy50eXBlIT09Zi5uYW1lJiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLmFyZ3VtZW50PXRoaXMucGFyc2VCaW5kaW5nQXRvbSgpLHRoaXMuZmluaXNoTm9kZShlLCJSZXN0RWxlbWVudCIpfSxldC5wYXJzZUJpbmRpbmdBdG9tPWZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXN3aXRjaCh0aGlzLnR5cGUpe2Nhc2UgZi5icmFja2V0TDp2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSxlLmVsZW1lbnRzPXRoaXMucGFyc2VCaW5kaW5nTGlzdChmLmJyYWNrZXRSLCEwLCEwKSx0aGlzLmZpbmlzaE5vZGUoZSwiQXJyYXlQYXR0ZXJuIik7Y2FzZSBmLmJyYWNlTDpyZXR1cm4gdGhpcy5wYXJzZU9iaighMCl9cmV0dXJuIHRoaXMucGFyc2VJZGVudCgpfSxldC5wYXJzZUJpbmRpbmdMaXN0PWZ1bmN0aW9uKGUsdCxpLHMpe2Zvcih2YXIgbj1bXSxyPSEwOyF0aGlzLmVhdChlKTspaWYocj9yPSExOnRoaXMuZXhwZWN0KGYuY29tbWEpLHQmJnRoaXMudHlwZT09PWYuY29tbWEpbi5wdXNoKG51bGwpO2Vsc2V7aWYoaSYmdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoZSkpYnJlYWs7aWYodGhpcy50eXBlPT09Zi5lbGxpcHNpcyl7dmFyIGE9dGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7dGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShhKSxuLnB1c2goYSksdGhpcy50eXBlPT09Zi5jb21tYSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudCIpLHRoaXMuZXhwZWN0KGUpO2JyZWFrfW4ucHVzaCh0aGlzLnBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKHMpKX1yZXR1cm4gbn0sZXQucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW09ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LHRoaXMuc3RhcnRMb2MpO3JldHVybiB0aGlzLnBhcnNlQmluZGluZ0xpc3RJdGVtKHQpLHR9LGV0LnBhcnNlQmluZGluZ0xpc3RJdGVtPWZ1bmN0aW9uKGUpe3JldHVybiBlfSxldC5wYXJzZU1heWJlRGVmYXVsdD1mdW5jdGlvbihlLHQsaSl7aWYoaT1pfHx0aGlzLnBhcnNlQmluZGluZ0F0b20oKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248Nnx8IXRoaXMuZWF0KGYuZXEpKXJldHVybiBpO3ZhciBzPXRoaXMuc3RhcnROb2RlQXQoZSx0KTtyZXR1cm4gcy5sZWZ0PWkscy5yaWdodD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmZpbmlzaE5vZGUocywiQXNzaWdubWVudFBhdHRlcm4iKX0sZXQuY2hlY2tMVmFsU2ltcGxlPWZ1bmN0aW9uKGUsdCxpKXt0PT09dm9pZCAwJiYodD0wKTt2YXIgcz10IT09MDtzd2l0Y2goZS50eXBlKXtjYXNlIklkZW50aWZpZXIiOnRoaXMuc3RyaWN0JiZ0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZS5uYW1lKSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsKHM/IkJpbmRpbmcgIjoiQXNzaWduaW5nIHRvICIpK2UubmFtZSsiIGluIHN0cmljdCBtb2RlIikscyYmKHQ9PT0yJiZlLm5hbWU9PT0ibGV0IiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsImxldCBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUiKSxpJiYoZ3MoaSxlLm5hbWUpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiQXJndW1lbnQgbmFtZSBjbGFzaCIpLGlbZS5uYW1lXT0hMCksdCE9PTUmJnRoaXMuZGVjbGFyZU5hbWUoZS5uYW1lLHQsZS5zdGFydCkpO2JyZWFrO2Nhc2UiQ2hhaW5FeHByZXNzaW9uIjp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZSIpO2JyZWFrO2Nhc2UiTWVtYmVyRXhwcmVzc2lvbiI6cyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24iKTticmVhaztjYXNlIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIjpyZXR1cm4gcyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIkJpbmRpbmcgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIiksdGhpcy5jaGVja0xWYWxTaW1wbGUoZS5leHByZXNzaW9uLHQsaSk7ZGVmYXVsdDp0aGlzLnJhaXNlKGUuc3RhcnQsKHM/IkJpbmRpbmciOiJBc3NpZ25pbmcgdG8iKSsiIHJ2YWx1ZSIpfX0sZXQuY2hlY2tMVmFsUGF0dGVybj1mdW5jdGlvbihlLHQsaSl7c3dpdGNoKHQ9PT12b2lkIDAmJih0PTApLGUudHlwZSl7Y2FzZSJPYmplY3RQYXR0ZXJuIjpmb3IodmFyIHM9MCxuPWUucHJvcGVydGllcztzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc107dGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4ocix0LGkpfWJyZWFrO2Nhc2UiQXJyYXlQYXR0ZXJuIjpmb3IodmFyIGE9MCxvPWUuZWxlbWVudHM7YTxvLmxlbmd0aDthKz0xKXt2YXIgaD1vW2FdO2gmJnRoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKGgsdCxpKX1icmVhaztkZWZhdWx0OnRoaXMuY2hlY2tMVmFsU2ltcGxlKGUsdCxpKX19LGV0LmNoZWNrTFZhbElubmVyUGF0dGVybj1mdW5jdGlvbihlLHQsaSl7c3dpdGNoKHQ9PT12b2lkIDAmJih0PTApLGUudHlwZSl7Y2FzZSJQcm9wZXJ0eSI6dGhpcy5jaGVja0xWYWxJbm5lclBhdHRlcm4oZS52YWx1ZSx0LGkpO2JyZWFrO2Nhc2UiQXNzaWdubWVudFBhdHRlcm4iOnRoaXMuY2hlY2tMVmFsUGF0dGVybihlLmxlZnQsdCxpKTticmVhaztjYXNlIlJlc3RFbGVtZW50Ijp0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZS5hcmd1bWVudCx0LGkpO2JyZWFrO2RlZmF1bHQ6dGhpcy5jaGVja0xWYWxQYXR0ZXJuKGUsdCxpKX19O3ZhciB0dD1mdW5jdGlvbihlLHQsaSxzLG4pe3RoaXMudG9rZW49ZSx0aGlzLmlzRXhwcj0hIXQsdGhpcy5wcmVzZXJ2ZVNwYWNlPSEhaSx0aGlzLm92ZXJyaWRlPXMsdGhpcy5nZW5lcmF0b3I9ISFufSxwZT17Yl9zdGF0Om5ldyB0dCgieyIsITEpLGJfZXhwcjpuZXcgdHQoInsiLCEwKSxiX3RtcGw6bmV3IHR0KCIkeyIsITEpLHBfc3RhdDpuZXcgdHQoIigiLCExKSxwX2V4cHI6bmV3IHR0KCIoIiwhMCkscV90bXBsOm5ldyB0dCgiYCIsITAsITAsZnVuY3Rpb24oZSl7cmV0dXJuIGUudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKX0pLGZfc3RhdDpuZXcgdHQoImZ1bmN0aW9uIiwhMSksZl9leHByOm5ldyB0dCgiZnVuY3Rpb24iLCEwKSxmX2V4cHJfZ2VuOm5ldyB0dCgiZnVuY3Rpb24iLCEwLCExLG51bGwsITApLGZfZ2VuOm5ldyB0dCgiZnVuY3Rpb24iLCExLCExLG51bGwsITApfSxWaT1nZS5wcm90b3R5cGU7VmkuaW5pdGlhbENvbnRleHQ9ZnVuY3Rpb24oKXtyZXR1cm5bcGUuYl9zdGF0XX0sVmkuY3VyQ29udGV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aC0xXX0sVmkuYnJhY2VJc0Jsb2NrPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuY3VyQ29udGV4dCgpO3JldHVybiB0PT09cGUuZl9leHByfHx0PT09cGUuZl9zdGF0fHwoZSE9PWYuY29sb258fHQhPT1wZS5iX3N0YXQmJnQhPT1wZS5iX2V4cHI/ZT09PWYuX3JldHVybnx8ZT09PWYubmFtZSYmdGhpcy5leHByQWxsb3dlZD9LZS50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLHRoaXMuc3RhcnQpKTplPT09Zi5fZWxzZXx8ZT09PWYuc2VtaXx8ZT09PWYuZW9mfHxlPT09Zi5wYXJlblJ8fGU9PT1mLmFycm93fHwoZT09PWYuYnJhY2VMP3Q9PT1wZS5iX3N0YXQ6ZSE9PWYuX3ZhciYmZSE9PWYuX2NvbnN0JiZlIT09Zi5uYW1lJiYhdGhpcy5leHByQWxsb3dlZCk6IXQuaXNFeHByKX0sVmkuaW5HZW5lcmF0b3JDb250ZXh0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuY29udGV4dC5sZW5ndGgtMTtlPj0xO2UtLSl7dmFyIHQ9dGhpcy5jb250ZXh0W2VdO2lmKHQudG9rZW49PT0iZnVuY3Rpb24iKXJldHVybiB0LmdlbmVyYXRvcn1yZXR1cm4hMX0sVmkudXBkYXRlQ29udGV4dD1mdW5jdGlvbihlKXt2YXIgdCxpPXRoaXMudHlwZTtpLmtleXdvcmQmJmU9PT1mLmRvdD90aGlzLmV4cHJBbGxvd2VkPSExOih0PWkudXBkYXRlQ29udGV4dCk/dC5jYWxsKHRoaXMsZSk6dGhpcy5leHByQWxsb3dlZD1pLmJlZm9yZUV4cHJ9LFZpLm92ZXJyaWRlQ29udGV4dD1mdW5jdGlvbihlKXt0aGlzLmN1ckNvbnRleHQoKSE9PWUmJih0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aC0xXT1lKX0sZi5wYXJlblIudXBkYXRlQ29udGV4dD1mLmJyYWNlUi51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5jb250ZXh0Lmxlbmd0aCE9PTEpe3ZhciBlPXRoaXMuY29udGV4dC5wb3AoKTtlPT09cGUuYl9zdGF0JiZ0aGlzLmN1ckNvbnRleHQoKS50b2tlbj09PSJmdW5jdGlvbiImJihlPXRoaXMuY29udGV4dC5wb3AoKSksdGhpcy5leHByQWxsb3dlZD0hZS5pc0V4cHJ9ZWxzZSB0aGlzLmV4cHJBbGxvd2VkPSEwfSxmLmJyYWNlTC51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKGUpe3RoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKGUpP3BlLmJfc3RhdDpwZS5iX2V4cHIpLHRoaXMuZXhwckFsbG93ZWQ9ITB9LGYuZG9sbGFyQnJhY2VMLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oKXt0aGlzLmNvbnRleHQucHVzaChwZS5iX3RtcGwpLHRoaXMuZXhwckFsbG93ZWQ9ITB9LGYucGFyZW5MLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZT09PWYuX2lmfHxlPT09Zi5fZm9yfHxlPT09Zi5fd2l0aHx8ZT09PWYuX3doaWxlO3RoaXMuY29udGV4dC5wdXNoKHQ/cGUucF9zdGF0OnBlLnBfZXhwciksdGhpcy5leHByQWxsb3dlZD0hMH0sZi5pbmNEZWMudXBkYXRlQ29udGV4dD1mdW5jdGlvbigpe30sZi5fZnVuY3Rpb24udXBkYXRlQ29udGV4dD1mLl9jbGFzcy51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKGUpeyFlLmJlZm9yZUV4cHJ8fGU9PT1mLl9lbHNlfHxlPT09Zi5zZW1pJiZ0aGlzLmN1ckNvbnRleHQoKSE9PXBlLnBfc3RhdHx8ZT09PWYuX3JldHVybiYmS2UudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCx0aGlzLnN0YXJ0KSl8fChlPT09Zi5jb2xvbnx8ZT09PWYuYnJhY2VMKSYmdGhpcy5jdXJDb250ZXh0KCk9PT1wZS5iX3N0YXQ/dGhpcy5jb250ZXh0LnB1c2gocGUuZl9zdGF0KTp0aGlzLmNvbnRleHQucHVzaChwZS5mX2V4cHIpLHRoaXMuZXhwckFsbG93ZWQ9ITF9LGYuYmFja1F1b3RlLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oKXt0aGlzLmN1ckNvbnRleHQoKT09PXBlLnFfdG1wbD90aGlzLmNvbnRleHQucG9wKCk6dGhpcy5jb250ZXh0LnB1c2gocGUucV90bXBsKSx0aGlzLmV4cHJBbGxvd2VkPSExfSxmLnN0YXIudXBkYXRlQ29udGV4dD1mdW5jdGlvbihlKXtpZihlPT09Zi5fZnVuY3Rpb24pe3ZhciB0PXRoaXMuY29udGV4dC5sZW5ndGgtMTt0aGlzLmNvbnRleHRbdF09PT1wZS5mX2V4cHI/dGhpcy5jb250ZXh0W3RdPXBlLmZfZXhwcl9nZW46dGhpcy5jb250ZXh0W3RdPXBlLmZfZ2VufXRoaXMuZXhwckFsbG93ZWQ9ITB9LGYubmFtZS51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKGUpe3ZhciB0PSExO3RoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmZSE9PWYuZG90JiYodGhpcy52YWx1ZT09PSJvZiImJiF0aGlzLmV4cHJBbGxvd2VkfHx0aGlzLnZhbHVlPT09InlpZWxkIiYmdGhpcy5pbkdlbmVyYXRvckNvbnRleHQoKSkmJih0PSEwKSx0aGlzLmV4cHJBbGxvd2VkPXR9O3ZhciBxPWdlLnByb3RvdHlwZTtmdW5jdGlvbiBSbChlKXtyZXR1cm4gZS50eXBlPT09Ik1lbWJlckV4cHJlc3Npb24iJiZlLnByb3BlcnR5LnR5cGU9PT0iUHJpdmF0ZUlkZW50aWZpZXIifHxlLnR5cGU9PT0iQ2hhaW5FeHByZXNzaW9uIiYmUmwoZS5leHByZXNzaW9uKX1xLmNoZWNrUHJvcENsYXNoPWZ1bmN0aW9uKGUsdCxpKXtpZighKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmZS50eXBlPT09IlNwcmVhZEVsZW1lbnQifHx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJihlLmNvbXB1dGVkfHxlLm1ldGhvZHx8ZS5zaG9ydGhhbmQpKSl7dmFyIHMsbj1lLmtleTtzd2l0Y2gobi50eXBlKXtjYXNlIklkZW50aWZpZXIiOnM9bi5uYW1lO2JyZWFrO2Nhc2UiTGl0ZXJhbCI6cz1TdHJpbmcobi52YWx1ZSk7YnJlYWs7ZGVmYXVsdDpyZXR1cm59dmFyIHI9ZS5raW5kO2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NilzPT09Il9fcHJvdG9fXyImJnI9PT0iaW5pdCImJih0LnByb3RvJiYoaT9pLmRvdWJsZVByb3RvPDAmJihpLmRvdWJsZVByb3RvPW4uc3RhcnQpOnRoaXMucmFpc2VSZWNvdmVyYWJsZShuLnN0YXJ0LCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5IikpLHQucHJvdG89ITApO2Vsc2V7dmFyIGE9dFtzPSIkIitzXTthPyhyPT09ImluaXQiP3RoaXMuc3RyaWN0JiZhLmluaXR8fGEuZ2V0fHxhLnNldDphLmluaXR8fGFbcl0pJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUobi5zdGFydCwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5Iik6YT10W3NdPXtpbml0OiExLGdldDohMSxzZXQ6ITF9LGFbcl09ITB9fX0scS5wYXJzZUV4cHJlc3Npb249ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLnN0YXJ0LHM9dGhpcy5zdGFydExvYyxuPXRoaXMucGFyc2VNYXliZUFzc2lnbihlLHQpO2lmKHRoaXMudHlwZT09PWYuY29tbWEpe3ZhciByPXRoaXMuc3RhcnROb2RlQXQoaSxzKTtmb3Ioci5leHByZXNzaW9ucz1bbl07dGhpcy5lYXQoZi5jb21tYSk7KXIuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSx0KSk7cmV0dXJuIHRoaXMuZmluaXNoTm9kZShyLCJTZXF1ZW5jZUV4cHJlc3Npb24iKX1yZXR1cm4gbn0scS5wYXJzZU1heWJlQXNzaWduPWZ1bmN0aW9uKGUsdCxpKXtpZih0aGlzLmlzQ29udGV4dHVhbCgieWllbGQiKSl7aWYodGhpcy5pbkdlbmVyYXRvcilyZXR1cm4gdGhpcy5wYXJzZVlpZWxkKGUpO3RoaXMuZXhwckFsbG93ZWQ9ITF9dmFyIHM9ITEsbj0tMSxyPS0xLGE9LTE7dD8obj10LnBhcmVudGhlc2l6ZWRBc3NpZ24scj10LnRyYWlsaW5nQ29tbWEsYT10LmRvdWJsZVByb3RvLHQucGFyZW50aGVzaXplZEFzc2lnbj10LnRyYWlsaW5nQ29tbWE9LTEpOih0PW5ldyBTbixzPSEwKTt2YXIgbz10aGlzLnN0YXJ0LGg9dGhpcy5zdGFydExvYzt0aGlzLnR5cGUhPT1mLnBhcmVuTCYmdGhpcy50eXBlIT09Zi5uYW1lfHwodGhpcy5wb3RlbnRpYWxBcnJvd0F0PXRoaXMuc3RhcnQsdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXQ9ZT09PSJhd2FpdCIpO3ZhciBsPXRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKGUsdCk7aWYoaSYmKGw9aS5jYWxsKHRoaXMsbCxvLGgpKSx0aGlzLnR5cGUuaXNBc3NpZ24pe3ZhciBjPXRoaXMuc3RhcnROb2RlQXQobyxoKTtyZXR1cm4gYy5vcGVyYXRvcj10aGlzLnZhbHVlLHRoaXMudHlwZT09PWYuZXEmJihsPXRoaXMudG9Bc3NpZ25hYmxlKGwsITEsdCkpLHN8fCh0LnBhcmVudGhlc2l6ZWRBc3NpZ249dC50cmFpbGluZ0NvbW1hPXQuZG91YmxlUHJvdG89LTEpLHQuc2hvcnRoYW5kQXNzaWduPj1sLnN0YXJ0JiYodC5zaG9ydGhhbmRBc3NpZ249LTEpLHRoaXMudHlwZT09PWYuZXE/dGhpcy5jaGVja0xWYWxQYXR0ZXJuKGwpOnRoaXMuY2hlY2tMVmFsU2ltcGxlKGwpLGMubGVmdD1sLHRoaXMubmV4dCgpLGMucmlnaHQ9dGhpcy5wYXJzZU1heWJlQXNzaWduKGUpLGE+LTEmJih0LmRvdWJsZVByb3RvPWEpLHRoaXMuZmluaXNoTm9kZShjLCJBc3NpZ25tZW50RXhwcmVzc2lvbiIpfXJldHVybiBzJiZ0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyh0LCEwKSxuPi0xJiYodC5wYXJlbnRoZXNpemVkQXNzaWduPW4pLHI+LTEmJih0LnRyYWlsaW5nQ29tbWE9ciksbH0scS5wYXJzZU1heWJlQ29uZGl0aW9uYWw9ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLnN0YXJ0LHM9dGhpcy5zdGFydExvYyxuPXRoaXMucGFyc2VFeHByT3BzKGUsdCk7aWYodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnModCkpcmV0dXJuIG47aWYodGhpcy5lYXQoZi5xdWVzdGlvbikpe3ZhciByPXRoaXMuc3RhcnROb2RlQXQoaSxzKTtyZXR1cm4gci50ZXN0PW4sci5jb25zZXF1ZW50PXRoaXMucGFyc2VNYXliZUFzc2lnbigpLHRoaXMuZXhwZWN0KGYuY29sb24pLHIuYWx0ZXJuYXRlPXRoaXMucGFyc2VNYXliZUFzc2lnbihlKSx0aGlzLmZpbmlzaE5vZGUociwiQ29uZGl0aW9uYWxFeHByZXNzaW9uIil9cmV0dXJuIG59LHEucGFyc2VFeHByT3BzPWZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcy5zdGFydCxzPXRoaXMuc3RhcnRMb2Msbj10aGlzLnBhcnNlTWF5YmVVbmFyeSh0LCExLCExLGUpO3JldHVybiB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyh0KXx8bi5zdGFydD09PWkmJm4udHlwZT09PSJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiI/bjp0aGlzLnBhcnNlRXhwck9wKG4saSxzLC0xLGUpfSxxLnBhcnNlRXhwck9wPWZ1bmN0aW9uKGUsdCxpLHMsbil7dmFyIHI9dGhpcy50eXBlLmJpbm9wO2lmKHIhPW51bGwmJighbnx8dGhpcy50eXBlIT09Zi5faW4pJiZyPnMpe3ZhciBhPXRoaXMudHlwZT09PWYubG9naWNhbE9SfHx0aGlzLnR5cGU9PT1mLmxvZ2ljYWxBTkQsbz10aGlzLnR5cGU9PT1mLmNvYWxlc2NlO28mJihyPWYubG9naWNhbEFORC5iaW5vcCk7dmFyIGg9dGhpcy52YWx1ZTt0aGlzLm5leHQoKTt2YXIgbD10aGlzLnN0YXJ0LGM9dGhpcy5zdGFydExvYyxwPXRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwhMSwhMSxuKSxsLGMscixuKSxtPXRoaXMuYnVpbGRCaW5hcnkodCxpLGUscCxoLGF8fG8pO3JldHVybihhJiZ0aGlzLnR5cGU9PT1mLmNvYWxlc2NlfHxvJiYodGhpcy50eXBlPT09Zi5sb2dpY2FsT1J8fHRoaXMudHlwZT09PWYubG9naWNhbEFORCkpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwiTG9naWNhbCBleHByZXNzaW9ucyBhbmQgY29hbGVzY2UgZXhwcmVzc2lvbnMgY2Fubm90IGJlIG1peGVkLiBXcmFwIGVpdGhlciBieSBwYXJlbnRoZXNlcyIpLHRoaXMucGFyc2VFeHByT3AobSx0LGkscyxuKX1yZXR1cm4gZX0scS5idWlsZEJpbmFyeT1mdW5jdGlvbihlLHQsaSxzLG4scil7cy50eXBlPT09IlByaXZhdGVJZGVudGlmaWVyIiYmdGhpcy5yYWlzZShzLnN0YXJ0LCJQcml2YXRlIGlkZW50aWZpZXIgY2FuIG9ubHkgYmUgbGVmdCBzaWRlIG9mIGJpbmFyeSBleHByZXNzaW9uIik7dmFyIGE9dGhpcy5zdGFydE5vZGVBdChlLHQpO3JldHVybiBhLmxlZnQ9aSxhLm9wZXJhdG9yPW4sYS5yaWdodD1zLHRoaXMuZmluaXNoTm9kZShhLHI/IkxvZ2ljYWxFeHByZXNzaW9uIjoiQmluYXJ5RXhwcmVzc2lvbiIpfSxxLnBhcnNlTWF5YmVVbmFyeT1mdW5jdGlvbihlLHQsaSxzKXt2YXIgbixyPXRoaXMuc3RhcnQsYT10aGlzLnN0YXJ0TG9jO2lmKHRoaXMuaXNDb250ZXh0dWFsKCJhd2FpdCIpJiZ0aGlzLmNhbkF3YWl0KW49dGhpcy5wYXJzZUF3YWl0KHMpLHQ9ITA7ZWxzZSBpZih0aGlzLnR5cGUucHJlZml4KXt2YXIgbz10aGlzLnN0YXJ0Tm9kZSgpLGg9dGhpcy50eXBlPT09Zi5pbmNEZWM7by5vcGVyYXRvcj10aGlzLnZhbHVlLG8ucHJlZml4PSEwLHRoaXMubmV4dCgpLG8uYXJndW1lbnQ9dGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwhMCxoLHMpLHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKGUsITApLGg/dGhpcy5jaGVja0xWYWxTaW1wbGUoby5hcmd1bWVudCk6dGhpcy5zdHJpY3QmJm8ub3BlcmF0b3I9PT0iZGVsZXRlIiYmby5hcmd1bWVudC50eXBlPT09IklkZW50aWZpZXIiP3RoaXMucmFpc2VSZWNvdmVyYWJsZShvLnN0YXJ0LCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZSIpOm8ub3BlcmF0b3I9PT0iZGVsZXRlIiYmUmwoby5hcmd1bWVudCk/dGhpcy5yYWlzZVJlY292ZXJhYmxlKG8uc3RhcnQsIlByaXZhdGUgZmllbGRzIGNhbiBub3QgYmUgZGVsZXRlZCIpOnQ9ITAsbj10aGlzLmZpbmlzaE5vZGUobyxoPyJVcGRhdGVFeHByZXNzaW9uIjoiVW5hcnlFeHByZXNzaW9uIil9ZWxzZSBpZih0fHx0aGlzLnR5cGUhPT1mLnByaXZhdGVJZCl7aWYobj10aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoZSxzKSx0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhlKSlyZXR1cm4gbjtmb3IoO3RoaXMudHlwZS5wb3N0Zml4JiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTspe3ZhciBsPXRoaXMuc3RhcnROb2RlQXQocixhKTtsLm9wZXJhdG9yPXRoaXMudmFsdWUsbC5wcmVmaXg9ITEsbC5hcmd1bWVudD1uLHRoaXMuY2hlY2tMVmFsU2ltcGxlKG4pLHRoaXMubmV4dCgpLG49dGhpcy5maW5pc2hOb2RlKGwsIlVwZGF0ZUV4cHJlc3Npb24iKX19ZWxzZShzfHx0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoPT09MCkmJnRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMmJnRoaXMudW5leHBlY3RlZCgpLG49dGhpcy5wYXJzZVByaXZhdGVJZGVudCgpLHRoaXMudHlwZSE9PWYuX2luJiZ0aGlzLnVuZXhwZWN0ZWQoKTtyZXR1cm4gaXx8IXRoaXMuZWF0KGYuc3RhcnN0YXIpP246dD92b2lkIHRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk6dGhpcy5idWlsZEJpbmFyeShyLGEsbix0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCExLCExLHMpLCIqKiIsITEpfSxxLnBhcnNlRXhwclN1YnNjcmlwdHM9ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLnN0YXJ0LHM9dGhpcy5zdGFydExvYyxuPXRoaXMucGFyc2VFeHByQXRvbShlLHQpO2lmKG4udHlwZT09PSJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiImJnRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rU3RhcnQsdGhpcy5sYXN0VG9rRW5kKSE9PSIpIilyZXR1cm4gbjt2YXIgcj10aGlzLnBhcnNlU3Vic2NyaXB0cyhuLGkscywhMSx0KTtyZXR1cm4gZSYmci50eXBlPT09Ik1lbWJlckV4cHJlc3Npb24iJiYoZS5wYXJlbnRoZXNpemVkQXNzaWduPj1yLnN0YXJ0JiYoZS5wYXJlbnRoZXNpemVkQXNzaWduPS0xKSxlLnBhcmVudGhlc2l6ZWRCaW5kPj1yLnN0YXJ0JiYoZS5wYXJlbnRoZXNpemVkQmluZD0tMSksZS50cmFpbGluZ0NvbW1hPj1yLnN0YXJ0JiYoZS50cmFpbGluZ0NvbW1hPS0xKSkscn0scS5wYXJzZVN1YnNjcmlwdHM9ZnVuY3Rpb24oZSx0LGkscyxuKXtmb3IodmFyIHI9dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04JiZlLnR5cGU9PT0iSWRlbnRpZmllciImJmUubmFtZT09PSJhc3luYyImJnRoaXMubGFzdFRva0VuZD09PWUuZW5kJiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmZS5lbmQtZS5zdGFydD09NSYmdGhpcy5wb3RlbnRpYWxBcnJvd0F0PT09ZS5zdGFydCxhPSExOzspe3ZhciBvPXRoaXMucGFyc2VTdWJzY3JpcHQoZSx0LGkscyxyLGEsbik7aWYoby5vcHRpb25hbCYmKGE9ITApLG89PT1lfHxvLnR5cGU9PT0iQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iKXtpZihhKXt2YXIgaD10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7aC5leHByZXNzaW9uPW8sbz10aGlzLmZpbmlzaE5vZGUoaCwiQ2hhaW5FeHByZXNzaW9uIil9cmV0dXJuIG99ZT1vfX0scS5zaG91bGRQYXJzZUFzeW5jQXJyb3c9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmdGhpcy5lYXQoZi5hcnJvdyl9LHEucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93PWZ1bmN0aW9uKGUsdCxpLHMpe3JldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoZSx0KSxpLCEwLHMpfSxxLnBhcnNlU3Vic2NyaXB0PWZ1bmN0aW9uKGUsdCxpLHMsbixyLGEpe3ZhciBvPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEsaD1vJiZ0aGlzLmVhdChmLnF1ZXN0aW9uRG90KTtzJiZoJiZ0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zIik7dmFyIGw9dGhpcy5lYXQoZi5icmFja2V0TCk7aWYobHx8aCYmdGhpcy50eXBlIT09Zi5wYXJlbkwmJnRoaXMudHlwZSE9PWYuYmFja1F1b3RlfHx0aGlzLmVhdChmLmRvdCkpe3ZhciBjPXRoaXMuc3RhcnROb2RlQXQodCxpKTtjLm9iamVjdD1lLGw/KGMucHJvcGVydHk9dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLmV4cGVjdChmLmJyYWNrZXRSKSk6dGhpcy50eXBlPT09Zi5wcml2YXRlSWQmJmUudHlwZSE9PSJTdXBlciI/Yy5wcm9wZXJ0eT10aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCk6Yy5wcm9wZXJ0eT10aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQhPT0ibmV2ZXIiKSxjLmNvbXB1dGVkPSEhbCxvJiYoYy5vcHRpb25hbD1oKSxlPXRoaXMuZmluaXNoTm9kZShjLCJNZW1iZXJFeHByZXNzaW9uIil9ZWxzZSBpZighcyYmdGhpcy5lYXQoZi5wYXJlbkwpKXt2YXIgcD1uZXcgU24sbT10aGlzLnlpZWxkUG9zLHk9dGhpcy5hd2FpdFBvcyxFPXRoaXMuYXdhaXRJZGVudFBvczt0aGlzLnlpZWxkUG9zPTAsdGhpcy5hd2FpdFBvcz0wLHRoaXMuYXdhaXRJZGVudFBvcz0wO3ZhciBnPXRoaXMucGFyc2VFeHByTGlzdChmLnBhcmVuUix0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgsITEscCk7aWYobiYmIWgmJnRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpcmV0dXJuIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHAsITEpLHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCksdGhpcy5hd2FpdElkZW50UG9zPjAmJnRoaXMucmFpc2UodGhpcy5hd2FpdElkZW50UG9zLCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb24iKSx0aGlzLnlpZWxkUG9zPW0sdGhpcy5hd2FpdFBvcz15LHRoaXMuYXdhaXRJZGVudFBvcz1FLHRoaXMucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93KHQsaSxnLGEpO3RoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHAsITApLHRoaXMueWllbGRQb3M9bXx8dGhpcy55aWVsZFBvcyx0aGlzLmF3YWl0UG9zPXl8fHRoaXMuYXdhaXRQb3MsdGhpcy5hd2FpdElkZW50UG9zPUV8fHRoaXMuYXdhaXRJZGVudFBvczt2YXIgeD10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7eC5jYWxsZWU9ZSx4LmFyZ3VtZW50cz1nLG8mJih4Lm9wdGlvbmFsPWgpLGU9dGhpcy5maW5pc2hOb2RlKHgsIkNhbGxFeHByZXNzaW9uIil9ZWxzZSBpZih0aGlzLnR5cGU9PT1mLmJhY2tRdW90ZSl7KGh8fHIpJiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRhZyBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbnMiKTt2YXIgdj10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7di50YWc9ZSx2LnF1YXNpPXRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6ITB9KSxlPXRoaXMuZmluaXNoTm9kZSh2LCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iKX1yZXR1cm4gZX0scS5wYXJzZUV4cHJBdG9tPWZ1bmN0aW9uKGUsdCxpKXt0aGlzLnR5cGU9PT1mLnNsYXNoJiZ0aGlzLnJlYWRSZWdleHAoKTt2YXIgcyxuPXRoaXMucG90ZW50aWFsQXJyb3dBdD09PXRoaXMuc3RhcnQ7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZSBmLl9zdXBlcjpyZXR1cm4gdGhpcy5hbGxvd1N1cGVyfHx0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kIikscz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMubmV4dCgpLHRoaXMudHlwZSE9PWYucGFyZW5MfHx0aGlzLmFsbG93RGlyZWN0U3VwZXJ8fHRoaXMucmFpc2Uocy5zdGFydCwic3VwZXIoKSBjYWxsIG91dHNpZGUgY29uc3RydWN0b3Igb2YgYSBzdWJjbGFzcyIpLHRoaXMudHlwZSE9PWYuZG90JiZ0aGlzLnR5cGUhPT1mLmJyYWNrZXRMJiZ0aGlzLnR5cGUhPT1mLnBhcmVuTCYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5maW5pc2hOb2RlKHMsIlN1cGVyIik7Y2FzZSBmLl90aGlzOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCksdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsIlRoaXNFeHByZXNzaW9uIik7Y2FzZSBmLm5hbWU6dmFyIHI9dGhpcy5zdGFydCxhPXRoaXMuc3RhcnRMb2Msbz10aGlzLmNvbnRhaW5zRXNjLGg9dGhpcy5wYXJzZUlkZW50KCExKTtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJiFvJiZoLm5hbWU9PT0iYXN5bmMiJiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmdGhpcy5lYXQoZi5fZnVuY3Rpb24pKXJldHVybiB0aGlzLm92ZXJyaWRlQ29udGV4dChwZS5mX2V4cHIpLHRoaXMucGFyc2VGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0KHIsYSksMCwhMSwhMCx0KTtpZihuJiYhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSl7aWYodGhpcy5lYXQoZi5hcnJvdykpcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChyLGEpLFtoXSwhMSx0KTtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJmgubmFtZT09PSJhc3luYyImJnRoaXMudHlwZT09PWYubmFtZSYmIW8mJighdGhpcy5wb3RlbnRpYWxBcnJvd0luRm9yQXdhaXR8fHRoaXMudmFsdWUhPT0ib2YifHx0aGlzLmNvbnRhaW5zRXNjKSlyZXR1cm4gaD10aGlzLnBhcnNlSWRlbnQoITEpLCF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpJiZ0aGlzLmVhdChmLmFycm93KXx8dGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHIsYSksW2hdLCEwLHQpfXJldHVybiBoO2Nhc2UgZi5yZWdleHA6dmFyIGw9dGhpcy52YWx1ZTtyZXR1cm4ocz10aGlzLnBhcnNlTGl0ZXJhbChsLnZhbHVlKSkucmVnZXg9e3BhdHRlcm46bC5wYXR0ZXJuLGZsYWdzOmwuZmxhZ3N9LHM7Y2FzZSBmLm51bTpjYXNlIGYuc3RyaW5nOnJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtjYXNlIGYuX251bGw6Y2FzZSBmLl90cnVlOmNhc2UgZi5fZmFsc2U6cmV0dXJuKHM9dGhpcy5zdGFydE5vZGUoKSkudmFsdWU9dGhpcy50eXBlPT09Zi5fbnVsbD9udWxsOnRoaXMudHlwZT09PWYuX3RydWUscy5yYXc9dGhpcy50eXBlLmtleXdvcmQsdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKHMsIkxpdGVyYWwiKTtjYXNlIGYucGFyZW5MOnZhciBjPXRoaXMuc3RhcnQscD10aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24obix0KTtyZXR1cm4gZSYmKGUucGFyZW50aGVzaXplZEFzc2lnbjwwJiYhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChwKSYmKGUucGFyZW50aGVzaXplZEFzc2lnbj1jKSxlLnBhcmVudGhlc2l6ZWRCaW5kPDAmJihlLnBhcmVudGhlc2l6ZWRCaW5kPWMpKSxwO2Nhc2UgZi5icmFja2V0TDpyZXR1cm4gcz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMubmV4dCgpLHMuZWxlbWVudHM9dGhpcy5wYXJzZUV4cHJMaXN0KGYuYnJhY2tldFIsITAsITAsZSksdGhpcy5maW5pc2hOb2RlKHMsIkFycmF5RXhwcmVzc2lvbiIpO2Nhc2UgZi5icmFjZUw6cmV0dXJuIHRoaXMub3ZlcnJpZGVDb250ZXh0KHBlLmJfZXhwciksdGhpcy5wYXJzZU9iaighMSxlKTtjYXNlIGYuX2Z1bmN0aW9uOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCksdGhpcy5uZXh0KCksdGhpcy5wYXJzZUZ1bmN0aW9uKHMsMCk7Y2FzZSBmLl9jbGFzczpyZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMuc3RhcnROb2RlKCksITEpO2Nhc2UgZi5fbmV3OnJldHVybiB0aGlzLnBhcnNlTmV3KCk7Y2FzZSBmLmJhY2tRdW90ZTpyZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKCk7Y2FzZSBmLl9pbXBvcnQ6cmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTE/dGhpcy5wYXJzZUV4cHJJbXBvcnQoaSk6dGhpcy51bmV4cGVjdGVkKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5wYXJzZUV4cHJBdG9tRGVmYXVsdCgpfX0scS5wYXJzZUV4cHJBdG9tRGVmYXVsdD1mdW5jdGlvbigpe3RoaXMudW5leHBlY3RlZCgpfSxxLnBhcnNlRXhwckltcG9ydD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMuY29udGFpbnNFc2MmJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBpbXBvcnQiKTt2YXIgaT10aGlzLnBhcnNlSWRlbnQoITApO3JldHVybiB0aGlzLnR5cGUhPT1mLnBhcmVuTHx8ZT90aGlzLnR5cGU9PT1mLmRvdD8odC5tZXRhPWksdGhpcy5wYXJzZUltcG9ydE1ldGEodCkpOnZvaWQgdGhpcy51bmV4cGVjdGVkKCk6dGhpcy5wYXJzZUR5bmFtaWNJbXBvcnQodCl9LHEucGFyc2VEeW5hbWljSW1wb3J0PWZ1bmN0aW9uKGUpe2lmKHRoaXMubmV4dCgpLGUuc291cmNlPXRoaXMucGFyc2VNYXliZUFzc2lnbigpLCF0aGlzLmVhdChmLnBhcmVuUikpe3ZhciB0PXRoaXMuc3RhcnQ7dGhpcy5lYXQoZi5jb21tYSkmJnRoaXMuZWF0KGYucGFyZW5SKT90aGlzLnJhaXNlUmVjb3ZlcmFibGUodCwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KCkiKTp0aGlzLnVuZXhwZWN0ZWQodCl9cmV0dXJuIHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnRFeHByZXNzaW9uIil9LHEucGFyc2VJbXBvcnRNZXRhPWZ1bmN0aW9uKGUpe3RoaXMubmV4dCgpO3ZhciB0PXRoaXMuY29udGFpbnNFc2M7cmV0dXJuIGUucHJvcGVydHk9dGhpcy5wYXJzZUlkZW50KCEwKSxlLnByb3BlcnR5Lm5hbWUhPT0ibWV0YSImJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnByb3BlcnR5LnN0YXJ0LCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBpbXBvcnQgaXMgJ2ltcG9ydC5tZXRhJyIpLHQmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzIiksdGhpcy5vcHRpb25zLnNvdXJjZVR5cGU9PT0ibW9kdWxlInx8dGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZXx8dGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIkNhbm5vdCB1c2UgJ2ltcG9ydC5tZXRhJyBvdXRzaWRlIGEgbW9kdWxlIiksdGhpcy5maW5pc2hOb2RlKGUsIk1ldGFQcm9wZXJ0eSIpfSxxLnBhcnNlTGl0ZXJhbD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0LnZhbHVlPWUsdC5yYXc9dGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LHRoaXMuZW5kKSx0LnJhdy5jaGFyQ29kZUF0KHQucmF3Lmxlbmd0aC0xKT09PTExMCYmKHQuYmlnaW50PXQucmF3LnNsaWNlKDAsLTEpLnJlcGxhY2UoL18vZywiIikpLHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZSh0LCJMaXRlcmFsIil9LHEucGFyc2VQYXJlbkV4cHJlc3Npb249ZnVuY3Rpb24oKXt0aGlzLmV4cGVjdChmLnBhcmVuTCk7dmFyIGU9dGhpcy5wYXJzZUV4cHJlc3Npb24oKTtyZXR1cm4gdGhpcy5leHBlY3QoZi5wYXJlblIpLGV9LHEuc2hvdWxkUGFyc2VBcnJvdz1mdW5jdGlvbihlKXtyZXR1cm4hdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKX0scS5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uPWZ1bmN0aW9uKGUsdCl7dmFyIGkscz10aGlzLnN0YXJ0LG49dGhpcy5zdGFydExvYyxyPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49ODtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYpe3RoaXMubmV4dCgpO3ZhciBhLG89dGhpcy5zdGFydCxoPXRoaXMuc3RhcnRMb2MsbD1bXSxjPSEwLHA9ITEsbT1uZXcgU24seT10aGlzLnlpZWxkUG9zLEU9dGhpcy5hd2FpdFBvcztmb3IodGhpcy55aWVsZFBvcz0wLHRoaXMuYXdhaXRQb3M9MDt0aGlzLnR5cGUhPT1mLnBhcmVuUjspe2lmKGM/Yz0hMTp0aGlzLmV4cGVjdChmLmNvbW1hKSxyJiZ0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShmLnBhcmVuUiwhMCkpe3A9ITA7YnJlYWt9aWYodGhpcy50eXBlPT09Zi5lbGxpcHNpcyl7YT10aGlzLnN0YXJ0LGwucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpKSksdGhpcy50eXBlPT09Zi5jb21tYSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudCIpO2JyZWFrfWwucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oITEsbSx0aGlzLnBhcnNlUGFyZW5JdGVtKSl9dmFyIGc9dGhpcy5sYXN0VG9rRW5kLHg9dGhpcy5sYXN0VG9rRW5kTG9jO2lmKHRoaXMuZXhwZWN0KGYucGFyZW5SKSxlJiZ0aGlzLnNob3VsZFBhcnNlQXJyb3cobCkmJnRoaXMuZWF0KGYuYXJyb3cpKXJldHVybiB0aGlzLmNoZWNrUGF0dGVybkVycm9ycyhtLCExKSx0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpLHRoaXMueWllbGRQb3M9eSx0aGlzLmF3YWl0UG9zPUUsdGhpcy5wYXJzZVBhcmVuQXJyb3dMaXN0KHMsbixsLHQpO2wubGVuZ3RoJiYhcHx8dGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KSxhJiZ0aGlzLnVuZXhwZWN0ZWQoYSksdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMobSwhMCksdGhpcy55aWVsZFBvcz15fHx0aGlzLnlpZWxkUG9zLHRoaXMuYXdhaXRQb3M9RXx8dGhpcy5hd2FpdFBvcyxsLmxlbmd0aD4xPygoaT10aGlzLnN0YXJ0Tm9kZUF0KG8saCkpLmV4cHJlc3Npb25zPWwsdGhpcy5maW5pc2hOb2RlQXQoaSwiU2VxdWVuY2VFeHByZXNzaW9uIixnLHgpKTppPWxbMF19ZWxzZSBpPXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtpZih0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpe3ZhciB2PXRoaXMuc3RhcnROb2RlQXQocyxuKTtyZXR1cm4gdi5leHByZXNzaW9uPWksdGhpcy5maW5pc2hOb2RlKHYsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIil9cmV0dXJuIGl9LHEucGFyc2VQYXJlbkl0ZW09ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LHEucGFyc2VQYXJlbkFycm93TGlzdD1mdW5jdGlvbihlLHQsaSxzKXtyZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KGUsdCksaSwhMSxzKX07dmFyIGtmPVtdO3EucGFyc2VOZXc9ZnVuY3Rpb24oKXt0aGlzLmNvbnRhaW5zRXNjJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgbmV3Iik7dmFyIGU9dGhpcy5zdGFydE5vZGUoKSx0PXRoaXMucGFyc2VJZGVudCghMCk7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiZ0aGlzLmVhdChmLmRvdCkpe2UubWV0YT10O3ZhciBpPXRoaXMuY29udGFpbnNFc2M7cmV0dXJuIGUucHJvcGVydHk9dGhpcy5wYXJzZUlkZW50KCEwKSxlLnByb3BlcnR5Lm5hbWUhPT0idGFyZ2V0IiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUucHJvcGVydHkuc3RhcnQsIlRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yIG5ldyBpcyAnbmV3LnRhcmdldCciKSxpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiJ25ldy50YXJnZXQnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzIiksdGhpcy5hbGxvd05ld0RvdFRhcmdldHx8dGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIiduZXcudGFyZ2V0JyBjYW4gb25seSBiZSB1c2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3Mgc3RhdGljIGJsb2NrIiksdGhpcy5maW5pc2hOb2RlKGUsIk1ldGFQcm9wZXJ0eSIpfXZhciBzPXRoaXMuc3RhcnQsbj10aGlzLnN0YXJ0TG9jO3JldHVybiBlLmNhbGxlZT10aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20obnVsbCwhMSwhMCkscyxuLCEwLCExKSx0aGlzLmVhdChmLnBhcmVuTCk/ZS5hcmd1bWVudHM9dGhpcy5wYXJzZUV4cHJMaXN0KGYucGFyZW5SLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCwhMSk6ZS5hcmd1bWVudHM9a2YsdGhpcy5maW5pc2hOb2RlKGUsIk5ld0V4cHJlc3Npb24iKX0scS5wYXJzZVRlbXBsYXRlRWxlbWVudD1mdW5jdGlvbihlKXt2YXIgdD1lLmlzVGFnZ2VkLGk9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy50eXBlPT09Zi5pbnZhbGlkVGVtcGxhdGU/KHR8fHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCJCYWQgZXNjYXBlIHNlcXVlbmNlIGluIHVudGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWwiKSxpLnZhbHVlPXtyYXc6dGhpcy52YWx1ZSxjb29rZWQ6bnVsbH0pOmkudmFsdWU9e3Jhdzp0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5lbmQpLnJlcGxhY2UoL1xyXG4/L2csYApgKSxjb29rZWQ6dGhpcy52YWx1ZX0sdGhpcy5uZXh0KCksaS50YWlsPXRoaXMudHlwZT09PWYuYmFja1F1b3RlLHRoaXMuZmluaXNoTm9kZShpLCJUZW1wbGF0ZUVsZW1lbnQiKX0scS5wYXJzZVRlbXBsYXRlPWZ1bmN0aW9uKGUpe2U9PT12b2lkIDAmJihlPXt9KTt2YXIgdD1lLmlzVGFnZ2VkO3Q9PT12b2lkIDAmJih0PSExKTt2YXIgaT10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMubmV4dCgpLGkuZXhwcmVzc2lvbnM9W107dmFyIHM9dGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6dH0pO2ZvcihpLnF1YXNpcz1bc107IXMudGFpbDspdGhpcy50eXBlPT09Zi5lb2YmJnRoaXMucmFpc2UodGhpcy5wb3MsIlVudGVybWluYXRlZCB0ZW1wbGF0ZSBsaXRlcmFsIiksdGhpcy5leHBlY3QoZi5kb2xsYXJCcmFjZUwpLGkuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlRXhwcmVzc2lvbigpKSx0aGlzLmV4cGVjdChmLmJyYWNlUiksaS5xdWFzaXMucHVzaChzPXRoaXMucGFyc2VUZW1wbGF0ZUVsZW1lbnQoe2lzVGFnZ2VkOnR9KSk7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZShpLCJUZW1wbGF0ZUxpdGVyYWwiKX0scS5pc0FzeW5jUHJvcD1mdW5jdGlvbihlKXtyZXR1cm4hZS5jb21wdXRlZCYmZS5rZXkudHlwZT09PSJJZGVudGlmaWVyIiYmZS5rZXkubmFtZT09PSJhc3luYyImJih0aGlzLnR5cGU9PT1mLm5hbWV8fHRoaXMudHlwZT09PWYubnVtfHx0aGlzLnR5cGU9PT1mLnN0cmluZ3x8dGhpcy50eXBlPT09Zi5icmFja2V0THx8dGhpcy50eXBlLmtleXdvcmR8fHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmdGhpcy50eXBlPT09Zi5zdGFyKSYmIUtlLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsdGhpcy5zdGFydCkpfSxxLnBhcnNlT2JqPWZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcy5zdGFydE5vZGUoKSxzPSEwLG49e307Zm9yKGkucHJvcGVydGllcz1bXSx0aGlzLm5leHQoKTshdGhpcy5lYXQoZi5icmFjZVIpOyl7aWYocylzPSExO2Vsc2UgaWYodGhpcy5leHBlY3QoZi5jb21tYSksdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj01JiZ0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShmLmJyYWNlUikpYnJlYWs7dmFyIHI9dGhpcy5wYXJzZVByb3BlcnR5KGUsdCk7ZXx8dGhpcy5jaGVja1Byb3BDbGFzaChyLG4sdCksaS5wcm9wZXJ0aWVzLnB1c2gocil9cmV0dXJuIHRoaXMuZmluaXNoTm9kZShpLGU/Ik9iamVjdFBhdHRlcm4iOiJPYmplY3RFeHByZXNzaW9uIil9LHEucGFyc2VQcm9wZXJ0eT1mdW5jdGlvbihlLHQpe3ZhciBpLHMsbixyLGE9dGhpcy5zdGFydE5vZGUoKTtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJnRoaXMuZWF0KGYuZWxsaXBzaXMpKXJldHVybiBlPyhhLmFyZ3VtZW50PXRoaXMucGFyc2VJZGVudCghMSksdGhpcy50eXBlPT09Zi5jb21tYSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudCIpLHRoaXMuZmluaXNoTm9kZShhLCJSZXN0RWxlbWVudCIpKTooYS5hcmd1bWVudD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oITEsdCksdGhpcy50eXBlPT09Zi5jb21tYSYmdCYmdC50cmFpbGluZ0NvbW1hPDAmJih0LnRyYWlsaW5nQ29tbWE9dGhpcy5zdGFydCksdGhpcy5maW5pc2hOb2RlKGEsIlNwcmVhZEVsZW1lbnQiKSk7dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiYoYS5tZXRob2Q9ITEsYS5zaG9ydGhhbmQ9ITEsKGV8fHQpJiYobj10aGlzLnN0YXJ0LHI9dGhpcy5zdGFydExvYyksZXx8KGk9dGhpcy5lYXQoZi5zdGFyKSkpO3ZhciBvPXRoaXMuY29udGFpbnNFc2M7cmV0dXJuIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoYSksIWUmJiFvJiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJiFpJiZ0aGlzLmlzQXN5bmNQcm9wKGEpPyhzPSEwLGk9dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiZ0aGlzLmVhdChmLnN0YXIpLHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoYSkpOnM9ITEsdGhpcy5wYXJzZVByb3BlcnR5VmFsdWUoYSxlLGkscyxuLHIsdCxvKSx0aGlzLmZpbmlzaE5vZGUoYSwiUHJvcGVydHkiKX0scS5wYXJzZUdldHRlclNldHRlcj1mdW5jdGlvbihlKXtlLmtpbmQ9ZS5rZXkubmFtZSx0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGUpLGUudmFsdWU9dGhpcy5wYXJzZU1ldGhvZCghMSk7dmFyIHQ9ZS5raW5kPT09ImdldCI/MDoxO2lmKGUudmFsdWUucGFyYW1zLmxlbmd0aCE9PXQpe3ZhciBpPWUudmFsdWUuc3RhcnQ7ZS5raW5kPT09ImdldCI/dGhpcy5yYWlzZVJlY292ZXJhYmxlKGksImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXMiKTp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoaSwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtIil9ZWxzZSBlLmtpbmQ9PT0ic2V0IiYmZS52YWx1ZS5wYXJhbXNbMF0udHlwZT09PSJSZXN0RWxlbWVudCImJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnZhbHVlLnBhcmFtc1swXS5zdGFydCwiU2V0dGVyIGNhbm5vdCB1c2UgcmVzdCBwYXJhbXMiKX0scS5wYXJzZVByb3BlcnR5VmFsdWU9ZnVuY3Rpb24oZSx0LGkscyxuLHIsYSxvKXsoaXx8cykmJnRoaXMudHlwZT09PWYuY29sb24mJnRoaXMudW5leHBlY3RlZCgpLHRoaXMuZWF0KGYuY29sb24pPyhlLnZhbHVlPXQ/dGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXJ0LHRoaXMuc3RhcnRMb2MpOnRoaXMucGFyc2VNYXliZUFzc2lnbighMSxhKSxlLmtpbmQ9ImluaXQiKTp0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJnRoaXMudHlwZT09PWYucGFyZW5MPyh0JiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLmtpbmQ9ImluaXQiLGUubWV0aG9kPSEwLGUudmFsdWU9dGhpcy5wYXJzZU1ldGhvZChpLHMpKTp0fHxvfHwhKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NSl8fGUuY29tcHV0ZWR8fGUua2V5LnR5cGUhPT0iSWRlbnRpZmllciJ8fGUua2V5Lm5hbWUhPT0iZ2V0IiYmZS5rZXkubmFtZSE9PSJzZXQifHx0aGlzLnR5cGU9PT1mLmNvbW1hfHx0aGlzLnR5cGU9PT1mLmJyYWNlUnx8dGhpcy50eXBlPT09Zi5lcT90aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJiFlLmNvbXB1dGVkJiZlLmtleS50eXBlPT09IklkZW50aWZpZXIiPygoaXx8cykmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMuY2hlY2tVbnJlc2VydmVkKGUua2V5KSxlLmtleS5uYW1lIT09ImF3YWl0Inx8dGhpcy5hd2FpdElkZW50UG9zfHwodGhpcy5hd2FpdElkZW50UG9zPW4pLGUua2luZD0iaW5pdCIsdD9lLnZhbHVlPXRoaXMucGFyc2VNYXliZURlZmF1bHQobixyLHRoaXMuY29weU5vZGUoZS5rZXkpKTp0aGlzLnR5cGU9PT1mLmVxJiZhPyhhLnNob3J0aGFuZEFzc2lnbjwwJiYoYS5zaG9ydGhhbmRBc3NpZ249dGhpcy5zdGFydCksZS52YWx1ZT10aGlzLnBhcnNlTWF5YmVEZWZhdWx0KG4scix0aGlzLmNvcHlOb2RlKGUua2V5KSkpOmUudmFsdWU9dGhpcy5jb3B5Tm9kZShlLmtleSksZS5zaG9ydGhhbmQ9ITApOnRoaXMudW5leHBlY3RlZCgpOigoaXx8cykmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMucGFyc2VHZXR0ZXJTZXR0ZXIoZSkpfSxxLnBhcnNlUHJvcGVydHlOYW1lPWZ1bmN0aW9uKGUpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49Nil7aWYodGhpcy5lYXQoZi5icmFja2V0TCkpcmV0dXJuIGUuY29tcHV0ZWQ9ITAsZS5rZXk9dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdGhpcy5leHBlY3QoZi5icmFja2V0UiksZS5rZXk7ZS5jb21wdXRlZD0hMX1yZXR1cm4gZS5rZXk9dGhpcy50eXBlPT09Zi5udW18fHRoaXMudHlwZT09PWYuc3RyaW5nP3RoaXMucGFyc2VFeHByQXRvbSgpOnRoaXMucGFyc2VJZGVudCh0aGlzLm9wdGlvbnMuYWxsb3dSZXNlcnZlZCE9PSJuZXZlciIpfSxxLmluaXRGdW5jdGlvbj1mdW5jdGlvbihlKXtlLmlkPW51bGwsdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiYoZS5nZW5lcmF0b3I9ZS5leHByZXNzaW9uPSExKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJihlLmFzeW5jPSExKX0scS5wYXJzZU1ldGhvZD1mdW5jdGlvbihlLHQsaSl7dmFyIHM9dGhpcy5zdGFydE5vZGUoKSxuPXRoaXMueWllbGRQb3Mscj10aGlzLmF3YWl0UG9zLGE9dGhpcy5hd2FpdElkZW50UG9zO3JldHVybiB0aGlzLmluaXRGdW5jdGlvbihzKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJihzLmdlbmVyYXRvcj1lKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJihzLmFzeW5jPSEhdCksdGhpcy55aWVsZFBvcz0wLHRoaXMuYXdhaXRQb3M9MCx0aGlzLmF3YWl0SWRlbnRQb3M9MCx0aGlzLmVudGVyU2NvcGUoNjR8dWEodCxzLmdlbmVyYXRvcil8KGk/MTI4OjApKSx0aGlzLmV4cGVjdChmLnBhcmVuTCkscy5wYXJhbXM9dGhpcy5wYXJzZUJpbmRpbmdMaXN0KGYucGFyZW5SLCExLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCksdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKSx0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KHMsITEsITAsITEpLHRoaXMueWllbGRQb3M9bix0aGlzLmF3YWl0UG9zPXIsdGhpcy5hd2FpdElkZW50UG9zPWEsdGhpcy5maW5pc2hOb2RlKHMsIkZ1bmN0aW9uRXhwcmVzc2lvbiIpfSxxLnBhcnNlQXJyb3dFeHByZXNzaW9uPWZ1bmN0aW9uKGUsdCxpLHMpe3ZhciBuPXRoaXMueWllbGRQb3Mscj10aGlzLmF3YWl0UG9zLGE9dGhpcy5hd2FpdElkZW50UG9zO3JldHVybiB0aGlzLmVudGVyU2NvcGUoMTZ8dWEoaSwhMSkpLHRoaXMuaW5pdEZ1bmN0aW9uKGUpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCYmKGUuYXN5bmM9ISFpKSx0aGlzLnlpZWxkUG9zPTAsdGhpcy5hd2FpdFBvcz0wLHRoaXMuYXdhaXRJZGVudFBvcz0wLGUucGFyYW1zPXRoaXMudG9Bc3NpZ25hYmxlTGlzdCh0LCEwKSx0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KGUsITAsITEscyksdGhpcy55aWVsZFBvcz1uLHRoaXMuYXdhaXRQb3M9cix0aGlzLmF3YWl0SWRlbnRQb3M9YSx0aGlzLmZpbmlzaE5vZGUoZSwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iKX0scS5wYXJzZUZ1bmN0aW9uQm9keT1mdW5jdGlvbihlLHQsaSxzKXt2YXIgbj10JiZ0aGlzLnR5cGUhPT1mLmJyYWNlTCxyPXRoaXMuc3RyaWN0LGE9ITE7aWYobillLmJvZHk9dGhpcy5wYXJzZU1heWJlQXNzaWduKHMpLGUuZXhwcmVzc2lvbj0hMCx0aGlzLmNoZWNrUGFyYW1zKGUsITEpO2Vsc2V7dmFyIG89dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj03JiYhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChlLnBhcmFtcyk7ciYmIW98fChhPXRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKSkmJm8mJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0Iik7dmFyIGg9dGhpcy5sYWJlbHM7dGhpcy5sYWJlbHM9W10sYSYmKHRoaXMuc3RyaWN0PSEwKSx0aGlzLmNoZWNrUGFyYW1zKGUsIXImJiFhJiYhdCYmIWkmJnRoaXMuaXNTaW1wbGVQYXJhbUxpc3QoZS5wYXJhbXMpKSx0aGlzLnN0cmljdCYmZS5pZCYmdGhpcy5jaGVja0xWYWxTaW1wbGUoZS5pZCw1KSxlLmJvZHk9dGhpcy5wYXJzZUJsb2NrKCExLHZvaWQgMCxhJiYhciksZS5leHByZXNzaW9uPSExLHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShlLmJvZHkuYm9keSksdGhpcy5sYWJlbHM9aH10aGlzLmV4aXRTY29wZSgpfSxxLmlzU2ltcGxlUGFyYW1MaXN0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLGk9ZTt0PGkubGVuZ3RoO3QrPTEpaWYoaVt0XS50eXBlIT09IklkZW50aWZpZXIiKXJldHVybiExO3JldHVybiEwfSxxLmNoZWNrUGFyYW1zPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPU9iamVjdC5jcmVhdGUobnVsbCkscz0wLG49ZS5wYXJhbXM7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHIsMSx0P251bGw6aSl9fSxxLnBhcnNlRXhwckxpc3Q9ZnVuY3Rpb24oZSx0LGkscyl7Zm9yKHZhciBuPVtdLHI9ITA7IXRoaXMuZWF0KGUpOyl7aWYocilyPSExO2Vsc2UgaWYodGhpcy5leHBlY3QoZi5jb21tYSksdCYmdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoZSkpYnJlYWs7dmFyIGE9dm9pZCAwO2kmJnRoaXMudHlwZT09PWYuY29tbWE/YT1udWxsOnRoaXMudHlwZT09PWYuZWxsaXBzaXM/KGE9dGhpcy5wYXJzZVNwcmVhZChzKSxzJiZ0aGlzLnR5cGU9PT1mLmNvbW1hJiZzLnRyYWlsaW5nQ29tbWE8MCYmKHMudHJhaWxpbmdDb21tYT10aGlzLnN0YXJ0KSk6YT10aGlzLnBhcnNlTWF5YmVBc3NpZ24oITEscyksbi5wdXNoKGEpfXJldHVybiBufSxxLmNoZWNrVW5yZXNlcnZlZD1mdW5jdGlvbihlKXt2YXIgdD1lLnN0YXJ0LGk9ZS5lbmQscz1lLm5hbWU7dGhpcy5pbkdlbmVyYXRvciYmcz09PSJ5aWVsZCImJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0LCJDYW5ub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3IiKSx0aGlzLmluQXN5bmMmJnM9PT0iYXdhaXQiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodCwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uIiksdGhpcy5jdXJyZW50VGhpc1Njb3BlKCkuaW5DbGFzc0ZpZWxkSW5pdCYmcz09PSJhcmd1bWVudHMiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodCwiQ2Fubm90IHVzZSAnYXJndW1lbnRzJyBpbiBjbGFzcyBmaWVsZCBpbml0aWFsaXplciIpLCF0aGlzLmluQ2xhc3NTdGF0aWNCbG9ja3x8cyE9PSJhcmd1bWVudHMiJiZzIT09ImF3YWl0Inx8dGhpcy5yYWlzZSh0LCJDYW5ub3QgdXNlICIrcysiIGluIGNsYXNzIHN0YXRpYyBpbml0aWFsaXphdGlvbiBibG9jayIpLHRoaXMua2V5d29yZHMudGVzdChzKSYmdGhpcy5yYWlzZSh0LCJVbmV4cGVjdGVkIGtleXdvcmQgJyIrcysiJyIpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjw2JiZ0aGlzLmlucHV0LnNsaWNlKHQsaSkuaW5kZXhPZigiXFwiKSE9PS0xfHwodGhpcy5zdHJpY3Q/dGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0OnRoaXMucmVzZXJ2ZWRXb3JkcykudGVzdChzKSYmKHRoaXMuaW5Bc3luY3x8cyE9PSJhd2FpdCJ8fHRoaXMucmFpc2VSZWNvdmVyYWJsZSh0LCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uIiksdGhpcy5yYWlzZVJlY292ZXJhYmxlKHQsIlRoZSBrZXl3b3JkICciK3MrIicgaXMgcmVzZXJ2ZWQiKSl9LHEucGFyc2VJZGVudD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBhcnNlSWRlbnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCghIWUpLHRoaXMuZmluaXNoTm9kZSh0LCJJZGVudGlmaWVyIiksZXx8KHRoaXMuY2hlY2tVbnJlc2VydmVkKHQpLHQubmFtZSE9PSJhd2FpdCJ8fHRoaXMuYXdhaXRJZGVudFBvc3x8KHRoaXMuYXdhaXRJZGVudFBvcz10LnN0YXJ0KSksdH0scS5wYXJzZUlkZW50Tm9kZT1mdW5jdGlvbigpe3ZhciBlPXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMudHlwZT09PWYubmFtZT9lLm5hbWU9dGhpcy52YWx1ZTp0aGlzLnR5cGUua2V5d29yZD8oZS5uYW1lPXRoaXMudHlwZS5rZXl3b3JkLGUubmFtZSE9PSJjbGFzcyImJmUubmFtZSE9PSJmdW5jdGlvbiJ8fHRoaXMubGFzdFRva0VuZD09PXRoaXMubGFzdFRva1N0YXJ0KzEmJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCk9PT00Nnx8dGhpcy5jb250ZXh0LnBvcCgpKTp0aGlzLnVuZXhwZWN0ZWQoKSxlfSxxLnBhcnNlUHJpdmF0ZUlkZW50PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy50eXBlPT09Zi5wcml2YXRlSWQ/ZS5uYW1lPXRoaXMudmFsdWU6dGhpcy51bmV4cGVjdGVkKCksdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKGUsIlByaXZhdGVJZGVudGlmaWVyIiksdGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcyYmKHRoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGg9PT0wP3RoaXMucmFpc2UoZS5zdGFydCwiUHJpdmF0ZSBmaWVsZCAnIyIrZS5uYW1lKyInIG11c3QgYmUgZGVjbGFyZWQgaW4gYW4gZW5jbG9zaW5nIGNsYXNzIik6dGhpcy5wcml2YXRlTmFtZVN0YWNrW3RoaXMucHJpdmF0ZU5hbWVTdGFjay5sZW5ndGgtMV0udXNlZC5wdXNoKGUpKSxlfSxxLnBhcnNlWWllbGQ9ZnVuY3Rpb24oZSl7dGhpcy55aWVsZFBvc3x8KHRoaXMueWllbGRQb3M9dGhpcy5zdGFydCk7dmFyIHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy50eXBlPT09Zi5zZW1pfHx0aGlzLmNhbkluc2VydFNlbWljb2xvbigpfHx0aGlzLnR5cGUhPT1mLnN0YXImJiF0aGlzLnR5cGUuc3RhcnRzRXhwcj8odC5kZWxlZ2F0ZT0hMSx0LmFyZ3VtZW50PW51bGwpOih0LmRlbGVnYXRlPXRoaXMuZWF0KGYuc3RhciksdC5hcmd1bWVudD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSkpLHRoaXMuZmluaXNoTm9kZSh0LCJZaWVsZEV4cHJlc3Npb24iKX0scS5wYXJzZUF3YWl0PWZ1bmN0aW9uKGUpe3RoaXMuYXdhaXRQb3N8fCh0aGlzLmF3YWl0UG9zPXRoaXMuc3RhcnQpO3ZhciB0PXRoaXMuc3RhcnROb2RlKCk7cmV0dXJuIHRoaXMubmV4dCgpLHQuYXJndW1lbnQ9dGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwhMCwhMSxlKSx0aGlzLmZpbmlzaE5vZGUodCwiQXdhaXRFeHByZXNzaW9uIil9O3ZhciB3bj1nZS5wcm90b3R5cGU7d24ucmFpc2U9ZnVuY3Rpb24oZSx0KXt2YXIgaT1sYSh0aGlzLmlucHV0LGUpO3QrPSIgKCIraS5saW5lKyI6IitpLmNvbHVtbisiKSI7dmFyIHM9bmV3IFN5bnRheEVycm9yKHQpO3Rocm93IHMucG9zPWUscy5sb2M9aSxzLnJhaXNlZEF0PXRoaXMucG9zLHN9LHduLnJhaXNlUmVjb3ZlcmFibGU9d24ucmFpc2Usd24uY3VyUG9zaXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLm9wdGlvbnMubG9jYXRpb25zKXJldHVybiBuZXcgT2kodGhpcy5jdXJMaW5lLHRoaXMucG9zLXRoaXMubGluZVN0YXJ0KX07dmFyIEt0PWdlLnByb3RvdHlwZSx3Zj1mdW5jdGlvbihlKXt0aGlzLmZsYWdzPWUsdGhpcy52YXI9W10sdGhpcy5sZXhpY2FsPVtdLHRoaXMuZnVuY3Rpb25zPVtdLHRoaXMuaW5DbGFzc0ZpZWxkSW5pdD0hMX07S3QuZW50ZXJTY29wZT1mdW5jdGlvbihlKXt0aGlzLnNjb3BlU3RhY2sucHVzaChuZXcgd2YoZSkpfSxLdC5leGl0U2NvcGU9ZnVuY3Rpb24oKXt0aGlzLnNjb3BlU3RhY2sucG9wKCl9LEt0LnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlPWZ1bmN0aW9uKGUpe3JldHVybiAyJmUuZmxhZ3N8fCF0aGlzLmluTW9kdWxlJiYxJmUuZmxhZ3N9LEt0LmRlY2xhcmVOYW1lPWZ1bmN0aW9uKGUsdCxpKXt2YXIgcz0hMTtpZih0PT09Mil7dmFyIG49dGhpcy5jdXJyZW50U2NvcGUoKTtzPW4ubGV4aWNhbC5pbmRleE9mKGUpPi0xfHxuLmZ1bmN0aW9ucy5pbmRleE9mKGUpPi0xfHxuLnZhci5pbmRleE9mKGUpPi0xLG4ubGV4aWNhbC5wdXNoKGUpLHRoaXMuaW5Nb2R1bGUmJjEmbi5mbGFncyYmZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tlXX1lbHNlIGlmKHQ9PT00KXRoaXMuY3VycmVudFNjb3BlKCkubGV4aWNhbC5wdXNoKGUpO2Vsc2UgaWYodD09PTMpe3ZhciByPXRoaXMuY3VycmVudFNjb3BlKCk7cz10aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXI/ci5sZXhpY2FsLmluZGV4T2YoZSk+LTE6ci5sZXhpY2FsLmluZGV4T2YoZSk+LTF8fHIudmFyLmluZGV4T2YoZSk+LTEsci5mdW5jdGlvbnMucHVzaChlKX1lbHNlIGZvcih2YXIgYT10aGlzLnNjb3BlU3RhY2subGVuZ3RoLTE7YT49MDstLWEpe3ZhciBvPXRoaXMuc2NvcGVTdGFja1thXTtpZihvLmxleGljYWwuaW5kZXhPZihlKT4tMSYmISgzMiZvLmZsYWdzJiZvLmxleGljYWxbMF09PT1lKXx8IXRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUobykmJm8uZnVuY3Rpb25zLmluZGV4T2YoZSk+LTEpe3M9ITA7YnJlYWt9aWYoby52YXIucHVzaChlKSx0aGlzLmluTW9kdWxlJiYxJm8uZmxhZ3MmJmRlbGV0ZSB0aGlzLnVuZGVmaW5lZEV4cG9ydHNbZV0sMjU5Jm8uZmxhZ3MpYnJlYWt9cyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGksIklkZW50aWZpZXIgJyIrZSsiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkIil9LEt0LmNoZWNrTG9jYWxFeHBvcnQ9ZnVuY3Rpb24oZSl7dGhpcy5zY29wZVN0YWNrWzBdLmxleGljYWwuaW5kZXhPZihlLm5hbWUpPT09LTEmJnRoaXMuc2NvcGVTdGFja1swXS52YXIuaW5kZXhPZihlLm5hbWUpPT09LTEmJih0aGlzLnVuZGVmaW5lZEV4cG9ydHNbZS5uYW1lXT1lKX0sS3QuY3VycmVudFNjb3BlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoLTFdfSxLdC5jdXJyZW50VmFyU2NvcGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xOztlLS0pe3ZhciB0PXRoaXMuc2NvcGVTdGFja1tlXTtpZigyNTkmdC5mbGFncylyZXR1cm4gdH19LEt0LmN1cnJlbnRUaGlzU2NvcGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xOztlLS0pe3ZhciB0PXRoaXMuc2NvcGVTdGFja1tlXTtpZigyNTkmdC5mbGFncyYmISgxNiZ0LmZsYWdzKSlyZXR1cm4gdH19O3ZhciBicz1mdW5jdGlvbihlLHQsaSl7dGhpcy50eXBlPSIiLHRoaXMuc3RhcnQ9dCx0aGlzLmVuZD0wLGUub3B0aW9ucy5sb2NhdGlvbnMmJih0aGlzLmxvYz1uZXcgeXMoZSxpKSksZS5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUmJih0aGlzLnNvdXJjZUZpbGU9ZS5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGUpLGUub3B0aW9ucy5yYW5nZXMmJih0aGlzLnJhbmdlPVt0LDBdKX0sdnM9Z2UucHJvdG90eXBlO2Z1bmN0aW9uIE9sKGUsdCxpLHMpe3JldHVybiBlLnR5cGU9dCxlLmVuZD1pLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9cyksdGhpcy5vcHRpb25zLnJhbmdlcyYmKGUucmFuZ2VbMV09aSksZX12cy5zdGFydE5vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGJzKHRoaXMsdGhpcy5zdGFydCx0aGlzLnN0YXJ0TG9jKX0sdnMuc3RhcnROb2RlQXQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IGJzKHRoaXMsZSx0KX0sdnMuZmluaXNoTm9kZT1mdW5jdGlvbihlLHQpe3JldHVybiBPbC5jYWxsKHRoaXMsZSx0LHRoaXMubGFzdFRva0VuZCx0aGlzLmxhc3RUb2tFbmRMb2MpfSx2cy5maW5pc2hOb2RlQXQ9ZnVuY3Rpb24oZSx0LGkscyl7cmV0dXJuIE9sLmNhbGwodGhpcyxlLHQsaSxzKX0sdnMuY29weU5vZGU9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGJzKHRoaXMsZS5zdGFydCx0aGlzLnN0YXJ0TG9jKTtmb3IodmFyIGkgaW4gZSl0W2ldPWVbaV07cmV0dXJuIHR9O3ZhciBWbD0iQVNDSUkgQVNDSUlfSGV4X0RpZ2l0IEFIZXggQWxwaGFiZXRpYyBBbHBoYSBBbnkgQXNzaWduZWQgQmlkaV9Db250cm9sIEJpZGlfQyBCaWRpX01pcnJvcmVkIEJpZGlfTSBDYXNlX0lnbm9yYWJsZSBDSSBDYXNlZCBDaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGIENoYW5nZXNfV2hlbl9DYXNlbWFwcGVkIENXQ00gQ2hhbmdlc19XaGVuX0xvd2VyY2FzZWQgQ1dMIENoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0YgQ2hhbmdlc19XaGVuX1RpdGxlY2FzZWQgQ1dUIENoYW5nZXNfV2hlbl9VcHBlcmNhc2VkIENXVSBEYXNoIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgREkgRGVwcmVjYXRlZCBEZXAgRGlhY3JpdGljIERpYSBFbW9qaSBFbW9qaV9Db21wb25lbnQgRW1vamlfTW9kaWZpZXIgRW1vamlfTW9kaWZpZXJfQmFzZSBFbW9qaV9QcmVzZW50YXRpb24gRXh0ZW5kZXIgRXh0IEdyYXBoZW1lX0Jhc2UgR3JfQmFzZSBHcmFwaGVtZV9FeHRlbmQgR3JfRXh0IEhleF9EaWdpdCBIZXggSURTX0JpbmFyeV9PcGVyYXRvciBJRFNCIElEU19UcmluYXJ5X09wZXJhdG9yIElEU1QgSURfQ29udGludWUgSURDIElEX1N0YXJ0IElEUyBJZGVvZ3JhcGhpYyBJZGVvIEpvaW5fQ29udHJvbCBKb2luX0MgTG9naWNhbF9PcmRlcl9FeGNlcHRpb24gTE9FIExvd2VyY2FzZSBMb3dlciBNYXRoIE5vbmNoYXJhY3Rlcl9Db2RlX1BvaW50IE5DaGFyIFBhdHRlcm5fU3ludGF4IFBhdF9TeW4gUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1MgUXVvdGF0aW9uX01hcmsgUU1hcmsgUmFkaWNhbCBSZWdpb25hbF9JbmRpY2F0b3IgUkkgU2VudGVuY2VfVGVybWluYWwgU1Rlcm0gU29mdF9Eb3R0ZWQgU0QgVGVybWluYWxfUHVuY3R1YXRpb24gVGVybSBVbmlmaWVkX0lkZW9ncmFwaCBVSWRlbyBVcHBlcmNhc2UgVXBwZXIgVmFyaWF0aW9uX1NlbGVjdG9yIFZTIFdoaXRlX1NwYWNlIHNwYWNlIFhJRF9Db250aW51ZSBYSURDIFhJRF9TdGFydCBYSURTIixkYT1WbCsiIEV4dGVuZGVkX1BpY3RvZ3JhcGhpYyIsZmE9ZGErIiBFQmFzZSBFQ29tcCBFTW9kIEVQcmVzIEV4dFBpY3QiLEFmPXs5OlZsLDEwOmRhLDExOmRhLDEyOmZhLDEzOmZhLDE0OmZhfSxDZj17OToiIiwxMDoiIiwxMToiIiwxMjoiIiwxMzoiIiwxNDoiQmFzaWNfRW1vamkgRW1vamlfS2V5Y2FwX1NlcXVlbmNlIFJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZSBSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZSBSR0lfRW1vamlfVGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9aV0pfU2VxdWVuY2UgUkdJX0Vtb2ppIn0sTWw9IkNhc2VkX0xldHRlciBMQyBDbG9zZV9QdW5jdHVhdGlvbiBQZSBDb25uZWN0b3JfUHVuY3R1YXRpb24gUGMgQ29udHJvbCBDYyBjbnRybCBDdXJyZW5jeV9TeW1ib2wgU2MgRGFzaF9QdW5jdHVhdGlvbiBQZCBEZWNpbWFsX051bWJlciBOZCBkaWdpdCBFbmNsb3NpbmdfTWFyayBNZSBGaW5hbF9QdW5jdHVhdGlvbiBQZiBGb3JtYXQgQ2YgSW5pdGlhbF9QdW5jdHVhdGlvbiBQaSBMZXR0ZXIgTCBMZXR0ZXJfTnVtYmVyIE5sIExpbmVfU2VwYXJhdG9yIFpsIExvd2VyY2FzZV9MZXR0ZXIgTGwgTWFyayBNIENvbWJpbmluZ19NYXJrIE1hdGhfU3ltYm9sIFNtIE1vZGlmaWVyX0xldHRlciBMbSBNb2RpZmllcl9TeW1ib2wgU2sgTm9uc3BhY2luZ19NYXJrIE1uIE51bWJlciBOIE9wZW5fUHVuY3R1YXRpb24gUHMgT3RoZXIgQyBPdGhlcl9MZXR0ZXIgTG8gT3RoZXJfTnVtYmVyIE5vIE90aGVyX1B1bmN0dWF0aW9uIFBvIE90aGVyX1N5bWJvbCBTbyBQYXJhZ3JhcGhfU2VwYXJhdG9yIFpwIFByaXZhdGVfVXNlIENvIFB1bmN0dWF0aW9uIFAgcHVuY3QgU2VwYXJhdG9yIFogU3BhY2VfU2VwYXJhdG9yIFpzIFNwYWNpbmdfTWFyayBNYyBTdXJyb2dhdGUgQ3MgU3ltYm9sIFMgVGl0bGVjYXNlX0xldHRlciBMdCBVbmFzc2lnbmVkIENuIFVwcGVyY2FzZV9MZXR0ZXIgTHUiLERsPSJBZGxhbSBBZGxtIEFob20gQW5hdG9saWFuX0hpZXJvZ2x5cGhzIEhsdXcgQXJhYmljIEFyYWIgQXJtZW5pYW4gQXJtbiBBdmVzdGFuIEF2c3QgQmFsaW5lc2UgQmFsaSBCYW11bSBCYW11IEJhc3NhX1ZhaCBCYXNzIEJhdGFrIEJhdGsgQmVuZ2FsaSBCZW5nIEJoYWlrc3VraSBCaGtzIEJvcG9tb2ZvIEJvcG8gQnJhaG1pIEJyYWggQnJhaWxsZSBCcmFpIEJ1Z2luZXNlIEJ1Z2kgQnVoaWQgQnVoZCBDYW5hZGlhbl9BYm9yaWdpbmFsIENhbnMgQ2FyaWFuIENhcmkgQ2F1Y2FzaWFuX0FsYmFuaWFuIEFnaGIgQ2hha21hIENha20gQ2hhbSBDaGFtIENoZXJva2VlIENoZXIgQ29tbW9uIFp5eXkgQ29wdGljIENvcHQgUWFhYyBDdW5laWZvcm0gWHN1eCBDeXByaW90IENwcnQgQ3lyaWxsaWMgQ3lybCBEZXNlcmV0IERzcnQgRGV2YW5hZ2FyaSBEZXZhIER1cGxveWFuIER1cGwgRWd5cHRpYW5fSGllcm9nbHlwaHMgRWd5cCBFbGJhc2FuIEVsYmEgRXRoaW9waWMgRXRoaSBHZW9yZ2lhbiBHZW9yIEdsYWdvbGl0aWMgR2xhZyBHb3RoaWMgR290aCBHcmFudGhhIEdyYW4gR3JlZWsgR3JlayBHdWphcmF0aSBHdWpyIEd1cm11a2hpIEd1cnUgSGFuIEhhbmkgSGFuZ3VsIEhhbmcgSGFudW5vbyBIYW5vIEhhdHJhbiBIYXRyIEhlYnJldyBIZWJyIEhpcmFnYW5hIEhpcmEgSW1wZXJpYWxfQXJhbWFpYyBBcm1pIEluaGVyaXRlZCBaaW5oIFFhYWkgSW5zY3JpcHRpb25hbF9QYWhsYXZpIFBobGkgSW5zY3JpcHRpb25hbF9QYXJ0aGlhbiBQcnRpIEphdmFuZXNlIEphdmEgS2FpdGhpIEt0aGkgS2FubmFkYSBLbmRhIEthdGFrYW5hIEthbmEgS2F5YWhfTGkgS2FsaSBLaGFyb3NodGhpIEtoYXIgS2htZXIgS2htciBLaG9qa2kgS2hvaiBLaHVkYXdhZGkgU2luZCBMYW8gTGFvbyBMYXRpbiBMYXRuIExlcGNoYSBMZXBjIExpbWJ1IExpbWIgTGluZWFyX0EgTGluYSBMaW5lYXJfQiBMaW5iIExpc3UgTGlzdSBMeWNpYW4gTHljaSBMeWRpYW4gTHlkaSBNYWhhamFuaSBNYWhqIE1hbGF5YWxhbSBNbHltIE1hbmRhaWMgTWFuZCBNYW5pY2hhZWFuIE1hbmkgTWFyY2hlbiBNYXJjIE1hc2FyYW1fR29uZGkgR29ubSBNZWV0ZWlfTWF5ZWsgTXRlaSBNZW5kZV9LaWtha3VpIE1lbmQgTWVyb2l0aWNfQ3Vyc2l2ZSBNZXJjIE1lcm9pdGljX0hpZXJvZ2x5cGhzIE1lcm8gTWlhbyBQbHJkIE1vZGkgTW9uZ29saWFuIE1vbmcgTXJvIE1yb28gTXVsdGFuaSBNdWx0IE15YW5tYXIgTXltciBOYWJhdGFlYW4gTmJhdCBOZXdfVGFpX0x1ZSBUYWx1IE5ld2EgTmV3YSBOa28gTmtvbyBOdXNodSBOc2h1IE9naGFtIE9nYW0gT2xfQ2hpa2kgT2xjayBPbGRfSHVuZ2FyaWFuIEh1bmcgT2xkX0l0YWxpYyBJdGFsIE9sZF9Ob3J0aF9BcmFiaWFuIE5hcmIgT2xkX1Blcm1pYyBQZXJtIE9sZF9QZXJzaWFuIFhwZW8gT2xkX1NvdXRoX0FyYWJpYW4gU2FyYiBPbGRfVHVya2ljIE9ya2ggT3JpeWEgT3J5YSBPc2FnZSBPc2dlIE9zbWFueWEgT3NtYSBQYWhhd2hfSG1vbmcgSG1uZyBQYWxteXJlbmUgUGFsbSBQYXVfQ2luX0hhdSBQYXVjIFBoYWdzX1BhIFBoYWcgUGhvZW5pY2lhbiBQaG54IFBzYWx0ZXJfUGFobGF2aSBQaGxwIFJlamFuZyBSam5nIFJ1bmljIFJ1bnIgU2FtYXJpdGFuIFNhbXIgU2F1cmFzaHRyYSBTYXVyIFNoYXJhZGEgU2hyZCBTaGF2aWFuIFNoYXcgU2lkZGhhbSBTaWRkIFNpZ25Xcml0aW5nIFNnbncgU2luaGFsYSBTaW5oIFNvcmFfU29tcGVuZyBTb3JhIFNveW9tYm8gU295byBTdW5kYW5lc2UgU3VuZCBTeWxvdGlfTmFncmkgU3lsbyBTeXJpYWMgU3lyYyBUYWdhbG9nIFRnbGcgVGFnYmFud2EgVGFnYiBUYWlfTGUgVGFsZSBUYWlfVGhhbSBMYW5hIFRhaV9WaWV0IFRhdnQgVGFrcmkgVGFrciBUYW1pbCBUYW1sIFRhbmd1dCBUYW5nIFRlbHVndSBUZWx1IFRoYWFuYSBUaGFhIFRoYWkgVGhhaSBUaWJldGFuIFRpYnQgVGlmaW5hZ2ggVGZuZyBUaXJodXRhIFRpcmggVWdhcml0aWMgVWdhciBWYWkgVmFpaSBXYXJhbmdfQ2l0aSBXYXJhIFlpIFlpaWkgWmFuYWJhemFyX1NxdWFyZSBaYW5iIixCbD1EbCsiIERvZ3JhIERvZ3IgR3VuamFsYV9Hb25kaSBHb25nIEhhbmlmaV9Sb2hpbmd5YSBSb2hnIE1ha2FzYXIgTWFrYSBNZWRlZmFpZHJpbiBNZWRmIE9sZF9Tb2dkaWFuIFNvZ28gU29nZGlhbiBTb2dkIixGbD1CbCsiIEVseW1haWMgRWx5bSBOYW5kaW5hZ2FyaSBOYW5kIE55aWFrZW5nX1B1YWNodWVfSG1vbmcgSG1ucCBXYW5jaG8gV2NobyIsemw9RmwrIiBDaG9yYXNtaWFuIENocnMgRGlhayBEaXZlc19Ba3VydSBLaGl0YW5fU21hbGxfU2NyaXB0IEtpdHMgWWV6aSBZZXppZGkiLGpsPXpsKyIgQ3lwcm9fTWlub2FuIENwbW4gT2xkX1V5Z2h1ciBPdWdyIFRhbmdzYSBUbnNhIFRvdG8gVml0aGt1cWkgVml0aCIsSWY9ezk6RGwsMTA6QmwsMTE6RmwsMTI6emwsMTM6amwsMTQ6amwrIiBIcmt0IEthdGFrYW5hX09yX0hpcmFnYW5hIEthd2kgTmFnX011bmRhcmkgTmFnbSBVbmtub3duIFp6enoifSxVbD17fTtmdW5jdGlvbiBQZihlKXt2YXIgdD1VbFtlXT17YmluYXJ5OnF0KEFmW2VdKyIgIitNbCksYmluYXJ5T2ZTdHJpbmdzOnF0KENmW2VdKSxub25CaW5hcnk6e0dlbmVyYWxfQ2F0ZWdvcnk6cXQoTWwpLFNjcmlwdDpxdChJZltlXSl9fTt0Lm5vbkJpbmFyeS5TY3JpcHRfRXh0ZW5zaW9ucz10Lm5vbkJpbmFyeS5TY3JpcHQsdC5ub25CaW5hcnkuZ2M9dC5ub25CaW5hcnkuR2VuZXJhbF9DYXRlZ29yeSx0Lm5vbkJpbmFyeS5zYz10Lm5vbkJpbmFyeS5TY3JpcHQsdC5ub25CaW5hcnkuc2N4PXQubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zfWZvcih2YXIgbWE9MCxHbD1bOSwxMCwxMSwxMiwxMywxNF07bWE8R2wubGVuZ3RoO21hKz0xKVBmKEdsW21hXSk7dmFyIE09Z2UucHJvdG90eXBlLEV0PWZ1bmN0aW9uKGUpe3RoaXMucGFyc2VyPWUsdGhpcy52YWxpZEZsYWdzPSJnaW0iKyhlLm9wdGlvbnMuZWNtYVZlcnNpb24+PTY/InV5IjoiIikrKGUub3B0aW9ucy5lY21hVmVyc2lvbj49OT8icyI6IiIpKyhlLm9wdGlvbnMuZWNtYVZlcnNpb24+PTEzPyJkIjoiIikrKGUub3B0aW9ucy5lY21hVmVyc2lvbj49MTU/InYiOiIiKSx0aGlzLnVuaWNvZGVQcm9wZXJ0aWVzPVVsW2Uub3B0aW9ucy5lY21hVmVyc2lvbj49MTQ/MTQ6ZS5vcHRpb25zLmVjbWFWZXJzaW9uXSx0aGlzLnNvdXJjZT0iIix0aGlzLmZsYWdzPSIiLHRoaXMuc3RhcnQ9MCx0aGlzLnN3aXRjaFU9ITEsdGhpcy5zd2l0Y2hWPSExLHRoaXMuc3dpdGNoTj0hMSx0aGlzLnBvcz0wLHRoaXMubGFzdEludFZhbHVlPTAsdGhpcy5sYXN0U3RyaW5nVmFsdWU9IiIsdGhpcy5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGU9ITEsdGhpcy5udW1DYXB0dXJpbmdQYXJlbnM9MCx0aGlzLm1heEJhY2tSZWZlcmVuY2U9MCx0aGlzLmdyb3VwTmFtZXM9W10sdGhpcy5iYWNrUmVmZXJlbmNlTmFtZXM9W119O2Z1bmN0aW9uIFdsKGUpe3JldHVybiBlPT09MzZ8fGU+PTQwJiZlPD00M3x8ZT09PTQ2fHxlPT09NjN8fGU+PTkxJiZlPD05NHx8ZT49MTIzJiZlPD0xMjV9ZnVuY3Rpb24gcWwoZSl7cmV0dXJuIGU+PTY1JiZlPD05MHx8ZT49OTcmJmU8PTEyMn1FdC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oZSx0LGkpe3ZhciBzPWkuaW5kZXhPZigidiIpIT09LTEsbj1pLmluZGV4T2YoInUiKSE9PS0xO3RoaXMuc3RhcnQ9MHxlLHRoaXMuc291cmNlPXQrIiIsdGhpcy5mbGFncz1pLHMmJnRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24+PTE1Pyh0aGlzLnN3aXRjaFU9ITAsdGhpcy5zd2l0Y2hWPSEwLHRoaXMuc3dpdGNoTj0hMCk6KHRoaXMuc3dpdGNoVT1uJiZ0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uPj02LHRoaXMuc3dpdGNoVj0hMSx0aGlzLnN3aXRjaE49biYmdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbj49OSl9LEV0LnByb3RvdHlwZS5yYWlzZT1mdW5jdGlvbihlKXt0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvIit0aGlzLnNvdXJjZSsiLzogIitlKX0sRXQucHJvdG90eXBlLmF0PWZ1bmN0aW9uKGUsdCl7dD09PXZvaWQgMCYmKHQ9ITEpO3ZhciBpPXRoaXMuc291cmNlLHM9aS5sZW5ndGg7aWYoZT49cylyZXR1cm4tMTt2YXIgbj1pLmNoYXJDb2RlQXQoZSk7aWYoIXQmJiF0aGlzLnN3aXRjaFV8fG48PTU1Mjk1fHxuPj01NzM0NHx8ZSsxPj1zKXJldHVybiBuO3ZhciByPWkuY2hhckNvZGVBdChlKzEpO3JldHVybiByPj01NjMyMCYmcjw9NTczNDM/KG48PDEwKStyLTU2NjEzODg4Om59LEV0LnByb3RvdHlwZS5uZXh0SW5kZXg9ZnVuY3Rpb24oZSx0KXt0PT09dm9pZCAwJiYodD0hMSk7dmFyIGk9dGhpcy5zb3VyY2Uscz1pLmxlbmd0aDtpZihlPj1zKXJldHVybiBzO3ZhciBuLHI9aS5jaGFyQ29kZUF0KGUpO3JldHVybiF0JiYhdGhpcy5zd2l0Y2hVfHxyPD01NTI5NXx8cj49NTczNDR8fGUrMT49c3x8KG49aS5jaGFyQ29kZUF0KGUrMSkpPDU2MzIwfHxuPjU3MzQzP2UrMTplKzJ9LEV0LnByb3RvdHlwZS5jdXJyZW50PWZ1bmN0aW9uKGUpe3JldHVybiBlPT09dm9pZCAwJiYoZT0hMSksdGhpcy5hdCh0aGlzLnBvcyxlKX0sRXQucHJvdG90eXBlLmxvb2thaGVhZD1mdW5jdGlvbihlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9ITEpLHRoaXMuYXQodGhpcy5uZXh0SW5kZXgodGhpcy5wb3MsZSksZSl9LEV0LnByb3RvdHlwZS5hZHZhbmNlPWZ1bmN0aW9uKGUpe2U9PT12b2lkIDAmJihlPSExKSx0aGlzLnBvcz10aGlzLm5leHRJbmRleCh0aGlzLnBvcyxlKX0sRXQucHJvdG90eXBlLmVhdD1mdW5jdGlvbihlLHQpe3JldHVybiB0PT09dm9pZCAwJiYodD0hMSksdGhpcy5jdXJyZW50KHQpPT09ZSYmKHRoaXMuYWR2YW5jZSh0KSwhMCl9LEV0LnByb3RvdHlwZS5lYXRDaGFycz1mdW5jdGlvbihlLHQpe3Q9PT12b2lkIDAmJih0PSExKTtmb3IodmFyIGk9dGhpcy5wb3Mscz0wLG49ZTtzPG4ubGVuZ3RoO3MrPTEpe3ZhciByPW5bc10sYT10aGlzLmF0KGksdCk7aWYoYT09PS0xfHxhIT09cilyZXR1cm4hMTtpPXRoaXMubmV4dEluZGV4KGksdCl9cmV0dXJuIHRoaXMucG9zPWksITB9LE0udmFsaWRhdGVSZWdFeHBGbGFncz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9ZS52YWxpZEZsYWdzLGk9ZS5mbGFncyxzPSExLG49ITEscj0wO3I8aS5sZW5ndGg7cisrKXt2YXIgYT1pLmNoYXJBdChyKTt0LmluZGV4T2YoYSk9PT0tMSYmdGhpcy5yYWlzZShlLnN0YXJ0LCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnIiksaS5pbmRleE9mKGEscisxKT4tMSYmdGhpcy5yYWlzZShlLnN0YXJ0LCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWciKSxhPT09InUiJiYocz0hMCksYT09PSJ2IiYmKG49ITApfXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTUmJnMmJm4mJnRoaXMucmFpc2UoZS5zdGFydCwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZyIpfSxNLnZhbGlkYXRlUmVnRXhwUGF0dGVybj1mdW5jdGlvbihlKXt0aGlzLnJlZ2V4cF9wYXR0ZXJuKGUpLCFlLnN3aXRjaE4mJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmZS5ncm91cE5hbWVzLmxlbmd0aD4wJiYoZS5zd2l0Y2hOPSEwLHRoaXMucmVnZXhwX3BhdHRlcm4oZSkpfSxNLnJlZ2V4cF9wYXR0ZXJuPWZ1bmN0aW9uKGUpe2UucG9zPTAsZS5sYXN0SW50VmFsdWU9MCxlLmxhc3RTdHJpbmdWYWx1ZT0iIixlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZT0hMSxlLm51bUNhcHR1cmluZ1BhcmVucz0wLGUubWF4QmFja1JlZmVyZW5jZT0wLGUuZ3JvdXBOYW1lcy5sZW5ndGg9MCxlLmJhY2tSZWZlcmVuY2VOYW1lcy5sZW5ndGg9MCx0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihlKSxlLnBvcyE9PWUuc291cmNlLmxlbmd0aCYmKGUuZWF0KDQxKSYmZS5yYWlzZSgiVW5tYXRjaGVkICcpJyIpLChlLmVhdCg5Myl8fGUuZWF0KDEyNSkpJiZlLnJhaXNlKCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHMiKSksZS5tYXhCYWNrUmVmZXJlbmNlPmUubnVtQ2FwdHVyaW5nUGFyZW5zJiZlLnJhaXNlKCJJbnZhbGlkIGVzY2FwZSIpO2Zvcih2YXIgdD0wLGk9ZS5iYWNrUmVmZXJlbmNlTmFtZXM7dDxpLmxlbmd0aDt0Kz0xKXt2YXIgcz1pW3RdO2UuZ3JvdXBOYW1lcy5pbmRleE9mKHMpPT09LTEmJmUucmFpc2UoIkludmFsaWQgbmFtZWQgY2FwdHVyZSByZWZlcmVuY2VkIil9fSxNLnJlZ2V4cF9kaXNqdW5jdGlvbj1mdW5jdGlvbihlKXtmb3IodGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoZSk7ZS5lYXQoMTI0KTspdGhpcy5yZWdleHBfYWx0ZXJuYXRpdmUoZSk7dGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihlLCEwKSYmZS5yYWlzZSgiTm90aGluZyB0byByZXBlYXQiKSxlLmVhdCgxMjMpJiZlLnJhaXNlKCJMb25lIHF1YW50aWZpZXIgYnJhY2tldHMiKX0sTS5yZWdleHBfYWx0ZXJuYXRpdmU9ZnVuY3Rpb24oZSl7Zm9yKDtlLnBvczxlLnNvdXJjZS5sZW5ndGgmJnRoaXMucmVnZXhwX2VhdFRlcm0oZSk7KTt9LE0ucmVnZXhwX2VhdFRlcm09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdEFzc2VydGlvbihlKT8oZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGUmJnRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoZSkmJmUuc3dpdGNoVSYmZS5yYWlzZSgiSW52YWxpZCBxdWFudGlmaWVyIiksITApOiEhKGUuc3dpdGNoVT90aGlzLnJlZ2V4cF9lYXRBdG9tKGUpOnRoaXMucmVnZXhwX2VhdEV4dGVuZGVkQXRvbShlKSkmJih0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKGUpLCEwKX0sTS5yZWdleHBfZWF0QXNzZXJ0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlPSExLGUuZWF0KDk0KXx8ZS5lYXQoMzYpKXJldHVybiEwO2lmKGUuZWF0KDkyKSl7aWYoZS5lYXQoNjYpfHxlLmVhdCg5OCkpcmV0dXJuITA7ZS5wb3M9dH1pZihlLmVhdCg0MCkmJmUuZWF0KDYzKSl7dmFyIGk9ITE7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiYoaT1lLmVhdCg2MCkpLGUuZWF0KDYxKXx8ZS5lYXQoMzMpKXJldHVybiB0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihlKSxlLmVhdCg0MSl8fGUucmFpc2UoIlVudGVybWluYXRlZCBncm91cCIpLGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlPSFpLCEwfXJldHVybiBlLnBvcz10LCExfSxNLnJlZ2V4cF9lYXRRdWFudGlmaWVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQ9PT12b2lkIDAmJih0PSExKSwhIXRoaXMucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXgoZSx0KSYmKGUuZWF0KDYzKSwhMCl9LE0ucmVnZXhwX2VhdFF1YW50aWZpZXJQcmVmaXg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5lYXQoNDIpfHxlLmVhdCg0Myl8fGUuZWF0KDYzKXx8dGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihlLHQpfSxNLnJlZ2V4cF9lYXRCcmFjZWRRdWFudGlmaWVyPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5wb3M7aWYoZS5lYXQoMTIzKSl7dmFyIHM9MCxuPS0xO2lmKHRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoZSkmJihzPWUubGFzdEludFZhbHVlLGUuZWF0KDQ0KSYmdGhpcy5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cyhlKSYmKG49ZS5sYXN0SW50VmFsdWUpLGUuZWF0KDEyNSkpKXJldHVybiBuIT09LTEmJm48cyYmIXQmJmUucmFpc2UoIm51bWJlcnMgb3V0IG9mIG9yZGVyIGluIHt9IHF1YW50aWZpZXIiKSwhMDtlLnN3aXRjaFUmJiF0JiZlLnJhaXNlKCJJbmNvbXBsZXRlIHF1YW50aWZpZXIiKSxlLnBvcz1pfXJldHVybiExfSxNLnJlZ2V4cF9lYXRBdG9tPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlZ2V4cF9lYXRQYXR0ZXJuQ2hhcmFjdGVycyhlKXx8ZS5lYXQoNDYpfHx0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKGUpfHx0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKGUpfHx0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChlKX0sTS5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDkyKSl7aWYodGhpcy5yZWdleHBfZWF0QXRvbUVzY2FwZShlKSlyZXR1cm4hMDtlLnBvcz10fXJldHVybiExfSxNLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDQwKSl7aWYoZS5lYXQoNjMpJiZlLmVhdCg1OCkpe2lmKHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKGUpLGUuZWF0KDQxKSlyZXR1cm4hMDtlLnJhaXNlKCJVbnRlcm1pbmF0ZWQgZ3JvdXAiKX1lLnBvcz10fXJldHVybiExfSxNLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cD1mdW5jdGlvbihlKXtpZihlLmVhdCg0MCkpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OT90aGlzLnJlZ2V4cF9ncm91cFNwZWNpZmllcihlKTplLmN1cnJlbnQoKT09PTYzJiZlLnJhaXNlKCJJbnZhbGlkIGdyb3VwIiksdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oZSksZS5lYXQoNDEpKXJldHVybiBlLm51bUNhcHR1cmluZ1BhcmVucys9MSwhMDtlLnJhaXNlKCJVbnRlcm1pbmF0ZWQgZ3JvdXAiKX1yZXR1cm4hMX0sTS5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tPWZ1bmN0aW9uKGUpe3JldHVybiBlLmVhdCg0Nil8fHRoaXMucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZShlKXx8dGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3MoZSl8fHRoaXMucmVnZXhwX2VhdFVuY2FwdHVyaW5nR3JvdXAoZSl8fHRoaXMucmVnZXhwX2VhdENhcHR1cmluZ0dyb3VwKGUpfHx0aGlzLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcihlKXx8dGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyKGUpfSxNLnJlZ2V4cF9lYXRJbnZhbGlkQnJhY2VkUXVhbnRpZmllcj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcihlLCEwKSYmZS5yYWlzZSgiTm90aGluZyB0byByZXBlYXQiKSwhMX0sTS5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiEhV2wodCkmJihlLmxhc3RJbnRWYWx1ZT10LGUuYWR2YW5jZSgpLCEwKX0sTS5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUucG9zLGk9MDsoaT1lLmN1cnJlbnQoKSkhPT0tMSYmIVdsKGkpOyllLmFkdmFuY2UoKTtyZXR1cm4gZS5wb3MhPT10fSxNLnJlZ2V4cF9lYXRFeHRlbmRlZFBhdHRlcm5DaGFyYWN0ZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jdXJyZW50KCk7cmV0dXJuISh0PT09LTF8fHQ9PT0zNnx8dD49NDAmJnQ8PTQzfHx0PT09NDZ8fHQ9PT02M3x8dD09PTkxfHx0PT09OTR8fHQ9PT0xMjQpJiYoZS5hZHZhbmNlKCksITApfSxNLnJlZ2V4cF9ncm91cFNwZWNpZmllcj1mdW5jdGlvbihlKXtpZihlLmVhdCg2Mykpe2lmKHRoaXMucmVnZXhwX2VhdEdyb3VwTmFtZShlKSlyZXR1cm4gZS5ncm91cE5hbWVzLmluZGV4T2YoZS5sYXN0U3RyaW5nVmFsdWUpIT09LTEmJmUucmFpc2UoIkR1cGxpY2F0ZSBjYXB0dXJlIGdyb3VwIG5hbWUiKSx2b2lkIGUuZ3JvdXBOYW1lcy5wdXNoKGUubGFzdFN0cmluZ1ZhbHVlKTtlLnJhaXNlKCJJbnZhbGlkIGdyb3VwIil9fSxNLnJlZ2V4cF9lYXRHcm91cE5hbWU9ZnVuY3Rpb24oZSl7aWYoZS5sYXN0U3RyaW5nVmFsdWU9IiIsZS5lYXQoNjApKXtpZih0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShlKSYmZS5lYXQoNjIpKXJldHVybiEwO2UucmFpc2UoIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lIil9cmV0dXJuITF9LE0ucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lPWZ1bmN0aW9uKGUpe2lmKGUubGFzdFN0cmluZ1ZhbHVlPSIiLHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChlKSl7Zm9yKGUubGFzdFN0cmluZ1ZhbHVlKz1IdChlLmxhc3RJbnRWYWx1ZSk7dGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoZSk7KWUubGFzdFN0cmluZ1ZhbHVlKz1IdChlLmxhc3RJbnRWYWx1ZSk7cmV0dXJuITB9cmV0dXJuITF9LE0ucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcyxpPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEscz1lLmN1cnJlbnQoaSk7cmV0dXJuIGUuYWR2YW5jZShpKSxzPT09OTImJnRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShlLGkpJiYocz1lLmxhc3RJbnRWYWx1ZSksZnVuY3Rpb24obil7cmV0dXJuIGJ0KG4sITApfHxuPT09MzZ8fG49PT05NX0ocyk/KGUubGFzdEludFZhbHVlPXMsITApOihlLnBvcz10LCExKX0sTS5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3MsaT10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTExLHM9ZS5jdXJyZW50KGkpO3JldHVybiBlLmFkdmFuY2UoaSkscz09PTkyJiZ0aGlzLnJlZ2V4cF9lYXRSZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2UoZSxpKSYmKHM9ZS5sYXN0SW50VmFsdWUpLGZ1bmN0aW9uKG4pe3JldHVybiBmaShuLCEwKXx8bj09PTM2fHxuPT09OTV8fG49PT04MjA0fHxuPT09ODIwNX0ocyk/KGUubGFzdEludFZhbHVlPXMsITApOihlLnBvcz10LCExKX0sTS5yZWdleHBfZWF0QXRvbUVzY2FwZT1mdW5jdGlvbihlKXtyZXR1cm4hISh0aGlzLnJlZ2V4cF9lYXRCYWNrUmVmZXJlbmNlKGUpfHx0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShlKXx8dGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKGUpfHxlLnN3aXRjaE4mJnRoaXMucmVnZXhwX2VhdEtHcm91cE5hbWUoZSkpfHwoZS5zd2l0Y2hVJiYoZS5jdXJyZW50KCk9PT05OSYmZS5yYWlzZSgiSW52YWxpZCB1bmljb2RlIGVzY2FwZSIpLGUucmFpc2UoIkludmFsaWQgZXNjYXBlIikpLCExKX0sTS5yZWdleHBfZWF0QmFja1JlZmVyZW5jZT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZih0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKGUpKXt2YXIgaT1lLmxhc3RJbnRWYWx1ZTtpZihlLnN3aXRjaFUpcmV0dXJuIGk+ZS5tYXhCYWNrUmVmZXJlbmNlJiYoZS5tYXhCYWNrUmVmZXJlbmNlPWkpLCEwO2lmKGk8PWUubnVtQ2FwdHVyaW5nUGFyZW5zKXJldHVybiEwO2UucG9zPXR9cmV0dXJuITF9LE0ucmVnZXhwX2VhdEtHcm91cE5hbWU9ZnVuY3Rpb24oZSl7aWYoZS5lYXQoMTA3KSl7aWYodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKGUpKXJldHVybiBlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKGUubGFzdFN0cmluZ1ZhbHVlKSwhMDtlLnJhaXNlKCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZSIpfXJldHVybiExfSxNLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKGUpfHx0aGlzLnJlZ2V4cF9lYXRaZXJvKGUpfHx0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShlKXx8dGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKGUsITEpfHwhZS5zd2l0Y2hVJiZ0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKGUpfHx0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShlKX0sTS5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3M7aWYoZS5lYXQoOTkpKXtpZih0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKGUpKXJldHVybiEwO2UucG9zPXR9cmV0dXJuITF9LE0ucmVnZXhwX2VhdFplcm89ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY3VycmVudCgpPT09NDgmJiFBbihlLmxvb2thaGVhZCgpKSYmKGUubGFzdEludFZhbHVlPTAsZS5hZHZhbmNlKCksITApfSxNLnJlZ2V4cF9lYXRDb250cm9sRXNjYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiB0PT09MTE2PyhlLmxhc3RJbnRWYWx1ZT05LGUuYWR2YW5jZSgpLCEwKTp0PT09MTEwPyhlLmxhc3RJbnRWYWx1ZT0xMCxlLmFkdmFuY2UoKSwhMCk6dD09PTExOD8oZS5sYXN0SW50VmFsdWU9MTEsZS5hZHZhbmNlKCksITApOnQ9PT0xMDI/KGUubGFzdEludFZhbHVlPTEyLGUuYWR2YW5jZSgpLCEwKTp0PT09MTE0JiYoZS5sYXN0SW50VmFsdWU9MTMsZS5hZHZhbmNlKCksITApfSxNLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiEhcWwodCkmJihlLmxhc3RJbnRWYWx1ZT10JTMyLGUuYWR2YW5jZSgpLCEwKX0sTS5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlPWZ1bmN0aW9uKGUsdCl7dD09PXZvaWQgMCYmKHQ9ITEpO3ZhciBpLHM9ZS5wb3Msbj10fHxlLnN3aXRjaFU7aWYoZS5lYXQoMTE3KSl7aWYodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoZSw0KSl7dmFyIHI9ZS5sYXN0SW50VmFsdWU7aWYobiYmcj49NTUyOTYmJnI8PTU2MzE5KXt2YXIgYT1lLnBvcztpZihlLmVhdCg5MikmJmUuZWF0KDExNykmJnRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKGUsNCkpe3ZhciBvPWUubGFzdEludFZhbHVlO2lmKG8+PTU2MzIwJiZvPD01NzM0MylyZXR1cm4gZS5sYXN0SW50VmFsdWU9MTAyNCooci01NTI5NikrKG8tNTYzMjApKzY1NTM2LCEwfWUucG9zPWEsZS5sYXN0SW50VmFsdWU9cn1yZXR1cm4hMH1pZihuJiZlLmVhdCgxMjMpJiZ0aGlzLnJlZ2V4cF9lYXRIZXhEaWdpdHMoZSkmJmUuZWF0KDEyNSkmJihpPWUubGFzdEludFZhbHVlKT49MCYmaTw9MTExNDExMSlyZXR1cm4hMDtuJiZlLnJhaXNlKCJJbnZhbGlkIHVuaWNvZGUgZXNjYXBlIiksZS5wb3M9c31yZXR1cm4hMX0sTS5yZWdleHBfZWF0SWRlbnRpdHlFc2NhcGU9ZnVuY3Rpb24oZSl7aWYoZS5zd2l0Y2hVKXJldHVybiEhdGhpcy5yZWdleHBfZWF0U3ludGF4Q2hhcmFjdGVyKGUpfHwhIWUuZWF0KDQ3KSYmKGUubGFzdEludFZhbHVlPTQ3LCEwKTt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4hKHQ9PT05OXx8ZS5zd2l0Y2hOJiZ0PT09MTA3KSYmKGUubGFzdEludFZhbHVlPXQsZS5hZHZhbmNlKCksITApfSxNLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlPWZ1bmN0aW9uKGUpe2UubGFzdEludFZhbHVlPTA7dmFyIHQ9ZS5jdXJyZW50KCk7aWYodD49NDkmJnQ8PTU3KXtkbyBlLmxhc3RJbnRWYWx1ZT0xMCplLmxhc3RJbnRWYWx1ZSsodC00OCksZS5hZHZhbmNlKCk7d2hpbGUoKHQ9ZS5jdXJyZW50KCkpPj00OCYmdDw9NTcpO3JldHVybiEwfXJldHVybiExfTtmdW5jdGlvbiBIbChlKXtyZXR1cm4gcWwoZSl8fGU9PT05NX1mdW5jdGlvbiBfZihlKXtyZXR1cm4gSGwoZSl8fEFuKGUpfWZ1bmN0aW9uIEFuKGUpe3JldHVybiBlPj00OCYmZTw9NTd9ZnVuY3Rpb24gS2woZSl7cmV0dXJuIGU+PTQ4JiZlPD01N3x8ZT49NjUmJmU8PTcwfHxlPj05NyYmZTw9MTAyfWZ1bmN0aW9uIFFsKGUpe3JldHVybiBlPj02NSYmZTw9NzA/ZS02NSsxMDplPj05NyYmZTw9MTAyP2UtOTcrMTA6ZS00OH1mdW5jdGlvbiBZbChlKXtyZXR1cm4gZT49NDgmJmU8PTU1fU0ucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO2lmKGZ1bmN0aW9uKG4pe3JldHVybiBuPT09MTAwfHxuPT09Njh8fG49PT0xMTV8fG49PT04M3x8bj09PTExOXx8bj09PTg3fSh0KSlyZXR1cm4gZS5sYXN0SW50VmFsdWU9LTEsZS5hZHZhbmNlKCksMTt2YXIgaT0hMTtpZihlLnN3aXRjaFUmJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmKChpPXQ9PT04MCl8fHQ9PT0xMTIpKXt2YXIgcztpZihlLmxhc3RJbnRWYWx1ZT0tMSxlLmFkdmFuY2UoKSxlLmVhdCgxMjMpJiYocz10aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZUV4cHJlc3Npb24oZSkpJiZlLmVhdCgxMjUpKXJldHVybiBpJiZzPT09MiYmZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSBuYW1lIikscztlLnJhaXNlKCJJbnZhbGlkIHByb3BlcnR5IG5hbWUiKX1yZXR1cm4gMH0sTS5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWVFeHByZXNzaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eU5hbWUoZSkmJmUuZWF0KDYxKSl7dmFyIGk9ZS5sYXN0U3RyaW5nVmFsdWU7aWYodGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoZSkpe3ZhciBzPWUubGFzdFN0cmluZ1ZhbHVlO3JldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVBbmRWYWx1ZShlLGkscyksMX19aWYoZS5wb3M9dCx0aGlzLnJlZ2V4cF9lYXRMb25lVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoZSkpe3ZhciBuPWUubGFzdFN0cmluZ1ZhbHVlO3JldHVybiB0aGlzLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlKGUsbil9cmV0dXJuIDB9LE0ucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlPWZ1bmN0aW9uKGUsdCxpKXtncyhlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSx0KXx8ZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSBuYW1lIiksZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbdF0udGVzdChpKXx8ZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSIpfSxNLnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5LnRlc3QodCk/MTplLnN3aXRjaFYmJmUudW5pY29kZVByb3BlcnRpZXMuYmluYXJ5T2ZTdHJpbmdzLnRlc3QodCk/Mjp2b2lkIGUucmFpc2UoIkludmFsaWQgcHJvcGVydHkgbmFtZSIpfSxNLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PTA7Zm9yKGUubGFzdFN0cmluZ1ZhbHVlPSIiO0hsKHQ9ZS5jdXJyZW50KCkpOyllLmxhc3RTdHJpbmdWYWx1ZSs9SHQodCksZS5hZHZhbmNlKCk7cmV0dXJuIGUubGFzdFN0cmluZ1ZhbHVlIT09IiJ9LE0ucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlPWZ1bmN0aW9uKGUpe3ZhciB0PTA7Zm9yKGUubGFzdFN0cmluZ1ZhbHVlPSIiO19mKHQ9ZS5jdXJyZW50KCkpOyllLmxhc3RTdHJpbmdWYWx1ZSs9SHQodCksZS5hZHZhbmNlKCk7cmV0dXJuIGUubGFzdFN0cmluZ1ZhbHVlIT09IiJ9LE0ucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoZSl9LE0ucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzPWZ1bmN0aW9uKGUpe2lmKGUuZWF0KDkxKSl7dmFyIHQ9ZS5lYXQoOTQpLGk9dGhpcy5yZWdleHBfY2xhc3NDb250ZW50cyhlKTtyZXR1cm4gZS5lYXQoOTMpfHxlLnJhaXNlKCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzIiksdCYmaT09PTImJmUucmFpc2UoIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3MiKSwhMH1yZXR1cm4hMX0sTS5yZWdleHBfY2xhc3NDb250ZW50cz1mdW5jdGlvbihlKXtyZXR1cm4gZS5jdXJyZW50KCk9PT05Mz8xOmUuc3dpdGNoVj90aGlzLnJlZ2V4cF9jbGFzc1NldEV4cHJlc3Npb24oZSk6KHRoaXMucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXMoZSksMSl9LE0ucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXM9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oZSk7KXt2YXIgdD1lLmxhc3RJbnRWYWx1ZTtpZihlLmVhdCg0NSkmJnRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShlKSl7dmFyIGk9ZS5sYXN0SW50VmFsdWU7IWUuc3dpdGNoVXx8dCE9PS0xJiZpIT09LTF8fGUucmFpc2UoIkludmFsaWQgY2hhcmFjdGVyIGNsYXNzIiksdCE9PS0xJiZpIT09LTEmJnQ+aSYmZS5yYWlzZSgiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzcyIpfX19LE0ucmVnZXhwX2VhdENsYXNzQXRvbT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZihlLmVhdCg5Mikpe2lmKHRoaXMucmVnZXhwX2VhdENsYXNzRXNjYXBlKGUpKXJldHVybiEwO2lmKGUuc3dpdGNoVSl7dmFyIGk9ZS5jdXJyZW50KCk7KGk9PT05OXx8WWwoaSkpJiZlLnJhaXNlKCJJbnZhbGlkIGNsYXNzIGVzY2FwZSIpLGUucmFpc2UoIkludmFsaWQgZXNjYXBlIil9ZS5wb3M9dH12YXIgcz1lLmN1cnJlbnQoKTtyZXR1cm4gcyE9PTkzJiYoZS5sYXN0SW50VmFsdWU9cyxlLmFkdmFuY2UoKSwhMCl9LE0ucmVnZXhwX2VhdENsYXNzRXNjYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDk4KSlyZXR1cm4gZS5sYXN0SW50VmFsdWU9OCwhMDtpZihlLnN3aXRjaFUmJmUuZWF0KDQ1KSlyZXR1cm4gZS5sYXN0SW50VmFsdWU9NDUsITA7aWYoIWUuc3dpdGNoVSYmZS5lYXQoOTkpKXtpZih0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoZSkpcmV0dXJuITA7ZS5wb3M9dH1yZXR1cm4gdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShlKX0sTS5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uPWZ1bmN0aW9uKGUpe3ZhciB0LGk9MTtpZighdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShlKSlpZih0PXRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChlKSl7dD09PTImJihpPTIpO2Zvcih2YXIgcz1lLnBvcztlLmVhdENoYXJzKFszOCwzOF0pOyllLmN1cnJlbnQoKSE9PTM4JiYodD10aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoZSkpP3QhPT0yJiYoaT0xKTplLnJhaXNlKCJJbnZhbGlkIGNoYXJhY3RlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKTtpZihzIT09ZS5wb3MpcmV0dXJuIGk7Zm9yKDtlLmVhdENoYXJzKFs0NSw0NV0pOyl0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoZSl8fGUucmFpc2UoIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzcyIpO2lmKHMhPT1lLnBvcylyZXR1cm4gaX1lbHNlIGUucmFpc2UoIkludmFsaWQgY2hhcmFjdGVyIGluIGNoYXJhY3RlciBjbGFzcyIpO2Zvcig7OylpZighdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZShlKSl7aWYoISh0PXRoaXMucmVnZXhwX2VhdENsYXNzU2V0T3BlcmFuZChlKSkpcmV0dXJuIGk7dD09PTImJihpPTIpfX0sTS5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZih0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihlKSl7dmFyIGk9ZS5sYXN0SW50VmFsdWU7aWYoZS5lYXQoNDUpJiZ0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihlKSl7dmFyIHM9ZS5sYXN0SW50VmFsdWU7cmV0dXJuIGkhPT0tMSYmcyE9PS0xJiZpPnMmJmUucmFpc2UoIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKSwhMH1lLnBvcz10fXJldHVybiExfSxNLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKGUpPzE6dGhpcy5yZWdleHBfZWF0Q2xhc3NTdHJpbmdEaXNqdW5jdGlvbihlKXx8dGhpcy5yZWdleHBfZWF0TmVzdGVkQ2xhc3MoZSl9LE0ucmVnZXhwX2VhdE5lc3RlZENsYXNzPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDkxKSl7dmFyIGk9ZS5lYXQoOTQpLHM9dGhpcy5yZWdleHBfY2xhc3NDb250ZW50cyhlKTtpZihlLmVhdCg5MykpcmV0dXJuIGkmJnM9PT0yJiZlLnJhaXNlKCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzIikscztlLnBvcz10fWlmKGUuZWF0KDkyKSl7dmFyIG49dGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoZSk7aWYobilyZXR1cm4gbjtlLnBvcz10fXJldHVybiBudWxsfSxNLnJlZ2V4cF9lYXRDbGFzc1N0cmluZ0Rpc2p1bmN0aW9uPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0Q2hhcnMoWzkyLDExM10pKXtpZihlLmVhdCgxMjMpKXt2YXIgaT10aGlzLnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHMoZSk7aWYoZS5lYXQoMTI1KSlyZXR1cm4gaX1lbHNlIGUucmFpc2UoIkludmFsaWQgZXNjYXBlIik7ZS5wb3M9dH1yZXR1cm4gbnVsbH0sTS5yZWdleHBfY2xhc3NTdHJpbmdEaXNqdW5jdGlvbkNvbnRlbnRzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhlKTtlLmVhdCgxMjQpOyl0aGlzLnJlZ2V4cF9jbGFzc1N0cmluZyhlKT09PTImJih0PTIpO3JldHVybiB0fSxNLnJlZ2V4cF9jbGFzc1N0cmluZz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihlKTspdCsrO3JldHVybiB0PT09MT8xOjJ9LE0ucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDkyKSlyZXR1cm4hKCF0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoZSkmJiF0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihlKSl8fChlLmVhdCg5OCk/KGUubGFzdEludFZhbHVlPTgsITApOihlLnBvcz10LCExKSk7dmFyIGk9ZS5jdXJyZW50KCk7cmV0dXJuIShpPDB8fGk9PT1lLmxvb2thaGVhZCgpJiZmdW5jdGlvbihzKXtyZXR1cm4gcz09PTMzfHxzPj0zNSYmczw9Mzh8fHM+PTQyJiZzPD00NHx8cz09PTQ2fHxzPj01OCYmczw9NjR8fHM9PT05NHx8cz09PTk2fHxzPT09MTI2fShpKSkmJiFmdW5jdGlvbihzKXtyZXR1cm4gcz09PTQwfHxzPT09NDF8fHM9PT00NXx8cz09PTQ3fHxzPj05MSYmczw9OTN8fHM+PTEyMyYmczw9MTI1fShpKSYmKGUuYWR2YW5jZSgpLGUubGFzdEludFZhbHVlPWksITApfSxNLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcj1mdW5jdGlvbihlKXt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4hIWZ1bmN0aW9uKGkpe3JldHVybiBpPT09MzN8fGk9PT0zNXx8aT09PTM3fHxpPT09Mzh8fGk9PT00NHx8aT09PTQ1fHxpPj01OCYmaTw9NjJ8fGk9PT02NHx8aT09PTk2fHxpPT09MTI2fSh0KSYmKGUubGFzdEludFZhbHVlPXQsZS5hZHZhbmNlKCksITApfSxNLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jdXJyZW50KCk7cmV0dXJuISghQW4odCkmJnQhPT05NSkmJihlLmxhc3RJbnRWYWx1ZT10JTMyLGUuYWR2YW5jZSgpLCEwKX0sTS5yZWdleHBfZWF0SGV4RXNjYXBlU2VxdWVuY2U9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3M7aWYoZS5lYXQoMTIwKSl7aWYodGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoZSwyKSlyZXR1cm4hMDtlLnN3aXRjaFUmJmUucmFpc2UoIkludmFsaWQgZXNjYXBlIiksZS5wb3M9dH1yZXR1cm4hMX0sTS5yZWdleHBfZWF0RGVjaW1hbERpZ2l0cz1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcyxpPTA7Zm9yKGUubGFzdEludFZhbHVlPTA7QW4oaT1lLmN1cnJlbnQoKSk7KWUubGFzdEludFZhbHVlPTEwKmUubGFzdEludFZhbHVlKyhpLTQ4KSxlLmFkdmFuY2UoKTtyZXR1cm4gZS5wb3MhPT10fSxNLnJlZ2V4cF9lYXRIZXhEaWdpdHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3MsaT0wO2ZvcihlLmxhc3RJbnRWYWx1ZT0wO0tsKGk9ZS5jdXJyZW50KCkpOyllLmxhc3RJbnRWYWx1ZT0xNiplLmxhc3RJbnRWYWx1ZStRbChpKSxlLmFkdmFuY2UoKTtyZXR1cm4gZS5wb3MhPT10fSxNLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlPWZ1bmN0aW9uKGUpe2lmKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSkpe3ZhciB0PWUubGFzdEludFZhbHVlO2lmKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSkpe3ZhciBpPWUubGFzdEludFZhbHVlO3Q8PTMmJnRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSk/ZS5sYXN0SW50VmFsdWU9NjQqdCs4KmkrZS5sYXN0SW50VmFsdWU6ZS5sYXN0SW50VmFsdWU9OCp0K2l9ZWxzZSBlLmxhc3RJbnRWYWx1ZT10O3JldHVybiEwfXJldHVybiExfSxNLnJlZ2V4cF9lYXRPY3RhbERpZ2l0PWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiBZbCh0KT8oZS5sYXN0SW50VmFsdWU9dC00OCxlLmFkdmFuY2UoKSwhMCk6KGUubGFzdEludFZhbHVlPTAsITEpfSxNLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cz1mdW5jdGlvbihlLHQpe3ZhciBpPWUucG9zO2UubGFzdEludFZhbHVlPTA7Zm9yKHZhciBzPTA7czx0Oysrcyl7dmFyIG49ZS5jdXJyZW50KCk7aWYoIUtsKG4pKXJldHVybiBlLnBvcz1pLCExO2UubGFzdEludFZhbHVlPTE2KmUubGFzdEludFZhbHVlK1FsKG4pLGUuYWR2YW5jZSgpfXJldHVybiEwfTt2YXIgQ249ZnVuY3Rpb24oZSl7dGhpcy50eXBlPWUudHlwZSx0aGlzLnZhbHVlPWUudmFsdWUsdGhpcy5zdGFydD1lLnN0YXJ0LHRoaXMuZW5kPWUuZW5kLGUub3B0aW9ucy5sb2NhdGlvbnMmJih0aGlzLmxvYz1uZXcgeXMoZSxlLnN0YXJ0TG9jLGUuZW5kTG9jKSksZS5vcHRpb25zLnJhbmdlcyYmKHRoaXMucmFuZ2U9W2Uuc3RhcnQsZS5lbmRdKX0sSj1nZS5wcm90b3R5cGU7ZnVuY3Rpb24gWGwoZSl7cmV0dXJuIHR5cGVvZiBCaWdJbnQhPSJmdW5jdGlvbiI/bnVsbDpCaWdJbnQoZS5yZXBsYWNlKC9fL2csIiIpKX1KLm5leHQ9ZnVuY3Rpb24oZSl7IWUmJnRoaXMudHlwZS5rZXl3b3JkJiZ0aGlzLmNvbnRhaW5zRXNjJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwiRXNjYXBlIHNlcXVlbmNlIGluIGtleXdvcmQgIit0aGlzLnR5cGUua2V5d29yZCksdGhpcy5vcHRpb25zLm9uVG9rZW4mJnRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBDbih0aGlzKSksdGhpcy5sYXN0VG9rRW5kPXRoaXMuZW5kLHRoaXMubGFzdFRva1N0YXJ0PXRoaXMuc3RhcnQsdGhpcy5sYXN0VG9rRW5kTG9jPXRoaXMuZW5kTG9jLHRoaXMubGFzdFRva1N0YXJ0TG9jPXRoaXMuc3RhcnRMb2MsdGhpcy5uZXh0VG9rZW4oKX0sSi5nZXRUb2tlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHQoKSxuZXcgQ24odGhpcyl9LHR5cGVvZiBTeW1ib2w8InUiJiYoSltTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcztyZXR1cm57bmV4dDpmdW5jdGlvbigpe3ZhciB0PWUuZ2V0VG9rZW4oKTtyZXR1cm57ZG9uZTp0LnR5cGU9PT1mLmVvZix2YWx1ZTp0fX19fSksSi5uZXh0VG9rZW49ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmN1ckNvbnRleHQoKTtyZXR1cm4gZSYmZS5wcmVzZXJ2ZVNwYWNlfHx0aGlzLnNraXBTcGFjZSgpLHRoaXMuc3RhcnQ9dGhpcy5wb3MsdGhpcy5vcHRpb25zLmxvY2F0aW9ucyYmKHRoaXMuc3RhcnRMb2M9dGhpcy5jdXJQb3NpdGlvbigpKSx0aGlzLnBvcz49dGhpcy5pbnB1dC5sZW5ndGg/dGhpcy5maW5pc2hUb2tlbihmLmVvZik6ZS5vdmVycmlkZT9lLm92ZXJyaWRlKHRoaXMpOnZvaWQgdGhpcy5yZWFkVG9rZW4odGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKX0sSi5yZWFkVG9rZW49ZnVuY3Rpb24oZSl7cmV0dXJuIGJ0KGUsdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXx8ZT09PTkyP3RoaXMucmVhZFdvcmQoKTp0aGlzLmdldFRva2VuRnJvbUNvZGUoZSl9LEouZnVsbENoYXJDb2RlQXRQb3M9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO2lmKGU8PTU1Mjk1fHxlPj01NjMyMClyZXR1cm4gZTt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk7cmV0dXJuIHQ8PTU2MzE5fHx0Pj01NzM0ND9lOihlPDwxMCkrdC01NjYxMzg4OH0sSi5za2lwQmxvY2tDb21tZW50PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zLm9uQ29tbWVudCYmdGhpcy5jdXJQb3NpdGlvbigpLHQ9dGhpcy5wb3MsaT10aGlzLmlucHV0LmluZGV4T2YoIiovIix0aGlzLnBvcys9Mik7aWYoaT09PS0xJiZ0aGlzLnJhaXNlKHRoaXMucG9zLTIsIlVudGVybWluYXRlZCBjb21tZW50IiksdGhpcy5wb3M9aSsyLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpZm9yKHZhciBzPXZvaWQgMCxuPXQ7KHM9X2wodGhpcy5pbnB1dCxuLHRoaXMucG9zKSk+LTE7KSsrdGhpcy5jdXJMaW5lLG49dGhpcy5saW5lU3RhcnQ9czt0aGlzLm9wdGlvbnMub25Db21tZW50JiZ0aGlzLm9wdGlvbnMub25Db21tZW50KCEwLHRoaXMuaW5wdXQuc2xpY2UodCsyLGkpLHQsdGhpcy5wb3MsZSx0aGlzLmN1clBvc2l0aW9uKCkpfSxKLnNraXBMaW5lQ29tbWVudD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5wb3MsaT10aGlzLm9wdGlvbnMub25Db21tZW50JiZ0aGlzLmN1clBvc2l0aW9uKCkscz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrPWUpO3RoaXMucG9zPHRoaXMuaW5wdXQubGVuZ3RoJiYhbWkocyk7KXM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO3RoaXMub3B0aW9ucy5vbkNvbW1lbnQmJnRoaXMub3B0aW9ucy5vbkNvbW1lbnQoITEsdGhpcy5pbnB1dC5zbGljZSh0K2UsdGhpcy5wb3MpLHQsdGhpcy5wb3MsaSx0aGlzLmN1clBvc2l0aW9uKCkpfSxKLnNraXBTcGFjZT1mdW5jdGlvbigpe2U6Zm9yKDt0aGlzLnBvczx0aGlzLmlucHV0Lmxlbmd0aDspe3ZhciBlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7c3dpdGNoKGUpe2Nhc2UgMzI6Y2FzZSAxNjA6Kyt0aGlzLnBvczticmVhaztjYXNlIDEzOnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKT09PTEwJiYrK3RoaXMucG9zO2Nhc2UgMTA6Y2FzZSA4MjMyOmNhc2UgODIzMzorK3RoaXMucG9zLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJigrK3RoaXMuY3VyTGluZSx0aGlzLmxpbmVTdGFydD10aGlzLnBvcyk7YnJlYWs7Y2FzZSA0Nzpzd2l0Y2godGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpKXtjYXNlIDQyOnRoaXMuc2tpcEJsb2NrQ29tbWVudCgpO2JyZWFrO2Nhc2UgNDc6dGhpcy5za2lwTGluZUNvbW1lbnQoMik7YnJlYWs7ZGVmYXVsdDpicmVhayBlfWJyZWFrO2RlZmF1bHQ6aWYoIShlPjgmJmU8MTR8fGU+PTU3NjAmJmhhLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSkpKWJyZWFrIGU7Kyt0aGlzLnBvc319fSxKLmZpbmlzaFRva2VuPWZ1bmN0aW9uKGUsdCl7dGhpcy5lbmQ9dGhpcy5wb3MsdGhpcy5vcHRpb25zLmxvY2F0aW9ucyYmKHRoaXMuZW5kTG9jPXRoaXMuY3VyUG9zaXRpb24oKSk7dmFyIGk9dGhpcy50eXBlO3RoaXMudHlwZT1lLHRoaXMudmFsdWU9dCx0aGlzLnVwZGF0ZUNvbnRleHQoaSl9LEoucmVhZFRva2VuX2RvdD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKTtpZihlPj00OCYmZTw9NTcpcmV0dXJuIHRoaXMucmVhZE51bWJlcighMCk7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpO3JldHVybiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJmU9PT00NiYmdD09PTQ2Pyh0aGlzLnBvcys9Myx0aGlzLmZpbmlzaFRva2VuKGYuZWxsaXBzaXMpKTooKyt0aGlzLnBvcyx0aGlzLmZpbmlzaFRva2VuKGYuZG90KSl9LEoucmVhZFRva2VuX3NsYXNoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO3JldHVybiB0aGlzLmV4cHJBbGxvd2VkPygrK3RoaXMucG9zLHRoaXMucmVhZFJlZ2V4cCgpKTplPT09NjE/dGhpcy5maW5pc2hPcChmLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKGYuc2xhc2gsMSl9LEoucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSksaT0xLHM9ZT09PTQyP2Yuc3RhcjpmLm1vZHVsbztyZXR1cm4gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj03JiZlPT09NDImJnQ9PT00MiYmKCsraSxzPWYuc3RhcnN0YXIsdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMikpLHQ9PT02MT90aGlzLmZpbmlzaE9wKGYuYXNzaWduLGkrMSk6dGhpcy5maW5pc2hPcChzLGkpfSxKLnJlYWRUb2tlbl9waXBlX2FtcD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk7cmV0dXJuIHQ9PT1lP3RoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTImJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKT09PTYxP3RoaXMuZmluaXNoT3AoZi5hc3NpZ24sMyk6dGhpcy5maW5pc2hPcChlPT09MTI0P2YubG9naWNhbE9SOmYubG9naWNhbEFORCwyKTp0PT09NjE/dGhpcy5maW5pc2hPcChmLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKGU9PT0xMjQ/Zi5iaXR3aXNlT1I6Zi5iaXR3aXNlQU5ELDEpfSxKLnJlYWRUb2tlbl9jYXJldD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk9PT02MT90aGlzLmZpbmlzaE9wKGYuYXNzaWduLDIpOnRoaXMuZmluaXNoT3AoZi5iaXR3aXNlWE9SLDEpfSxKLnJlYWRUb2tlbl9wbHVzX21pbj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk7cmV0dXJuIHQ9PT1lP3QhPT00NXx8dGhpcy5pbk1vZHVsZXx8dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpIT09NjJ8fHRoaXMubGFzdFRva0VuZCE9PTAmJiFLZS50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLHRoaXMucG9zKSk/dGhpcy5maW5pc2hPcChmLmluY0RlYywyKToodGhpcy5za2lwTGluZUNvbW1lbnQoMyksdGhpcy5za2lwU3BhY2UoKSx0aGlzLm5leHRUb2tlbigpKTp0PT09NjE/dGhpcy5maW5pc2hPcChmLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKGYucGx1c01pbiwxKX0sSi5yZWFkVG9rZW5fbHRfZ3Q9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpLGk9MTtyZXR1cm4gdD09PWU/KGk9ZT09PTYyJiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMik9PT02Mj8zOjIsdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zK2kpPT09NjE/dGhpcy5maW5pc2hPcChmLmFzc2lnbixpKzEpOnRoaXMuZmluaXNoT3AoZi5iaXRTaGlmdCxpKSk6dCE9PTMzfHxlIT09NjB8fHRoaXMuaW5Nb2R1bGV8fHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKSE9PTQ1fHx0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMykhPT00NT8odD09PTYxJiYoaT0yKSx0aGlzLmZpbmlzaE9wKGYucmVsYXRpb25hbCxpKSk6KHRoaXMuc2tpcExpbmVDb21tZW50KDQpLHRoaXMuc2tpcFNwYWNlKCksdGhpcy5uZXh0VG9rZW4oKSl9LEoucmVhZFRva2VuX2VxX2V4Y2w9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO3JldHVybiB0PT09NjE/dGhpcy5maW5pc2hPcChmLmVxdWFsaXR5LHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKT09PTYxPzM6Mik6ZT09PTYxJiZ0PT09NjImJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49Nj8odGhpcy5wb3MrPTIsdGhpcy5maW5pc2hUb2tlbihmLmFycm93KSk6dGhpcy5maW5pc2hPcChlPT09NjE/Zi5lcTpmLnByZWZpeCwxKX0sSi5yZWFkVG9rZW5fcXVlc3Rpb249ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb247aWYoZT49MTEpe3ZhciB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKTtpZih0PT09NDYpe3ZhciBpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKTtpZihpPDQ4fHxpPjU3KXJldHVybiB0aGlzLmZpbmlzaE9wKGYucXVlc3Rpb25Eb3QsMil9aWYodD09PTYzKXJldHVybiBlPj0xMiYmdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpPT09NjE/dGhpcy5maW5pc2hPcChmLmFzc2lnbiwzKTp0aGlzLmZpbmlzaE9wKGYuY29hbGVzY2UsMil9cmV0dXJuIHRoaXMuZmluaXNoT3AoZi5xdWVzdGlvbiwxKX0sSi5yZWFkVG9rZW5fbnVtYmVyU2lnbj1mdW5jdGlvbigpe3ZhciBlPTM1O2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTMmJigrK3RoaXMucG9zLGJ0KGU9dGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpLCEwKXx8ZT09PTkyKSlyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihmLnByaXZhdGVJZCx0aGlzLnJlYWRXb3JkMSgpKTt0aGlzLnJhaXNlKHRoaXMucG9zLCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnIitIdChlKSsiJyIpfSxKLmdldFRva2VuRnJvbUNvZGU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UgNDY6cmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpO2Nhc2UgNDA6cmV0dXJuKyt0aGlzLnBvcyx0aGlzLmZpbmlzaFRva2VuKGYucGFyZW5MKTtjYXNlIDQxOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLnBhcmVuUik7Y2FzZSA1OTpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZi5zZW1pKTtjYXNlIDQ0OnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLmNvbW1hKTtjYXNlIDkxOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLmJyYWNrZXRMKTtjYXNlIDkzOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLmJyYWNrZXRSKTtjYXNlIDEyMzpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZi5icmFjZUwpO2Nhc2UgMTI1OnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLmJyYWNlUik7Y2FzZSA1ODpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZi5jb2xvbik7Y2FzZSA5NjppZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248NilicmVhaztyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZi5iYWNrUXVvdGUpO2Nhc2UgNDg6dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO2lmKHQ9PT0xMjB8fHQ9PT04OClyZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49Nil7aWYodD09PTExMXx8dD09PTc5KXJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTtpZih0PT09OTh8fHQ9PT02NilyZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMil9Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6cmV0dXJuIHRoaXMucmVhZE51bWJlcighMSk7Y2FzZSAzNDpjYXNlIDM5OnJldHVybiB0aGlzLnJlYWRTdHJpbmcoZSk7Y2FzZSA0NzpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtjYXNlIDM3OmNhc2UgNDI6cmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChlKTtjYXNlIDEyNDpjYXNlIDM4OnJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChlKTtjYXNlIDk0OnJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO2Nhc2UgNDM6Y2FzZSA0NTpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oZSk7Y2FzZSA2MDpjYXNlIDYyOnJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChlKTtjYXNlIDYxOmNhc2UgMzM6cmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woZSk7Y2FzZSA2MzpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKTtjYXNlIDEyNjpyZXR1cm4gdGhpcy5maW5pc2hPcChmLnByZWZpeCwxKTtjYXNlIDM1OnJldHVybiB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKCl9dGhpcy5yYWlzZSh0aGlzLnBvcywiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJyIrSHQoZSkrIiciKX0sSi5maW5pc2hPcD1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsdGhpcy5wb3MrdCk7cmV0dXJuIHRoaXMucG9zKz10LHRoaXMuZmluaXNoVG9rZW4oZSxpKX0sSi5yZWFkUmVnZXhwPWZ1bmN0aW9uKCl7Zm9yKHZhciBlLHQsaT10aGlzLnBvczs7KXt0aGlzLnBvcz49dGhpcy5pbnB1dC5sZW5ndGgmJnRoaXMucmFpc2UoaSwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiIpO3ZhciBzPXRoaXMuaW5wdXQuY2hhckF0KHRoaXMucG9zKTtpZihLZS50ZXN0KHMpJiZ0aGlzLnJhaXNlKGksIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb24iKSxlKWU9ITE7ZWxzZXtpZihzPT09IlsiKXQ9ITA7ZWxzZSBpZihzPT09Il0iJiZ0KXQ9ITE7ZWxzZSBpZihzPT09Ii8iJiYhdClicmVhaztlPXM9PT0iXFwifSsrdGhpcy5wb3N9dmFyIG49dGhpcy5pbnB1dC5zbGljZShpLHRoaXMucG9zKTsrK3RoaXMucG9zO3ZhciByPXRoaXMucG9zLGE9dGhpcy5yZWFkV29yZDEoKTt0aGlzLmNvbnRhaW5zRXNjJiZ0aGlzLnVuZXhwZWN0ZWQocik7dmFyIG89dGhpcy5yZWdleHBTdGF0ZXx8KHRoaXMucmVnZXhwU3RhdGU9bmV3IEV0KHRoaXMpKTtvLnJlc2V0KGksbixhKSx0aGlzLnZhbGlkYXRlUmVnRXhwRmxhZ3MobyksdGhpcy52YWxpZGF0ZVJlZ0V4cFBhdHRlcm4obyk7dmFyIGg9bnVsbDt0cnl7aD1uZXcgUmVnRXhwKG4sYSl9Y2F0Y2h7fXJldHVybiB0aGlzLmZpbmlzaFRva2VuKGYucmVnZXhwLHtwYXR0ZXJuOm4sZmxhZ3M6YSx2YWx1ZTpofSl9LEoucmVhZEludD1mdW5jdGlvbihlLHQsaSl7Zm9yKHZhciBzPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTImJnQ9PT12b2lkIDAsbj1pJiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpPT09NDgscj10aGlzLnBvcyxhPTAsbz0wLGg9MCxsPXQ/PzEvMDtoPGw7KytoLCsrdGhpcy5wb3Mpe3ZhciBjPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykscD12b2lkIDA7aWYocyYmYz09PTk1KW4mJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgaW4gbGVnYWN5IG9jdGFsIG51bWVyaWMgbGl0ZXJhbHMiKSxvPT09OTUmJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywiTnVtZXJpYyBzZXBhcmF0b3IgbXVzdCBiZSBleGFjdGx5IG9uZSB1bmRlcnNjb3JlIiksaD09PTAmJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnBvcywiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGZpcnN0IG9mIGRpZ2l0cyIpLG89YztlbHNle2lmKChwPWM+PTk3P2MtOTcrMTA6Yz49NjU/Yy02NSsxMDpjPj00OCYmYzw9NTc/Yy00ODoxLzApPj1lKWJyZWFrO289YyxhPWEqZStwfX1yZXR1cm4gcyYmbz09PTk1JiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MtMSwiTnVtZXJpYyBzZXBhcmF0b3IgaXMgbm90IGFsbG93ZWQgYXQgdGhlIGxhc3Qgb2YgZGlnaXRzIiksdGhpcy5wb3M9PT1yfHx0IT1udWxsJiZ0aGlzLnBvcy1yIT09dD9udWxsOmF9LEoucmVhZFJhZGl4TnVtYmVyPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucG9zO3RoaXMucG9zKz0yO3ZhciBpPXRoaXMucmVhZEludChlKTtyZXR1cm4gaT09bnVsbCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0KzIsIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCAiK2UpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEmJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk9PT0xMTA/KGk9WGwodGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSksKyt0aGlzLnBvcyk6YnQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSYmdGhpcy5yYWlzZSh0aGlzLnBvcywiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXIiKSx0aGlzLmZpbmlzaFRva2VuKGYubnVtLGkpfSxKLnJlYWROdW1iZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wb3M7ZXx8dGhpcy5yZWFkSW50KDEwLHZvaWQgMCwhMCkhPT1udWxsfHx0aGlzLnJhaXNlKHQsIkludmFsaWQgbnVtYmVyIik7dmFyIGk9dGhpcy5wb3MtdD49MiYmdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHQpPT09NDg7aSYmdGhpcy5zdHJpY3QmJnRoaXMucmFpc2UodCwiSW52YWxpZCBudW1iZXIiKTt2YXIgcz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO2lmKCFpJiYhZSYmdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMSYmcz09PTExMCl7dmFyIG49WGwodGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSk7cmV0dXJuKyt0aGlzLnBvcyxidCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpJiZ0aGlzLnJhaXNlKHRoaXMucG9zLCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlciIpLHRoaXMuZmluaXNoVG9rZW4oZi5udW0sbil9aSYmL1s4OV0vLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSkmJihpPSExKSxzIT09NDZ8fGl8fCgrK3RoaXMucG9zLHRoaXMucmVhZEludCgxMCkscz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpKSxzIT09NjkmJnMhPT0xMDF8fGl8fCgocz10aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykpIT09NDMmJnMhPT00NXx8Kyt0aGlzLnBvcyx0aGlzLnJlYWRJbnQoMTApPT09bnVsbCYmdGhpcy5yYWlzZSh0LCJJbnZhbGlkIG51bWJlciIpKSxidCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpJiZ0aGlzLnJhaXNlKHRoaXMucG9zLCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlciIpO3ZhciByLGE9KHI9dGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSxpP3BhcnNlSW50KHIsOCk6cGFyc2VGbG9hdChyLnJlcGxhY2UoL18vZywiIikpKTtyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihmLm51bSxhKX0sSi5yZWFkQ29kZVBvaW50PWZ1bmN0aW9uKCl7dmFyIGU7aWYodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKT09PTEyMyl7dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDYmJnRoaXMudW5leHBlY3RlZCgpO3ZhciB0PSsrdGhpcy5wb3M7ZT10aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZigifSIsdGhpcy5wb3MpLXRoaXMucG9zKSwrK3RoaXMucG9zLGU+MTExNDExMSYmdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odCwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzIil9ZWxzZSBlPXRoaXMucmVhZEhleENoYXIoNCk7cmV0dXJuIGV9LEoucmVhZFN0cmluZz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9IiIsaT0rK3RoaXMucG9zOzspe3RoaXMucG9zPj10aGlzLmlucHV0Lmxlbmd0aCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50Iik7dmFyIHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtpZihzPT09ZSlicmVhaztzPT09OTI/KHQrPXRoaXMuaW5wdXQuc2xpY2UoaSx0aGlzLnBvcyksdCs9dGhpcy5yZWFkRXNjYXBlZENoYXIoITEpLGk9dGhpcy5wb3MpOnM9PT04MjMyfHxzPT09ODIzMz8odGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDEwJiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnQiKSwrK3RoaXMucG9zLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJih0aGlzLmN1ckxpbmUrKyx0aGlzLmxpbmVTdGFydD10aGlzLnBvcykpOihtaShzKSYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50IiksKyt0aGlzLnBvcyl9cmV0dXJuIHQrPXRoaXMuaW5wdXQuc2xpY2UoaSx0aGlzLnBvcysrKSx0aGlzLmZpbmlzaFRva2VuKGYuc3RyaW5nLHQpfTt2YXIgWmw9e307Si50cnlSZWFkVGVtcGxhdGVUb2tlbj1mdW5jdGlvbigpe3RoaXMuaW5UZW1wbGF0ZUVsZW1lbnQ9ITA7dHJ5e3RoaXMucmVhZFRtcGxUb2tlbigpfWNhdGNoKGUpe2lmKGUhPT1abCl0aHJvdyBlO3RoaXMucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuKCl9dGhpcy5pblRlbXBsYXRlRWxlbWVudD0hMX0sSi5pbnZhbGlkU3RyaW5nVG9rZW49ZnVuY3Rpb24oZSx0KXtpZih0aGlzLmluVGVtcGxhdGVFbGVtZW50JiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkpdGhyb3cgWmw7dGhpcy5yYWlzZShlLHQpfSxKLnJlYWRUbXBsVG9rZW49ZnVuY3Rpb24oKXtmb3IodmFyIGU9IiIsdD10aGlzLnBvczs7KXt0aGlzLnBvcz49dGhpcy5pbnB1dC5sZW5ndGgmJnRoaXMucmFpc2UodGhpcy5zdGFydCwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIik7dmFyIGk9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtpZihpPT09OTZ8fGk9PT0zNiYmdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpPT09MTIzKXJldHVybiB0aGlzLnBvcyE9PXRoaXMuc3RhcnR8fHRoaXMudHlwZSE9PWYudGVtcGxhdGUmJnRoaXMudHlwZSE9PWYuaW52YWxpZFRlbXBsYXRlPyhlKz10aGlzLmlucHV0LnNsaWNlKHQsdGhpcy5wb3MpLHRoaXMuZmluaXNoVG9rZW4oZi50ZW1wbGF0ZSxlKSk6aT09PTM2Pyh0aGlzLnBvcys9Mix0aGlzLmZpbmlzaFRva2VuKGYuZG9sbGFyQnJhY2VMKSk6KCsrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihmLmJhY2tRdW90ZSkpO2lmKGk9PT05MillKz10aGlzLmlucHV0LnNsaWNlKHQsdGhpcy5wb3MpLGUrPXRoaXMucmVhZEVzY2FwZWRDaGFyKCEwKSx0PXRoaXMucG9zO2Vsc2UgaWYobWkoaSkpe3N3aXRjaChlKz10aGlzLmlucHV0LnNsaWNlKHQsdGhpcy5wb3MpLCsrdGhpcy5wb3MsaSl7Y2FzZSAxMzp0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpPT09MTAmJisrdGhpcy5wb3M7Y2FzZSAxMDplKz1gCmA7YnJlYWs7ZGVmYXVsdDplKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGkpfXRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJigrK3RoaXMuY3VyTGluZSx0aGlzLmxpbmVTdGFydD10aGlzLnBvcyksdD10aGlzLnBvc31lbHNlKyt0aGlzLnBvc319LEoucmVhZEludmFsaWRUZW1wbGF0ZVRva2VuPWZ1bmN0aW9uKCl7Zm9yKDt0aGlzLnBvczx0aGlzLmlucHV0Lmxlbmd0aDt0aGlzLnBvcysrKXN3aXRjaCh0aGlzLmlucHV0W3RoaXMucG9zXSl7Y2FzZSJcXCI6Kyt0aGlzLnBvczticmVhaztjYXNlIiQiOmlmKHRoaXMuaW5wdXRbdGhpcy5wb3MrMV0hPT0ieyIpYnJlYWs7Y2FzZSJgIjpyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihmLmludmFsaWRUZW1wbGF0ZSx0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsdGhpcy5wb3MpKX10aGlzLnJhaXNlKHRoaXMuc3RhcnQsIlVudGVybWluYXRlZCB0ZW1wbGF0ZSIpfSxKLnJlYWRFc2NhcGVkQ2hhcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7c3dpdGNoKCsrdGhpcy5wb3MsdCl7Y2FzZSAxMTA6cmV0dXJuYApgO2Nhc2UgMTE0OnJldHVybiJcciI7Y2FzZSAxMjA6cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSk7Y2FzZSAxMTc6cmV0dXJuIEh0KHRoaXMucmVhZENvZGVQb2ludCgpKTtjYXNlIDExNjpyZXR1cm4iCSI7Y2FzZSA5ODpyZXR1cm4iXGIiO2Nhc2UgMTE4OnJldHVybiJcdiI7Y2FzZSAxMDI6cmV0dXJuIlxmIjtjYXNlIDEzOnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk9PT0xMCYmKyt0aGlzLnBvcztjYXNlIDEwOnJldHVybiB0aGlzLm9wdGlvbnMubG9jYXRpb25zJiYodGhpcy5saW5lU3RhcnQ9dGhpcy5wb3MsKyt0aGlzLmN1ckxpbmUpLCIiO2Nhc2UgNTY6Y2FzZSA1NzppZih0aGlzLnN0cmljdCYmdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MtMSwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UiKSxlKXt2YXIgaT10aGlzLnBvcy0xO3RoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGksIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZyIpfWRlZmF1bHQ6aWYodD49NDgmJnQ8PTU1KXt2YXIgcz10aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcy0xLDMpLm1hdGNoKC9eWzAtN10rLylbMF0sbj1wYXJzZUludChzLDgpO3JldHVybiBuPjI1NSYmKHM9cy5zbGljZSgwLC0xKSxuPXBhcnNlSW50KHMsOCkpLHRoaXMucG9zKz1zLmxlbmd0aC0xLHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSxzPT09IjAiJiZ0IT09NTYmJnQhPT01N3x8IXRoaXMuc3RyaWN0JiYhZXx8dGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MtMS1zLmxlbmd0aCxlPyJPY3RhbCBsaXRlcmFsIGluIHRlbXBsYXRlIHN0cmluZyI6Ik9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGUiKSxTdHJpbmcuZnJvbUNoYXJDb2RlKG4pfXJldHVybiBtaSh0KT8iIjpTdHJpbmcuZnJvbUNoYXJDb2RlKHQpfX0sSi5yZWFkSGV4Q2hhcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBvcyxpPXRoaXMucmVhZEludCgxNixlKTtyZXR1cm4gaT09PW51bGwmJnRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHQsIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlIiksaX0sSi5yZWFkV29yZDE9ZnVuY3Rpb24oKXt0aGlzLmNvbnRhaW5zRXNjPSExO2Zvcih2YXIgZT0iIix0PSEwLGk9dGhpcy5wb3Mscz10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTY7dGhpcy5wb3M8dGhpcy5pbnB1dC5sZW5ndGg7KXt2YXIgbj10aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCk7aWYoZmkobixzKSl0aGlzLnBvcys9bjw9NjU1MzU/MToyO2Vsc2V7aWYobiE9PTkyKWJyZWFrO3RoaXMuY29udGFpbnNFc2M9ITAsZSs9dGhpcy5pbnB1dC5zbGljZShpLHRoaXMucG9zKTt2YXIgcj10aGlzLnBvczt0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcykhPT0xMTcmJnRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHRoaXMucG9zLCJFeHBlY3RpbmcgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgXFx1WFhYWCIpLCsrdGhpcy5wb3M7dmFyIGE9dGhpcy5yZWFkQ29kZVBvaW50KCk7KHQ/YnQ6ZmkpKGEscyl8fHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHIsIkludmFsaWQgVW5pY29kZSBlc2NhcGUiKSxlKz1IdChhKSxpPXRoaXMucG9zfXQ9ITF9cmV0dXJuIGUrdGhpcy5pbnB1dC5zbGljZShpLHRoaXMucG9zKX0sSi5yZWFkV29yZD1mdW5jdGlvbigpe3ZhciBlPXRoaXMucmVhZFdvcmQxKCksdD1mLm5hbWU7cmV0dXJuIHRoaXMua2V5d29yZHMudGVzdChlKSYmKHQ9dm5bZV0pLHRoaXMuZmluaXNoVG9rZW4odCxlKX07dmFyIEpsPSI4LjEwLjAiO2dlLmFjb3JuPXtQYXJzZXI6Z2UsdmVyc2lvbjpKbCxkZWZhdWx0T3B0aW9uczpFbixQb3NpdGlvbjpPaSxTb3VyY2VMb2NhdGlvbjp5cyxnZXRMaW5lSW5mbzpsYSxOb2RlOmJzLFRva2VuVHlwZTpuZSx0b2tUeXBlczpmLGtleXdvcmRUeXBlczp2bixUb2tDb250ZXh0OnR0LHRva0NvbnRleHRzOnBlLGlzSWRlbnRpZmllckNoYXI6ZmksaXNJZGVudGlmaWVyU3RhcnQ6YnQsVG9rZW46Q24saXNOZXdMaW5lOm1pLGxpbmVCcmVhazpLZSxsaW5lQnJlYWtHOlBsLG5vbkFTQ0lJd2hpdGVzcGFjZTpoYX07dmFyIE5mPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLE5vZGU6YnMsUGFyc2VyOmdlLFBvc2l0aW9uOk9pLFNvdXJjZUxvY2F0aW9uOnlzLFRva0NvbnRleHQ6dHQsVG9rZW46Q24sVG9rZW5UeXBlOm5lLGRlZmF1bHRPcHRpb25zOkVuLGdldExpbmVJbmZvOmxhLGlzSWRlbnRpZmllckNoYXI6ZmksaXNJZGVudGlmaWVyU3RhcnQ6YnQsaXNOZXdMaW5lOm1pLGtleXdvcmRUeXBlczp2bixsaW5lQnJlYWs6S2UsbGluZUJyZWFrRzpQbCxub25BU0NJSXdoaXRlc3BhY2U6aGEscGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZ2UucGFyc2UoZSx0KX0scGFyc2VFeHByZXNzaW9uQXQ6ZnVuY3Rpb24oZSx0LGkpe3JldHVybiBnZS5wYXJzZUV4cHJlc3Npb25BdChlLHQsaSl9LHRva0NvbnRleHRzOnBlLHRva1R5cGVzOmYsdG9rZW5pemVyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIGdlLnRva2VuaXplcihlLHQpfSx2ZXJzaW9uOkpsfSk7Y29uc3QgSW49ZT0+KCk9PkwoZnVuY3Rpb24odCl7cmV0dXJue2NvZGU6Ik5PX0ZTX0lOX0JST1dTRVIiLG1lc3NhZ2U6YENhbm5vdCBhY2Nlc3MgdGhlIGZpbGUgc3lzdGVtICh2aWEgIiR7dH0iKSB3aGVuIHVzaW5nIHRoZSBicm93c2VyIGJ1aWxkIG9mIFJvbGx1cC4gTWFrZSBzdXJlIHlvdSBzdXBwbHkgYSBwbHVnaW4gd2l0aCBjdXN0b20gcmVzb2x2ZUlkIGFuZCBsb2FkIGhvb2tzIHRvIFJvbGx1cC5gLHVybDpfZSgicGx1Z2luLWRldmVsb3BtZW50LyNhLXNpbXBsZS1leGFtcGxlIil9fShlKSksJGY9SW4oImZzLm1rZGlyIiksTGY9SW4oImZzLnJlYWRGaWxlIiksVGY9SW4oImZzLndyaXRlRmlsZSIpO2FzeW5jIGZ1bmN0aW9uIGV1KGUsdCxpLHMsbixyLGEsbyxoKXtjb25zdCBsPWF3YWl0IGZ1bmN0aW9uKGMscCxtLHksRSxnLHgsdil7bGV0IHc9bnVsbCxiPW51bGw7aWYoRSl7dz1uZXcgU2V0O2Zvcihjb25zdCBTIG9mIEUpYz09PVMuc291cmNlJiZwPT09Uy5pbXBvcnRlciYmdy5hZGQoUy5wbHVnaW4pO2I9KFMsayk9Pih7Li4uUyxyZXNvbHZlOihDLFAse2Fzc2VydGlvbnM6XyxjdXN0b206QSxpc0VudHJ5Ok4sc2tpcFNlbGY6VX09JGUpPT55KEMsUCxBLE4sX3x8cWUsVT9bLi4uRSx7aW1wb3J0ZXI6UCxwbHVnaW46ayxzb3VyY2U6Q31dOkUpfSl9cmV0dXJuIG0uaG9va0ZpcnN0QW5kR2V0UGx1Z2luKCJyZXNvbHZlSWQiLFtjLHAse2Fzc2VydGlvbnM6dixjdXN0b206Zyxpc0VudHJ5Onh9XSxiLHcpfShlLHQscyxuLHIsYSxvLGgpO3JldHVybiBsPT1udWxsP0luKCJwYXRoLnJlc29sdmUiKSgpOmxbMF19Y29uc3QgZ2E9ImF0IHBvc2l0aW9uICIseWE9ImF0IG91dHB1dCBwb3NpdGlvbiAiLFJmPXtkZWxldGU6KCk9PiExLGdldCgpe30saGFzOigpPT4hMSxzZXQoKXt9fTtmdW5jdGlvbiBQbihlKXtyZXR1cm4gZS5zdGFydHNXaXRoKGdhKXx8ZS5zdGFydHNXaXRoKHlhKT9MKHtjb2RlOkdjLG1lc3NhZ2U6IkEgcGx1Z2luIGlzIHRyeWluZyB0byB1c2UgdGhlIFJvbGx1cCBjYWNoZSBidXQgaXMgbm90IGRlY2xhcmluZyBhIHBsdWdpbiBuYW1lIG9yIGNhY2hlS2V5LiJ9KTpMKHtjb2RlOlljLG1lc3NhZ2U6YFRoZSBwbHVnaW4gbmFtZSAke2V9IGlzIGJlaW5nIHVzZWQgdHdpY2UgaW4gdGhlIHNhbWUgYnVpbGQuIFBsdWdpbiBuYW1lcyBtdXN0IGJlIGRpc3RpbmN0IG9yIHByb3ZpZGUgYSBjYWNoZUtleSAocGxlYXNlIHBvc3QgYW4gaXNzdWUgdG8gdGhlIHBsdWdpbiBpZiB5b3UgYXJlIGEgcGx1Z2luIHVzZXIpLmB9KX1jb25zdCB0dT0oZSx0LGk9VmYpPT57Y29uc3R7b253YXJuOnMsb25Mb2c6bn09ZSxyPU9mKGkscyk7aWYobil7Y29uc3QgYT1zaVt0XTtyZXR1cm4obyxoKT0+bihvLGl1KGgpLChsLGMpPT57aWYobD09PSJlcnJvciIpcmV0dXJuIEwoU3QoYykpO3NpW2xdPj1hJiZyKGwsU3QoYykpfSl9cmV0dXJuIHJ9LE9mPShlLHQpPT50PyhpLHMpPT57aT09PUs/dChpdShzKSxuPT5lKEssU3QobikpKTplKGkscyl9OmUsaXU9ZT0+KE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCJ0b1N0cmluZyIse3ZhbHVlOigpPT5zdShlKSx3cml0YWJsZTohMH0pLGUpLFN0PWU9PnR5cGVvZiBlPT0ic3RyaW5nIj97bWVzc2FnZTplfTp0eXBlb2YgZT09ImZ1bmN0aW9uIj9TdChlKCkpOmUsc3U9ZT0+e2xldCB0PSIiO3JldHVybiBlLnBsdWdpbiYmKHQrPWAoJHtlLnBsdWdpbn0gcGx1Z2luKSBgKSxlLmxvYyYmKHQrPWAke1goZS5sb2MuZmlsZSl9ICgke2UubG9jLmxpbmV9OiR7ZS5sb2MuY29sdW1ufSkgYCksdCtlLm1lc3NhZ2V9LFZmPShlLHQpPT57Y29uc3QgaT1zdSh0KTtzd2l0Y2goZSl7Y2FzZSBLOnJldHVybiBjb25zb2xlLndhcm4oaSk7Y2FzZSBxaTpyZXR1cm4gY29uc29sZS5kZWJ1ZyhpKTtkZWZhdWx0OnJldHVybiBjb25zb2xlLmluZm8oaSl9fTtmdW5jdGlvbiBudShlLHQsaSxzLG49LyQuLyl7Y29uc3Qgcj1uZXcgU2V0KHQpLGE9T2JqZWN0LmtleXMoZSkuZmlsdGVyKG89PiEoci5oYXMobyl8fG4udGVzdChvKSkpO2EubGVuZ3RoPjAmJnMoSyxmdW5jdGlvbihvLGgsbCl7cmV0dXJue2NvZGU6Y3AsbWVzc2FnZTpgVW5rbm93biAke299OiAke2guam9pbigiLCAiKX0uIEFsbG93ZWQgb3B0aW9uczogJHtsLmpvaW4oIiwgIil9YH19KGksYSxbLi4ucl0uc29ydCgpKSl9Y29uc3QgTWY9e3JlY29tbWVuZGVkOnthbm5vdGF0aW9uczohMCxjb3JyZWN0VmFyVmFsdWVCZWZvcmVEZWNsYXJhdGlvbjohMSxtYW51YWxQdXJlRnVuY3Rpb25zOnZlLG1vZHVsZVNpZGVFZmZlY3RzOigpPT4hMCxwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0czohMCx0cnlDYXRjaERlb3B0aW1pemF0aW9uOiEwLHVua25vd25HbG9iYWxTaWRlRWZmZWN0czohMX0sc2FmZXN0Onthbm5vdGF0aW9uczohMCxjb3JyZWN0VmFyVmFsdWVCZWZvcmVEZWNsYXJhdGlvbjohMCxtYW51YWxQdXJlRnVuY3Rpb25zOnZlLG1vZHVsZVNpZGVFZmZlY3RzOigpPT4hMCxwcm9wZXJ0eVJlYWRTaWRlRWZmZWN0czohMCx0cnlDYXRjaERlb3B0aW1pemF0aW9uOiEwLHVua25vd25HbG9iYWxTaWRlRWZmZWN0czohMH0sc21hbGxlc3Q6e2Fubm90YXRpb25zOiEwLGNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uOiExLG1hbnVhbFB1cmVGdW5jdGlvbnM6dmUsbW9kdWxlU2lkZUVmZmVjdHM6KCk9PiExLHByb3BlcnR5UmVhZFNpZGVFZmZlY3RzOiExLHRyeUNhdGNoRGVvcHRpbWl6YXRpb246ITEsdW5rbm93bkdsb2JhbFNpZGVFZmZlY3RzOiExfX0sRGY9e2VzMjAxNTp7YXJyb3dGdW5jdGlvbnM6ITAsY29uc3RCaW5kaW5nczohMCxvYmplY3RTaG9ydGhhbmQ6ITAscmVzZXJ2ZWROYW1lc0FzUHJvcHM6ITAsc3ltYm9sczohMH0sZXM1OnthcnJvd0Z1bmN0aW9uczohMSxjb25zdEJpbmRpbmdzOiExLG9iamVjdFNob3J0aGFuZDohMSxyZXNlcnZlZE5hbWVzQXNQcm9wczohMCxzeW1ib2xzOiExfX0scnU9KGUsdCxpLHMsbik9Pntjb25zdCByPWU9PW51bGw/dm9pZCAwOmUucHJlc2V0O2lmKHIpe2NvbnN0IGE9dFtyXTtpZihhKXJldHVybnsuLi5hLC4uLmV9O0woRWUoYCR7aX0ucHJlc2V0YCxzLGB2YWxpZCB2YWx1ZXMgYXJlICR7SXQoT2JqZWN0LmtleXModCkpfWAscikpfXJldHVybigoYSxvLGgsbCk9PmM9PntpZih0eXBlb2YgYz09InN0cmluZyIpe2NvbnN0IHA9YVtjXTtpZihwKXJldHVybiBwO0woRWUobyxoLGB2YWxpZCB2YWx1ZXMgYXJlICR7bH0ke0l0KE9iamVjdC5rZXlzKGEpKX0uIFlvdSBjYW4gYWxzbyBzdXBwbHkgYW4gb2JqZWN0IGZvciBtb3JlIGZpbmUtZ3JhaW5lZCBjb250cm9sYCxjKSl9cmV0dXJuKHA9PnAmJnR5cGVvZiBwPT0ib2JqZWN0Ij9wOnt9KShjKX0pKHQsaSxzLG4pKGUpfSxfbj1hc3luYyBlPT4oYXdhaXQgYXN5bmMgZnVuY3Rpb24odCl7ZG8gdD0oYXdhaXQgUHJvbWlzZS5hbGwodCkpLmZsYXQoMS8wKTt3aGlsZSh0LnNvbWUoaT0+aT09bnVsbD92b2lkIDA6aS50aGVuKSk7cmV0dXJuIHR9KFtlXSkpLmZpbHRlcihCb29sZWFuKTthc3luYyBmdW5jdGlvbiBCZihlLHQsaSxzKXtjb25zdCBuPXQuaWQscj1bXTtsZXQgYT1lLm1hcD09PW51bGw/bnVsbDokaShlLm1hcCk7Y29uc3Qgbz1lLmNvZGU7bGV0IGg9ZS5hc3Q7Y29uc3QgbD1bXSxjPVtdO2xldCBwPSExO2NvbnN0IG09KCk9PnA9ITA7bGV0IHk9IiIsRT1lLmNvZGU7Y29uc3QgZz12PT4odyxiKT0+e3c9U3QodyksYiYmRHModyxiLEUsbiksdy5pZD1uLHcuaG9vaz0idHJhbnNmb3JtIix2KHcpfTtsZXQgeDt0cnl7eD1hd2FpdCBpLmhvb2tSZWR1Y2VBcmcwKCJ0cmFuc2Zvcm0iLFtFLG5dLGZ1bmN0aW9uKHYsdyxiKXtsZXQgUyxrO2lmKHR5cGVvZiB3PT0ic3RyaW5nIilTPXc7ZWxzZXtpZighd3x8dHlwZW9mIHchPSJvYmplY3QiKXJldHVybiB2O2lmKHQudXBkYXRlT3B0aW9ucyh3KSx3LmNvZGU9PW51bGwpcmV0dXJuKHcubWFwfHx3LmFzdCkmJnMoSyxmdW5jdGlvbihDKXtyZXR1cm57Y29kZTpocCxtZXNzYWdlOmBUaGUgcGx1Z2luICIke0N9IiByZXR1cm5lZCBhICJtYXAiIG9yICJhc3QiIHdpdGhvdXQgcmV0dXJuaW5nIGEgImNvZGUiLiBUaGlzIHdpbGwgYmUgaWdub3JlZC5gfX0oYi5uYW1lKSksdjsoe2NvZGU6UyxtYXA6ayxhc3Q6aH09dyl9cmV0dXJuIGshPT1udWxsJiZyLnB1c2goJGkodHlwZW9mIGs9PSJzdHJpbmciP0pTT04ucGFyc2Uoayk6ayl8fHttaXNzaW5nOiEwLHBsdWdpbjpiLm5hbWV9KSxFPVMsU30sKHYsdyk9PntyZXR1cm4geT13Lm5hbWUsey4uLnYsYWRkV2F0Y2hGaWxlKGspe2wucHVzaChrKSx2LmFkZFdhdGNoRmlsZShrKX0sY2FjaGU6cD92LmNhY2hlOihiPXYuY2FjaGUsUz1tLHtkZWxldGU6az0+KFMoKSxiLmRlbGV0ZShrKSksZ2V0Oms9PihTKCksYi5nZXQoaykpLGhhczprPT4oUygpLGIuaGFzKGspKSxzZXQ6KGssQyk9PihTKCksYi5zZXQoayxDKSl9KSxkZWJ1ZzpnKHYuZGVidWcpLGVtaXRGaWxlOms9PihjLnB1c2goayksaS5lbWl0RmlsZShrKSksZXJyb3I6KGssQyk9Pih0eXBlb2Ygaz09InN0cmluZyImJihrPXttZXNzYWdlOmt9KSxDJiZEcyhrLEMsRSxuKSxrLmlkPW4say5ob29rPSJ0cmFuc2Zvcm0iLHYuZXJyb3IoaykpLGdldENvbWJpbmVkU291cmNlbWFwKCl7Y29uc3Qgaz1mdW5jdGlvbihDLFAsXyxBLE4pe3JldHVybiBBLmxlbmd0aD09PTA/XzokaSh7dmVyc2lvbjozLC4uLmRsKEMsUCxfLEEscGwoTikpLnRyYWNlTWFwcGluZ3MoKX0pfShuLG8sYSxyLHMpO3JldHVybiBrPyhhIT09ayYmKGE9ayxyLmxlbmd0aD0wKSxuZXcgTnMoey4uLmssZmlsZTpudWxsLHNvdXJjZXNDb250ZW50Omsuc291cmNlc0NvbnRlbnR9KSk6bmV3IFp0KG8pLmdlbmVyYXRlTWFwKHtoaXJlczohMCxpbmNsdWRlQ29udGVudDohMCxzb3VyY2U6bn0pfSxpbmZvOmcodi5pbmZvKSxzZXRBc3NldFNvdXJjZSgpe3JldHVybiB0aGlzLmVycm9yKHtjb2RlOmlwLG1lc3NhZ2U6InNldEFzc2V0U291cmNlIGNhbm5vdCBiZSBjYWxsZWQgaW4gdHJhbnNmb3JtIGZvciBjYWNoaW5nIHJlYXNvbnMuIFVzZSBlbWl0RmlsZSB3aXRoIGEgc291cmNlLCBvciBjYWxsIHNldEFzc2V0U291cmNlIGluIGFub3RoZXIgaG9vay4ifSl9LHdhcm46Zyh2Lndhcm4pfTt2YXIgYixTfSl9Y2F0Y2godil7cmV0dXJuIEwoS2kodix5LHtob29rOiJ0cmFuc2Zvcm0iLGlkOm59KSl9cmV0dXJuIXAmJmMubGVuZ3RoPjAmJih0LnRyYW5zZm9ybUZpbGVzPWMpLHthc3Q6aCxjb2RlOngsY3VzdG9tVHJhbnNmb3JtQ2FjaGU6cCxvcmlnaW5hbENvZGU6byxvcmlnaW5hbFNvdXJjZW1hcDphLHNvdXJjZW1hcENoYWluOnIsdHJhbnNmb3JtRGVwZW5kZW5jaWVzOmx9fWNvbnN0IHhhPSJyZXNvbHZlRGVwZW5kZW5jaWVzIjtjbGFzcyBGZntjb25zdHJ1Y3Rvcih0LGkscyxuKXt0aGlzLmdyYXBoPXQsdGhpcy5tb2R1bGVzQnlJZD1pLHRoaXMub3B0aW9ucz1zLHRoaXMucGx1Z2luRHJpdmVyPW4sdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcz1uZXcgU2V0LHRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcz1bXSx0aGlzLmxhdGVzdExvYWRNb2R1bGVzUHJvbWlzZT1Qcm9taXNlLnJlc29sdmUoKSx0aGlzLm1vZHVsZUxvYWRQcm9taXNlcz1uZXcgTWFwLHRoaXMubW9kdWxlc1dpdGhMb2FkZWREZXBlbmRlbmNpZXM9bmV3IFNldCx0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eT0wLHRoaXMubmV4dEVudHJ5TW9kdWxlSW5kZXg9MCx0aGlzLnJlc29sdmVJZD1hc3luYyhyLGEsbyxoLGwsYz1udWxsKT0+dGhpcy5nZXRSZXNvbHZlZElkV2l0aERlZmF1bHRzKHRoaXMuZ2V0Tm9ybWFsaXplZFJlc29sdmVkSWRXaXRob3V0RGVmYXVsdHMoIXRoaXMub3B0aW9ucy5leHRlcm5hbChyLGEsITEpJiZhd2FpdCBldShyLGEsdGhpcy5vcHRpb25zLnByZXNlcnZlU3ltbGlua3MsdGhpcy5wbHVnaW5Ecml2ZXIsdGhpcy5yZXNvbHZlSWQsYyxvLHR5cGVvZiBoPT0iYm9vbGVhbiI/aDohYSxsKSxhLHIpLGwpLHRoaXMuaGFzTW9kdWxlU2lkZUVmZmVjdHM9cy50cmVlc2hha2U/cy50cmVlc2hha2UubW9kdWxlU2lkZUVmZmVjdHM6KCk9PiEwfWFzeW5jIGFkZEFkZGl0aW9uYWxNb2R1bGVzKHQsaSl7Y29uc3Qgcz10aGlzLmV4dGVuZExvYWRNb2R1bGVzUHJvbWlzZShQcm9taXNlLmFsbCh0Lm1hcChuPT50aGlzLmxvYWRFbnRyeU1vZHVsZShuLCExLHZvaWQgMCxudWxsLGkpKSkpO3JldHVybiBhd2FpdCB0aGlzLmF3YWl0TG9hZE1vZHVsZXNQcm9taXNlKCksc31hc3luYyBhZGRFbnRyeU1vZHVsZXModCxpKXtjb25zdCBzPXRoaXMubmV4dEVudHJ5TW9kdWxlSW5kZXg7dGhpcy5uZXh0RW50cnlNb2R1bGVJbmRleCs9dC5sZW5ndGg7Y29uc3Qgbj10aGlzLm5leHRDaHVua05hbWVQcmlvcml0eTt0aGlzLm5leHRDaHVua05hbWVQcmlvcml0eSs9dC5sZW5ndGg7Y29uc3Qgcj1hd2FpdCB0aGlzLmV4dGVuZExvYWRNb2R1bGVzUHJvbWlzZShQcm9taXNlLmFsbCh0Lm1hcCgoe2lkOmEsaW1wb3J0ZXI6b30pPT50aGlzLmxvYWRFbnRyeU1vZHVsZShhLCEwLG8sbnVsbCkpKS50aGVuKGE9Pntmb3IoY29uc3RbbyxoXW9mIGEuZW50cmllcygpKXtoLmlzVXNlckRlZmluZWRFbnRyeVBvaW50PWguaXNVc2VyRGVmaW5lZEVudHJ5UG9pbnR8fGksb3UoaCx0W29dLGksbitvKTtjb25zdCBsPXRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcy5maW5kKGM9PmMubW9kdWxlPT09aCk7bD9sLmluZGV4PU1hdGgubWluKGwuaW5kZXgscytvKTp0aGlzLmluZGV4ZWRFbnRyeU1vZHVsZXMucHVzaCh7aW5kZXg6cytvLG1vZHVsZTpofSl9cmV0dXJuIHRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcy5zb3J0KCh7aW5kZXg6b30se2luZGV4Omh9KT0+bz5oPzE6LTEpLGF9KSk7cmV0dXJuIGF3YWl0IHRoaXMuYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKSx7ZW50cnlNb2R1bGVzOnRoaXMuaW5kZXhlZEVudHJ5TW9kdWxlcy5tYXAoKHttb2R1bGU6YX0pPT5hKSxpbXBsaWNpdEVudHJ5TW9kdWxlczpbLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc10sbmV3RW50cnlNb2R1bGVzOnJ9fWFzeW5jIGVtaXRDaHVuayh7ZmlsZU5hbWU6dCxpZDppLGltcG9ydGVyOnMsbmFtZTpuLGltcGxpY2l0bHlMb2FkZWRBZnRlck9uZU9mOnIscHJlc2VydmVTaWduYXR1cmU6YX0pe2NvbnN0IG89e2ZpbGVOYW1lOnR8fG51bGwsaWQ6aSxpbXBvcnRlcjpzLG5hbWU6bnx8bnVsbH0saD1yP2F3YWl0IHRoaXMuYWRkRW50cnlXaXRoSW1wbGljaXREZXBlbmRhbnRzKG8scik6KGF3YWl0IHRoaXMuYWRkRW50cnlNb2R1bGVzKFtvXSwhMSkpLm5ld0VudHJ5TW9kdWxlc1swXTtyZXR1cm4gYSE9bnVsbCYmKGgucHJlc2VydmVTaWduYXR1cmU9YSksaH1hc3luYyBwcmVsb2FkTW9kdWxlKHQpe3JldHVybihhd2FpdCB0aGlzLmZldGNoTW9kdWxlKHRoaXMuZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyh0LHFlKSx2b2lkIDAsITEsIXQucmVzb2x2ZURlcGVuZGVuY2llc3x8eGEpKS5pbmZvfWFkZEVudHJ5V2l0aEltcGxpY2l0RGVwZW5kYW50cyh0LGkpe2NvbnN0IHM9dGhpcy5uZXh0Q2h1bmtOYW1lUHJpb3JpdHkrKztyZXR1cm4gdGhpcy5leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UodGhpcy5sb2FkRW50cnlNb2R1bGUodC5pZCwhMSx0LmltcG9ydGVyLG51bGwpLnRoZW4oYXN5bmMgbj0+e2lmKG91KG4sdCwhMSxzKSwhbi5pbmZvLmlzRW50cnkpe3RoaXMuaW1wbGljaXRFbnRyeU1vZHVsZXMuYWRkKG4pO2NvbnN0IHI9YXdhaXQgUHJvbWlzZS5hbGwoaS5tYXAoYT0+dGhpcy5sb2FkRW50cnlNb2R1bGUoYSwhMSx0LmltcG9ydGVyLG4uaWQpKSk7Zm9yKGNvbnN0IGEgb2YgciluLmltcGxpY2l0bHlMb2FkZWRBZnRlci5hZGQoYSk7Zm9yKGNvbnN0IGEgb2Ygbi5pbXBsaWNpdGx5TG9hZGVkQWZ0ZXIpYS5pbXBsaWNpdGx5TG9hZGVkQmVmb3JlLmFkZChuKX1yZXR1cm4gbn0pKX1hc3luYyBhZGRNb2R1bGVTb3VyY2UodCxpLHMpe2xldCBuO3RyeXtuPWF3YWl0IHRoaXMuZ3JhcGguZmlsZU9wZXJhdGlvblF1ZXVlLnJ1bihhc3luYygpPT5hd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rRmlyc3QoImxvYWQiLFt0XSk/P2F3YWl0IExmKHQsInV0ZjgiKSl9Y2F0Y2gobyl7bGV0IGg9YENvdWxkIG5vdCBsb2FkICR7dH1gO3Rocm93IGkmJihoKz1gIChpbXBvcnRlZCBieSAke1goaSl9KWApLGgrPWA6ICR7by5tZXNzYWdlfWAsby5tZXNzYWdlPWgsb31jb25zdCByPXR5cGVvZiBuPT0ic3RyaW5nIj97Y29kZTpufTpuIT1udWxsJiZ0eXBlb2Ygbj09Im9iamVjdCImJnR5cGVvZiBuLmNvZGU9PSJzdHJpbmciP246TChmdW5jdGlvbihvKXtyZXR1cm57Y29kZToiQkFEX0xPQURFUiIsbWVzc2FnZTpgRXJyb3IgbG9hZGluZyAiJHtYKG8pfSI6IHBsdWdpbiBsb2FkIGhvb2sgc2hvdWxkIHJldHVybiBhIHN0cmluZywgYSB7IGNvZGUsIG1hcCB9IG9iamVjdCwgb3Igbm90aGluZy9udWxsLmB9fSh0KSksYT10aGlzLmdyYXBoLmNhY2hlZE1vZHVsZXMuZ2V0KHQpO2lmKCFhfHxhLmN1c3RvbVRyYW5zZm9ybUNhY2hlfHxhLm9yaWdpbmFsQ29kZSE9PXIuY29kZXx8YXdhaXQgdGhpcy5wbHVnaW5Ecml2ZXIuaG9va0ZpcnN0KCJzaG91bGRUcmFuc2Zvcm1DYWNoZWRNb2R1bGUiLFt7YXN0OmEuYXN0LGNvZGU6YS5jb2RlLGlkOmEuaWQsbWV0YTphLm1ldGEsbW9kdWxlU2lkZUVmZmVjdHM6YS5tb2R1bGVTaWRlRWZmZWN0cyxyZXNvbHZlZFNvdXJjZXM6YS5yZXNvbHZlZElkcyxzeW50aGV0aWNOYW1lZEV4cG9ydHM6YS5zeW50aGV0aWNOYW1lZEV4cG9ydHN9XSkpcy51cGRhdGVPcHRpb25zKHIpLHMuc2V0U291cmNlKGF3YWl0IEJmKHIscyx0aGlzLnBsdWdpbkRyaXZlcix0aGlzLm9wdGlvbnMub25Mb2cpKTtlbHNle2lmKGEudHJhbnNmb3JtRmlsZXMpZm9yKGNvbnN0IG8gb2YgYS50cmFuc2Zvcm1GaWxlcyl0aGlzLnBsdWdpbkRyaXZlci5lbWl0RmlsZShvKTtzLnNldFNvdXJjZShhKX19YXN5bmMgYXdhaXRMb2FkTW9kdWxlc1Byb21pc2UoKXtsZXQgdDtkbyB0PXRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlLGF3YWl0IHQ7d2hpbGUodCE9PXRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlKX1leHRlbmRMb2FkTW9kdWxlc1Byb21pc2UodCl7cmV0dXJuIHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlPVByb21pc2UuYWxsKFt0LHRoaXMubGF0ZXN0TG9hZE1vZHVsZXNQcm9taXNlXSksdGhpcy5sYXRlc3RMb2FkTW9kdWxlc1Byb21pc2UuY2F0Y2goKCk9Pnt9KSx0fWFzeW5jIGZldGNoRHluYW1pY0RlcGVuZGVuY2llcyh0LGkpe2NvbnN0IHM9YXdhaXQgUHJvbWlzZS5hbGwoaS5tYXAobj0+bi50aGVuKGFzeW5jKFtyLGFdKT0+YT09PW51bGw/bnVsbDp0eXBlb2YgYT09InN0cmluZyI/KHIucmVzb2x1dGlvbj1hLG51bGwpOnIucmVzb2x1dGlvbj1hd2FpdCB0aGlzLmZldGNoUmVzb2x2ZWREZXBlbmRlbmN5KFgoYS5pZCksdC5pZCxhKSkpKTtmb3IoY29uc3QgbiBvZiBzKW4mJih0LmR5bmFtaWNEZXBlbmRlbmNpZXMuYWRkKG4pLG4uZHluYW1pY0ltcG9ydGVycy5wdXNoKHQuaWQpKX1hc3luYyBmZXRjaE1vZHVsZSh7YXNzZXJ0aW9uczp0LGlkOmksbWV0YTpzLG1vZHVsZVNpZGVFZmZlY3RzOm4sc3ludGhldGljTmFtZWRFeHBvcnRzOnJ9LGEsbyxoKXtjb25zdCBsPXRoaXMubW9kdWxlc0J5SWQuZ2V0KGkpO2lmKGwgaW5zdGFuY2VvZiB5ZSlyZXR1cm4gYSYmdW4odCxsLmluZm8uYXNzZXJ0aW9ucykmJnRoaXMub3B0aW9ucy5vbkxvZyhLLEJzKGwuaW5mby5hc3NlcnRpb25zLHQsaSxhKSksYXdhaXQgdGhpcy5oYW5kbGVFeGlzdGluZ01vZHVsZShsLG8saCksbDtpZihsIGluc3RhbmNlb2YgbGUpcmV0dXJuIEwoe2NvZGU6IkVYVEVSTkFMX01PRFVMRVNfQ0FOTk9UX0JFX1RSQU5TRk9STUVEX1RPX01PRFVMRVMiLG1lc3NhZ2U6YCR7bC5pZH0gaXMgcmVzb2x2ZWQgYXMgYSBtb2R1bGUgbm93LCBidXQgaXQgd2FzIGFuIGV4dGVybmFsIG1vZHVsZSBiZWZvcmUuIFBsZWFzZSBjaGVjayB3aGV0aGVyIHRoZXJlIGFyZSBjb25mbGljdHMgaW4geW91ciBSb2xsdXAgb3B0aW9ucyAiZXh0ZXJuYWwiIGFuZCAibWFudWFsQ2h1bmtzIiwgbWFudWFsQ2h1bmtzIGNhbm5vdCBpbmNsdWRlIGV4dGVybmFsIG1vZHVsZXMuYH0pO2NvbnN0IGM9bmV3IHllKHRoaXMuZ3JhcGgsaSx0aGlzLm9wdGlvbnMsbyxuLHIscyx0KTt0aGlzLm1vZHVsZXNCeUlkLnNldChpLGMpLHRoaXMuZ3JhcGgud2F0Y2hGaWxlc1tpXT0hMDtjb25zdCBwPXRoaXMuYWRkTW9kdWxlU291cmNlKGksYSxjKS50aGVuKCgpPT5bdGhpcy5nZXRSZXNvbHZlU3RhdGljRGVwZW5kZW5jeVByb21pc2VzKGMpLHRoaXMuZ2V0UmVzb2x2ZUR5bmFtaWNJbXBvcnRQcm9taXNlcyhjKSxtXSksbT1odShwKS50aGVuKCgpPT50aGlzLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoIm1vZHVsZVBhcnNlZCIsW2MuaW5mb10pKTttLmNhdGNoKCgpPT57fSksdGhpcy5tb2R1bGVMb2FkUHJvbWlzZXMuc2V0KGMscCk7Y29uc3QgeT1hd2FpdCBwO3JldHVybiBoP2g9PT14YSYmYXdhaXQgbTphd2FpdCB0aGlzLmZldGNoTW9kdWxlRGVwZW5kZW5jaWVzKGMsLi4ueSksY31hc3luYyBmZXRjaE1vZHVsZURlcGVuZGVuY2llcyh0LGkscyxuKXt0aGlzLm1vZHVsZXNXaXRoTG9hZGVkRGVwZW5kZW5jaWVzLmhhcyh0KXx8KHRoaXMubW9kdWxlc1dpdGhMb2FkZWREZXBlbmRlbmNpZXMuYWRkKHQpLGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLmZldGNoU3RhdGljRGVwZW5kZW5jaWVzKHQsaSksdGhpcy5mZXRjaER5bmFtaWNEZXBlbmRlbmNpZXModCxzKV0pLHQubGlua0ltcG9ydHMoKSxhd2FpdCBuKX1mZXRjaFJlc29sdmVkRGVwZW5kZW5jeSh0LGkscyl7aWYocy5leHRlcm5hbCl7Y29uc3R7YXNzZXJ0aW9uczpuLGV4dGVybmFsOnIsaWQ6YSxtb2R1bGVTaWRlRWZmZWN0czpvLG1ldGE6aH09cztsZXQgbD10aGlzLm1vZHVsZXNCeUlkLmdldChhKTtpZihsKXtpZighKGwgaW5zdGFuY2VvZiBsZSkpcmV0dXJuIEwoZnVuY3Rpb24oYyxwKXtyZXR1cm57Y29kZToiSU5WQUxJRF9FWFRFUk5BTF9JRCIsbWVzc2FnZTpgIiR7Y30iIGlzIGltcG9ydGVkIGFzIGFuIGV4dGVybmFsIGJ5ICIke1gocCl9IiwgYnV0IGlzIGFscmVhZHkgYW4gZXhpc3Rpbmcgbm9uLWV4dGVybmFsIG1vZHVsZSBpZC5gfX0odCxpKSk7dW4obC5pbmZvLmFzc2VydGlvbnMsbikmJnRoaXMub3B0aW9ucy5vbkxvZyhLLEJzKGwuaW5mby5hc3NlcnRpb25zLG4sdCxpKSl9ZWxzZSBsPW5ldyBsZSh0aGlzLm9wdGlvbnMsYSxvLGgsciE9PSJhYnNvbHV0ZSImJlZ0KGEpLG4pLHRoaXMubW9kdWxlc0J5SWQuc2V0KGEsbCk7cmV0dXJuIFByb21pc2UucmVzb2x2ZShsKX1yZXR1cm4gdGhpcy5mZXRjaE1vZHVsZShzLGksITEsITEpfWFzeW5jIGZldGNoU3RhdGljRGVwZW5kZW5jaWVzKHQsaSl7Zm9yKGNvbnN0IHMgb2YgYXdhaXQgUHJvbWlzZS5hbGwoaS5tYXAobj0+bi50aGVuKChbcixhXSk9PnRoaXMuZmV0Y2hSZXNvbHZlZERlcGVuZGVuY3kocix0LmlkLGEpKSkpKXQuZGVwZW5kZW5jaWVzLmFkZChzKSxzLmltcG9ydGVycy5wdXNoKHQuaWQpO2lmKCF0aGlzLm9wdGlvbnMudHJlZXNoYWtlfHx0LmluZm8ubW9kdWxlU2lkZUVmZmVjdHM9PT0ibm8tdHJlZXNoYWtlIilmb3IoY29uc3QgcyBvZiB0LmRlcGVuZGVuY2llcylzIGluc3RhbmNlb2YgeWUmJihzLmltcG9ydGVkRnJvbU5vdFRyZWVzaGFrZW49ITApfWdldE5vcm1hbGl6ZWRSZXNvbHZlZElkV2l0aG91dERlZmF1bHRzKHQsaSxzKXtjb25zdHttYWtlQWJzb2x1dGVFeHRlcm5hbHNSZWxhdGl2ZTpufT10aGlzLm9wdGlvbnM7aWYodCl7aWYodHlwZW9mIHQ9PSJvYmplY3QiKXtjb25zdCBvPXQuZXh0ZXJuYWx8fHRoaXMub3B0aW9ucy5leHRlcm5hbCh0LmlkLGksITApO3JldHVybnsuLi50LGV4dGVybmFsOm8mJihvPT09InJlbGF0aXZlInx8IVZ0KHQuaWQpfHxvPT09ITAmJmJhKHQuaWQscyxuKXx8ImFic29sdXRlIil9fWNvbnN0IGE9dGhpcy5vcHRpb25zLmV4dGVybmFsKHQsaSwhMCk7cmV0dXJue2V4dGVybmFsOmEmJihiYSh0LHMsbil8fCJhYnNvbHV0ZSIpLGlkOmEmJm4/YXUodCxpKTp0fX1jb25zdCByPW4/YXUocyxpKTpzO3JldHVybiB0PT09ITF8fHRoaXMub3B0aW9ucy5leHRlcm5hbChyLGksITApP3tleHRlcm5hbDpiYShyLHMsbil8fCJhYnNvbHV0ZSIsaWQ6cn06bnVsbH1nZXRSZXNvbHZlRHluYW1pY0ltcG9ydFByb21pc2VzKHQpe3JldHVybiB0LmR5bmFtaWNJbXBvcnRzLm1hcChhc3luYyBpPT57Y29uc3Qgcz1hd2FpdCB0aGlzLnJlc29sdmVEeW5hbWljSW1wb3J0KHQsdHlwZW9mIGkuYXJndW1lbnQ9PSJzdHJpbmciP2kuYXJndW1lbnQ6aS5hcmd1bWVudC5lc1RyZWVOb2RlLHQuaWQsZnVuY3Rpb24obil7dmFyIG8saCxsO2NvbnN0IHI9KGw9KGg9KG89bi5hcmd1bWVudHMpPT1udWxsP3ZvaWQgMDpvWzBdKT09bnVsbD92b2lkIDA6aC5wcm9wZXJ0aWVzLmZpbmQoYz0+R3IoYyk9PT0iYXNzZXJ0IikpPT1udWxsP3ZvaWQgMDpsLnZhbHVlO2lmKCFyKXJldHVybiBxZTtjb25zdCBhPXIucHJvcGVydGllcy5tYXAoYz0+e2NvbnN0IHA9R3IoYyk7cmV0dXJuIHR5cGVvZiBwPT0ic3RyaW5nIiYmdHlwZW9mIGMudmFsdWUudmFsdWU9PSJzdHJpbmciP1twLGMudmFsdWUudmFsdWVdOm51bGx9KS5maWx0ZXIoYz0+ISFjKTtyZXR1cm4gYS5sZW5ndGg+MD9PYmplY3QuZnJvbUVudHJpZXMoYSk6cWV9KGkubm9kZSkpO3JldHVybiBzJiZ0eXBlb2Ygcz09Im9iamVjdCImJihpLmlkPXMuaWQpLFtpLHNdfSl9Z2V0UmVzb2x2ZVN0YXRpY0RlcGVuZGVuY3lQcm9taXNlcyh0KXtyZXR1cm4gQXJyYXkuZnJvbSh0LnNvdXJjZXNXaXRoQXNzZXJ0aW9ucyxhc3luYyhbaSxzXSk9PltpLHQucmVzb2x2ZWRJZHNbaV09dC5yZXNvbHZlZElkc1tpXXx8dGhpcy5oYW5kbGVJbnZhbGlkUmVzb2x2ZWRJZChhd2FpdCB0aGlzLnJlc29sdmVJZChpLHQuaWQscWUsITEscyksaSx0LmlkLHMpXSl9Z2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyh0LGkpe2lmKCF0KXJldHVybiBudWxsO2NvbnN0IHM9dC5leHRlcm5hbHx8ITE7cmV0dXJue2Fzc2VydGlvbnM6dC5hc3NlcnRpb25zfHxpLGV4dGVybmFsOnMsaWQ6dC5pZCxtZXRhOnQubWV0YXx8e30sbW9kdWxlU2lkZUVmZmVjdHM6dC5tb2R1bGVTaWRlRWZmZWN0cz8/dGhpcy5oYXNNb2R1bGVTaWRlRWZmZWN0cyh0LmlkLCEhcykscmVzb2x2ZWRCeTp0LnJlc29sdmVkQnk/PyJyb2xsdXAiLHN5bnRoZXRpY05hbWVkRXhwb3J0czp0LnN5bnRoZXRpY05hbWVkRXhwb3J0cz8/ITF9fWFzeW5jIGhhbmRsZUV4aXN0aW5nTW9kdWxlKHQsaSxzKXtjb25zdCBuPXRoaXMubW9kdWxlTG9hZFByb21pc2VzLmdldCh0KTtpZihzKXJldHVybiBzPT09eGE/aHUobik6bjtpZihpKXt0LmluZm8uaXNFbnRyeT0hMCx0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzLmRlbGV0ZSh0KTtmb3IoY29uc3QgciBvZiB0LmltcGxpY2l0bHlMb2FkZWRBZnRlcilyLmltcGxpY2l0bHlMb2FkZWRCZWZvcmUuZGVsZXRlKHQpO3QuaW1wbGljaXRseUxvYWRlZEFmdGVyLmNsZWFyKCl9cmV0dXJuIHRoaXMuZmV0Y2hNb2R1bGVEZXBlbmRlbmNpZXModCwuLi5hd2FpdCBuKX1oYW5kbGVJbnZhbGlkUmVzb2x2ZWRJZCh0LGkscyxuKXtyZXR1cm4gdD09PW51bGw/am4oaSk/TChmdW5jdGlvbihyLGEpe3JldHVybntjb2RlOmJvLGV4cG9ydGVyOnIsaWQ6YSxtZXNzYWdlOmBDb3VsZCBub3QgcmVzb2x2ZSAiJHtyfSIgZnJvbSAiJHtYKGEpfSJgfX0oaSxzKSk6KHRoaXMub3B0aW9ucy5vbkxvZyhLLGZ1bmN0aW9uKHIsYSl7cmV0dXJue2NvZGU6Ym8sZXhwb3J0ZXI6cixpZDphLG1lc3NhZ2U6YCIke3J9IiBpcyBpbXBvcnRlZCBieSAiJHtYKGEpfSIsIGJ1dCBjb3VsZCBub3QgYmUgcmVzb2x2ZWQg4oCTIHRyZWF0aW5nIGl0IGFzIGFuIGV4dGVybmFsIGRlcGVuZGVuY3kuYCx1cmw6X2UoInRyb3VibGVzaG9vdGluZy8jd2FybmluZy10cmVhdGluZy1tb2R1bGUtYXMtZXh0ZXJuYWwtZGVwZW5kZW5jeSIpfX0oaSxzKSkse2Fzc2VydGlvbnM6bixleHRlcm5hbDohMCxpZDppLG1ldGE6e30sbW9kdWxlU2lkZUVmZmVjdHM6dGhpcy5oYXNNb2R1bGVTaWRlRWZmZWN0cyhpLCEwKSxyZXNvbHZlZEJ5OiJyb2xsdXAiLHN5bnRoZXRpY05hbWVkRXhwb3J0czohMX0pOih0LmV4dGVybmFsJiZ0LnN5bnRoZXRpY05hbWVkRXhwb3J0cyYmdGhpcy5vcHRpb25zLm9uTG9nKEssZnVuY3Rpb24ocixhKXtyZXR1cm57Y29kZToiRVhURVJOQUxfU1lOVEhFVElDX0VYUE9SVFMiLGV4cG9ydGVyOnIsbWVzc2FnZTpgRXh0ZXJuYWwgIiR7cn0iIGNhbm5vdCBoYXZlICJzeW50aGV0aWNOYW1lZEV4cG9ydHMiIGVuYWJsZWQgKGltcG9ydGVkIGJ5ICIke1goYSl9IikuYH19KGkscykpLHQpfWFzeW5jIGxvYWRFbnRyeU1vZHVsZSh0LGkscyxuLHI9ITEpe2NvbnN0IGE9YXdhaXQgZXUodCxzLHRoaXMub3B0aW9ucy5wcmVzZXJ2ZVN5bWxpbmtzLHRoaXMucGx1Z2luRHJpdmVyLHRoaXMucmVzb2x2ZUlkLG51bGwscWUsITAscWUpO2lmKGE9PW51bGwpcmV0dXJuIEwobj09PW51bGw/ZnVuY3Rpb24oaCl7cmV0dXJue2NvZGU6eG8sbWVzc2FnZTpgQ291bGQgbm90IHJlc29sdmUgZW50cnkgbW9kdWxlICIke1goaCl9Ii5gfX0odCk6ZnVuY3Rpb24oaCxsKXtyZXR1cm57Y29kZTp0cixtZXNzYWdlOmBNb2R1bGUgIiR7WChoKX0iIHRoYXQgc2hvdWxkIGJlIGltcGxpY2l0bHkgbG9hZGVkIGJlZm9yZSAiJHtYKGwpfSIgY291bGQgbm90IGJlIHJlc29sdmVkLmB9fSh0LG4pKTtjb25zdCBvPXR5cGVvZiBhPT0ib2JqZWN0IiYmYS5leHRlcm5hbDtyZXR1cm4gYT09PSExfHxvP0wobj09PW51bGw/byYmcj97Y29kZToiRVhURVJOQUxfTU9EVUxFU19DQU5OT1RfQkVfSU5DTFVERURfSU5fTUFOVUFMX0NIVU5LUyIsbWVzc2FnZTpgIiR7dH0iIGNhbm5vdCBiZSBpbmNsdWRlZCBpbiBtYW51YWxDaHVua3MgYmVjYXVzZSBpdCBpcyByZXNvbHZlZCBhcyBhbiBleHRlcm5hbCBtb2R1bGUgYnkgdGhlICJleHRlcm5hbCIgb3B0aW9uIG9yIHBsdWdpbnMuYH06ZnVuY3Rpb24oaCl7cmV0dXJue2NvZGU6eG8sbWVzc2FnZTpgRW50cnkgbW9kdWxlICIke1goaCl9IiBjYW5ub3QgYmUgZXh0ZXJuYWwuYH19KHQpOmZ1bmN0aW9uKGgsbCl7cmV0dXJue2NvZGU6dHIsbWVzc2FnZTpgTW9kdWxlICIke1goaCl9IiB0aGF0IHNob3VsZCBiZSBpbXBsaWNpdGx5IGxvYWRlZCBiZWZvcmUgIiR7WChsKX0iIGNhbm5vdCBiZSBleHRlcm5hbC5gfX0odCxuKSk6dGhpcy5mZXRjaE1vZHVsZSh0aGlzLmdldFJlc29sdmVkSWRXaXRoRGVmYXVsdHModHlwZW9mIGE9PSJvYmplY3QiP2E6e2lkOmF9LHFlKSx2b2lkIDAsaSwhMSl9YXN5bmMgcmVzb2x2ZUR5bmFtaWNJbXBvcnQodCxpLHMsbil7Y29uc3Qgcj1hd2FpdCB0aGlzLnBsdWdpbkRyaXZlci5ob29rRmlyc3QoInJlc29sdmVEeW5hbWljSW1wb3J0IixbaSxzLHthc3NlcnRpb25zOm59XSk7aWYodHlwZW9mIGkhPSJzdHJpbmciKXJldHVybiB0eXBlb2Ygcj09InN0cmluZyI/cjpyP3RoaXMuZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyhyLG4pOm51bGw7aWYocj09bnVsbCl7Y29uc3QgYT10LnJlc29sdmVkSWRzW2ldO3JldHVybiBhPyh1bihhLmFzc2VydGlvbnMsbikmJnRoaXMub3B0aW9ucy5vbkxvZyhLLEJzKGEuYXNzZXJ0aW9ucyxuLGkscykpLGEpOnQucmVzb2x2ZWRJZHNbaV09dGhpcy5oYW5kbGVJbnZhbGlkUmVzb2x2ZWRJZChhd2FpdCB0aGlzLnJlc29sdmVJZChpLHQuaWQscWUsITEsbiksaSx0LmlkLG4pfXJldHVybiB0aGlzLmhhbmRsZUludmFsaWRSZXNvbHZlZElkKHRoaXMuZ2V0UmVzb2x2ZWRJZFdpdGhEZWZhdWx0cyh0aGlzLmdldE5vcm1hbGl6ZWRSZXNvbHZlZElkV2l0aG91dERlZmF1bHRzKHIscyxpKSxuKSxpLHMsbil9fWZ1bmN0aW9uIGF1KGUsdCl7cmV0dXJuIGpuKGUpP3Q/aHQodCwiLi4iLGUpOmh0KGUpOmV9ZnVuY3Rpb24gb3UoZSx7ZmlsZU5hbWU6dCxuYW1lOml9LHMsbil7dmFyIHI7aWYodCE9PW51bGwpZS5jaHVua0ZpbGVOYW1lcy5hZGQodCk7ZWxzZSBpZihpIT09bnVsbCl7bGV0IGE9MDtmb3IoOygocj1lLmNodW5rTmFtZXNbYV0pPT1udWxsP3ZvaWQgMDpyLnByaW9yaXR5KTxuOylhKys7ZS5jaHVua05hbWVzLnNwbGljZShhLDAse2lzVXNlckRlZmluZWQ6cyxuYW1lOmkscHJpb3JpdHk6bn0pfX1mdW5jdGlvbiBiYShlLHQsaSl7cmV0dXJuIGk9PT0hMHx8aT09PSJpZlJlbGF0aXZlU291cmNlIiYmam4odCl8fCFWdChlKX1hc3luYyBmdW5jdGlvbiBodShlKXtjb25zdFt0LGldPWF3YWl0IGU7cmV0dXJuIFByb21pc2UuYWxsKFsuLi50LC4uLmldKX1jbGFzcyB6ZiBleHRlbmRzIEtve2NvbnN0cnVjdG9yKCl7c3VwZXIoKSx0aGlzLnBhcmVudD1udWxsLHRoaXMudmFyaWFibGVzLnNldCgidW5kZWZpbmVkIixuZXcgTWgpfWZpbmRWYXJpYWJsZSh0KXtsZXQgaT10aGlzLnZhcmlhYmxlcy5nZXQodCk7cmV0dXJuIGl8fChpPW5ldyB4cih0KSx0aGlzLnZhcmlhYmxlcy5zZXQodCxpKSksaX19ZnVuY3Rpb24gbHUoZSl7cmV0dXJuIFJpKCkudXBkYXRlKGUpLmRpZ2VzdCgiaGV4Iil9ZnVuY3Rpb24gdXUoZSx0LGkscyxuKXtjb25zdCByPXMuc2FuaXRpemVGaWxlTmFtZShlfHwiYXNzZXQiKTtyZXR1cm4gdGEoZWEodHlwZW9mIHMuYXNzZXRGaWxlTmFtZXM9PSJmdW5jdGlvbiI/cy5hc3NldEZpbGVOYW1lcyh7bmFtZTplLHNvdXJjZTp0LHR5cGU6ImFzc2V0In0pOnMuYXNzZXRGaWxlTmFtZXMsIm91dHB1dC5hc3NldEZpbGVOYW1lcyIse2V4dDooKT0+TXQocikuc2xpY2UoMSksZXh0bmFtZTooKT0+TXQociksaGFzaDphPT5pLnNsaWNlKDAsTWF0aC5tYXgoMCxhfHw4KSksbmFtZTooKT0+ci5zbGljZSgwLE1hdGgubWF4KDAsci5sZW5ndGgtTXQocikubGVuZ3RoKSl9KSxuKX1mdW5jdGlvbiBjdShlLHtidW5kbGU6dH0saSl7dFtnbl0uaGFzKGUudG9Mb3dlckNhc2UoKSk/aShLLGZ1bmN0aW9uKHMpe3JldHVybntjb2RlOlhjLG1lc3NhZ2U6YFRoZSBlbWl0dGVkIGZpbGUgIiR7c30iIG92ZXJ3cml0ZXMgYSBwcmV2aW91c2x5IGVtaXR0ZWQgZmlsZSBvZiB0aGUgc2FtZSBuYW1lLmB9fShlKSk6dFtlXT1Kcn1jb25zdCBqZj1uZXcgU2V0KFsiY2h1bmsiLCJhc3NldCIsInByZWJ1aWx0LWNodW5rIl0pO2Z1bmN0aW9uIHB1KGUsdCxpKXtpZighKHR5cGVvZiBlPT0ic3RyaW5nInx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKXtjb25zdCBzPXQuZmlsZU5hbWV8fHQubmFtZXx8aTtyZXR1cm4gTChCZShgQ291bGQgbm90IHNldCBzb3VyY2UgZm9yICR7dHlwZW9mIHM9PSJzdHJpbmciP2Bhc3NldCAiJHtzfSJgOiJ1bm5hbWVkIGFzc2V0In0sIGFzc2V0IHNvdXJjZSBuZWVkcyB0byBiZSBhIHN0cmluZywgVWludDhBcnJheSBvciBCdWZmZXIuYCkpfXJldHVybiBlfWZ1bmN0aW9uIFVmKGUsdCl7cmV0dXJuIHR5cGVvZiBlLmZpbGVOYW1lIT0ic3RyaW5nIj9MKChpPWUubmFtZXx8dCx7Y29kZTpXYyxtZXNzYWdlOmBQbHVnaW4gZXJyb3IgLSBVbmFibGUgdG8gZ2V0IGZpbGUgbmFtZSBmb3IgYXNzZXQgIiR7aX0iLiBFbnN1cmUgdGhhdCB0aGUgc291cmNlIGlzIHNldCBhbmQgdGhhdCBnZW5lcmF0ZSBpcyBjYWxsZWQgZmlyc3QuIElmIHlvdSByZWZlcmVuY2UgYXNzZXRzIHZpYSBpbXBvcnQubWV0YS5ST0xMVVBfRklMRV9VUkxfPHJlZmVyZW5jZUlkPiwgeW91IG5lZWQgdG8gZWl0aGVyIGhhdmUgc2V0IHRoZWlyIHNvdXJjZSBhZnRlciAicmVuZGVyU3RhcnQiIG9yIG5lZWQgdG8gcHJvdmlkZSBhbiBleHBsaWNpdCAiZmlsZU5hbWUiIHdoZW4gZW1pdHRpbmcgdGhlbS5gfSkpOmUuZmlsZU5hbWU7dmFyIGl9ZnVuY3Rpb24gR2YoZSx0KXtyZXR1cm4gZS5maWxlTmFtZT9lLmZpbGVOYW1lOnQ/dC5nZXQoZS5tb2R1bGUpLmdldEZpbGVOYW1lKCk6TCgoaT1lLmZpbGVOYW1lfHxlLm5hbWUse2NvZGU6SGMsbWVzc2FnZTpgUGx1Z2luIGVycm9yIC0gVW5hYmxlIHRvIGdldCBmaWxlIG5hbWUgZm9yIGVtaXR0ZWQgY2h1bmsgIiR7aX0iLiBZb3UgY2FuIG9ubHkgZ2V0IGZpbGUgbmFtZXMgb25jZSBjaHVua3MgaGF2ZSBiZWVuIGdlbmVyYXRlZCBhZnRlciB0aGUgInJlbmRlclN0YXJ0IiBob29rLmB9KSk7dmFyIGl9Y2xhc3MgV2Z7Y29uc3RydWN0b3IodCxpLHMpe3RoaXMuZ3JhcGg9dCx0aGlzLm9wdGlvbnM9aSx0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGU9bnVsbCx0aGlzLm5leHRJZEJhc2U9MSx0aGlzLm91dHB1dD1udWxsLHRoaXMub3V0cHV0RmlsZUVtaXR0ZXJzPVtdLHRoaXMuZW1pdEZpbGU9bj0+ZnVuY3Rpb24ocil7cmV0dXJuISEociYmamYuaGFzKHIudHlwZSkpfShuKT9uLnR5cGU9PT0icHJlYnVpbHQtY2h1bmsiP3RoaXMuZW1pdFByZWJ1aWx0Q2h1bmsobik6ZnVuY3Rpb24ocil7Y29uc3QgYT1yLmZpbGVOYW1lfHxyLm5hbWU7cmV0dXJuIWF8fHR5cGVvZiBhPT0ic3RyaW5nIiYmIUxzKGEpfShuKT9uLnR5cGU9PT0iY2h1bmsiP3RoaXMuZW1pdENodW5rKG4pOnRoaXMuZW1pdEFzc2V0KG4pOkwoQmUoYFRoZSAiZmlsZU5hbWUiIG9yICJuYW1lIiBwcm9wZXJ0aWVzIG9mIGVtaXR0ZWQgY2h1bmtzIGFuZCBhc3NldHMgbXVzdCBiZSBzdHJpbmdzIHRoYXQgYXJlIG5laXRoZXIgYWJzb2x1dGUgbm9yIHJlbGF0aXZlIHBhdGhzLCByZWNlaXZlZCAiJHtuLmZpbGVOYW1lfHxuLm5hbWV9Ii5gKSk6TChCZShgRW1pdHRlZCBmaWxlcyBtdXN0IGJlIG9mIHR5cGUgImFzc2V0IiwgImNodW5rIiBvciAicHJlYnVpbHQtY2h1bmsiLCByZWNlaXZlZCAiJHtuJiZuLnR5cGV9Ii5gKSksdGhpcy5maW5hbGlzZUFzc2V0cz0oKT0+e2Zvcihjb25zdFtuLHJdb2YgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQpaWYoci50eXBlPT09ImFzc2V0IiYmdHlwZW9mIHIuZmlsZU5hbWUhPSJzdHJpbmciKXJldHVybiBMKHtjb2RlOiJBU1NFVF9TT1VSQ0VfTUlTU0lORyIsbWVzc2FnZTpgUGx1Z2luIGVycm9yIGNyZWF0aW5nIGFzc2V0ICIke3IubmFtZXx8bn0iIC0gbm8gYXNzZXQgc291cmNlIHNldC5gfSl9LHRoaXMuZ2V0RmlsZU5hbWU9bj0+e2NvbnN0IHI9dGhpcy5maWxlc0J5UmVmZXJlbmNlSWQuZ2V0KG4pO3JldHVybiByP3IudHlwZT09PSJjaHVuayI/R2Yocix0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGUpOnIudHlwZT09PSJwcmVidWlsdC1jaHVuayI/ci5maWxlTmFtZTpVZihyLG4pOkwoe2NvZGU6IkZJTEVfTk9UX0ZPVU5EIixtZXNzYWdlOmBQbHVnaW4gZXJyb3IgLSBVbmFibGUgdG8gZ2V0IGZpbGUgbmFtZSBmb3IgdW5rbm93biBmaWxlICIke259Ii5gfSl9LHRoaXMuc2V0QXNzZXRTb3VyY2U9KG4scik9Pntjb25zdCBhPXRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLmdldChuKTtpZighYSlyZXR1cm4gTCh7Y29kZToiQVNTRVRfTk9UX0ZPVU5EIixtZXNzYWdlOmBQbHVnaW4gZXJyb3IgLSBVbmFibGUgdG8gc2V0IHRoZSBzb3VyY2UgZm9yIHVua25vd24gYXNzZXQgIiR7bn0iLmB9KTtpZihhLnR5cGUhPT0iYXNzZXQiKXJldHVybiBMKEJlKGBBc3NldCBzb3VyY2VzIGNhbiBvbmx5IGJlIHNldCBmb3IgZW1pdHRlZCBhc3NldHMgYnV0ICIke259IiBpcyBhbiBlbWl0dGVkIGNodW5rLmApKTtpZihhLnNvdXJjZSE9PXZvaWQgMClyZXR1cm4gTCh7Y29kZToiQVNTRVRfU09VUkNFX0FMUkVBRFlfU0VUIixtZXNzYWdlOmBVbmFibGUgdG8gc2V0IHRoZSBzb3VyY2UgZm9yIGFzc2V0ICIke2EubmFtZXx8bn0iLCBzb3VyY2UgYWxyZWFkeSBzZXQuYH0pO2NvbnN0IG89cHUocixhLG4pO2lmKHRoaXMub3V0cHV0KXRoaXMuZmluYWxpemVBZGRpdGlvbmFsQXNzZXQoYSxvLHRoaXMub3V0cHV0KTtlbHNle2Euc291cmNlPW87Zm9yKGNvbnN0IGggb2YgdGhpcy5vdXRwdXRGaWxlRW1pdHRlcnMpaC5maW5hbGl6ZUFkZGl0aW9uYWxBc3NldChhLG8saC5vdXRwdXQpfX0sdGhpcy5zZXRDaHVua0luZm9ybWF0aW9uPW49Pnt0aGlzLmZhY2FkZUNodW5rQnlNb2R1bGU9bn0sdGhpcy5zZXRPdXRwdXRCdW5kbGU9KG4scik9Pntjb25zdCBhPXRoaXMub3V0cHV0PXtidW5kbGU6bixmaWxlTmFtZXNCeVNvdXJjZTpuZXcgTWFwLG91dHB1dE9wdGlvbnM6cn07Zm9yKGNvbnN0IGggb2YgdGhpcy5maWxlc0J5UmVmZXJlbmNlSWQudmFsdWVzKCkpaC5maWxlTmFtZSYmY3UoaC5maWxlTmFtZSxhLHRoaXMub3B0aW9ucy5vbkxvZyk7Y29uc3Qgbz1uZXcgTWFwO2Zvcihjb25zdCBoIG9mIHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLnZhbHVlcygpKWgudHlwZT09PSJhc3NldCImJmguc291cmNlIT09dm9pZCAwP2guZmlsZU5hbWU/dGhpcy5maW5hbGl6ZUFkZGl0aW9uYWxBc3NldChoLGguc291cmNlLGEpOkdlKG8sbHUoaC5zb3VyY2UpLCgpPT5bXSkucHVzaChoKTpoLnR5cGU9PT0icHJlYnVpbHQtY2h1bmsiJiYodGhpcy5vdXRwdXQuYnVuZGxlW2guZmlsZU5hbWVdPXRoaXMuY3JlYXRlUHJlYnVpbHRDaHVuayhoKSk7Zm9yKGNvbnN0W2gsbF1vZiBvKXRoaXMuZmluYWxpemVBc3NldHNXaXRoU2FtZVNvdXJjZShsLGgsYSl9LHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkPXM/bmV3IE1hcChzLmZpbGVzQnlSZWZlcmVuY2VJZCk6bmV3IE1hcCxzPT1udWxsfHxzLmFkZE91dHB1dEZpbGVFbWl0dGVyKHRoaXMpfWFkZE91dHB1dEZpbGVFbWl0dGVyKHQpe3RoaXMub3V0cHV0RmlsZUVtaXR0ZXJzLnB1c2godCl9YXNzaWduUmVmZXJlbmNlSWQodCxpKXtsZXQgcz1pO2RvIHM9UmkoKS51cGRhdGUocykuZGlnZXN0KCJoZXgiKS5zbGljZSgwLDgpO3doaWxlKHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLmhhcyhzKXx8dGhpcy5vdXRwdXRGaWxlRW1pdHRlcnMuc29tZSgoe2ZpbGVzQnlSZWZlcmVuY2VJZDpufSk9Pm4uaGFzKHMpKSk7dC5yZWZlcmVuY2VJZD1zLHRoaXMuZmlsZXNCeVJlZmVyZW5jZUlkLnNldChzLHQpO2Zvcihjb25zdHtmaWxlc0J5UmVmZXJlbmNlSWQ6bn1vZiB0aGlzLm91dHB1dEZpbGVFbWl0dGVycyluLnNldChzLHQpO3JldHVybiBzfWNyZWF0ZVByZWJ1aWx0Q2h1bmsodCl7cmV0dXJue2NvZGU6dC5jb2RlLGR5bmFtaWNJbXBvcnRzOltdLGV4cG9ydHM6dC5leHBvcnRzfHxbXSxmYWNhZGVNb2R1bGVJZDpudWxsLGZpbGVOYW1lOnQuZmlsZU5hbWUsaW1wbGljaXRseUxvYWRlZEJlZm9yZTpbXSxpbXBvcnRlZEJpbmRpbmdzOnt9LGltcG9ydHM6W10saXNEeW5hbWljRW50cnk6ITEsaXNFbnRyeTohMSxpc0ltcGxpY2l0RW50cnk6ITEsbWFwOnQubWFwfHxudWxsLG1vZHVsZUlkczpbXSxtb2R1bGVzOnt9LG5hbWU6dC5maWxlTmFtZSxwcmVsaW1pbmFyeUZpbGVOYW1lOnQuZmlsZU5hbWUscmVmZXJlbmNlZEZpbGVzOltdLHNvdXJjZW1hcEZpbGVOYW1lOnQuc291cmNlbWFwRmlsZU5hbWV8fG51bGwsdHlwZToiY2h1bmsifX1lbWl0QXNzZXQodCl7Y29uc3QgaT10LnNvdXJjZT09PXZvaWQgMD92b2lkIDA6cHUodC5zb3VyY2UsdCxudWxsKSxzPXtmaWxlTmFtZTp0LmZpbGVOYW1lLG5hbWU6dC5uYW1lLG5lZWRzQ29kZVJlZmVyZW5jZTohIXQubmVlZHNDb2RlUmVmZXJlbmNlLHJlZmVyZW5jZUlkOiIiLHNvdXJjZTppLHR5cGU6ImFzc2V0In0sbj10aGlzLmFzc2lnblJlZmVyZW5jZUlkKHMsdC5maWxlTmFtZXx8dC5uYW1lfHxTdHJpbmcodGhpcy5uZXh0SWRCYXNlKyspKTtpZih0aGlzLm91dHB1dCl0aGlzLmVtaXRBc3NldFdpdGhSZWZlcmVuY2VJZChzLHRoaXMub3V0cHV0KTtlbHNlIGZvcihjb25zdCByIG9mIHRoaXMub3V0cHV0RmlsZUVtaXR0ZXJzKXIuZW1pdEFzc2V0V2l0aFJlZmVyZW5jZUlkKHMsci5vdXRwdXQpO3JldHVybiBufWVtaXRBc3NldFdpdGhSZWZlcmVuY2VJZCh0LGkpe2NvbnN0e2ZpbGVOYW1lOnMsc291cmNlOm59PXQ7cyYmY3UocyxpLHRoaXMub3B0aW9ucy5vbkxvZyksbiE9PXZvaWQgMCYmdGhpcy5maW5hbGl6ZUFkZGl0aW9uYWxBc3NldCh0LG4saSl9ZW1pdENodW5rKHQpe2lmKHRoaXMuZ3JhcGgucGhhc2U+R3QuTE9BRF9BTkRfUEFSU0UpcmV0dXJuIEwoe2NvZGU6Zm8sbWVzc2FnZToiQ2Fubm90IGVtaXQgY2h1bmtzIGFmdGVyIG1vZHVsZSBsb2FkaW5nIGhhcyBmaW5pc2hlZC4ifSk7aWYodHlwZW9mIHQuaWQhPSJzdHJpbmciKXJldHVybiBMKEJlKGBFbWl0dGVkIGNodW5rcyBuZWVkIHRvIGhhdmUgYSB2YWxpZCBzdHJpbmcgaWQsIHJlY2VpdmVkICIke3QuaWR9ImApKTtjb25zdCBpPXtmaWxlTmFtZTp0LmZpbGVOYW1lLG1vZHVsZTpudWxsLG5hbWU6dC5uYW1lfHx0LmlkLHJlZmVyZW5jZUlkOiIiLHR5cGU6ImNodW5rIn07cmV0dXJuIHRoaXMuZ3JhcGgubW9kdWxlTG9hZGVyLmVtaXRDaHVuayh0KS50aGVuKHM9PmkubW9kdWxlPXMpLmNhdGNoKCgpPT57fSksdGhpcy5hc3NpZ25SZWZlcmVuY2VJZChpLHQuaWQpfWVtaXRQcmVidWlsdENodW5rKHQpe2lmKHR5cGVvZiB0LmNvZGUhPSJzdHJpbmciKXJldHVybiBMKEJlKGBFbWl0dGVkIHByZWJ1aWx0IGNodW5rcyBuZWVkIHRvIGhhdmUgYSB2YWxpZCBzdHJpbmcgY29kZSwgcmVjZWl2ZWQgIiR7dC5jb2RlfSIuYCkpO2lmKHR5cGVvZiB0LmZpbGVOYW1lIT0ic3RyaW5nInx8THModC5maWxlTmFtZSkpcmV0dXJuIEwoQmUoYFRoZSAiZmlsZU5hbWUiIHByb3BlcnR5IG9mIGVtaXR0ZWQgcHJlYnVpbHQgY2h1bmtzIG11c3QgYmUgc3RyaW5ncyB0aGF0IGFyZSBuZWl0aGVyIGFic29sdXRlIG5vciByZWxhdGl2ZSBwYXRocywgcmVjZWl2ZWQgIiR7dC5maWxlTmFtZX0iLmApKTtjb25zdCBpPXtjb2RlOnQuY29kZSxleHBvcnRzOnQuZXhwb3J0cyxmaWxlTmFtZTp0LmZpbGVOYW1lLG1hcDp0Lm1hcCxyZWZlcmVuY2VJZDoiIix0eXBlOiJwcmVidWlsdC1jaHVuayJ9LHM9dGhpcy5hc3NpZ25SZWZlcmVuY2VJZChpLGkuZmlsZU5hbWUpO3JldHVybiB0aGlzLm91dHB1dCYmKHRoaXMub3V0cHV0LmJ1bmRsZVtpLmZpbGVOYW1lXT10aGlzLmNyZWF0ZVByZWJ1aWx0Q2h1bmsoaSkpLHN9ZmluYWxpemVBZGRpdGlvbmFsQXNzZXQodCxpLHtidW5kbGU6cyxmaWxlTmFtZXNCeVNvdXJjZTpuLG91dHB1dE9wdGlvbnM6cn0pe2xldHtmaWxlTmFtZTphLG5lZWRzQ29kZVJlZmVyZW5jZTpvLHJlZmVyZW5jZUlkOmh9PXQ7aWYoIWEpe2NvbnN0IHA9bHUoaSk7YT1uLmdldChwKSxhfHwoYT11dSh0Lm5hbWUsaSxwLHIscyksbi5zZXQocCxhKSl9Y29uc3QgbD17Li4udCxmaWxlTmFtZTphLHNvdXJjZTppfTt0aGlzLmZpbGVzQnlSZWZlcmVuY2VJZC5zZXQoaCxsKTtjb25zdCBjPXNbYV07KGM9PW51bGw/dm9pZCAwOmMudHlwZSk9PT0iYXNzZXQiP2MubmVlZHNDb2RlUmVmZXJlbmNlJiYoYy5uZWVkc0NvZGVSZWZlcmVuY2U9byk6c1thXT17ZmlsZU5hbWU6YSxuYW1lOnQubmFtZSxuZWVkc0NvZGVSZWZlcmVuY2U6byxzb3VyY2U6aSx0eXBlOiJhc3NldCJ9fWZpbmFsaXplQXNzZXRzV2l0aFNhbWVTb3VyY2UodCxpLHtidW5kbGU6cyxmaWxlTmFtZXNCeVNvdXJjZTpuLG91dHB1dE9wdGlvbnM6cn0pe2xldCBhLG89IiIsaD0hMDtmb3IoY29uc3QgbCBvZiB0KXtoJiYoaD1sLm5lZWRzQ29kZVJlZmVyZW5jZSk7Y29uc3QgYz11dShsLm5hbWUsbC5zb3VyY2UsaSxyLHMpOyghb3x8Yy5sZW5ndGg8by5sZW5ndGh8fGMubGVuZ3RoPT09by5sZW5ndGgmJmM8bykmJihvPWMsYT1sKX1uLnNldChpLG8pO2Zvcihjb25zdCBsIG9mIHQpe2NvbnN0IGM9ey4uLmwsZmlsZU5hbWU6b307dGhpcy5maWxlc0J5UmVmZXJlbmNlSWQuc2V0KGwucmVmZXJlbmNlSWQsYyl9c1tvXT17ZmlsZU5hbWU6byxuYW1lOmEubmFtZSxuZWVkc0NvZGVSZWZlcmVuY2U6aCxzb3VyY2U6YS5zb3VyY2UsdHlwZToiYXNzZXQifX19ZnVuY3Rpb24gTWkoZSx0LGkscyxuKXtyZXR1cm4gc2lbZV08c2lbbl0/dXQ6KHIsYSk9PnthIT1udWxsJiZpKEsse2NvZGU6ZXAsbWVzc2FnZTpgUGx1Z2luICIke3N9IiB0cmllZCB0byBhZGQgYSBmaWxlIHBvc2l0aW9uIHRvIGEgbG9nIG9yIHdhcm5pbmcuIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlICJ0cmFuc2Zvcm0iIGhvb2sgYXQgdGhlIG1vbWVudCBhbmQgd2lsbCBiZSBpZ25vcmVkLmB9KSwocj1TdChyKSkuY29kZSYmIXIucGx1Z2luQ29kZSYmKHIucGx1Z2luQ29kZT1yLmNvZGUpLHIuY29kZT10LHIucGx1Z2luPXMsaShlLHIpfX1mdW5jdGlvbiBxZihlLHQsaSxzLG4scil7Y29uc3R7bG9nTGV2ZWw6YSxvbkxvZzpvfT1zO2xldCBoLGw9ITA7aWYodHlwZW9mIGUuY2FjaGVLZXkhPSJzdHJpbmciJiYoZS5uYW1lLnN0YXJ0c1dpdGgoZ2EpfHxlLm5hbWUuc3RhcnRzV2l0aCh5YSl8fHIuaGFzKGUubmFtZSk/bD0hMTpyLmFkZChlLm5hbWUpKSx0KWlmKGwpe2NvbnN0IG09ZS5jYWNoZUtleXx8ZS5uYW1lO3A9dFttXXx8KHRbbV09T2JqZWN0LmNyZWF0ZShudWxsKSksaD17ZGVsZXRlOnk9PmRlbGV0ZSBwW3ldLGdldCh5KXtjb25zdCBFPXBbeV07aWYoRSlyZXR1cm4gRVswXT0wLEVbMV19LGhhcyh5KXtjb25zdCBFPXBbeV07cmV0dXJuISFFJiYoRVswXT0wLCEwKX0sc2V0KHksRSl7cFt5XT1bMCxFXX19fWVsc2UgYz1lLm5hbWUsaD17ZGVsZXRlOigpPT5QbihjKSxnZXQ6KCk9PlBuKGMpLGhhczooKT0+UG4oYyksc2V0OigpPT5QbihjKX07ZWxzZSBoPVJmO3ZhciBjLHA7cmV0dXJue2FkZFdhdGNoRmlsZShtKXtpZihpLnBoYXNlPj1HdC5HRU5FUkFURSlyZXR1cm4gdGhpcy5lcnJvcih7Y29kZTpmbyxtZXNzYWdlOidDYW5ub3QgY2FsbCAiYWRkV2F0Y2hGaWxlIiBhZnRlciB0aGUgYnVpbGQgaGFzIGZpbmlzaGVkLid9KTtpLndhdGNoRmlsZXNbbV09ITB9LGNhY2hlOmgsZGVidWc6TWkocWksIlBMVUdJTl9MT0ciLG8sZS5uYW1lLGEpLGVtaXRGaWxlOm4uZW1pdEZpbGUuYmluZChuKSxlcnJvcjptPT5MKEtpKFN0KG0pLGUubmFtZSkpLGdldEZpbGVOYW1lOm4uZ2V0RmlsZU5hbWUsZ2V0TW9kdWxlSWRzOigpPT5pLm1vZHVsZXNCeUlkLmtleXMoKSxnZXRNb2R1bGVJbmZvOmkuZ2V0TW9kdWxlSW5mbyxnZXRXYXRjaEZpbGVzOigpPT5PYmplY3Qua2V5cyhpLndhdGNoRmlsZXMpLGluZm86TWkoaWksIlBMVUdJTl9MT0ciLG8sZS5uYW1lLGEpLGxvYWQ6bT0+aS5tb2R1bGVMb2FkZXIucHJlbG9hZE1vZHVsZShtKSxtZXRhOntyb2xsdXBWZXJzaW9uOkJuLHdhdGNoTW9kZTppLndhdGNoTW9kZX0sZ2V0IG1vZHVsZUlkcygpe2NvbnN0IG09aS5tb2R1bGVzQnlJZC5rZXlzKCk7cmV0dXJuIGZ1bmN0aW9uKigpe25pKGBBY2Nlc3NpbmcgInRoaXMubW9kdWxlSWRzIiBvbiB0aGUgcGx1Z2luIGNvbnRleHQgYnkgcGx1Z2luICR7ZS5uYW1lfSBpcyBkZXByZWNhdGVkLiBUaGUgInRoaXMuZ2V0TW9kdWxlSWRzIiBwbHVnaW4gY29udGV4dCBmdW5jdGlvbiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLmAsInBsdWdpbi1kZXZlbG9wbWVudC8jdGhpcy1nZXRtb2R1bGVpZHMiLCEwLHMsZS5uYW1lKSx5aWVsZCptfSgpfSxwYXJzZTppLmNvbnRleHRQYXJzZS5iaW5kKGkpLHJlc29sdmU6KG0seSx7YXNzZXJ0aW9uczpFLGN1c3RvbTpnLGlzRW50cnk6eCxza2lwU2VsZjp2fT0kZSk9PmkubW9kdWxlTG9hZGVyLnJlc29sdmVJZChtLHksZyx4LEV8fHFlLHY/W3tpbXBvcnRlcjp5LHBsdWdpbjplLHNvdXJjZTptfV06bnVsbCksc2V0QXNzZXRTb3VyY2U6bi5zZXRBc3NldFNvdXJjZSx3YXJuOk1pKEssIlBMVUdJTl9XQVJOSU5HIixvLGUubmFtZSxhKX19Y29uc3QgSGY9T2JqZWN0LmtleXMoe2J1aWxkRW5kOjEsYnVpbGRTdGFydDoxLGNsb3NlQnVuZGxlOjEsY2xvc2VXYXRjaGVyOjEsbG9hZDoxLG1vZHVsZVBhcnNlZDoxLG9uTG9nOjEsb3B0aW9uczoxLHJlc29sdmVEeW5hbWljSW1wb3J0OjEscmVzb2x2ZUlkOjEsc2hvdWxkVHJhbnNmb3JtQ2FjaGVkTW9kdWxlOjEsdHJhbnNmb3JtOjEsd2F0Y2hDaGFuZ2U6MX0pO2NsYXNzIHZhe2NvbnN0cnVjdG9yKHQsaSxzLG4scil7dGhpcy5ncmFwaD10LHRoaXMub3B0aW9ucz1pLHRoaXMucGx1Z2luQ2FjaGU9bix0aGlzLnNvcnRlZFBsdWdpbnM9bmV3IE1hcCx0aGlzLnVuZnVsZmlsbGVkQWN0aW9ucz1uZXcgU2V0LHRoaXMuZmlsZUVtaXR0ZXI9bmV3IFdmKHQsaSxyJiZyLmZpbGVFbWl0dGVyKSx0aGlzLmVtaXRGaWxlPXRoaXMuZmlsZUVtaXR0ZXIuZW1pdEZpbGUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKSx0aGlzLmdldEZpbGVOYW1lPXRoaXMuZmlsZUVtaXR0ZXIuZ2V0RmlsZU5hbWUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKSx0aGlzLmZpbmFsaXNlQXNzZXRzPXRoaXMuZmlsZUVtaXR0ZXIuZmluYWxpc2VBc3NldHMuYmluZCh0aGlzLmZpbGVFbWl0dGVyKSx0aGlzLnNldENodW5rSW5mb3JtYXRpb249dGhpcy5maWxlRW1pdHRlci5zZXRDaHVua0luZm9ybWF0aW9uLmJpbmQodGhpcy5maWxlRW1pdHRlciksdGhpcy5zZXRPdXRwdXRCdW5kbGU9dGhpcy5maWxlRW1pdHRlci5zZXRPdXRwdXRCdW5kbGUuYmluZCh0aGlzLmZpbGVFbWl0dGVyKSx0aGlzLnBsdWdpbnM9Wy4uLnI/ci5wbHVnaW5zOltdLC4uLnNdO2NvbnN0IGE9bmV3IFNldDtpZih0aGlzLnBsdWdpbkNvbnRleHRzPW5ldyBNYXAodGhpcy5wbHVnaW5zLm1hcChoPT5baCxxZihoLG4sdCxpLHRoaXMuZmlsZUVtaXR0ZXIsYSldKSkscilmb3IoY29uc3QgaCBvZiBzKWZvcihjb25zdCBsIG9mIEhmKWwgaW4gaCYmaS5vbkxvZyhLLChvPWgubmFtZSx7Y29kZToiSU5QVVRfSE9PS19JTl9PVVRQVVRfUExVR0lOIixtZXNzYWdlOmBUaGUgIiR7bH0iIGhvb2sgdXNlZCBieSB0aGUgb3V0cHV0IHBsdWdpbiAke299IGlzIGEgYnVpbGQgdGltZSBob29rIGFuZCB3aWxsIG5vdCBiZSBydW4gZm9yIHRoYXQgcGx1Z2luLiBFaXRoZXIgdGhpcyBwbHVnaW4gY2Fubm90IGJlIHVzZWQgYXMgYW4gb3V0cHV0IHBsdWdpbiwgb3IgaXQgc2hvdWxkIGhhdmUgYW4gb3B0aW9uIHRvIGNvbmZpZ3VyZSBpdCBhcyBhbiBvdXRwdXQgcGx1Z2luLmB9KSk7dmFyIG99Y3JlYXRlT3V0cHV0UGx1Z2luRHJpdmVyKHQpe3JldHVybiBuZXcgdmEodGhpcy5ncmFwaCx0aGlzLm9wdGlvbnMsdCx0aGlzLnBsdWdpbkNhY2hlLHRoaXMpfWdldFVuZnVsZmlsbGVkSG9va0FjdGlvbnMoKXtyZXR1cm4gdGhpcy51bmZ1bGZpbGxlZEFjdGlvbnN9aG9va0ZpcnN0KHQsaSxzLG4pe3JldHVybiB0aGlzLmhvb2tGaXJzdEFuZEdldFBsdWdpbih0LGkscyxuKS50aGVuKHI9PnImJnJbMF0pfWFzeW5jIGhvb2tGaXJzdEFuZEdldFBsdWdpbih0LGkscyxuKXtmb3IoY29uc3QgciBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnModCkpe2lmKG4hPW51bGwmJm4uaGFzKHIpKWNvbnRpbnVlO2NvbnN0IGE9YXdhaXQgdGhpcy5ydW5Ib29rKHQsaSxyLHMpO2lmKGEhPW51bGwpcmV0dXJuW2Escl19cmV0dXJuIG51bGx9aG9va0ZpcnN0U3luYyh0LGkscyl7Zm9yKGNvbnN0IG4gb2YgdGhpcy5nZXRTb3J0ZWRQbHVnaW5zKHQpKXtjb25zdCByPXRoaXMucnVuSG9va1N5bmModCxpLG4scyk7aWYociE9bnVsbClyZXR1cm4gcn1yZXR1cm4gbnVsbH1hc3luYyBob29rUGFyYWxsZWwodCxpLHMpe2NvbnN0IG49W107Zm9yKGNvbnN0IHIgb2YgdGhpcy5nZXRTb3J0ZWRQbHVnaW5zKHQpKXJbdF0uc2VxdWVudGlhbD8oYXdhaXQgUHJvbWlzZS5hbGwobiksbi5sZW5ndGg9MCxhd2FpdCB0aGlzLnJ1bkhvb2sodCxpLHIscykpOm4ucHVzaCh0aGlzLnJ1bkhvb2sodCxpLHIscykpO2F3YWl0IFByb21pc2UuYWxsKG4pfWhvb2tSZWR1Y2VBcmcwKHQsW2ksLi4uc10sbixyKXtsZXQgYT1Qcm9taXNlLnJlc29sdmUoaSk7Zm9yKGNvbnN0IG8gb2YgdGhpcy5nZXRTb3J0ZWRQbHVnaW5zKHQpKWE9YS50aGVuKGg9PnRoaXMucnVuSG9vayh0LFtoLC4uLnNdLG8scikudGhlbihsPT5uLmNhbGwodGhpcy5wbHVnaW5Db250ZXh0cy5nZXQobyksaCxsLG8pKSk7cmV0dXJuIGF9aG9va1JlZHVjZUFyZzBTeW5jKHQsW2ksLi4uc10sbixyKXtmb3IoY29uc3QgYSBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnModCkpe2NvbnN0IG89W2ksLi4uc10saD10aGlzLnJ1bkhvb2tTeW5jKHQsbyxhLHIpO2k9bi5jYWxsKHRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KGEpLGksaCxhKX1yZXR1cm4gaX1hc3luYyBob29rUmVkdWNlVmFsdWUodCxpLHMsbil7Y29uc3Qgcj1bXSxhPVtdO2Zvcihjb25zdCBvIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyh0LFFmKSlvW3RdLnNlcXVlbnRpYWw/KHIucHVzaCguLi5hd2FpdCBQcm9taXNlLmFsbChhKSksYS5sZW5ndGg9MCxyLnB1c2goYXdhaXQgdGhpcy5ydW5Ib29rKHQscyxvKSkpOmEucHVzaCh0aGlzLnJ1bkhvb2sodCxzLG8pKTtyZXR1cm4gci5wdXNoKC4uLmF3YWl0IFByb21pc2UuYWxsKGEpKSxyLnJlZHVjZShuLGF3YWl0IGkpfWhvb2tSZWR1Y2VWYWx1ZVN5bmModCxpLHMsbixyKXtsZXQgYT1pO2Zvcihjb25zdCBvIG9mIHRoaXMuZ2V0U29ydGVkUGx1Z2lucyh0KSl7Y29uc3QgaD10aGlzLnJ1bkhvb2tTeW5jKHQscyxvLHIpO2E9bi5jYWxsKHRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KG8pLGEsaCxvKX1yZXR1cm4gYX1ob29rU2VxKHQsaSxzKXtsZXQgbj1Qcm9taXNlLnJlc29sdmUoKTtmb3IoY29uc3QgciBvZiB0aGlzLmdldFNvcnRlZFBsdWdpbnModCkpbj1uLnRoZW4oKCk9PnRoaXMucnVuSG9vayh0LGkscixzKSk7cmV0dXJuIG4udGhlbihZZil9Z2V0U29ydGVkUGx1Z2lucyh0LGkpe3JldHVybiBHZSh0aGlzLnNvcnRlZFBsdWdpbnMsdCwoKT0+RWEodCx0aGlzLnBsdWdpbnMsaSkpfXJ1bkhvb2sodCxpLHMsbil7Y29uc3Qgcj1zW3RdLGE9dHlwZW9mIHI9PSJvYmplY3QiP3IuaGFuZGxlcjpyO2xldCBvPXRoaXMucGx1Z2luQ29udGV4dHMuZ2V0KHMpO24mJihvPW4obyxzKSk7bGV0IGg9bnVsbDtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e2lmKHR5cGVvZiBhIT0iZnVuY3Rpb24iKXJldHVybiBhO2NvbnN0IGw9YS5hcHBseShvLGkpO3JldHVybiBsIT1udWxsJiZsLnRoZW4/KGg9W3MubmFtZSx0LGldLHRoaXMudW5mdWxmaWxsZWRBY3Rpb25zLmFkZChoKSxQcm9taXNlLnJlc29sdmUobCkudGhlbihjPT4odGhpcy51bmZ1bGZpbGxlZEFjdGlvbnMuZGVsZXRlKGgpLGMpKSk6bH0pLmNhdGNoKGw9PihoIT09bnVsbCYmdGhpcy51bmZ1bGZpbGxlZEFjdGlvbnMuZGVsZXRlKGgpLEwoS2kobCxzLm5hbWUse2hvb2s6dH0pKSkpfXJ1bkhvb2tTeW5jKHQsaSxzLG4pe2NvbnN0IHI9c1t0XSxhPXR5cGVvZiByPT0ib2JqZWN0Ij9yLmhhbmRsZXI6cjtsZXQgbz10aGlzLnBsdWdpbkNvbnRleHRzLmdldChzKTtuJiYobz1uKG8scykpO3RyeXtyZXR1cm4gYS5hcHBseShvLGkpfWNhdGNoKGgpe3JldHVybiBMKEtpKGgscy5uYW1lLHtob29rOnR9KSl9fX1mdW5jdGlvbiBFYShlLHQsaT1LZil7Y29uc3Qgcz1bXSxuPVtdLHI9W107Zm9yKGNvbnN0IGEgb2YgdCl7Y29uc3Qgbz1hW2VdO2lmKG8pe2lmKHR5cGVvZiBvPT0ib2JqZWN0Iil7aWYoaShvLmhhbmRsZXIsZSxhKSxvLm9yZGVyPT09InByZSIpe3MucHVzaChhKTtjb250aW51ZX1pZihvLm9yZGVyPT09InBvc3QiKXtyLnB1c2goYSk7Y29udGludWV9fWVsc2UgaShvLGUsYSk7bi5wdXNoKGEpfX1yZXR1cm5bLi4ucywuLi5uLC4uLnJdfWZ1bmN0aW9uIEtmKGUsdCxpKXt0eXBlb2YgZSE9ImZ1bmN0aW9uIiYmTChmdW5jdGlvbihzLG4pe3JldHVybntjb2RlOnBvLGhvb2s6cyxtZXNzYWdlOmBFcnJvciBydW5uaW5nIHBsdWdpbiBob29rICIke3N9IiBmb3IgcGx1Z2luICIke259IiwgZXhwZWN0ZWQgYSBmdW5jdGlvbiBob29rIG9yIGFuIG9iamVjdCB3aXRoIGEgImhhbmRsZXIiIGZ1bmN0aW9uLmAscGx1Z2luOm59fSh0LGkubmFtZSkpfWZ1bmN0aW9uIFFmKGUsdCxpKXtpZih0eXBlb2YgZSE9InN0cmluZyImJnR5cGVvZiBlIT0iZnVuY3Rpb24iKXJldHVybiBMKGZ1bmN0aW9uKHMsbil7cmV0dXJue2NvZGU6cG8saG9vazpzLG1lc3NhZ2U6YEVycm9yIHJ1bm5pbmcgcGx1Z2luIGhvb2sgIiR7c30iIGZvciBwbHVnaW4gIiR7bn0iLCBleHBlY3RlZCBhIHN0cmluZywgYSBmdW5jdGlvbiBob29rIG9yIGFuIG9iamVjdCB3aXRoIGEgImhhbmRsZXIiIHN0cmluZyBvciBmdW5jdGlvbi5gLHBsdWdpbjpufX0odCxpLm5hbWUpKX1mdW5jdGlvbiBZZigpe31jbGFzcyBYZntjb25zdHJ1Y3Rvcih0KXt0aGlzLm1heFBhcmFsbGVsPXQsdGhpcy5xdWV1ZT1bXSx0aGlzLndvcmtlckNvdW50PTB9cnVuKHQpe3JldHVybiBuZXcgUHJvbWlzZSgoaSxzKT0+e3RoaXMucXVldWUucHVzaCh7cmVqZWN0OnMscmVzb2x2ZTppLHRhc2s6dH0pLHRoaXMud29yaygpfSl9YXN5bmMgd29yaygpe2lmKHRoaXMud29ya2VyQ291bnQ+PXRoaXMubWF4UGFyYWxsZWwpcmV0dXJuO2xldCB0O2Zvcih0aGlzLndvcmtlckNvdW50Kys7dD10aGlzLnF1ZXVlLnNoaWZ0KCk7KXtjb25zdHtyZWplY3Q6aSxyZXNvbHZlOnMsdGFzazpufT10O3RyeXtzKGF3YWl0IG4oKSl9Y2F0Y2gocil7aShyKX19dGhpcy53b3JrZXJDb3VudC0tfX1jbGFzcyBaZntjb25zdHJ1Y3Rvcih0LGkpe3ZhciBzLG47aWYodGhpcy5vcHRpb25zPXQsdGhpcy5hc3RMcnU9ZnVuY3Rpb24ocil7dmFyIGEsbyxoLGw9cnx8MTtmdW5jdGlvbiBjKG0seSl7KythPmwmJihoPW8scCgxKSwrK2EpLG9bbV09eX1mdW5jdGlvbiBwKG0pe2E9MCxvPU9iamVjdC5jcmVhdGUobnVsbCksbXx8KGg9T2JqZWN0LmNyZWF0ZShudWxsKSl9cmV0dXJuIHAoKSx7Y2xlYXI6cCxoYXM6ZnVuY3Rpb24obSl7cmV0dXJuIG9bbV0hPT12b2lkIDB8fGhbbV0hPT12b2lkIDB9LGdldDpmdW5jdGlvbihtKXt2YXIgeT1vW21dO3JldHVybiB5IT09dm9pZCAwP3k6KHk9aFttXSkhPT12b2lkIDA/KGMobSx5KSx5KTp2b2lkIDB9LHNldDpmdW5jdGlvbihtLHkpe29bbV0hPT12b2lkIDA/b1ttXT15OmMobSx5KX19fSg1KSx0aGlzLmNhY2hlZE1vZHVsZXM9bmV3IE1hcCx0aGlzLmRlb3B0aW1pemF0aW9uVHJhY2tlcj1uZXcga2ksdGhpcy5lbnRyeU1vZHVsZXM9W10sdGhpcy5tb2R1bGVzQnlJZD1uZXcgTWFwLHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3M9ITEsdGhpcy5waGFzZT1HdC5MT0FEX0FORF9QQVJTRSx0aGlzLnNjb3BlPW5ldyB6Zix0aGlzLndhdGNoRmlsZXM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLndhdGNoTW9kZT0hMSx0aGlzLmV4dGVybmFsTW9kdWxlcz1bXSx0aGlzLmltcGxpY2l0RW50cnlNb2R1bGVzPVtdLHRoaXMubW9kdWxlcz1bXSx0aGlzLmdldE1vZHVsZUluZm89cj0+e2NvbnN0IGE9dGhpcy5tb2R1bGVzQnlJZC5nZXQocik7cmV0dXJuIGE/YS5pbmZvOm51bGx9LHQuY2FjaGUhPT0hMSl7aWYoKHM9dC5jYWNoZSkhPW51bGwmJnMubW9kdWxlcylmb3IoY29uc3QgciBvZiB0LmNhY2hlLm1vZHVsZXMpdGhpcy5jYWNoZWRNb2R1bGVzLnNldChyLmlkLHIpO3RoaXMucGx1Z2luQ2FjaGU9KChuPXQuY2FjaGUpPT1udWxsP3ZvaWQgMDpuLnBsdWdpbnMpfHxPYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdCByIGluIHRoaXMucGx1Z2luQ2FjaGUpe2NvbnN0IGE9dGhpcy5wbHVnaW5DYWNoZVtyXTtmb3IoY29uc3QgbyBvZiBPYmplY3QudmFsdWVzKGEpKW9bMF0rK319aWYoaSl7dGhpcy53YXRjaE1vZGU9ITA7Y29uc3Qgcj0oLi4ubyk9PnRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgid2F0Y2hDaGFuZ2UiLG8pLGE9KCk9PnRoaXMucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgiY2xvc2VXYXRjaGVyIixbXSk7aS5vbkN1cnJlbnRSdW4oImNoYW5nZSIsciksaS5vbkN1cnJlbnRSdW4oImNsb3NlIixhKX10aGlzLnBsdWdpbkRyaXZlcj1uZXcgdmEodGhpcyx0LHQucGx1Z2lucyx0aGlzLnBsdWdpbkNhY2hlKSx0aGlzLmFjb3JuUGFyc2VyPWdlLmV4dGVuZCguLi50LmFjb3JuSW5qZWN0UGx1Z2lucyksdGhpcy5tb2R1bGVMb2FkZXI9bmV3IEZmKHRoaXMsdGhpcy5tb2R1bGVzQnlJZCx0aGlzLm9wdGlvbnMsdGhpcy5wbHVnaW5Ecml2ZXIpLHRoaXMuZmlsZU9wZXJhdGlvblF1ZXVlPW5ldyBYZih0Lm1heFBhcmFsbGVsRmlsZU9wcyksdGhpcy5wdXJlRnVuY3Rpb25zPSgoe3RyZWVzaGFrZTpyfSk9Pntjb25zdCBhPU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGNvbnN0IG8gb2Ygcj9yLm1hbnVhbFB1cmVGdW5jdGlvbnM6W10pe2xldCBoPWE7Zm9yKGNvbnN0IGwgb2Ygby5zcGxpdCgiLiIpKWg9aFtsXXx8KGhbbF09T2JqZWN0LmNyZWF0ZShudWxsKSk7aFttcl09ITB9cmV0dXJuIGF9KSh0KX1hc3luYyBidWlsZCgpe0NlKCJnZW5lcmF0ZSBtb2R1bGUgZ3JhcGgiLDIpLGF3YWl0IHRoaXMuZ2VuZXJhdGVNb2R1bGVHcmFwaCgpLFNlKCJnZW5lcmF0ZSBtb2R1bGUgZ3JhcGgiLDIpLENlKCJzb3J0IGFuZCBiaW5kIG1vZHVsZXMiLDIpLHRoaXMucGhhc2U9R3QuQU5BTFlTRSx0aGlzLnNvcnRNb2R1bGVzKCksU2UoInNvcnQgYW5kIGJpbmQgbW9kdWxlcyIsMiksQ2UoIm1hcmsgaW5jbHVkZWQgc3RhdGVtZW50cyIsMiksdGhpcy5pbmNsdWRlU3RhdGVtZW50cygpLFNlKCJtYXJrIGluY2x1ZGVkIHN0YXRlbWVudHMiLDIpLHRoaXMucGhhc2U9R3QuR0VORVJBVEV9Y29udGV4dFBhcnNlKHQsaT17fSl7Y29uc3Qgcz1pLm9uQ29tbWVudCxuPVtdO2kub25Db21tZW50PXMmJnR5cGVvZiBzPT0iZnVuY3Rpb24iPyhhLG8saCxsLC4uLmMpPT4obi5wdXNoKHtlbmQ6bCxzdGFydDpoLHR5cGU6YT8iQmxvY2siOiJMaW5lIix2YWx1ZTpvfSkscy5jYWxsKGksYSxvLGgsbCwuLi5jKSk6bjtjb25zdCByPXRoaXMuYWNvcm5QYXJzZXIucGFyc2UodCx7Li4udGhpcy5vcHRpb25zLmFjb3JuLC4uLml9KTtyZXR1cm4gdHlwZW9mIHM9PSJvYmplY3QiJiZzLnB1c2goLi4ubiksaS5vbkNvbW1lbnQ9cyxmdW5jdGlvbihhLG8saCl7Y29uc3QgbD1bXSxjPVtdO2Zvcihjb25zdCBwIG9mIGEpe2Zvcihjb25zdFttLHldb2YgT3ApeS50ZXN0KHAudmFsdWUpJiZsLnB1c2goey4uLnAsYW5ub3RhdGlvblR5cGU6bX0pO0xwLnRlc3QocC52YWx1ZSkmJmMucHVzaChwKX1mb3IoY29uc3QgcCBvZiBjKVdzKG8scCwhMSk7VG8obyx7YW5ub3RhdGlvbkluZGV4OjAsYW5ub3RhdGlvbnM6bCxjb2RlOmh9KX0obixyLHQpLHJ9Z2V0Q2FjaGUoKXtmb3IoY29uc3QgdCBpbiB0aGlzLnBsdWdpbkNhY2hlKXtjb25zdCBpPXRoaXMucGx1Z2luQ2FjaGVbdF07bGV0IHM9ITA7Zm9yKGNvbnN0W24scl1vZiBPYmplY3QuZW50cmllcyhpKSlyWzBdPj10aGlzLm9wdGlvbnMuZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnk/ZGVsZXRlIGlbbl06cz0hMTtzJiZkZWxldGUgdGhpcy5wbHVnaW5DYWNoZVt0XX1yZXR1cm57bW9kdWxlczp0aGlzLm1vZHVsZXMubWFwKHQ9PnQudG9KU09OKCkpLHBsdWdpbnM6dGhpcy5wbHVnaW5DYWNoZX19YXN5bmMgZ2VuZXJhdGVNb2R1bGVHcmFwaCgpe3ZhciB0O2lmKHtlbnRyeU1vZHVsZXM6dGhpcy5lbnRyeU1vZHVsZXMsaW1wbGljaXRFbnRyeU1vZHVsZXM6dGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc309YXdhaXQgdGhpcy5tb2R1bGVMb2FkZXIuYWRkRW50cnlNb2R1bGVzKCh0PXRoaXMub3B0aW9ucy5pbnB1dCxBcnJheS5pc0FycmF5KHQpP3QubWFwKGk9Pih7ZmlsZU5hbWU6bnVsbCxpZDppLGltcGxpY2l0bHlMb2FkZWRBZnRlcjpbXSxpbXBvcnRlcjp2b2lkIDAsbmFtZTpudWxsfSkpOk9iamVjdC5lbnRyaWVzKHQpLm1hcCgoW2ksc10pPT4oe2ZpbGVOYW1lOm51bGwsaWQ6cyxpbXBsaWNpdGx5TG9hZGVkQWZ0ZXI6W10saW1wb3J0ZXI6dm9pZCAwLG5hbWU6aX0pKSksITApLHRoaXMuZW50cnlNb2R1bGVzLmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKCJZb3UgbXVzdCBzdXBwbHkgb3B0aW9ucy5pbnB1dCB0byByb2xsdXAiKTtmb3IoY29uc3QgaSBvZiB0aGlzLm1vZHVsZXNCeUlkLnZhbHVlcygpKWkgaW5zdGFuY2VvZiB5ZT90aGlzLm1vZHVsZXMucHVzaChpKTp0aGlzLmV4dGVybmFsTW9kdWxlcy5wdXNoKGkpfWluY2x1ZGVTdGF0ZW1lbnRzKCl7Y29uc3QgdD1bLi4udGhpcy5lbnRyeU1vZHVsZXMsLi4udGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlc107Zm9yKGNvbnN0IGkgb2YgdCltcyhpKTtpZih0aGlzLm9wdGlvbnMudHJlZXNoYWtlKXtsZXQgaT0xO2Rve0NlKGB0cmVlc2hha2luZyBwYXNzICR7aX1gLDMpLHRoaXMubmVlZHNUcmVlc2hha2luZ1Bhc3M9ITE7Zm9yKGNvbnN0IHMgb2YgdGhpcy5tb2R1bGVzKXMuaXNFeGVjdXRlZCYmKHMuaW5mby5tb2R1bGVTaWRlRWZmZWN0cz09PSJuby10cmVlc2hha2UiP3MuaW5jbHVkZUFsbEluQnVuZGxlKCk6cy5pbmNsdWRlKCkpO2lmKGk9PT0xKWZvcihjb25zdCBzIG9mIHQpcy5wcmVzZXJ2ZVNpZ25hdHVyZSE9PSExJiYocy5pbmNsdWRlQWxsRXhwb3J0cyghMSksdGhpcy5uZWVkc1RyZWVzaGFraW5nUGFzcz0hMCk7U2UoInRyZWVzaGFraW5nIHBhc3MgIitpKyssMyl9d2hpbGUodGhpcy5uZWVkc1RyZWVzaGFraW5nUGFzcyl9ZWxzZSBmb3IoY29uc3QgaSBvZiB0aGlzLm1vZHVsZXMpaS5pbmNsdWRlQWxsSW5CdW5kbGUoKTtmb3IoY29uc3QgaSBvZiB0aGlzLmV4dGVybmFsTW9kdWxlcylpLndhcm5VbnVzZWRJbXBvcnRzKCk7Zm9yKGNvbnN0IGkgb2YgdGhpcy5pbXBsaWNpdEVudHJ5TW9kdWxlcylmb3IoY29uc3QgcyBvZiBpLmltcGxpY2l0bHlMb2FkZWRBZnRlcilzLmluZm8uaXNFbnRyeXx8cy5pc0luY2x1ZGVkKCl8fEwoZ3AocykpfXNvcnRNb2R1bGVzKCl7Y29uc3R7b3JkZXJlZE1vZHVsZXM6dCxjeWNsZVBhdGhzOml9PWZ1bmN0aW9uKHMpe2xldCBuPTA7Y29uc3Qgcj1bXSxhPW5ldyBTZXQsbz1uZXcgU2V0LGg9bmV3IE1hcCxsPVtdLGM9cD0+e2lmKHAgaW5zdGFuY2VvZiB5ZSl7Zm9yKGNvbnN0IG0gb2YgcC5kZXBlbmRlbmNpZXMpaC5oYXMobSk/YS5oYXMobSl8fHIucHVzaCh6ZChtLHAsaCkpOihoLnNldChtLHApLGMobSkpO2Zvcihjb25zdCBtIG9mIHAuaW1wbGljaXRseUxvYWRlZEJlZm9yZSlvLmFkZChtKTtmb3IoY29uc3R7cmVzb2x1dGlvbjptfW9mIHAuZHluYW1pY0ltcG9ydHMpbSBpbnN0YW5jZW9mIHllJiZvLmFkZChtKTtsLnB1c2gocCl9cC5leGVjSW5kZXg9bisrLGEuYWRkKHApfTtmb3IoY29uc3QgcCBvZiBzKWguaGFzKHApfHwoaC5zZXQocCxudWxsKSxjKHApKTtmb3IoY29uc3QgcCBvZiBvKWguaGFzKHApfHwoaC5zZXQocCxudWxsKSxjKHApKTtyZXR1cm57Y3ljbGVQYXRoczpyLG9yZGVyZWRNb2R1bGVzOmx9fSh0aGlzLmVudHJ5TW9kdWxlcyk7Zm9yKGNvbnN0IHMgb2YgaSl0aGlzLm9wdGlvbnMub25Mb2coSyxmcChzKSk7dGhpcy5tb2R1bGVzPXQ7Zm9yKGNvbnN0IHMgb2YgdGhpcy5tb2R1bGVzKXMuYmluZFJlZmVyZW5jZXMoKTt0aGlzLndhcm5Gb3JNaXNzaW5nRXhwb3J0cygpfXdhcm5Gb3JNaXNzaW5nRXhwb3J0cygpe2Zvcihjb25zdCB0IG9mIHRoaXMubW9kdWxlcylmb3IoY29uc3QgaSBvZiB0LmltcG9ydERlc2NyaXB0aW9ucy52YWx1ZXMoKSlpLm5hbWU9PT0iKiJ8fGkubW9kdWxlLmdldFZhcmlhYmxlRm9yRXhwb3J0TmFtZShpLm5hbWUpWzBdfHx0LmxvZyhLLEZzKGkubmFtZSx0LmlkLGkubW9kdWxlLmlkKSxpLnN0YXJ0KX19ZnVuY3Rpb24gZHUoZSx0KXtyZXR1cm4gdCgpfWZ1bmN0aW9uIGZ1KGUsdCxpLHMpe2U9RWEoIm9uTG9nIixlKTtjb25zdCBuPXNpW3NdLHI9KGEsbyxoPXNvKT0+e2lmKCEoc2lbYV08bikpe2Zvcihjb25zdCBsIG9mIGUpe2lmKGguaGFzKGwpKWNvbnRpbnVlO2NvbnN0e29uTG9nOmN9PWwscD1tPT5zaVttXTxuP3V0Onk9PnIobSxTdCh5KSxuZXcgU2V0KGgpLmFkZChsKSk7aWYoKCJoYW5kbGVyImluIGM/Yy5oYW5kbGVyOmMpLmNhbGwoe2RlYnVnOnAocWkpLGVycm9yOm09PkwoU3QobSkpLGluZm86cChpaSksbWV0YTp7cm9sbHVwVmVyc2lvbjpCbix3YXRjaE1vZGU6aX0sd2FybjpwKEspfSxhLG8pPT09ITEpcmV0dXJufXQoYSxvKX19O3JldHVybiByfWNvbnN0IEpmPTEyMyxlbT0zMixtdT0iYXNzZXJ0IjtmdW5jdGlvbiB0bShlKXtjb25zdCB0PWUuYWNvcm58fE5mLHt0b2tUeXBlczppLFRva2VuVHlwZTpzfT10O3JldHVybiBjbGFzcyBleHRlbmRzIGV7Y29uc3RydWN0b3IoLi4ubil7c3VwZXIoLi4ubiksdGhpcy5hc3NlcnRUb2tlbj1uZXcgcyhtdSl9X2NvZGVBdChuKXtyZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG4pfV9lYXQobil7dGhpcy50eXBlIT09biYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5uZXh0KCl9cmVhZFRva2VuKG4pe2xldCByPTA7Zm9yKDtyPDY7cisrKWlmKHRoaXMuX2NvZGVBdCh0aGlzLnBvcytyKSE9PW11LmNoYXJDb2RlQXQocikpcmV0dXJuIHN1cGVyLnJlYWRUb2tlbihuKTtmb3IoO3RoaXMuX2NvZGVBdCh0aGlzLnBvcytyKSE9PUpmO3IrKylpZih0aGlzLl9jb2RlQXQodGhpcy5wb3MrcikhPT1lbSlyZXR1cm4gc3VwZXIucmVhZFRva2VuKG4pO3JldHVybiB0aGlzLnR5cGUubGFiZWw9PT0ieyI/c3VwZXIucmVhZFRva2VuKG4pOih0aGlzLnBvcys9Nix0aGlzLmZpbmlzaFRva2VuKHRoaXMuYXNzZXJ0VG9rZW4pKX1wYXJzZUR5bmFtaWNJbXBvcnQobil7aWYodGhpcy5uZXh0KCksbi5zb3VyY2U9dGhpcy5wYXJzZU1heWJlQXNzaWduKCksdGhpcy5lYXQoaS5jb21tYSkpe2NvbnN0IHI9dGhpcy5wYXJzZU9iaighMSk7bi5hcmd1bWVudHM9W3JdfXJldHVybiB0aGlzLl9lYXQoaS5wYXJlblIpLHRoaXMuZmluaXNoTm9kZShuLCJJbXBvcnRFeHByZXNzaW9uIil9cGFyc2VFeHBvcnQobixyKXtpZih0aGlzLm5leHQoKSx0aGlzLmVhdChpLnN0YXIpKXtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTExJiYodGhpcy5lYXRDb250ZXh0dWFsKCJhcyIpPyhuLmV4cG9ydGVkPXRoaXMucGFyc2VJZGVudCghMCksdGhpcy5jaGVja0V4cG9ydChyLG4uZXhwb3J0ZWQubmFtZSx0aGlzLmxhc3RUb2tTdGFydCkpOm4uZXhwb3J0ZWQ9bnVsbCksdGhpcy5leHBlY3RDb250ZXh0dWFsKCJmcm9tIiksdGhpcy50eXBlIT09aS5zdHJpbmcmJnRoaXMudW5leHBlY3RlZCgpLG4uc291cmNlPXRoaXMucGFyc2VFeHByQXRvbSgpLHRoaXMudHlwZT09PXRoaXMuYXNzZXJ0VG9rZW58fHRoaXMudHlwZT09PWkuX3dpdGgpe3RoaXMubmV4dCgpO2NvbnN0IG09dGhpcy5wYXJzZUltcG9ydEFzc2VydGlvbnMoKTttJiYobi5hc3NlcnRpb25zPW0pfXJldHVybiB0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShuLCJFeHBvcnRBbGxEZWNsYXJhdGlvbiIpfWlmKHRoaXMuZWF0KGkuX2RlZmF1bHQpKXt2YXIgYTtpZih0aGlzLmNoZWNrRXhwb3J0KHIsImRlZmF1bHQiLHRoaXMubGFzdFRva1N0YXJ0KSx0aGlzLnR5cGU9PT1pLl9mdW5jdGlvbnx8KGE9dGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkpe3ZhciBvPXRoaXMuc3RhcnROb2RlKCk7dGhpcy5uZXh0KCksYSYmdGhpcy5uZXh0KCksbi5kZWNsYXJhdGlvbj10aGlzLnBhcnNlRnVuY3Rpb24obyw1LCExLGEpfWVsc2UgaWYodGhpcy50eXBlPT09aS5fY2xhc3Mpe3ZhciBoPXRoaXMuc3RhcnROb2RlKCk7bi5kZWNsYXJhdGlvbj10aGlzLnBhcnNlQ2xhc3MoaCwibnVsbGFibGVJRCIpfWVsc2Ugbi5kZWNsYXJhdGlvbj10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLnNlbWljb2xvbigpO3JldHVybiB0aGlzLmZpbmlzaE5vZGUobiwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIil9aWYodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKW4uZGVjbGFyYXRpb249dGhpcy5wYXJzZVN0YXRlbWVudChudWxsKSxuLmRlY2xhcmF0aW9uLnR5cGU9PT0iVmFyaWFibGVEZWNsYXJhdGlvbiI/dGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KHIsbi5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnMpOnRoaXMuY2hlY2tFeHBvcnQocixuLmRlY2xhcmF0aW9uLmlkLm5hbWUsbi5kZWNsYXJhdGlvbi5pZC5zdGFydCksbi5zcGVjaWZpZXJzPVtdLG4uc291cmNlPW51bGw7ZWxzZXtpZihuLmRlY2xhcmF0aW9uPW51bGwsbi5zcGVjaWZpZXJzPXRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKHIpLHRoaXMuZWF0Q29udGV4dHVhbCgiZnJvbSIpKXtpZih0aGlzLnR5cGUhPT1pLnN0cmluZyYmdGhpcy51bmV4cGVjdGVkKCksbi5zb3VyY2U9dGhpcy5wYXJzZUV4cHJBdG9tKCksdGhpcy50eXBlPT09dGhpcy5hc3NlcnRUb2tlbnx8dGhpcy50eXBlPT09aS5fd2l0aCl7dGhpcy5uZXh0KCk7Y29uc3QgbT10aGlzLnBhcnNlSW1wb3J0QXNzZXJ0aW9ucygpO20mJihuLmFzc2VydGlvbnM9bSl9fWVsc2V7Zm9yKHZhciBsPTAsYz1uLnNwZWNpZmllcnM7bDxjLmxlbmd0aDtsKz0xKXt2YXIgcD1jW2xdO3RoaXMuY2hlY2tVbnJlc2VydmVkKHAubG9jYWwpLHRoaXMuY2hlY2tMb2NhbEV4cG9ydChwLmxvY2FsKX1uLnNvdXJjZT1udWxsfXRoaXMuc2VtaWNvbG9uKCl9cmV0dXJuIHRoaXMuZmluaXNoTm9kZShuLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIil9cGFyc2VJbXBvcnQobil7aWYodGhpcy5uZXh0KCksdGhpcy50eXBlPT09aS5zdHJpbmc/KG4uc3BlY2lmaWVycz1bXSxuLnNvdXJjZT10aGlzLnBhcnNlRXhwckF0b20oKSk6KG4uc3BlY2lmaWVycz10aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpLHRoaXMuZXhwZWN0Q29udGV4dHVhbCgiZnJvbSIpLG4uc291cmNlPXRoaXMudHlwZT09PWkuc3RyaW5nP3RoaXMucGFyc2VFeHByQXRvbSgpOnRoaXMudW5leHBlY3RlZCgpKSx0aGlzLnR5cGU9PT10aGlzLmFzc2VydFRva2VufHx0aGlzLnR5cGU9PWkuX3dpdGgpe3RoaXMubmV4dCgpO2NvbnN0IHI9dGhpcy5wYXJzZUltcG9ydEFzc2VydGlvbnMoKTtyJiYobi5hc3NlcnRpb25zPXIpfXJldHVybiB0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShuLCJJbXBvcnREZWNsYXJhdGlvbiIpfXBhcnNlSW1wb3J0QXNzZXJ0aW9ucygpe3RoaXMuX2VhdChpLmJyYWNlTCk7Y29uc3Qgbj10aGlzLnBhcnNlQXNzZXJ0RW50cmllcygpO3JldHVybiB0aGlzLl9lYXQoaS5icmFjZVIpLG59cGFyc2VBc3NlcnRFbnRyaWVzKCl7Y29uc3Qgbj1bXSxyPW5ldyBTZXQ7ZG97aWYodGhpcy50eXBlPT09aS5icmFjZVIpYnJlYWs7Y29uc3QgYT10aGlzLnN0YXJ0Tm9kZSgpO2xldCBvO289dGhpcy50eXBlPT09aS5zdHJpbmc/dGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk6dGhpcy5wYXJzZUlkZW50KCEwKSx0aGlzLm5leHQoKSxhLmtleT1vLHIuaGFzKGEua2V5Lm5hbWUpJiZ0aGlzLnJhaXNlKHRoaXMucG9zLCJEdXBsaWNhdGVkIGtleSBpbiBhc3NlcnRpb25zIiksci5hZGQoYS5rZXkubmFtZSksdGhpcy50eXBlIT09aS5zdHJpbmcmJnRoaXMucmFpc2UodGhpcy5wb3MsIk9ubHkgc3RyaW5nIGlzIHN1cHBvcnRlZCBhcyBhbiBhc3NlcnRpb24gdmFsdWUiKSxhLnZhbHVlPXRoaXMucGFyc2VMaXRlcmFsKHRoaXMudmFsdWUpLG4ucHVzaCh0aGlzLmZpbmlzaE5vZGUoYSwiSW1wb3J0QXR0cmlidXRlIikpfXdoaWxlKHRoaXMuZWF0KGkuY29tbWEpKTtyZXR1cm4gbn19fWZ1bmN0aW9uIGd1KGUpe3JldHVybiBBcnJheS5pc0FycmF5KGUpP2UuZmlsdGVyKEJvb2xlYW4pOmU/W2VdOltdfWNvbnN0IGltPWU9Pih7ZWNtYVZlcnNpb246ImxhdGVzdCIsc291cmNlVHlwZToibW9kdWxlIiwuLi5lLmFjb3JufSksc209ZT0+W3RtLC4uLmd1KGUuYWNvcm5JbmplY3RQbHVnaW5zKV0sbm09ZT0+e3ZhciB0O3JldHVybiBlLmNhY2hlPT09ITA/dm9pZCAwOigodD1lLmNhY2hlKT09bnVsbD92b2lkIDA6dC5jYWNoZSl8fGUuY2FjaGV9LHJtPWU9PntpZihlPT09ITApcmV0dXJuKCk9PiEwO2lmKHR5cGVvZiBlPT0iZnVuY3Rpb24iKXJldHVybih0LC4uLmkpPT4hdC5zdGFydHNXaXRoKCJcMCIpJiZlKHQsLi4uaSl8fCExO2lmKGUpe2NvbnN0IHQ9bmV3IFNldCxpPVtdO2Zvcihjb25zdCBzIG9mIGd1KGUpKXMgaW5zdGFuY2VvZiBSZWdFeHA/aS5wdXNoKHMpOnQuYWRkKHMpO3JldHVybihzLC4uLm4pPT50LmhhcyhzKXx8aS5zb21lKHI9PnIudGVzdChzKSl9cmV0dXJuKCk9PiExfSxhbT0oZSx0LGkpPT57Y29uc3Qgcz1lLmlubGluZUR5bmFtaWNJbXBvcnRzO3JldHVybiBzJiZRaSgnVGhlICJpbmxpbmVEeW5hbWljSW1wb3J0cyIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgIm91dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0cyIgb3B0aW9uIGluc3RlYWQuJyxabiwhMCx0LGkpLHN9LG9tPWU9Pntjb25zdCB0PWUuaW5wdXQ7cmV0dXJuIHQ9PW51bGw/W106dHlwZW9mIHQ9PSJzdHJpbmciP1t0XTp0fSxobT0oZSx0LGkpPT57Y29uc3Qgcz1lLm1hbnVhbENodW5rcztyZXR1cm4gcyYmUWkoJ1RoZSAibWFudWFsQ2h1bmtzIiBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSAib3V0cHV0Lm1hbnVhbENodW5rcyIgb3B0aW9uIGluc3RlYWQuJyxlciwhMCx0LGkpLHN9LGxtPShlLHQsaSk9Pntjb25zdCBzPWUubWF4UGFyYWxsZWxGaWxlUmVhZHM7dHlwZW9mIHM9PSJudW1iZXIiJiZRaSgnVGhlICJtYXhQYXJhbGxlbEZpbGVSZWFkcyIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgIm1heFBhcmFsbGVsRmlsZU9wcyIgb3B0aW9uIGluc3RlYWQuJywiY29uZmlndXJhdGlvbi1vcHRpb25zLyNtYXhwYXJhbGxlbGZpbGVvcHMiLCEwLHQsaSk7Y29uc3Qgbj1lLm1heFBhcmFsbGVsRmlsZU9wcz8/cztyZXR1cm4gdHlwZW9mIG49PSJudW1iZXIiP248PTA/MS8wOm46MjB9LHVtPShlLHQpPT57Y29uc3QgaT1lLm1vZHVsZUNvbnRleHQ7aWYodHlwZW9mIGk9PSJmdW5jdGlvbiIpcmV0dXJuIHM9Pmkocyk/P3Q7aWYoaSl7Y29uc3Qgcz1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcihjb25zdFtuLHJdb2YgT2JqZWN0LmVudHJpZXMoaSkpc1todChuKV09cjtyZXR1cm4gbj0+c1tuXT8/dH1yZXR1cm4oKT0+dH0sY209KGUsdCxpKT0+e2NvbnN0IHM9ZS5wcmVzZXJ2ZU1vZHVsZXM7cmV0dXJuIHMmJlFpKCdUaGUgInByZXNlcnZlTW9kdWxlcyIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgIm91dHB1dC5wcmVzZXJ2ZU1vZHVsZXMiIG9wdGlvbiBpbnN0ZWFkLicsImNvbmZpZ3VyYXRpb24tb3B0aW9ucy8jb3V0cHV0LXByZXNlcnZlbW9kdWxlcyIsITAsdCxpKSxzfSxwbT1lPT57aWYoZS50cmVlc2hha2U9PT0hMSlyZXR1cm4hMTtjb25zdCB0PXJ1KGUudHJlZXNoYWtlLE1mLCJ0cmVlc2hha2UiLCJjb25maWd1cmF0aW9uLW9wdGlvbnMvI3RyZWVzaGFrZSIsImZhbHNlLCB0cnVlLCAiKTtyZXR1cm57YW5ub3RhdGlvbnM6dC5hbm5vdGF0aW9ucyE9PSExLGNvcnJlY3RWYXJWYWx1ZUJlZm9yZURlY2xhcmF0aW9uOnQuY29ycmVjdFZhclZhbHVlQmVmb3JlRGVjbGFyYXRpb249PT0hMCxtYW51YWxQdXJlRnVuY3Rpb25zOnQubWFudWFsUHVyZUZ1bmN0aW9ucz8/dmUsbW9kdWxlU2lkZUVmZmVjdHM6ZG0odC5tb2R1bGVTaWRlRWZmZWN0cykscHJvcGVydHlSZWFkU2lkZUVmZmVjdHM6dC5wcm9wZXJ0eVJlYWRTaWRlRWZmZWN0cz09PSJhbHdheXMiPyJhbHdheXMiOnQucHJvcGVydHlSZWFkU2lkZUVmZmVjdHMhPT0hMSx0cnlDYXRjaERlb3B0aW1pemF0aW9uOnQudHJ5Q2F0Y2hEZW9wdGltaXphdGlvbiE9PSExLHVua25vd25HbG9iYWxTaWRlRWZmZWN0czp0LnVua25vd25HbG9iYWxTaWRlRWZmZWN0cyE9PSExfX0sZG09ZT0+e2lmKHR5cGVvZiBlPT0iYm9vbGVhbiIpcmV0dXJuKCk9PmU7aWYoZT09PSJuby1leHRlcm5hbCIpcmV0dXJuKHQsaSk9PiFpO2lmKHR5cGVvZiBlPT0iZnVuY3Rpb24iKXJldHVybih0LGkpPT4hIXQuc3RhcnRzV2l0aCgiXDAiKXx8ZSh0LGkpIT09ITE7aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3QgdD1uZXcgU2V0KGUpO3JldHVybiBpPT50LmhhcyhpKX1yZXR1cm4gZSYmTChFZSgidHJlZXNoYWtlLm1vZHVsZVNpZGVFZmZlY3RzIiwiY29uZmlndXJhdGlvbi1vcHRpb25zLyN0cmVlc2hha2UtbW9kdWxlc2lkZWVmZmVjdHMiLCdwbGVhc2UgdXNlIG9uZSBvZiBmYWxzZSwgIm5vLWV4dGVybmFsIiwgYSBmdW5jdGlvbiBvciBhbiBhcnJheScpKSwoKT0+ITB9LGZtPS9bXHUwMDAwLVx1MDAxRiIjJCYqKyw6Ozw9Pj9bXF1eYHt8fVx1MDA3Rl0vZyxtbT0vXlthLXpdOi9pO2Z1bmN0aW9uIGdtKGUpe2NvbnN0IHQ9bW0uZXhlYyhlKSxpPXQ/dFswXToiIjtyZXR1cm4gaStlLnNsaWNlKGkubGVuZ3RoKS5yZXBsYWNlKGZtLCJfIil9Y29uc3QgeW09KGUsdCxpKT0+e2NvbnN0e2ZpbGU6c309ZTtpZih0eXBlb2Ygcz09InN0cmluZyIpe2lmKHQpcmV0dXJuIEwoRWUoIm91dHB1dC5maWxlIixIaSwneW91IG11c3Qgc2V0ICJvdXRwdXQuZGlyIiBpbnN0ZWFkIG9mICJvdXRwdXQuZmlsZSIgd2hlbiB1c2luZyB0aGUgIm91dHB1dC5wcmVzZXJ2ZU1vZHVsZXMiIG9wdGlvbicpKTtpZighQXJyYXkuaXNBcnJheShpLmlucHV0KSlyZXR1cm4gTChFZSgib3V0cHV0LmZpbGUiLEhpLCd5b3UgbXVzdCBzZXQgIm91dHB1dC5kaXIiIGluc3RlYWQgb2YgIm91dHB1dC5maWxlIiB3aGVuIHByb3ZpZGluZyBuYW1lZCBpbnB1dHMnKSl9cmV0dXJuIHN9LHhtPWU9Pntjb25zdCB0PWUuZm9ybWF0O3N3aXRjaCh0KXtjYXNlIHZvaWQgMDpjYXNlImVzIjpjYXNlImVzbSI6Y2FzZSJtb2R1bGUiOnJldHVybiJlcyI7Y2FzZSJjanMiOmNhc2UiY29tbW9uanMiOnJldHVybiJjanMiO2Nhc2Uic3lzdGVtIjpjYXNlInN5c3RlbWpzIjpyZXR1cm4ic3lzdGVtIjtjYXNlImFtZCI6Y2FzZSJpaWZlIjpjYXNlInVtZCI6cmV0dXJuIHQ7ZGVmYXVsdDpyZXR1cm4gTChFZSgib3V0cHV0LmZvcm1hdCIsaG8sJ1ZhbGlkIHZhbHVlcyBhcmUgImFtZCIsICJjanMiLCAic3lzdGVtIiwgImVzIiwgImlpZmUiIG9yICJ1bWQiJyx0KSl9fSxibT0oZSx0KT0+e2NvbnN0IGk9KGUuaW5saW5lRHluYW1pY0ltcG9ydHM/P3QuaW5saW5lRHluYW1pY0ltcG9ydHMpfHwhMSx7aW5wdXQ6c309dDtyZXR1cm4gaSYmKEFycmF5LmlzQXJyYXkocyk/czpPYmplY3Qua2V5cyhzKSkubGVuZ3RoPjE/TChFZSgib3V0cHV0LmlubGluZUR5bmFtaWNJbXBvcnRzIixabiwnbXVsdGlwbGUgaW5wdXRzIGFyZSBub3Qgc3VwcG9ydGVkIHdoZW4gIm91dHB1dC5pbmxpbmVEeW5hbWljSW1wb3J0cyIgaXMgdHJ1ZScpKTppfSx2bT0oZSx0LGkpPT57Y29uc3Qgcz0oZS5wcmVzZXJ2ZU1vZHVsZXM/P2kucHJlc2VydmVNb2R1bGVzKXx8ITE7aWYocyl7aWYodClyZXR1cm4gTChFZSgib3V0cHV0LmlubGluZUR5bmFtaWNJbXBvcnRzIixabiwndGhpcyBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBmb3IgIm91dHB1dC5wcmVzZXJ2ZU1vZHVsZXMiJykpO2lmKGkucHJlc2VydmVFbnRyeVNpZ25hdHVyZXM9PT0hMSlyZXR1cm4gTChFZSgicHJlc2VydmVFbnRyeVNpZ25hdHVyZXMiLCJjb25maWd1cmF0aW9uLW9wdGlvbnMvI3ByZXNlcnZlZW50cnlzaWduYXR1cmVzIiwnc2V0dGluZyB0aGlzIG9wdGlvbiB0byBmYWxzZSBpcyBub3Qgc3VwcG9ydGVkIGZvciAib3V0cHV0LnByZXNlcnZlTW9kdWxlcyInKSl9cmV0dXJuIHN9LEVtPShlLHQpPT57Y29uc3QgaT1lLnByZWZlckNvbnN0O3JldHVybiBpIT1udWxsJiZuaSgnVGhlICJvdXRwdXQucHJlZmVyQ29uc3QiIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgdGhlICJvdXRwdXQuZ2VuZXJhdGVkQ29kZS5jb25zdEJpbmRpbmdzIiBvcHRpb24gaW5zdGVhZC4nLCJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1nZW5lcmF0ZWRjb2RlLWNvbnN0YmluZGluZ3MiLCEwLHQpLCEhaX0sU209ZT0+e2NvbnN0e3ByZXNlcnZlTW9kdWxlc1Jvb3Q6dH09ZTtpZih0IT1udWxsKXJldHVybiBodCh0KX0sa209ZT0+e2NvbnN0IHQ9e2F1dG9JZDohMSxiYXNlUGF0aDoiIixkZWZpbmU6ImRlZmluZSIsZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHM6ITEsLi4uZS5hbWR9O3JldHVybih0LmF1dG9JZHx8dC5iYXNlUGF0aCkmJnQuaWQ/TChFZSgib3V0cHV0LmFtZC5pZCIsb28sJ3RoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHRvZ2V0aGVyIHdpdGggIm91dHB1dC5hbWQuYXV0b0lkIi8ib3V0cHV0LmFtZC5iYXNlUGF0aCInKSk6dC5iYXNlUGF0aCYmIXQuYXV0b0lkP0woRWUoIm91dHB1dC5hbWQuYmFzZVBhdGgiLCJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1hbWQtYmFzZXBhdGgiLCd0aGlzIG9wdGlvbiBvbmx5IHdvcmtzIHdpdGggIm91dHB1dC5hbWQuYXV0b0lkIicpKTp0LmF1dG9JZD97YXV0b0lkOiEwLGJhc2VQYXRoOnQuYmFzZVBhdGgsZGVmaW5lOnQuZGVmaW5lLGZvcmNlSnNFeHRlbnNpb25Gb3JJbXBvcnRzOnQuZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHN9OnthdXRvSWQ6ITEsZGVmaW5lOnQuZGVmaW5lLGZvcmNlSnNFeHRlbnNpb25Gb3JJbXBvcnRzOnQuZm9yY2VKc0V4dGVuc2lvbkZvckltcG9ydHMsaWQ6dC5pZH19LE5uPShlLHQpPT57Y29uc3QgaT1lW3RdO3JldHVybiB0eXBlb2YgaT09ImZ1bmN0aW9uIj9pOigpPT5pfHwiIn0sd209KGUsdCk9Pntjb25zdHtkaXI6aX09ZTtyZXR1cm4gdHlwZW9mIGk9PSJzdHJpbmciJiZ0eXBlb2YgdD09InN0cmluZyI/TChFZSgib3V0cHV0LmRpciIsSGksJ3lvdSBtdXN0IHNldCBlaXRoZXIgIm91dHB1dC5maWxlIiBmb3IgYSBzaW5nbGUtZmlsZSBidWlsZCBvciAib3V0cHV0LmRpciIgd2hlbiBnZW5lcmF0aW5nIG11bHRpcGxlIGNodW5rcycpKTppfSxBbT0oZSx0LGkpPT57Y29uc3Qgcz1lLmR5bmFtaWNJbXBvcnRGdW5jdGlvbjtyZXR1cm4gcyYmKG5pKCdUaGUgIm91dHB1dC5keW5hbWljSW1wb3J0RnVuY3Rpb24iIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBVc2UgdGhlICJyZW5kZXJEeW5hbWljSW1wb3J0IiBwbHVnaW4gaG9vayBpbnN0ZWFkLicsInBsdWdpbi1kZXZlbG9wbWVudC8jcmVuZGVyZHluYW1pY2ltcG9ydCIsITAsdCksaSE9PSJlcyImJnQub25Mb2coSyxFZSgib3V0cHV0LmR5bmFtaWNJbXBvcnRGdW5jdGlvbiIsImNvbmZpZ3VyYXRpb24tb3B0aW9ucy8jb3V0cHV0LWR5bmFtaWNpbXBvcnRmdW5jdGlvbiIsJ3RoaXMgb3B0aW9uIGlzIGlnbm9yZWQgZm9yIGZvcm1hdHMgb3RoZXIgdGhhbiAiZXMiJykpKSxzfSxDbT0oZSx0KT0+e2NvbnN0IGk9ZS5lbnRyeUZpbGVOYW1lcztyZXR1cm4gaT09bnVsbCYmdC5hZGQoImVudHJ5RmlsZU5hbWVzIiksaT8/IltuYW1lXS5qcyJ9O2Z1bmN0aW9uIEltKGUsdCl7Y29uc3QgaT1lLmV4cGVyaW1lbnRhbERlZXBEeW5hbWljQ2h1bmtPcHRpbWl6YXRpb247cmV0dXJuIGkhPW51bGwmJm5pKCdUaGUgIm91dHB1dC5leHBlcmltZW50YWxEZWVwRHluYW1pY0NodW5rT3B0aW1pemF0aW9uIiBvcHRpb24gaXMgZGVwcmVjYXRlZCBhcyBSb2xsdXAgYWx3YXlzIHJ1bnMgdGhlIGZ1bGwgY2h1bmtpbmcgYWxnb3JpdGhtIG5vdy4gVGhlIG9wdGlvbiBzaG91bGQgYmUgcmVtb3ZlZC4nLEJjLCEwLHQpLGl8fCExfWZ1bmN0aW9uIFBtKGUsdCl7Y29uc3QgaT1lLmV4cG9ydHM7aWYoaT09bnVsbCl0LmFkZCgiZXhwb3J0cyIpO2Vsc2UgaWYoIVsiZGVmYXVsdCIsIm5hbWVkIiwibm9uZSIsImF1dG8iXS5pbmNsdWRlcyhpKSlyZXR1cm4gTCh7Y29kZTpjbyxtZXNzYWdlOmAib3V0cHV0LmV4cG9ydHMiIG11c3QgYmUgImRlZmF1bHQiLCAibmFtZWQiLCAibm9uZSIsICJhdXRvIiwgb3IgbGVmdCB1bnNwZWNpZmllZCAoZGVmYXVsdHMgdG8gImF1dG8iKSwgcmVjZWl2ZWQgIiR7aX0iLmAsdXJsOl9lKFhuKX0pO3JldHVybiBpfHwiYXV0byJ9Y29uc3QgX209KGUsdCk9Pntjb25zdCBpPXJ1KGUuZ2VuZXJhdGVkQ29kZSxEZiwib3V0cHV0LmdlbmVyYXRlZENvZGUiLCJjb25maWd1cmF0aW9uLW9wdGlvbnMvI291dHB1dC1nZW5lcmF0ZWRjb2RlIiwiIik7cmV0dXJue2Fycm93RnVuY3Rpb25zOmkuYXJyb3dGdW5jdGlvbnM9PT0hMCxjb25zdEJpbmRpbmdzOmkuY29uc3RCaW5kaW5ncz09PSEwfHx0LG9iamVjdFNob3J0aGFuZDppLm9iamVjdFNob3J0aGFuZD09PSEwLHJlc2VydmVkTmFtZXNBc1Byb3BzOmkucmVzZXJ2ZWROYW1lc0FzUHJvcHMhPT0hMSxzeW1ib2xzOmkuc3ltYm9scz09PSEwfX0sTm09KGUsdCk9PntpZih0KXJldHVybiIiO2NvbnN0IGk9ZS5pbmRlbnQ7cmV0dXJuIGk9PT0hMT8iIjppPz8hMH0seXU9bmV3IFNldChbImNvbXBhdCIsImF1dG8iLCJlc01vZHVsZSIsImRlZmF1bHQiLCJkZWZhdWx0T25seSJdKSwkbT1lPT57Y29uc3QgdD1lLmludGVyb3A7aWYodHlwZW9mIHQ9PSJmdW5jdGlvbiIpe2NvbnN0IGk9T2JqZWN0LmNyZWF0ZShudWxsKTtsZXQgcz1udWxsO3JldHVybiBuPT5uPT09bnVsbD9zfHxTYShzPXQobikpOm4gaW4gaT9pW25dOlNhKGlbbl09dChuKSl9cmV0dXJuIHQ9PT12b2lkIDA/KCk9PiJkZWZhdWx0IjooKT0+U2EodCl9LFNhPWU9Pnl1LmhhcyhlKT9lOkwoRWUoIm91dHB1dC5pbnRlcm9wIixKbixgdXNlIG9uZSBvZiAke0FycmF5LmZyb20oeXUsdD0+SlNPTi5zdHJpbmdpZnkodCkpLmpvaW4oIiwgIil9YCxlKSksTG09KGUsdCxpLHMpPT57Y29uc3Qgbj1lLm1hbnVhbENodW5rc3x8cy5tYW51YWxDaHVua3M7aWYobil7aWYodClyZXR1cm4gTChFZSgib3V0cHV0Lm1hbnVhbENodW5rcyIsZXIsJ3RoaXMgb3B0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgZm9yICJvdXRwdXQuaW5saW5lRHluYW1pY0ltcG9ydHMiJykpO2lmKGkpcmV0dXJuIEwoRWUoIm91dHB1dC5tYW51YWxDaHVua3MiLGVyLCd0aGlzIG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciAib3V0cHV0LnByZXNlcnZlTW9kdWxlcyInKSl9cmV0dXJuIG58fHt9fSxUbT0oZSx0LGkpPT5lLm1pbmlmeUludGVybmFsRXhwb3J0cz8/KGl8fHQ9PT0iZXMifHx0PT09InN5c3RlbSIpLFJtPShlLHQsaSk9Pntjb25zdCBzPWUubmFtZXNwYWNlVG9TdHJpbmdUYWc7cmV0dXJuIHMhPW51bGw/KG5pKCdUaGUgIm91dHB1dC5uYW1lc3BhY2VUb1N0cmluZ1RhZyIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSB0aGUgIm91dHB1dC5nZW5lcmF0ZWRDb2RlLnN5bWJvbHMiIG9wdGlvbiBpbnN0ZWFkLicsImNvbmZpZ3VyYXRpb24tb3B0aW9ucy8jb3V0cHV0LWdlbmVyYXRlZGNvZGUtc3ltYm9scyIsITAsaSkscyk6dC5zeW1ib2xzfHwhMX0sT209KGUsdCk9Pntjb25zdCBpPWUuc291cmNlbWFwRmlsZU5hbWVzO3JldHVybiBpPT1udWxsJiZ0LmFkZCgic291cmNlbWFwRmlsZU5hbWVzIiksaX0sVm09ZT0+e2NvbnN0e3NvdXJjZW1hcEJhc2VVcmw6dH09ZTtpZih0KXJldHVybiBmdW5jdGlvbihzKXt0cnl7bmV3IFVSTChzKX1jYXRjaHtyZXR1cm4hMX1yZXR1cm4hMH0odCk/KGk9dCkuZW5kc1dpdGgoIi8iKT9pOmkrIi8iOkwoRWUoIm91dHB1dC5zb3VyY2VtYXBCYXNlVXJsIiwiY29uZmlndXJhdGlvbi1vcHRpb25zLyNvdXRwdXQtc291cmNlbWFwYmFzZXVybCIsYG11c3QgYmUgYSB2YWxpZCBVUkwsIHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodCl9YCkpO3ZhciBpfTtmdW5jdGlvbiBNbShlKXtyZXR1cm4gYXN5bmMgZnVuY3Rpb24odCxpKXtjb25zdHtvcHRpb25zOnMsdW5zZXRPcHRpb25zOm59PWF3YWl0IGFzeW5jIGZ1bmN0aW9uKGgsbCl7aWYoIWgpdGhyb3cgbmV3IEVycm9yKCJZb3UgbXVzdCBzdXBwbHkgYW4gb3B0aW9ucyBvYmplY3QgdG8gcm9sbHVwIik7Y29uc3QgYz1hd2FpdCBhc3luYyBmdW5jdGlvbih5LEUpe2NvbnN0IGc9RWEoIm9wdGlvbnMiLGF3YWl0IF9uKHkucGx1Z2lucykpLHg9eS5sb2dMZXZlbHx8aWksdj1mdShnLHR1KHkseCksRSx4KTtmb3IoY29uc3QgdyBvZiBnKXtjb25zdHtuYW1lOmIsb3B0aW9uczpTfT13LGs9ImhhbmRsZXIiaW4gUz9TLmhhbmRsZXI6UyxDPWF3YWl0IGsuY2FsbCh7ZGVidWc6TWkocWksIlBMVUdJTl9MT0ciLHYsYix4KSxlcnJvcjpQPT5MKEtpKFN0KFApLGIse2hvb2s6Im9uTG9nIn0pKSxpbmZvOk1pKGlpLCJQTFVHSU5fTE9HIix2LGIseCksbWV0YTp7cm9sbHVwVmVyc2lvbjpCbix3YXRjaE1vZGU6RX0sd2FybjpNaShLLCJQTFVHSU5fV0FSTklORyIsdixiLHgpfSx5KTtDJiYoeT1DKX1yZXR1cm4geX0oaCxsKSx7b3B0aW9uczpwLHVuc2V0T3B0aW9uczptfT1hd2FpdCBhc3luYyBmdW5jdGlvbih5LEUpe2NvbnN0IGc9bmV3IFNldCx4PXkuY29udGV4dD8/InVuZGVmaW5lZCIsdj1hd2FpdCBfbih5LnBsdWdpbnMpLHc9eS5sb2dMZXZlbHx8aWksYj1mdSh2LHR1KHksdyksRSx3KSxTPXkuc3RyaWN0RGVwcmVjYXRpb25zfHwhMSxrPWxtKHksYixTKSxDPXthY29ybjppbSh5KSxhY29ybkluamVjdFBsdWdpbnM6c20oeSksY2FjaGU6bm0oeSksY29udGV4dDp4LGV4cGVyaW1lbnRhbENhY2hlRXhwaXJ5OnkuZXhwZXJpbWVudGFsQ2FjaGVFeHBpcnk/PzEwLGV4cGVyaW1lbnRhbExvZ1NpZGVFZmZlY3RzOnkuZXhwZXJpbWVudGFsTG9nU2lkZUVmZmVjdHN8fCExLGV4dGVybmFsOnJtKHkuZXh0ZXJuYWwpLGlubGluZUR5bmFtaWNJbXBvcnRzOmFtKHksYixTKSxpbnB1dDpvbSh5KSxsb2dMZXZlbDp3LG1ha2VBYnNvbHV0ZUV4dGVybmFsc1JlbGF0aXZlOnkubWFrZUFic29sdXRlRXh0ZXJuYWxzUmVsYXRpdmU/PyJpZlJlbGF0aXZlU291cmNlIixtYW51YWxDaHVua3M6aG0oeSxiLFMpLG1heFBhcmFsbGVsRmlsZU9wczprLG1heFBhcmFsbGVsRmlsZVJlYWRzOmssbW9kdWxlQ29udGV4dDp1bSh5LHgpLG9uTG9nOmIsb253YXJuOlA9PmIoSyxQKSxwZXJmOnkucGVyZnx8ITEscGx1Z2luczp2LHByZXNlcnZlRW50cnlTaWduYXR1cmVzOnkucHJlc2VydmVFbnRyeVNpZ25hdHVyZXM/PyJleHBvcnRzLW9ubHkiLHByZXNlcnZlTW9kdWxlczpjbSh5LGIsUykscHJlc2VydmVTeW1saW5rczp5LnByZXNlcnZlU3ltbGlua3N8fCExLHNoaW1NaXNzaW5nRXhwb3J0czp5LnNoaW1NaXNzaW5nRXhwb3J0c3x8ITEsc3RyaWN0RGVwcmVjYXRpb25zOlMsdHJlZXNoYWtlOnBtKHkpfTtyZXR1cm4gbnUoeSxbLi4uT2JqZWN0LmtleXMoQyksIndhdGNoIl0sImlucHV0IG9wdGlvbnMiLGIsL14ob3V0cHV0KSQvKSx7b3B0aW9uczpDLHVuc2V0T3B0aW9uczpnfX0oYyxsKTtyZXR1cm4geHUocC5wbHVnaW5zLGdhKSx7b3B0aW9uczpwLHVuc2V0T3B0aW9uczptfX0odCxpIT09bnVsbCk7KGZ1bmN0aW9uKGgpe2gucGVyZj8oZnM9bmV3IE1hcCxDZT1oZCxTZT1sZCxoLnBsdWdpbnM9aC5wbHVnaW5zLm1hcChwZCkpOihDZT11dCxTZT11dCl9KShzKTtjb25zdCByPW5ldyBaZihzLGkpLGE9dC5jYWNoZSE9PSExO3QuY2FjaGUmJihzLmNhY2hlPXZvaWQgMCx0LmNhY2hlPXZvaWQgMCksQ2UoIkJVSUxEIiwxKSxhd2FpdCBkdShyLnBsdWdpbkRyaXZlcixhc3luYygpPT57dHJ5e0NlKCJpbml0aWFsaXplIiwyKSxhd2FpdCByLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoImJ1aWxkU3RhcnQiLFtzXSksU2UoImluaXRpYWxpemUiLDIpLGF3YWl0IHIuYnVpbGQoKX1jYXRjaChoKXtjb25zdCBsPU9iamVjdC5rZXlzKHIud2F0Y2hGaWxlcyk7dGhyb3cgbC5sZW5ndGg+MCYmKGgud2F0Y2hGaWxlcz1sKSxhd2FpdCByLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoImJ1aWxkRW5kIixbaF0pLGF3YWl0IHIucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgiY2xvc2VCdW5kbGUiLFtdKSxofWF3YWl0IHIucGx1Z2luRHJpdmVyLmhvb2tQYXJhbGxlbCgiYnVpbGRFbmQiLFtdKX0pLFNlKCJCVUlMRCIsMSk7Y29uc3Qgbz17Y2FjaGU6YT9yLmdldENhY2hlKCk6dm9pZCAwLGFzeW5jIGNsb3NlKCl7by5jbG9zZWR8fChvLmNsb3NlZD0hMCxhd2FpdCByLnBsdWdpbkRyaXZlci5ob29rUGFyYWxsZWwoImNsb3NlQnVuZGxlIixbXSkpfSxjbG9zZWQ6ITEsZ2VuZXJhdGU6YXN5bmMgaD0+by5jbG9zZWQ/TCh2bygpKTpidSghMSxzLG4saCxyKSx3YXRjaEZpbGVzOk9iamVjdC5rZXlzKHIud2F0Y2hGaWxlcyksd3JpdGU6YXN5bmMgaD0+by5jbG9zZWQ/TCh2bygpKTpidSghMCxzLG4saCxyKX07cmV0dXJuIHMucGVyZiYmKG8uZ2V0VGltaW5ncz11ZCksb30oZSxudWxsKX1mdW5jdGlvbiB4dShlLHQpe2Zvcihjb25zdFtpLHNdb2YgZS5lbnRyaWVzKCkpcy5uYW1lfHwocy5uYW1lPWAke3R9JHtpKzF9YCl9YXN5bmMgZnVuY3Rpb24gYnUoZSx0LGkscyxuKXtjb25zdHtvcHRpb25zOnIsb3V0cHV0UGx1Z2luRHJpdmVyOmEsdW5zZXRPcHRpb25zOm99PWF3YWl0IGFzeW5jIGZ1bmN0aW9uKGgsbCxjLHApe2lmKCFoKXRocm93IG5ldyBFcnJvcigiWW91IG11c3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0Iik7Y29uc3QgbT1hd2FpdCBfbihoLnBsdWdpbnMpO3h1KG0seWEpO2NvbnN0IHk9bC5jcmVhdGVPdXRwdXRQbHVnaW5Ecml2ZXIobSk7cmV0dXJuey4uLmF3YWl0IERtKGMscCxoLHkpLG91dHB1dFBsdWdpbkRyaXZlcjp5fX0ocyxuLnBsdWdpbkRyaXZlcix0LGkpO3JldHVybiBkdSgwLGFzeW5jKCk9Pntjb25zdCBoPW5ldyBsZihyLG8sdCxhLG4pLGw9YXdhaXQgaC5nZW5lcmF0ZShlKTtpZihlKXtpZihDZSgiV1JJVEUiLDEpLCFyLmRpciYmIXIuZmlsZSlyZXR1cm4gTCh7Y29kZTphcCxtZXNzYWdlOidZb3UgbXVzdCBzcGVjaWZ5ICJvdXRwdXQuZmlsZSIgb3IgIm91dHB1dC5kaXIiIGZvciB0aGUgYnVpbGQuJyx1cmw6X2UoSGkpfSk7YXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyhsKS5tYXAocD0+bi5maWxlT3BlcmF0aW9uUXVldWUucnVuKCgpPT5hc3luYyBmdW5jdGlvbihtLHkpe2NvbnN0IEU9aHQoeS5kaXJ8fEp0KHkuZmlsZSksbS5maWxlTmFtZSk7cmV0dXJuIGF3YWl0ICRmKEp0KEUpLHtyZWN1cnNpdmU6ITB9KSxUZihFLG0udHlwZT09PSJhc3NldCI/bS5zb3VyY2U6bS5jb2RlKX0ocCxyKSkpKSxhd2FpdCBhLmhvb2tQYXJhbGxlbCgid3JpdGVCdW5kbGUiLFtyLGxdKSxTZSgiV1JJVEUiLDEpfXJldHVybiBjPWwse291dHB1dDpPYmplY3QudmFsdWVzKGMpLmZpbHRlcihwPT5PYmplY3Qua2V5cyhwKS5sZW5ndGg+MCkuc29ydCgocCxtKT0+dnUocCktdnUobSkpfTt2YXIgY30pfWZ1bmN0aW9uIERtKGUsdCxpLHMpe3JldHVybiBhc3luYyBmdW5jdGlvbihuLHIsYSl7Y29uc3Qgbz1uZXcgU2V0KGEpLGg9bi5jb21wYWN0fHwhMSxsPXhtKG4pLGM9Ym0obixyKSxwPXZtKG4sYyxyKSxtPXltKG4scCxyKSx5PUVtKG4sciksRT1fbShuLHkpLGc9e2FtZDprbShuKSxhc3NldEZpbGVOYW1lczpuLmFzc2V0RmlsZU5hbWVzPz8iYXNzZXRzL1tuYW1lXS1baGFzaF1bZXh0bmFtZV0iLGJhbm5lcjpObihuLCJiYW5uZXIiKSxjaHVua0ZpbGVOYW1lczpuLmNodW5rRmlsZU5hbWVzPz8iW25hbWVdLVtoYXNoXS5qcyIsY29tcGFjdDpoLGRpcjp3bShuLG0pLGR5bmFtaWNJbXBvcnRGdW5jdGlvbjpBbShuLHIsbCksZHluYW1pY0ltcG9ydEluQ2pzOm4uZHluYW1pY0ltcG9ydEluQ2pzPz8hMCxlbnRyeUZpbGVOYW1lczpDbShuLG8pLGVzTW9kdWxlOm4uZXNNb2R1bGU/PyJpZi1kZWZhdWx0LXByb3AiLGV4cGVyaW1lbnRhbERlZXBEeW5hbWljQ2h1bmtPcHRpbWl6YXRpb246SW0obixyKSxleHBlcmltZW50YWxNaW5DaHVua1NpemU6bi5leHBlcmltZW50YWxNaW5DaHVua1NpemU/PzEsZXhwb3J0czpQbShuLG8pLGV4dGVuZDpuLmV4dGVuZHx8ITEsZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zOm4uZXh0ZXJuYWxJbXBvcnRBc3NlcnRpb25zPz8hMCxleHRlcm5hbExpdmVCaW5kaW5nczpuLmV4dGVybmFsTGl2ZUJpbmRpbmdzPz8hMCxmaWxlOm0sZm9vdGVyOk5uKG4sImZvb3RlciIpLGZvcm1hdDpsLGZyZWV6ZTpuLmZyZWV6ZT8/ITAsZ2VuZXJhdGVkQ29kZTpFLGdsb2JhbHM6bi5nbG9iYWxzfHx7fSxob2lzdFRyYW5zaXRpdmVJbXBvcnRzOm4uaG9pc3RUcmFuc2l0aXZlSW1wb3J0cz8/ITAsaW5kZW50Ok5tKG4saCksaW5saW5lRHluYW1pY0ltcG9ydHM6YyxpbnRlcm9wOiRtKG4pLGludHJvOk5uKG4sImludHJvIiksbWFudWFsQ2h1bmtzOkxtKG4sYyxwLHIpLG1pbmlmeUludGVybmFsRXhwb3J0czpUbShuLGwsaCksbmFtZTpuLm5hbWUsbmFtZXNwYWNlVG9TdHJpbmdUYWc6Um0obixFLHIpLG5vQ29uZmxpY3Q6bi5ub0NvbmZsaWN0fHwhMSxvdXRybzpObihuLCJvdXRybyIpLHBhdGhzOm4ucGF0aHN8fHt9LHBsdWdpbnM6YXdhaXQgX24obi5wbHVnaW5zKSxwcmVmZXJDb25zdDp5LHByZXNlcnZlTW9kdWxlczpwLHByZXNlcnZlTW9kdWxlc1Jvb3Q6U20obiksc2FuaXRpemVGaWxlTmFtZTp0eXBlb2Ygbi5zYW5pdGl6ZUZpbGVOYW1lPT0iZnVuY3Rpb24iP24uc2FuaXRpemVGaWxlTmFtZTpuLnNhbml0aXplRmlsZU5hbWU9PT0hMT94PT54OmdtLHNvdXJjZW1hcDpuLnNvdXJjZW1hcHx8ITEsc291cmNlbWFwQmFzZVVybDpWbShuKSxzb3VyY2VtYXBFeGNsdWRlU291cmNlczpuLnNvdXJjZW1hcEV4Y2x1ZGVTb3VyY2VzfHwhMSxzb3VyY2VtYXBGaWxlOm4uc291cmNlbWFwRmlsZSxzb3VyY2VtYXBGaWxlTmFtZXM6T20obixvKSxzb3VyY2VtYXBJZ25vcmVMaXN0OnR5cGVvZiBuLnNvdXJjZW1hcElnbm9yZUxpc3Q9PSJmdW5jdGlvbiI/bi5zb3VyY2VtYXBJZ25vcmVMaXN0Om4uc291cmNlbWFwSWdub3JlTGlzdD09PSExPygpPT4hMTp4PT54LmluY2x1ZGVzKCJub2RlX21vZHVsZXMiKSxzb3VyY2VtYXBQYXRoVHJhbnNmb3JtOm4uc291cmNlbWFwUGF0aFRyYW5zZm9ybSxzdHJpY3Q6bi5zdHJpY3Q/PyEwLHN5c3RlbU51bGxTZXR0ZXJzOm4uc3lzdGVtTnVsbFNldHRlcnM/PyEwLHZhbGlkYXRlOm4udmFsaWRhdGV8fCExfTtyZXR1cm4gbnUobixPYmplY3Qua2V5cyhnKSwib3V0cHV0IG9wdGlvbnMiLHIub25Mb2cpLHtvcHRpb25zOmcsdW5zZXRPcHRpb25zOm99fShzLmhvb2tSZWR1Y2VBcmcwU3luYygib3V0cHV0T3B0aW9ucyIsW2ldLChuLHIpPT5yfHxuLG49Pntjb25zdCByPSgpPT5uLmVycm9yKHtjb2RlOnFjLG1lc3NhZ2U6J0Nhbm5vdCBlbWl0IGZpbGVzIG9yIHNldCBhc3NldCBzb3VyY2VzIGluIHRoZSAib3V0cHV0T3B0aW9ucyIgaG9vaywgdXNlIHRoZSAicmVuZGVyU3RhcnQiIGhvb2sgaW5zdGVhZC4nfSk7cmV0dXJuey4uLm4sZW1pdEZpbGU6cixzZXRBc3NldFNvdXJjZTpyfX0pLGUsdCl9dmFyIEVzO2Z1bmN0aW9uIHZ1KGUpe3JldHVybiBlLnR5cGU9PT0iYXNzZXQiP0VzLkFTU0VUOmUuaXNFbnRyeT9Fcy5FTlRSWV9DSFVOSzpFcy5TRUNPTkRBUllfQ0hVTkt9KGZ1bmN0aW9uKGUpe2VbZS5FTlRSWV9DSFVOSz0wXT0iRU5UUllfQ0hVTksiLGVbZS5TRUNPTkRBUllfQ0hVTks9MV09IlNFQ09OREFSWV9DSFVOSyIsZVtlLkFTU0VUPTJdPSJBU1NFVCJ9KShFc3x8KEVzPXt9KSk7ZnVuY3Rpb24gRXUoZSx0LGkpe3Rocm93IG5ldyBFcnJvcihpP2BObyBrbm93biBjb25kaXRpb25zIGZvciAiJHt0fSIgc3BlY2lmaWVyIGluICIke2V9IiBwYWNrYWdlYDpgTWlzc2luZyAiJHt0fSIgc3BlY2lmaWVyIGluICIke2V9IiBwYWNrYWdlYCl9ZnVuY3Rpb24gQm0oZSx0LGkscyl7bGV0IG4scixhPVN1KGUsaSksbz1mdW5jdGlvbihsKXtsZXQgYz1uZXcgU2V0KFsiZGVmYXVsdCIsLi4ubC5jb25kaXRpb25zfHxbXV0pO3JldHVybiBsLnVuc2FmZXx8Yy5hZGQobC5yZXF1aXJlPyJyZXF1aXJlIjoiaW1wb3J0IiksbC51bnNhZmV8fGMuYWRkKGwuYnJvd3Nlcj8iYnJvd3NlciI6Im5vZGUiKSxjfShzfHx7fSksaD10W2FdO2lmKGg9PT12b2lkIDApe2xldCBsLGMscCxtO2ZvcihtIGluIHQpYyYmbS5sZW5ndGg8Yy5sZW5ndGh8fChtW20ubGVuZ3RoLTFdPT09Ii8iJiZhLnN0YXJ0c1dpdGgobSk/KHI9YS5zdWJzdHJpbmcobS5sZW5ndGgpLGM9bSk6bS5sZW5ndGg+MSYmKHA9bS5pbmRleE9mKCIqIiwxKSx+cCYmKGw9UmVnRXhwKCJeIittLnN1YnN0cmluZygwLHApKyIoLiopIittLnN1YnN0cmluZygxK3ApKS5leGVjKGEpLGwmJmxbMV0mJihyPWxbMV0sYz1tKSkpKTtoPXRbY119cmV0dXJuIGh8fEV1KGUsYSksbj1rYShoLG8pLG58fEV1KGUsYSwxKSxyJiZmdW5jdGlvbihsLGMpe2xldCBwLG09MCx5PWwubGVuZ3RoLEU9L1sqXS9nLGc9L1svXSQvO2Zvcig7bTx5O20rKylsW21dPUUudGVzdChwPWxbbV0pP3AucmVwbGFjZShFLGMpOmcudGVzdChwKT9wK2M6cH0obixyKSxufWZ1bmN0aW9uIFN1KGUsdCxpKXtpZihlPT09dHx8dD09PSIuIilyZXR1cm4iLiI7bGV0IHM9ZSsiLyIsbj1zLmxlbmd0aCxyPXQuc2xpY2UoMCxuKT09PXMsYT1yP3Quc2xpY2Uobik6dDtyZXR1cm4gYVswXT09PSIjIj9hOnJ8fCFpP2Euc2xpY2UoMCwyKT09PSIuLyI/YToiLi8iK2E6YX1mdW5jdGlvbiBrYShlLHQsaSl7aWYoZSl7aWYodHlwZW9mIGU9PSJzdHJpbmciKXJldHVybiBpJiZpLmFkZChlKSxbZV07bGV0IHMsbjtpZihBcnJheS5pc0FycmF5KGUpKXtmb3Iobj1pfHxuZXcgU2V0LHM9MDtzPGUubGVuZ3RoO3MrKylrYShlW3NdLHQsbik7aWYoIWkmJm4uc2l6ZSlyZXR1cm5bLi4ubl19ZWxzZSBmb3IocyBpbiBlKWlmKHQuaGFzKHMpKXJldHVybiBrYShlW3NdLHQsaSl9fWZ1bmN0aW9uIHdhKGUsdD17fSl7bGV0IGkscz0wLG49dC5icm93c2VyLHI9dC5maWVsZHN8fFsibW9kdWxlIiwibWFpbiJdLGE9dHlwZW9mIG49PSJzdHJpbmciO2ZvcihuJiYhci5pbmNsdWRlcygiYnJvd3NlciIpJiYoci51bnNoaWZ0KCJicm93c2VyIiksYSYmKG49U3UoZS5uYW1lLG4sITApKSk7czxyLmxlbmd0aDtzKyspaWYoaT1lW3Jbc11dKXtpZih0eXBlb2YgaSE9InN0cmluZyIpe2lmKHR5cGVvZiBpIT0ib2JqZWN0Inx8cltzXSE9ImJyb3dzZXIiKWNvbnRpbnVlO2lmKGEmJihpPWlbbl0saT09bnVsbCkpcmV0dXJuIG59cmV0dXJuIHR5cGVvZiBpPT0ic3RyaW5nIj8iLi8iK2kucmVwbGFjZSgvXlwuP1wvLywiIik6aX19ZnVuY3Rpb24gRm0oZSx0LGkpe2xldCBzLG49ZS5leHBvcnRzO2lmKG4pe2lmKHR5cGVvZiBuPT0ic3RyaW5nIiluPXsiLiI6bn07ZWxzZSBmb3IocyBpbiBuKXtzWzBdIT09Ii4iJiYobj17Ii4iOm59KTticmVha31yZXR1cm4gQm0oZS5uYW1lLG4sdHx8Ii4iLGkpfX12YXIgem09WzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDU3NCwzLDksOSwzNzAsMSw4MSwyLDcxLDEwLDUwLDMsMTIzLDIsNTQsMTQsMzIsMTAsMywxLDExLDMsNDYsMTAsOCwwLDQ2LDksNywyLDM3LDEzLDIsOSw2LDEsNDUsMCwxMywyLDQ5LDEzLDksMywyLDExLDgzLDExLDcsMCwzLDAsMTU4LDExLDYsOSw3LDMsNTYsMSwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw1LDAsODIsMTksMTMsOSwyMTQsNiwzLDgsMjgsMSw4MywxNiwxNiw5LDgyLDEyLDksOSw4NCwxNCw1LDksMjQzLDE0LDE2Niw5LDcxLDUsMiwxLDMsMywyLDAsMiwxLDEzLDksMTIwLDYsMyw2LDQsMCwyOSw5LDQxLDYsMiwzLDksMCwxMCwxMCw0NywxNSw0MDYsNywyLDcsMTcsOSw1NywyMSwyLDEzLDEyMyw1LDQsMCwyLDEsMiw2LDIsMCw5LDksNDksNCwyLDEsMiw0LDksOSwzMzAsMywxMCwxLDIsMCw0OSw2LDQsNCwxNCw5LDUzNTEsMCw3LDE0LDEzODM1LDksODcsOSwzOSw0LDYwLDYsMjYsOSwxMDE0LDAsMiw1NCw4LDMsODIsMCwxMiwxLDE5NjI4LDEsNDcwNiw0NSwzLDIyLDU0Myw0LDQsNSw5LDcsMyw2LDMxLDMsMTQ5LDIsMTQxOCw0OSw1MTMsNTQsNSw0OSw5LDAsMTUsMCwyMyw0LDIsMTQsMTM2MSw2LDIsMTYsMyw2LDIsMSwyLDQsMTAxLDAsMTYxLDYsMTAsOSwzNTcsMCw2MiwxMyw0OTksMTMsOTgzLDYsMTEwLDYsNiw5LDQ3NTksOSw3ODc3MTksMjM5XSxrdT1bMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTQsMjksNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDEzLDEwLDIsMTQsMiw2LDIsMSwyLDEwLDIsMTQsMiw2LDIsMSw2OCwzMTAsMTAsMjEsMTEsNywyNSw1LDIsNDEsMiw4LDcwLDUsMywwLDIsNDMsMiwxLDQsMCwzLDIyLDExLDIyLDEwLDMwLDY2LDE4LDIsMSwxMSwyMSwxMSwyNSw3MSw1NSw3LDEsNjUsMCwxNiwzLDIsMiwyLDI4LDQzLDI4LDQsMjgsMzYsNywyLDI3LDI4LDUzLDExLDIxLDExLDE4LDE0LDE3LDExMSw3Miw1Niw1MCwxNCw1MCwxNCwzNSwzNDksNDEsNywxLDc5LDI4LDExLDAsOSwyMSw0MywxNyw0NywyMCwyOCwyMiwxMyw1Miw1OCwxLDMsMCwxNCw0NCwzMywyNCwyNywzNSwzMCwwLDMsMCw5LDM0LDQsMCwxMyw0NywxNSwzLDIyLDAsMiwwLDM2LDE3LDIsMjQsMjAsMSw2NCw2LDIsMCwyLDMsMiwxNCwyLDksOCw0NiwzOSw3LDMsMSwzLDIxLDIsNiwyLDEsMiw0LDQsMCwxOSwwLDEzLDQsMTU5LDUyLDE5LDMsMjEsMiwzMSw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDE0LDAsNzIsMjYsMzgsNiwxODYsNDMsMTE3LDYzLDMyLDcsMywwLDMsNywyLDEsMiwyMywxNiwwLDIsMCw5NSw3LDMsMzgsMTcsMCwyLDAsMjksMCwxMSwzOSw4LDAsMjIsMCwxMiw0NSwyMCwwLDE5LDcyLDI2NCw4LDIsMzYsMTgsMCw1MCwyOSwxMTMsNiwyLDEsMiwzNywyMiwwLDI2LDUsMiwxLDIsMzEsMTUsMCwzMjgsMTgsMTYsMCwyLDEyLDIsMzMsMTI1LDAsODAsOTIxLDEwMywxMTAsMTgsMTk1LDI2MzcsOTYsMTYsMTA3MSwxOCw1LDQwMjYsNTgyLDg2MzQsNTY4LDgsMzAsMTgsNzgsMTgsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDY4OSw2MywxMjksNzQsNiwwLDY3LDEyLDY1LDEsMiwwLDI5LDYxMzUsOSwxMjM3LDQzLDgsODkzNiwzLDIsNiwyLDEsMiwyOTAsMTYsMCwzMCwyLDMsMCwxNSwzLDksMzk1LDIzMDksMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDE4NDUsMzAsNyw1LDI2Miw2MSwxNDcsNDQsMTEsNiwxNywwLDMyMiwyOSwxOSw0Myw0ODUsMjcsNzU3LDYsMiwzLDIsMSwyLDE0LDIsMTk2LDYwLDY3LDgsMCwxMjA1LDMsMiwyNiwyLDEsMiwwLDMsMCwyLDksMiwzLDIsMCwyLDAsNywwLDUsMCwyLDAsMiwwLDIsMiwyLDEsMiwwLDMsMCwyLDAsMiwwLDIsMCwyLDAsMiwxLDIsMCwzLDMsMiw2LDIsMywyLDMsMiwwLDIsOSwyLDE2LDYsMiwyLDQsMiwxNiw0NDIxLDQyNzE5LDMzLDQxNTMsNywyMjEsMyw1NzYxLDE1LDc0NzIsMTYsNjIxLDI0NjcsNTQxLDE1MDcsNDkzOCw2LDQxOTFdLGptPSLigIzigI3Ct8yALc2vzofSgy3Sh9aRLda91r/XgdeC14TXhdeH2JAt2JrZiy3Zqdmw25Yt25zbny3bpNun26jbqi3brduwLdu53JHcsC3dit6mLd6w34At34nfqy3fs9+94KCWLeCgmeCgmy3goKPgoKUt4KCn4KCpLeCgreChmS3goZvgopgt4KKf4KOKLeCjoeCjoy3gpIPgpLot4KS84KS+LeClj+ClkS3gpZfgpaLgpaPgpaYt4KWv4KaBLeCmg+CmvOCmvi3gp4Tgp4fgp4jgp4st4KeN4KeX4Kei4Kej4KemLeCnr+CnvuCogS3gqIPgqLzgqL4t4KmC4KmH4KmI4KmLLeCpjeCpkeCppi3gqbHgqbXgqoEt4KqD4Kq84Kq+LeCrheCrhy3gq4ngq4st4KuN4Kui4Kuj4KumLeCrr+Crui3gq7/grIEt4KyD4Ky84Ky+LeCthOCth+CtiOCtiy3grY3grZUt4K2X4K2i4K2j4K2mLeCtr+CuguCuvi3gr4Lgr4Yt4K+I4K+KLeCvjeCvl+Cvpi3gr6/gsIAt4LCE4LC84LC+LeCxhOCxhi3gsYjgsYot4LGN4LGV4LGW4LGi4LGj4LGmLeCxr+CygS3gsoPgsrzgsr4t4LOE4LOGLeCziOCzii3gs43gs5Xgs5bgs6Lgs6Pgs6Yt4LOv4LOz4LSALeC0g+C0u+C0vOC0vi3gtYTgtYYt4LWI4LWKLeC1jeC1l+C1ouC1o+C1pi3gta/gtoEt4LaD4LeK4LePLeC3lOC3luC3mC3gt5/gt6Yt4Lev4Ley4Lez4Lix4Li0LeC4uuC5hy3guY7guZAt4LmZ4Lqx4Lq0LeC6vOC7iC3gu47gu5At4LuZ4LyY4LyZ4LygLeC8qeC8teC8t+C8ueC8vuC8v+C9sS3gvoTgvobgvofgvo0t4L6X4L6ZLeC+vOC/huGAqy3hgL7hgYAt4YGJ4YGWLeGBmeGBni3hgaDhgaIt4YGk4YGnLeGBreGBsS3hgbThgoIt4YKN4YKPLeGCneGNnS3hjZ/hjakt4Y2x4ZySLeGcleGcsi3hnLThnZLhnZPhnbLhnbPhnrQt4Z+T4Z+d4Z+gLeGfqeGgiy3hoI3hoI8t4aCZ4aKp4aSgLeGkq+GksC3hpLvhpYYt4aWP4aeQLeGnmuGoly3hqJvhqZUt4ame4amgLeGpvOGpvy3hqonhqpAt4aqZ4aqwLeGqveGqvy3hq47hrIAt4ayE4ay0LeGthOGtkC3hrZnhrast4a2z4a6ALeGuguGuoS3hrq3hrrAt4a654a+mLeGvs+GwpC3hsLfhsYAt4bGJ4bGQLeGxmeGzkC3hs5Lhs5Qt4bOo4bOt4bO04bO3LeGzueG3gC3ht7/igIzigI3igL/igYDigZTig5At4oOc4oOh4oOlLeKDsOKzry3is7Hitb/it6At4re/44CqLeOAr+OCmeOCmuODu+qYoC3qmKnqma/qmbQt6pm96pqe6pqf6puw6pux6qCC6qCG6qCL6qCjLeqgp+qgrOqigOqigeqitC3qo4Xqo5At6qOZ6qOgLeqjseqjvy3qpInqpKYt6qSt6qWHLeqlk+qmgC3qpoPqprMt6qeA6qeQLeqnmeqnpeqnsC3qp7nqqKkt6qi26qmD6qmM6qmN6qmQLeqpmeqpuy3qqb3qqrDqqrIt6qq06qq36qq46qq+6qq/6quB6qurLeqrr+qrteqrtuqvoy3qr6rqr6zqr63qr7At6q+576ye77iALe+4j++4oC3vuK/vuLPvuLTvuY0t77mP77yQLe+8me+8v++9pSIsd3U9IsKqwrXCusOALcOWw5gtw7bDuC3LgcuGLcuRy6Aty6TLrMuuzbAtzbTNts23zbotzb3Nv86GzogtzorOjM6OLc6hzqMtz7XPty3SgdKKLdSv1LEt1ZbVmdWgLdaI15At16rXry3XstigLdmK2a7Zr9mxLduT25Xbpdum267br9u6Ldu827/ckNySLdyv3Y0t3qXesd+KLd+q37Tftd+64KCALeCgleCgmuCgpOCgqOChgC3goZjgoaAt4KGq4KGwLeCih+CiiS3goo7goqAt4KOJ4KSELeCkueCkveClkOClmC3gpaHgpbEt4KaA4KaFLeCmjOCmj+CmkOCmky3gpqjgpqot4Kaw4Kay4Ka2LeCmueCmveCnjuCnnOCnneCnny3gp6Hgp7Dgp7Hgp7zgqIUt4KiK4KiP4KiQ4KiTLeCoqOCoqi3gqLDgqLLgqLPgqLXgqLbgqLjgqLngqZkt4Kmc4Kme4KmyLeCptOCqhS3gqo3gqo8t4KqR4KqTLeCqqOCqqi3gqrDgqrLgqrPgqrUt4Kq54Kq94KuQ4Kug4Kuh4Ku54KyFLeCsjOCsj+CskOCsky3grKjgrKot4Kyw4Kyy4Kyz4Ky1LeCsueCsveCtnOCtneCtny3graHgrbHgroPgroUt4K6K4K6OLeCukOCuki3grpXgrpngrprgrpzgrp7grp/grqPgrqTgrqgt4K6q4K6uLeCuueCvkOCwhS3gsIzgsI4t4LCQ4LCSLeCwqOCwqi3gsLngsL3gsZgt4LGa4LGd4LGg4LGh4LKA4LKFLeCyjOCyji3gspDgspIt4LKo4LKqLeCys+CytS3gsrngsr3gs53gs57gs6Dgs6Hgs7Hgs7LgtIQt4LSM4LSOLeC0kOC0ki3gtLrgtL3gtY7gtZQt4LWW4LWfLeC1oeC1ui3gtb/gtoUt4LaW4LaaLeC2seC2sy3gtrvgtr3gt4At4LeG4LiBLeC4sOC4suC4s+C5gC3guYbguoHguoLguoTguoYt4LqK4LqMLeC6o+C6peC6py3gurDgurLgurPgur3gu4At4LuE4LuG4LucLeC7n+C8gOC9gC3gvYfgvYkt4L2s4L6ILeC+jOGAgC3hgKrhgL/hgZAt4YGV4YGaLeGBneGBoeGBpeGBpuGBri3hgbDhgbUt4YKB4YKO4YKgLeGDheGDh+GDjeGDkC3hg7rhg7wt4YmI4YmKLeGJjeGJkC3hiZbhiZjhiZot4Ymd4YmgLeGKiOGKii3hio3hipAt4Yqw4YqyLeGKteGKuC3hir7hi4Dhi4It4YuF4YuILeGLluGLmC3hjJDhjJIt4YyV4YyYLeGNmuGOgC3hjo/hjqAt4Y+14Y+4LeGPveGQgS3hmazhma8t4Zm/4ZqBLeGamuGaoC3hm6rhm64t4Zu44ZyALeGckeGcny3hnLHhnYAt4Z2R4Z2gLeGdrOGdri3hnbDhnoAt4Z6z4Z+X4Z+c4aCgLeGhuOGigC3hoqjhoqrhorAt4aO14aSALeGknuGlkC3hpa3hpbAt4aW04aaALeGmq+GmsC3hp4nhqIAt4aiW4aigLeGplOGqp+GshS3hrLPhrYUt4a2M4a6DLeGuoOGuruGur+Guui3hr6XhsIAt4bCj4bGNLeGxj+Gxmi3hsb3hsoAt4bKI4bKQLeGyuuGyvS3hsr/hs6kt4bOs4bOuLeGzs+GzteGztuGzuuG0gC3htr/huIAt4byV4byYLeG8neG8oC3hvYXhvYgt4b2N4b2QLeG9l+G9meG9m+G9neG9ny3hvb3hvoAt4b604b62LeG+vOG+vuG/gi3hv4Thv4Yt4b+M4b+QLeG/k+G/li3hv5vhv6At4b+s4b+yLeG/tOG/ti3hv7zigbHigb/igpAt4oKc4oSC4oSH4oSKLeKEk+KEleKEmC3ihJ3ihKTihKbihKjihKot4oS54oS8LeKEv+KFhS3ihYnihY7ihaAt4oaI4rCALeKzpOKzqy3is67is7Lis7PitIAt4rSl4rSn4rSt4rSwLeK1p+K1r+K2gC3itpbitqAt4ram4raoLeK2ruK2sC3itrbitrgt4ra+4reALeK3huK3iC3it47it5At4reW4reYLeK3nuOAhS3jgIfjgKEt44Cp44CxLeOAteOAuC3jgLzjgYEt44KW44KbLeOCn+OCoS3jg7rjg7wt44O/44SFLeOEr+OEsS3jho7jhqAt44a/44ewLeOHv+OQgC3ktr/kuIAt6pKM6pOQLeqTveqUgC3qmIzqmJAt6pif6piq6pir6pmALeqZruqZvy3qmp3qmqAt6puv6pyXLeqcn+qcoi3qnojqnost6p+K6p+Q6p+R6p+T6p+VLeqfmeqfsi3qoIHqoIMt6qCF6qCHLeqgiuqgjC3qoKLqoYAt6qGz6qKCLeqis+qjsi3qo7fqo7vqo73qo77qpIot6qSl6qSwLeqlhuqloC3qpbzqpoQt6qay6qeP6qegLeqnpOqnpi3qp6/qp7ot6qe+6qiALeqoqOqpgC3qqYLqqYQt6qmL6qmgLeqptuqpuuqpvi3qqq/qqrHqqrXqqrbqqrkt6qq96quA6quC6qubLeqrneqroC3qq6rqq7It6qu06qyBLeqshuqsiS3qrI7qrJEt6qyW6qygLeqspuqsqC3qrK7qrLAt6q2a6q2cLeqtqeqtsC3qr6LqsIAt7Z6j7Z6wLe2fhu2fiy3tn7vvpIAt76mt76mwLe+rme+sgC3vrIbvrJMt76yX76yd76yfLe+sqO+sqi3vrLbvrLgt76y876y+762A762B762D762E762GLe+use+vky3vtL3vtZAt77aP77aSLe+3h++3sC3vt7vvubAt77m077m2Le+7vO+8oS3vvLrvvYEt772a772mLe++vu+/gi3vv4fvv4ot77+P77+SLe+/l++/mi3vv5wiLEFhPXszOiJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlIiw1OiJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydCIsNjoiZW51bSIsc3RyaWN0OiJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkIixzdHJpY3RCaW5kOiJldmFsIGFyZ3VtZW50cyJ9LENhPSJicmVhayBjYXNlIGNhdGNoIGNvbnRpbnVlIGRlYnVnZ2VyIGRlZmF1bHQgZG8gZWxzZSBmaW5hbGx5IGZvciBmdW5jdGlvbiBpZiByZXR1cm4gc3dpdGNoIHRocm93IHRyeSB2YXIgd2hpbGUgd2l0aCBudWxsIHRydWUgZmFsc2UgaW5zdGFuY2VvZiB0eXBlb2Ygdm9pZCBkZWxldGUgbmV3IGluIHRoaXMiLFVtPXs1OkNhLCI1bW9kdWxlIjpDYSsiIGV4cG9ydCBpbXBvcnQiLDY6Q2ErIiBjb25zdCBjbGFzcyBleHRlbmRzIGV4cG9ydCBpbXBvcnQgc3VwZXIifSxHbT0vXmluKHN0YW5jZW9mKT8kLyxXbT1uZXcgUmVnRXhwKCJbIit3dSsiXSIpLHFtPW5ldyBSZWdFeHAoIlsiK3d1K2ptKyJdIik7ZnVuY3Rpb24gSWEoZSx0KXtmb3IodmFyIGk9NjU1MzYscz0wO3M8dC5sZW5ndGg7cys9Mil7aWYoaSs9dFtzXSxpPmUpcmV0dXJuITE7aWYoaSs9dFtzKzFdLGk+PWUpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gVHQoZSx0KXtyZXR1cm4gZTw2NT9lPT09MzY6ZTw5MT8hMDplPDk3P2U9PT05NTplPDEyMz8hMDplPD02NTUzNT9lPj0xNzAmJldtLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSk6dD09PSExPyExOklhKGUsa3UpfWZ1bmN0aW9uIERpKGUsdCl7cmV0dXJuIGU8NDg/ZT09PTM2OmU8NTg/ITA6ZTw2NT8hMTplPDkxPyEwOmU8OTc/ZT09PTk1OmU8MTIzPyEwOmU8PTY1NTM1P2U+PTE3MCYmcW0udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKTp0PT09ITE/ITE6SWEoZSxrdSl8fElhKGUsem0pfXZhciByZT1mdW5jdGlvbih0LGkpe2k9PT12b2lkIDAmJihpPXt9KSx0aGlzLmxhYmVsPXQsdGhpcy5rZXl3b3JkPWkua2V5d29yZCx0aGlzLmJlZm9yZUV4cHI9ISFpLmJlZm9yZUV4cHIsdGhpcy5zdGFydHNFeHByPSEhaS5zdGFydHNFeHByLHRoaXMuaXNMb29wPSEhaS5pc0xvb3AsdGhpcy5pc0Fzc2lnbj0hIWkuaXNBc3NpZ24sdGhpcy5wcmVmaXg9ISFpLnByZWZpeCx0aGlzLnBvc3RmaXg9ISFpLnBvc3RmaXgsdGhpcy5iaW5vcD1pLmJpbm9wfHxudWxsLHRoaXMudXBkYXRlQ29udGV4dD1udWxsfTtmdW5jdGlvbiBpdChlLHQpe3JldHVybiBuZXcgcmUoZSx7YmVmb3JlRXhwcjohMCxiaW5vcDp0fSl9dmFyIHN0PXtiZWZvcmVFeHByOiEwfSxqZT17c3RhcnRzRXhwcjohMH0sUGE9e307ZnVuY3Rpb24gc2UoZSx0KXtyZXR1cm4gdD09PXZvaWQgMCYmKHQ9e30pLHQua2V5d29yZD1lLFBhW2VdPW5ldyByZShlLHQpfXZhciBkPXtudW06bmV3IHJlKCJudW0iLGplKSxyZWdleHA6bmV3IHJlKCJyZWdleHAiLGplKSxzdHJpbmc6bmV3IHJlKCJzdHJpbmciLGplKSxuYW1lOm5ldyByZSgibmFtZSIsamUpLHByaXZhdGVJZDpuZXcgcmUoInByaXZhdGVJZCIsamUpLGVvZjpuZXcgcmUoImVvZiIpLGJyYWNrZXRMOm5ldyByZSgiWyIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGJyYWNrZXRSOm5ldyByZSgiXSIpLGJyYWNlTDpuZXcgcmUoInsiLHtiZWZvcmVFeHByOiEwLHN0YXJ0c0V4cHI6ITB9KSxicmFjZVI6bmV3IHJlKCJ9IikscGFyZW5MOm5ldyByZSgiKCIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLHBhcmVuUjpuZXcgcmUoIikiKSxjb21tYTpuZXcgcmUoIiwiLHN0KSxzZW1pOm5ldyByZSgiOyIsc3QpLGNvbG9uOm5ldyByZSgiOiIsc3QpLGRvdDpuZXcgcmUoIi4iKSxxdWVzdGlvbjpuZXcgcmUoIj8iLHN0KSxxdWVzdGlvbkRvdDpuZXcgcmUoIj8uIiksYXJyb3c6bmV3IHJlKCI9PiIsc3QpLHRlbXBsYXRlOm5ldyByZSgidGVtcGxhdGUiKSxpbnZhbGlkVGVtcGxhdGU6bmV3IHJlKCJpbnZhbGlkVGVtcGxhdGUiKSxlbGxpcHNpczpuZXcgcmUoIi4uLiIsc3QpLGJhY2tRdW90ZTpuZXcgcmUoImAiLGplKSxkb2xsYXJCcmFjZUw6bmV3IHJlKCIkeyIse2JlZm9yZUV4cHI6ITAsc3RhcnRzRXhwcjohMH0pLGVxOm5ldyByZSgiPSIse2JlZm9yZUV4cHI6ITAsaXNBc3NpZ246ITB9KSxhc3NpZ246bmV3IHJlKCJfPSIse2JlZm9yZUV4cHI6ITAsaXNBc3NpZ246ITB9KSxpbmNEZWM6bmV3IHJlKCIrKy8tLSIse3ByZWZpeDohMCxwb3N0Zml4OiEwLHN0YXJ0c0V4cHI6ITB9KSxwcmVmaXg6bmV3IHJlKCIhL34iLHtiZWZvcmVFeHByOiEwLHByZWZpeDohMCxzdGFydHNFeHByOiEwfSksbG9naWNhbE9SOml0KCJ8fCIsMSksbG9naWNhbEFORDppdCgiJiYiLDIpLGJpdHdpc2VPUjppdCgifCIsMyksYml0d2lzZVhPUjppdCgiXiIsNCksYml0d2lzZUFORDppdCgiJiIsNSksZXF1YWxpdHk6aXQoIj09LyE9Lz09PS8hPT0iLDYpLHJlbGF0aW9uYWw6aXQoIjwvPi88PS8+PSIsNyksYml0U2hpZnQ6aXQoIjw8Lz4+Lz4+PiIsOCkscGx1c01pbjpuZXcgcmUoIisvLSIse2JlZm9yZUV4cHI6ITAsYmlub3A6OSxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pLG1vZHVsbzppdCgiJSIsMTApLHN0YXI6aXQoIioiLDEwKSxzbGFzaDppdCgiLyIsMTApLHN0YXJzdGFyOm5ldyByZSgiKioiLHtiZWZvcmVFeHByOiEwfSksY29hbGVzY2U6aXQoIj8/IiwxKSxfYnJlYWs6c2UoImJyZWFrIiksX2Nhc2U6c2UoImNhc2UiLHN0KSxfY2F0Y2g6c2UoImNhdGNoIiksX2NvbnRpbnVlOnNlKCJjb250aW51ZSIpLF9kZWJ1Z2dlcjpzZSgiZGVidWdnZXIiKSxfZGVmYXVsdDpzZSgiZGVmYXVsdCIsc3QpLF9kbzpzZSgiZG8iLHtpc0xvb3A6ITAsYmVmb3JlRXhwcjohMH0pLF9lbHNlOnNlKCJlbHNlIixzdCksX2ZpbmFsbHk6c2UoImZpbmFsbHkiKSxfZm9yOnNlKCJmb3IiLHtpc0xvb3A6ITB9KSxfZnVuY3Rpb246c2UoImZ1bmN0aW9uIixqZSksX2lmOnNlKCJpZiIpLF9yZXR1cm46c2UoInJldHVybiIsc3QpLF9zd2l0Y2g6c2UoInN3aXRjaCIpLF90aHJvdzpzZSgidGhyb3ciLHN0KSxfdHJ5OnNlKCJ0cnkiKSxfdmFyOnNlKCJ2YXIiKSxfY29uc3Q6c2UoImNvbnN0IiksX3doaWxlOnNlKCJ3aGlsZSIse2lzTG9vcDohMH0pLF93aXRoOnNlKCJ3aXRoIiksX25ldzpzZSgibmV3Iix7YmVmb3JlRXhwcjohMCxzdGFydHNFeHByOiEwfSksX3RoaXM6c2UoInRoaXMiLGplKSxfc3VwZXI6c2UoInN1cGVyIixqZSksX2NsYXNzOnNlKCJjbGFzcyIsamUpLF9leHRlbmRzOnNlKCJleHRlbmRzIixzdCksX2V4cG9ydDpzZSgiZXhwb3J0IiksX2ltcG9ydDpzZSgiaW1wb3J0IixqZSksX251bGw6c2UoIm51bGwiLGplKSxfdHJ1ZTpzZSgidHJ1ZSIsamUpLF9mYWxzZTpzZSgiZmFsc2UiLGplKSxfaW46c2UoImluIix7YmVmb3JlRXhwcjohMCxiaW5vcDo3fSksX2luc3RhbmNlb2Y6c2UoImluc3RhbmNlb2YiLHtiZWZvcmVFeHByOiEwLGJpbm9wOjd9KSxfdHlwZW9mOnNlKCJ0eXBlb2YiLHtiZWZvcmVFeHByOiEwLHByZWZpeDohMCxzdGFydHNFeHByOiEwfSksX3ZvaWQ6c2UoInZvaWQiLHtiZWZvcmVFeHByOiEwLHByZWZpeDohMCxzdGFydHNFeHByOiEwfSksX2RlbGV0ZTpzZSgiZGVsZXRlIix7YmVmb3JlRXhwcjohMCxwcmVmaXg6ITAsc3RhcnRzRXhwcjohMH0pfSxudD0vXHJcbj98XG58XHUyMDI4fFx1MjAyOS8sSG09bmV3IFJlZ0V4cChudC5zb3VyY2UsImciKTtmdW5jdGlvbiBCaShlKXtyZXR1cm4gZT09PTEwfHxlPT09MTN8fGU9PT04MjMyfHxlPT09ODIzM31mdW5jdGlvbiBBdShlLHQsaSl7aT09PXZvaWQgMCYmKGk9ZS5sZW5ndGgpO2Zvcih2YXIgcz10O3M8aTtzKyspe3ZhciBuPWUuY2hhckNvZGVBdChzKTtpZihCaShuKSlyZXR1cm4gczxpLTEmJm49PT0xMyYmZS5jaGFyQ29kZUF0KHMrMSk9PT0xMD9zKzI6cysxfXJldHVybi0xfXZhciBDdT0vW1x1MTY4MFx1MjAwMC1cdTIwMGFcdTIwMmZcdTIwNWZcdTMwMDBcdWZlZmZdLyxydD0vKD86XHN8XC9cLy4qfFwvXCpbXl0qP1wqXC8pKi9nLEl1PU9iamVjdC5wcm90b3R5cGUsS209SXUuaGFzT3duUHJvcGVydHksUW09SXUudG9TdHJpbmcsU3M9T2JqZWN0Lmhhc093bnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gS20uY2FsbChlLHQpfSxQdT1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm4gUW0uY2FsbChlKT09PSJbb2JqZWN0IEFycmF5XSJ9LF91PU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gUXQoZSl7cmV0dXJuIF91W2VdfHwoX3VbZV09bmV3IFJlZ0V4cCgiXig/OiIrZS5yZXBsYWNlKC8gL2csInwiKSsiKSQiKSl9ZnVuY3Rpb24gWXQoZSl7cmV0dXJuIGU8PTY1NTM1P1N0cmluZy5mcm9tQ2hhckNvZGUoZSk6KGUtPTY1NTM2LFN0cmluZy5mcm9tQ2hhckNvZGUoKGU+PjEwKSs1NTI5NiwoZSYxMDIzKSs1NjMyMCkpfXZhciBZbT0vKD86W1x1RDgwMC1cdURCRkZdKD8hW1x1REMwMC1cdURGRkZdKXwoPzpbXlx1RDgwMC1cdURCRkZdfF4pW1x1REMwMC1cdURGRkZdKS8sa3M9ZnVuY3Rpb24odCxpKXt0aGlzLmxpbmU9dCx0aGlzLmNvbHVtbj1pfTtrcy5wcm90b3R5cGUub2Zmc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcga3ModGhpcy5saW5lLHRoaXMuY29sdW1uK3QpfTt2YXIgJG49ZnVuY3Rpb24odCxpLHMpe3RoaXMuc3RhcnQ9aSx0aGlzLmVuZD1zLHQuc291cmNlRmlsZSE9PW51bGwmJih0aGlzLnNvdXJjZT10LnNvdXJjZUZpbGUpfTtmdW5jdGlvbiBOdShlLHQpe2Zvcih2YXIgaT0xLHM9MDs7KXt2YXIgbj1BdShlLHMsdCk7aWYobjwwKXJldHVybiBuZXcga3MoaSx0LXMpOysraSxzPW59fXZhciBfYT17ZWNtYVZlcnNpb246bnVsbCxzb3VyY2VUeXBlOiJzY3JpcHQiLG9uSW5zZXJ0ZWRTZW1pY29sb246bnVsbCxvblRyYWlsaW5nQ29tbWE6bnVsbCxhbGxvd1Jlc2VydmVkOm51bGwsYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246ITEsYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiExLGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb246bnVsbCxhbGxvd1N1cGVyT3V0c2lkZU1ldGhvZDpudWxsLGFsbG93SGFzaEJhbmc6ITEsY2hlY2tQcml2YXRlRmllbGRzOiEwLGxvY2F0aW9uczohMSxvblRva2VuOm51bGwsb25Db21tZW50Om51bGwscmFuZ2VzOiExLHByb2dyYW06bnVsbCxzb3VyY2VGaWxlOm51bGwsZGlyZWN0U291cmNlRmlsZTpudWxsLHByZXNlcnZlUGFyZW5zOiExfSwkdT0hMTtmdW5jdGlvbiBYbShlKXt2YXIgdD17fTtmb3IodmFyIGkgaW4gX2EpdFtpXT1lJiZTcyhlLGkpP2VbaV06X2FbaV07aWYodC5lY21hVmVyc2lvbj09PSJsYXRlc3QiP3QuZWNtYVZlcnNpb249MWU4OnQuZWNtYVZlcnNpb249PW51bGw/KCEkdSYmdHlwZW9mIGNvbnNvbGU9PSJvYmplY3QiJiZjb25zb2xlLndhcm4mJigkdT0hMCxjb25zb2xlLndhcm4oYFNpbmNlIEFjb3JuIDguMC4wLCBvcHRpb25zLmVjbWFWZXJzaW9uIGlzIHJlcXVpcmVkLgpEZWZhdWx0aW5nIHRvIDIwMjAsIGJ1dCB0aGlzIHdpbGwgc3RvcCB3b3JraW5nIGluIHRoZSBmdXR1cmUuYCkpLHQuZWNtYVZlcnNpb249MTEpOnQuZWNtYVZlcnNpb24+PTIwMTUmJih0LmVjbWFWZXJzaW9uLT0yMDA5KSx0LmFsbG93UmVzZXJ2ZWQ9PW51bGwmJih0LmFsbG93UmVzZXJ2ZWQ9dC5lY21hVmVyc2lvbjw1KSwoIWV8fGUuYWxsb3dIYXNoQmFuZz09bnVsbCkmJih0LmFsbG93SGFzaEJhbmc9dC5lY21hVmVyc2lvbj49MTQpLFB1KHQub25Ub2tlbikpe3ZhciBzPXQub25Ub2tlbjt0Lm9uVG9rZW49ZnVuY3Rpb24obil7cmV0dXJuIHMucHVzaChuKX19cmV0dXJuIFB1KHQub25Db21tZW50KSYmKHQub25Db21tZW50PVptKHQsdC5vbkNvbW1lbnQpKSx0fWZ1bmN0aW9uIFptKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGkscyxuLHIsYSxvKXt2YXIgaD17dHlwZTppPyJCbG9jayI6IkxpbmUiLHZhbHVlOnMsc3RhcnQ6bixlbmQ6cn07ZS5sb2NhdGlvbnMmJihoLmxvYz1uZXcgJG4odGhpcyxhLG8pKSxlLnJhbmdlcyYmKGgucmFuZ2U9W24scl0pLHQucHVzaChoKX19dmFyIHdzPTEsRmk9MixOYT00LEx1PTgsVHU9MTYsUnU9MzIsJGE9NjQsT3U9MTI4LEFzPTI1NixMYT13c3xGaXxBcztmdW5jdGlvbiBUYShlLHQpe3JldHVybiBGaXwoZT9OYTowKXwodD9MdTowKX12YXIgTG49MCxSYT0xLFJ0PTIsVnU9MyxNdT00LER1PTUsUGU9ZnVuY3Rpb24odCxpLHMpe3RoaXMub3B0aW9ucz10PVhtKHQpLHRoaXMuc291cmNlRmlsZT10LnNvdXJjZUZpbGUsdGhpcy5rZXl3b3Jkcz1RdChVbVt0LmVjbWFWZXJzaW9uPj02PzY6dC5zb3VyY2VUeXBlPT09Im1vZHVsZSI/IjVtb2R1bGUiOjVdKTt2YXIgbj0iIjt0LmFsbG93UmVzZXJ2ZWQhPT0hMCYmKG49QWFbdC5lY21hVmVyc2lvbj49Nj82OnQuZWNtYVZlcnNpb249PT01PzU6M10sdC5zb3VyY2VUeXBlPT09Im1vZHVsZSImJihuKz0iIGF3YWl0IikpLHRoaXMucmVzZXJ2ZWRXb3Jkcz1RdChuKTt2YXIgcj0obj9uKyIgIjoiIikrQWEuc3RyaWN0O3RoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdD1RdChyKSx0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kPVF0KHIrIiAiK0FhLnN0cmljdEJpbmQpLHRoaXMuaW5wdXQ9U3RyaW5nKGkpLHRoaXMuY29udGFpbnNFc2M9ITEscz8odGhpcy5wb3M9cyx0aGlzLmxpbmVTdGFydD10aGlzLmlucHV0Lmxhc3RJbmRleE9mKGAKYCxzLTEpKzEsdGhpcy5jdXJMaW5lPXRoaXMuaW5wdXQuc2xpY2UoMCx0aGlzLmxpbmVTdGFydCkuc3BsaXQobnQpLmxlbmd0aCk6KHRoaXMucG9zPXRoaXMubGluZVN0YXJ0PTAsdGhpcy5jdXJMaW5lPTEpLHRoaXMudHlwZT1kLmVvZix0aGlzLnZhbHVlPW51bGwsdGhpcy5zdGFydD10aGlzLmVuZD10aGlzLnBvcyx0aGlzLnN0YXJ0TG9jPXRoaXMuZW5kTG9jPXRoaXMuY3VyUG9zaXRpb24oKSx0aGlzLmxhc3RUb2tFbmRMb2M9dGhpcy5sYXN0VG9rU3RhcnRMb2M9bnVsbCx0aGlzLmxhc3RUb2tTdGFydD10aGlzLmxhc3RUb2tFbmQ9dGhpcy5wb3MsdGhpcy5jb250ZXh0PXRoaXMuaW5pdGlhbENvbnRleHQoKSx0aGlzLmV4cHJBbGxvd2VkPSEwLHRoaXMuaW5Nb2R1bGU9dC5zb3VyY2VUeXBlPT09Im1vZHVsZSIsdGhpcy5zdHJpY3Q9dGhpcy5pbk1vZHVsZXx8dGhpcy5zdHJpY3REaXJlY3RpdmUodGhpcy5wb3MpLHRoaXMucG90ZW50aWFsQXJyb3dBdD0tMSx0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdD0hMSx0aGlzLnlpZWxkUG9zPXRoaXMuYXdhaXRQb3M9dGhpcy5hd2FpdElkZW50UG9zPTAsdGhpcy5sYWJlbHM9W10sdGhpcy51bmRlZmluZWRFeHBvcnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5wb3M9PT0wJiZ0LmFsbG93SGFzaEJhbmcmJnRoaXMuaW5wdXQuc2xpY2UoMCwyKT09PSIjISImJnRoaXMuc2tpcExpbmVDb21tZW50KDIpLHRoaXMuc2NvcGVTdGFjaz1bXSx0aGlzLmVudGVyU2NvcGUod3MpLHRoaXMucmVnZXhwU3RhdGU9bnVsbCx0aGlzLnByaXZhdGVOYW1lU3RhY2s9W119LGt0PXtpbkZ1bmN0aW9uOntjb25maWd1cmFibGU6ITB9LGluR2VuZXJhdG9yOntjb25maWd1cmFibGU6ITB9LGluQXN5bmM6e2NvbmZpZ3VyYWJsZTohMH0sY2FuQXdhaXQ6e2NvbmZpZ3VyYWJsZTohMH0sYWxsb3dTdXBlcjp7Y29uZmlndXJhYmxlOiEwfSxhbGxvd0RpcmVjdFN1cGVyOntjb25maWd1cmFibGU6ITB9LHRyZWF0RnVuY3Rpb25zQXNWYXI6e2NvbmZpZ3VyYWJsZTohMH0sYWxsb3dOZXdEb3RUYXJnZXQ6e2NvbmZpZ3VyYWJsZTohMH0saW5DbGFzc1N0YXRpY0Jsb2NrOntjb25maWd1cmFibGU6ITB9fTtQZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9wdGlvbnMucHJvZ3JhbXx8dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0VG9rZW4oKSx0aGlzLnBhcnNlVG9wTGV2ZWwodCl9LGt0LmluRnVuY3Rpb24uZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMuY3VycmVudFZhclNjb3BlKCkuZmxhZ3MmRmkpPjB9LGt0LmluR2VuZXJhdG9yLmdldD1mdW5jdGlvbigpe3JldHVybih0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzJkx1KT4wJiYhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0fSxrdC5pbkFzeW5jLmdldD1mdW5jdGlvbigpe3JldHVybih0aGlzLmN1cnJlbnRWYXJTY29wZSgpLmZsYWdzJk5hKT4wJiYhdGhpcy5jdXJyZW50VmFyU2NvcGUoKS5pbkNsYXNzRmllbGRJbml0fSxrdC5jYW5Bd2FpdC5nZXQ9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xO2U+PTA7ZS0tKXt2YXIgdD10aGlzLnNjb3BlU3RhY2tbZV07aWYodC5pbkNsYXNzRmllbGRJbml0fHx0LmZsYWdzJkFzKXJldHVybiExO2lmKHQuZmxhZ3MmRmkpcmV0dXJuKHQuZmxhZ3MmTmEpPjB9cmV0dXJuIHRoaXMuaW5Nb2R1bGUmJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTN8fHRoaXMub3B0aW9ucy5hbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9ufSxrdC5hbGxvd1N1cGVyLmdldD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY3VycmVudFRoaXNTY29wZSgpLHQ9ZS5mbGFncyxpPWUuaW5DbGFzc0ZpZWxkSW5pdDtyZXR1cm4odCYkYSk+MHx8aXx8dGhpcy5vcHRpb25zLmFsbG93U3VwZXJPdXRzaWRlTWV0aG9kfSxrdC5hbGxvd0RpcmVjdFN1cGVyLmdldD1mdW5jdGlvbigpe3JldHVybih0aGlzLmN1cnJlbnRUaGlzU2NvcGUoKS5mbGFncyZPdSk+MH0sa3QudHJlYXRGdW5jdGlvbnNBc1Zhci5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZSh0aGlzLmN1cnJlbnRTY29wZSgpKX0sa3QuYWxsb3dOZXdEb3RUYXJnZXQuZ2V0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5jdXJyZW50VGhpc1Njb3BlKCksdD1lLmZsYWdzLGk9ZS5pbkNsYXNzRmllbGRJbml0O3JldHVybih0JihGaXxBcykpPjB8fGl9LGt0LmluQ2xhc3NTdGF0aWNCbG9jay5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5jdXJyZW50VmFyU2NvcGUoKS5mbGFncyZBcyk+MH0sUGUuZXh0ZW5kPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGk9YXJndW1lbnRzLmxlbmd0aDtpLS07KXRbaV09YXJndW1lbnRzW2ldO2Zvcih2YXIgcz10aGlzLG49MDtuPHQubGVuZ3RoO24rKylzPXRbbl0ocyk7cmV0dXJuIHN9LFBlLnBhcnNlPWZ1bmN0aW9uKHQsaSl7cmV0dXJuIG5ldyB0aGlzKGksdCkucGFyc2UoKX0sUGUucGFyc2VFeHByZXNzaW9uQXQ9ZnVuY3Rpb24odCxpLHMpe3ZhciBuPW5ldyB0aGlzKHMsdCxpKTtyZXR1cm4gbi5uZXh0VG9rZW4oKSxuLnBhcnNlRXhwcmVzc2lvbigpfSxQZS50b2tlbml6ZXI9ZnVuY3Rpb24odCxpKXtyZXR1cm4gbmV3IHRoaXMoaSx0KX0sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUGUucHJvdG90eXBlLGt0KTt2YXIgVmU9UGUucHJvdG90eXBlLEptPS9eKD86JygoPzpcXC58W14nXFxdKSo/KSd8IigoPzpcXC58W14iXFxdKSo/KSIpLztWZS5zdHJpY3REaXJlY3RpdmU9ZnVuY3Rpb24oZSl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDUpcmV0dXJuITE7Zm9yKDs7KXtydC5sYXN0SW5kZXg9ZSxlKz1ydC5leGVjKHRoaXMuaW5wdXQpWzBdLmxlbmd0aDt2YXIgdD1KbS5leGVjKHRoaXMuaW5wdXQuc2xpY2UoZSkpO2lmKCF0KXJldHVybiExO2lmKCh0WzFdfHx0WzJdKT09PSJ1c2Ugc3RyaWN0Iil7cnQubGFzdEluZGV4PWUrdFswXS5sZW5ndGg7dmFyIGk9cnQuZXhlYyh0aGlzLmlucHV0KSxzPWkuaW5kZXgraVswXS5sZW5ndGgsbj10aGlzLmlucHV0LmNoYXJBdChzKTtyZXR1cm4gbj09PSI7Inx8bj09PSJ9Inx8bnQudGVzdChpWzBdKSYmISgvWyhgLlsrXC0vKiU8Pj0sP14mXS8udGVzdChuKXx8bj09PSIhIiYmdGhpcy5pbnB1dC5jaGFyQXQocysxKT09PSI9Iil9ZSs9dFswXS5sZW5ndGgscnQubGFzdEluZGV4PWUsZSs9cnQuZXhlYyh0aGlzLmlucHV0KVswXS5sZW5ndGgsdGhpcy5pbnB1dFtlXT09PSI7IiYmZSsrfX0sVmUuZWF0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnR5cGU9PT1lPyh0aGlzLm5leHQoKSwhMCk6ITF9LFZlLmlzQ29udGV4dHVhbD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy50eXBlPT09ZC5uYW1lJiZ0aGlzLnZhbHVlPT09ZSYmIXRoaXMuY29udGFpbnNFc2N9LFZlLmVhdENvbnRleHR1YWw9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKGUpPyh0aGlzLm5leHQoKSwhMCk6ITF9LFZlLmV4cGVjdENvbnRleHR1YWw9ZnVuY3Rpb24oZSl7dGhpcy5lYXRDb250ZXh0dWFsKGUpfHx0aGlzLnVuZXhwZWN0ZWQoKX0sVmUuY2FuSW5zZXJ0U2VtaWNvbG9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZT09PWQuZW9mfHx0aGlzLnR5cGU9PT1kLmJyYWNlUnx8bnQudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCx0aGlzLnN0YXJ0KSl9LFZlLmluc2VydFNlbWljb2xvbj1mdW5jdGlvbigpe2lmKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpcmV0dXJuIHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uJiZ0aGlzLm9wdGlvbnMub25JbnNlcnRlZFNlbWljb2xvbih0aGlzLmxhc3RUb2tFbmQsdGhpcy5sYXN0VG9rRW5kTG9jKSwhMH0sVmUuc2VtaWNvbG9uPWZ1bmN0aW9uKCl7IXRoaXMuZWF0KGQuc2VtaSkmJiF0aGlzLmluc2VydFNlbWljb2xvbigpJiZ0aGlzLnVuZXhwZWN0ZWQoKX0sVmUuYWZ0ZXJUcmFpbGluZ0NvbW1hPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy50eXBlPT09ZSlyZXR1cm4gdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSYmdGhpcy5vcHRpb25zLm9uVHJhaWxpbmdDb21tYSh0aGlzLmxhc3RUb2tTdGFydCx0aGlzLmxhc3RUb2tTdGFydExvYyksdHx8dGhpcy5uZXh0KCksITB9LFZlLmV4cGVjdD1mdW5jdGlvbihlKXt0aGlzLmVhdChlKXx8dGhpcy51bmV4cGVjdGVkKCl9LFZlLnVuZXhwZWN0ZWQ9ZnVuY3Rpb24oZSl7dGhpcy5yYWlzZShlPz90aGlzLnN0YXJ0LCJVbmV4cGVjdGVkIHRva2VuIil9O3ZhciBUbj1mdW5jdGlvbigpe3RoaXMuc2hvcnRoYW5kQXNzaWduPXRoaXMudHJhaWxpbmdDb21tYT10aGlzLnBhcmVudGhlc2l6ZWRBc3NpZ249dGhpcy5wYXJlbnRoZXNpemVkQmluZD10aGlzLmRvdWJsZVByb3RvPS0xfTtWZS5jaGVja1BhdHRlcm5FcnJvcnM9ZnVuY3Rpb24oZSx0KXtpZihlKXtlLnRyYWlsaW5nQ29tbWE+LTEmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnRyYWlsaW5nQ29tbWEsIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudCIpO3ZhciBpPXQ/ZS5wYXJlbnRoZXNpemVkQXNzaWduOmUucGFyZW50aGVzaXplZEJpbmQ7aT4tMSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGksdD8iQXNzaWduaW5nIHRvIHJ2YWx1ZSI6IlBhcmVudGhlc2l6ZWQgcGF0dGVybiIpfX0sVmUuY2hlY2tFeHByZXNzaW9uRXJyb3JzPWZ1bmN0aW9uKGUsdCl7aWYoIWUpcmV0dXJuITE7dmFyIGk9ZS5zaG9ydGhhbmRBc3NpZ24scz1lLmRvdWJsZVByb3RvO2lmKCF0KXJldHVybiBpPj0wfHxzPj0wO2k+PTAmJnRoaXMucmFpc2UoaSwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnMiKSxzPj0wJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUocywiUmVkZWZpbml0aW9uIG9mIF9fcHJvdG9fXyBwcm9wZXJ0eSIpfSxWZS5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXM9ZnVuY3Rpb24oKXt0aGlzLnlpZWxkUG9zJiYoIXRoaXMuYXdhaXRQb3N8fHRoaXMueWllbGRQb3M8dGhpcy5hd2FpdFBvcykmJnRoaXMucmFpc2UodGhpcy55aWVsZFBvcywiWWllbGQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgYSBkZWZhdWx0IHZhbHVlIiksdGhpcy5hd2FpdFBvcyYmdGhpcy5yYWlzZSh0aGlzLmF3YWl0UG9zLCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWUiKX0sVmUuaXNTaW1wbGVBc3NpZ25UYXJnZXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudHlwZT09PSJQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiI/dGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChlLmV4cHJlc3Npb24pOmUudHlwZT09PSJJZGVudGlmaWVyInx8ZS50eXBlPT09Ik1lbWJlckV4cHJlc3Npb24ifTt2YXIgej1QZS5wcm90b3R5cGU7ei5wYXJzZVRvcExldmVsPWZ1bmN0aW9uKGUpe3ZhciB0PU9iamVjdC5jcmVhdGUobnVsbCk7Zm9yKGUuYm9keXx8KGUuYm9keT1bXSk7dGhpcy50eXBlIT09ZC5lb2Y7KXt2YXIgaT10aGlzLnBhcnNlU3RhdGVtZW50KG51bGwsITAsdCk7ZS5ib2R5LnB1c2goaSl9aWYodGhpcy5pbk1vZHVsZSlmb3IodmFyIHM9MCxuPU9iamVjdC5rZXlzKHRoaXMudW5kZWZpbmVkRXhwb3J0cyk7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnVuZGVmaW5lZEV4cG9ydHNbcl0uc3RhcnQsIkV4cG9ydCAnIityKyInIGlzIG5vdCBkZWZpbmVkIil9cmV0dXJuIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShlLmJvZHkpLHRoaXMubmV4dCgpLGUuc291cmNlVHlwZT10aGlzLm9wdGlvbnMuc291cmNlVHlwZSx0aGlzLmZpbmlzaE5vZGUoZSwiUHJvZ3JhbSIpfTt2YXIgT2E9e2tpbmQ6Imxvb3AifSxlZz17a2luZDoic3dpdGNoIn07ei5pc0xldD1mdW5jdGlvbihlKXtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248Nnx8IXRoaXMuaXNDb250ZXh0dWFsKCJsZXQiKSlyZXR1cm4hMTtydC5sYXN0SW5kZXg9dGhpcy5wb3M7dmFyIHQ9cnQuZXhlYyh0aGlzLmlucHV0KSxpPXRoaXMucG9zK3RbMF0ubGVuZ3RoLHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KGkpO2lmKHM9PT05MXx8cz09PTkyKXJldHVybiEwO2lmKGUpcmV0dXJuITE7aWYocz09PTEyM3x8cz41NTI5NSYmczw1NjMyMClyZXR1cm4hMDtpZihUdChzLCEwKSl7Zm9yKHZhciBuPWkrMTtEaShzPXRoaXMuaW5wdXQuY2hhckNvZGVBdChuKSwhMCk7KSsrbjtpZihzPT09OTJ8fHM+NTUyOTUmJnM8NTYzMjApcmV0dXJuITA7dmFyIHI9dGhpcy5pbnB1dC5zbGljZShpLG4pO2lmKCFHbS50ZXN0KHIpKXJldHVybiEwfXJldHVybiExfSx6LmlzQXN5bmNGdW5jdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjw4fHwhdGhpcy5pc0NvbnRleHR1YWwoImFzeW5jIikpcmV0dXJuITE7cnQubGFzdEluZGV4PXRoaXMucG9zO3ZhciBlPXJ0LmV4ZWModGhpcy5pbnB1dCksdD10aGlzLnBvcytlWzBdLmxlbmd0aCxpO3JldHVybiFudC50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsdCkpJiZ0aGlzLmlucHV0LnNsaWNlKHQsdCs4KT09PSJmdW5jdGlvbiImJih0Kzg9PT10aGlzLmlucHV0Lmxlbmd0aHx8IShEaShpPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0KzgpKXx8aT41NTI5NSYmaTw1NjMyMCkpfSx6LnBhcnNlU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzLnR5cGUsbj10aGlzLnN0YXJ0Tm9kZSgpLHI7c3dpdGNoKHRoaXMuaXNMZXQoZSkmJihzPWQuX3ZhcixyPSJsZXQiKSxzKXtjYXNlIGQuX2JyZWFrOmNhc2UgZC5fY29udGludWU6cmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG4scy5rZXl3b3JkKTtjYXNlIGQuX2RlYnVnZ2VyOnJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobik7Y2FzZSBkLl9kbzpyZXR1cm4gdGhpcy5wYXJzZURvU3RhdGVtZW50KG4pO2Nhc2UgZC5fZm9yOnJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG4pO2Nhc2UgZC5fZnVuY3Rpb246cmV0dXJuIGUmJih0aGlzLnN0cmljdHx8ZSE9PSJpZiImJmUhPT0ibGFiZWwiKSYmdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiZ0aGlzLnVuZXhwZWN0ZWQoKSx0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobiwhMSwhZSk7Y2FzZSBkLl9jbGFzczpyZXR1cm4gZSYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUNsYXNzKG4sITApO2Nhc2UgZC5faWY6cmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChuKTtjYXNlIGQuX3JldHVybjpyZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChuKTtjYXNlIGQuX3N3aXRjaDpyZXR1cm4gdGhpcy5wYXJzZVN3aXRjaFN0YXRlbWVudChuKTtjYXNlIGQuX3Rocm93OnJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobik7Y2FzZSBkLl90cnk6cmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobik7Y2FzZSBkLl9jb25zdDpjYXNlIGQuX3ZhcjpyZXR1cm4gcj1yfHx0aGlzLnZhbHVlLGUmJnIhPT0idmFyIiYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZVZhclN0YXRlbWVudChuLHIpO2Nhc2UgZC5fd2hpbGU6cmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChuKTtjYXNlIGQuX3dpdGg6cmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG4pO2Nhc2UgZC5icmFjZUw6cmV0dXJuIHRoaXMucGFyc2VCbG9jayghMCxuKTtjYXNlIGQuc2VtaTpyZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG4pO2Nhc2UgZC5fZXhwb3J0OmNhc2UgZC5faW1wb3J0OmlmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj4xMCYmcz09PWQuX2ltcG9ydCl7cnQubGFzdEluZGV4PXRoaXMucG9zO3ZhciBhPXJ0LmV4ZWModGhpcy5pbnB1dCksbz10aGlzLnBvcythWzBdLmxlbmd0aCxoPXRoaXMuaW5wdXQuY2hhckNvZGVBdChvKTtpZihoPT09NDB8fGg9PT00NilyZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobix0aGlzLnBhcnNlRXhwcmVzc2lvbigpKX1yZXR1cm4gdGhpcy5vcHRpb25zLmFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZXx8KHR8fHRoaXMucmFpc2UodGhpcy5zdGFydCwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBvbmx5IGFwcGVhciBhdCB0aGUgdG9wIGxldmVsIiksdGhpcy5pbk1vZHVsZXx8dGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IG1vZHVsZSciKSkscz09PWQuX2ltcG9ydD90aGlzLnBhcnNlSW1wb3J0KG4pOnRoaXMucGFyc2VFeHBvcnQobixpKTtkZWZhdWx0OmlmKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpcmV0dXJuIGUmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMubmV4dCgpLHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChuLCEwLCFlKTt2YXIgbD10aGlzLnZhbHVlLGM9dGhpcy5wYXJzZUV4cHJlc3Npb24oKTtyZXR1cm4gcz09PWQubmFtZSYmYy50eXBlPT09IklkZW50aWZpZXIiJiZ0aGlzLmVhdChkLmNvbG9uKT90aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChuLGwsYyxlKTp0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChuLGMpfX0sei5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSx0KXt2YXIgaT10PT09ImJyZWFrIjt0aGlzLm5leHQoKSx0aGlzLmVhdChkLnNlbWkpfHx0aGlzLmluc2VydFNlbWljb2xvbigpP2UubGFiZWw9bnVsbDp0aGlzLnR5cGUhPT1kLm5hbWU/dGhpcy51bmV4cGVjdGVkKCk6KGUubGFiZWw9dGhpcy5wYXJzZUlkZW50KCksdGhpcy5zZW1pY29sb24oKSk7Zm9yKHZhciBzPTA7czx0aGlzLmxhYmVscy5sZW5ndGg7KytzKXt2YXIgbj10aGlzLmxhYmVsc1tzXTtpZigoZS5sYWJlbD09bnVsbHx8bi5uYW1lPT09ZS5sYWJlbC5uYW1lKSYmKG4ua2luZCE9bnVsbCYmKGl8fG4ua2luZD09PSJsb29wIil8fGUubGFiZWwmJmkpKWJyZWFrfXJldHVybiBzPT09dGhpcy5sYWJlbHMubGVuZ3RoJiZ0aGlzLnJhaXNlKGUuc3RhcnQsIlVuc3ludGFjdGljICIrdCksdGhpcy5maW5pc2hOb2RlKGUsaT8iQnJlYWtTdGF0ZW1lbnQiOiJDb250aW51ZVN0YXRlbWVudCIpfSx6LnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIkRlYnVnZ2VyU3RhdGVtZW50Iil9LHoucGFyc2VEb1N0YXRlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5sYWJlbHMucHVzaChPYSksZS5ib2R5PXRoaXMucGFyc2VTdGF0ZW1lbnQoImRvIiksdGhpcy5sYWJlbHMucG9wKCksdGhpcy5leHBlY3QoZC5fd2hpbGUpLGUudGVzdD10aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCksdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02P3RoaXMuZWF0KGQuc2VtaSk6dGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUoZSwiRG9XaGlsZVN0YXRlbWVudCIpfSx6LnBhcnNlRm9yU3RhdGVtZW50PWZ1bmN0aW9uKGUpe3RoaXMubmV4dCgpO3ZhciB0PXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmdGhpcy5jYW5Bd2FpdCYmdGhpcy5lYXRDb250ZXh0dWFsKCJhd2FpdCIpP3RoaXMubGFzdFRva1N0YXJ0Oi0xO2lmKHRoaXMubGFiZWxzLnB1c2goT2EpLHRoaXMuZW50ZXJTY29wZSgwKSx0aGlzLmV4cGVjdChkLnBhcmVuTCksdGhpcy50eXBlPT09ZC5zZW1pKXJldHVybiB0Pi0xJiZ0aGlzLnVuZXhwZWN0ZWQodCksdGhpcy5wYXJzZUZvcihlLG51bGwpO3ZhciBpPXRoaXMuaXNMZXQoKTtpZih0aGlzLnR5cGU9PT1kLl92YXJ8fHRoaXMudHlwZT09PWQuX2NvbnN0fHxpKXt2YXIgcz10aGlzLnN0YXJ0Tm9kZSgpLG49aT8ibGV0Ijp0aGlzLnZhbHVlO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnBhcnNlVmFyKHMsITAsbiksdGhpcy5maW5pc2hOb2RlKHMsIlZhcmlhYmxlRGVjbGFyYXRpb24iKSwodGhpcy50eXBlPT09ZC5faW58fHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmdGhpcy5pc0NvbnRleHR1YWwoIm9mIikpJiZzLmRlY2xhcmF0aW9ucy5sZW5ndGg9PT0xPyh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJih0aGlzLnR5cGU9PT1kLl9pbj90Pi0xJiZ0aGlzLnVuZXhwZWN0ZWQodCk6ZS5hd2FpdD10Pi0xKSx0aGlzLnBhcnNlRm9ySW4oZSxzKSk6KHQ+LTEmJnRoaXMudW5leHBlY3RlZCh0KSx0aGlzLnBhcnNlRm9yKGUscykpfXZhciByPXRoaXMuaXNDb250ZXh0dWFsKCJsZXQiKSxhPSExLG89bmV3IFRuLGg9dGhpcy5wYXJzZUV4cHJlc3Npb24odD4tMT8iYXdhaXQiOiEwLG8pO3JldHVybiB0aGlzLnR5cGU9PT1kLl9pbnx8KGE9dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiZ0aGlzLmlzQ29udGV4dHVhbCgib2YiKSk/KHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmKHRoaXMudHlwZT09PWQuX2luP3Q+LTEmJnRoaXMudW5leHBlY3RlZCh0KTplLmF3YWl0PXQ+LTEpLHImJmEmJnRoaXMucmFpc2UoaC5zdGFydCwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLiIpLHRoaXMudG9Bc3NpZ25hYmxlKGgsITEsbyksdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGgpLHRoaXMucGFyc2VGb3JJbihlLGgpKToodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMobywhMCksdD4tMSYmdGhpcy51bmV4cGVjdGVkKHQpLHRoaXMucGFyc2VGb3IoZSxoKSl9LHoucGFyc2VGdW5jdGlvblN0YXRlbWVudD1mdW5jdGlvbihlLHQsaSl7cmV0dXJuIHRoaXMubmV4dCgpLHRoaXMucGFyc2VGdW5jdGlvbihlLENzfChpPzA6VmEpLCExLHQpfSx6LnBhcnNlSWZTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLGUudGVzdD10aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCksZS5jb25zZXF1ZW50PXRoaXMucGFyc2VTdGF0ZW1lbnQoImlmIiksZS5hbHRlcm5hdGU9dGhpcy5lYXQoZC5fZWxzZSk/dGhpcy5wYXJzZVN0YXRlbWVudCgiaWYiKTpudWxsLHRoaXMuZmluaXNoTm9kZShlLCJJZlN0YXRlbWVudCIpfSx6LnBhcnNlUmV0dXJuU3RhdGVtZW50PWZ1bmN0aW9uKGUpe3JldHVybiF0aGlzLmluRnVuY3Rpb24mJiF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24mJnRoaXMucmFpc2UodGhpcy5zdGFydCwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvbiIpLHRoaXMubmV4dCgpLHRoaXMuZWF0KGQuc2VtaSl8fHRoaXMuaW5zZXJ0U2VtaWNvbG9uKCk/ZS5hcmd1bWVudD1udWxsOihlLmFyZ3VtZW50PXRoaXMucGFyc2VFeHByZXNzaW9uKCksdGhpcy5zZW1pY29sb24oKSksdGhpcy5maW5pc2hOb2RlKGUsIlJldHVyblN0YXRlbWVudCIpfSx6LnBhcnNlU3dpdGNoU3RhdGVtZW50PWZ1bmN0aW9uKGUpe3RoaXMubmV4dCgpLGUuZGlzY3JpbWluYW50PXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKSxlLmNhc2VzPVtdLHRoaXMuZXhwZWN0KGQuYnJhY2VMKSx0aGlzLmxhYmVscy5wdXNoKGVnKSx0aGlzLmVudGVyU2NvcGUoMCk7Zm9yKHZhciB0LGk9ITE7dGhpcy50eXBlIT09ZC5icmFjZVI7KWlmKHRoaXMudHlwZT09PWQuX2Nhc2V8fHRoaXMudHlwZT09PWQuX2RlZmF1bHQpe3ZhciBzPXRoaXMudHlwZT09PWQuX2Nhc2U7dCYmdGhpcy5maW5pc2hOb2RlKHQsIlN3aXRjaENhc2UiKSxlLmNhc2VzLnB1c2godD10aGlzLnN0YXJ0Tm9kZSgpKSx0LmNvbnNlcXVlbnQ9W10sdGhpcy5uZXh0KCkscz90LnRlc3Q9dGhpcy5wYXJzZUV4cHJlc3Npb24oKTooaSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMubGFzdFRva1N0YXJ0LCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXMiKSxpPSEwLHQudGVzdD1udWxsKSx0aGlzLmV4cGVjdChkLmNvbG9uKX1lbHNlIHR8fHRoaXMudW5leHBlY3RlZCgpLHQuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCkpO3JldHVybiB0aGlzLmV4aXRTY29wZSgpLHQmJnRoaXMuZmluaXNoTm9kZSh0LCJTd2l0Y2hDYXNlIiksdGhpcy5uZXh0KCksdGhpcy5sYWJlbHMucG9wKCksdGhpcy5maW5pc2hOb2RlKGUsIlN3aXRjaFN0YXRlbWVudCIpfSx6LnBhcnNlVGhyb3dTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubmV4dCgpLG50LnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsdGhpcy5zdGFydCkpJiZ0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwiSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93IiksZS5hcmd1bWVudD10aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuc2VtaWNvbG9uKCksdGhpcy5maW5pc2hOb2RlKGUsIlRocm93U3RhdGVtZW50Iil9O3ZhciB0Zz1bXTt6LnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbT1mdW5jdGlvbigpe3ZhciBlPXRoaXMucGFyc2VCaW5kaW5nQXRvbSgpLHQ9ZS50eXBlPT09IklkZW50aWZpZXIiO3JldHVybiB0aGlzLmVudGVyU2NvcGUodD9SdTowKSx0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZSx0P011OlJ0KSx0aGlzLmV4cGVjdChkLnBhcmVuUiksZX0sei5wYXJzZVRyeVN0YXRlbWVudD1mdW5jdGlvbihlKXtpZih0aGlzLm5leHQoKSxlLmJsb2NrPXRoaXMucGFyc2VCbG9jaygpLGUuaGFuZGxlcj1udWxsLHRoaXMudHlwZT09PWQuX2NhdGNoKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3RoaXMubmV4dCgpLHRoaXMuZWF0KGQucGFyZW5MKT90LnBhcmFtPXRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk6KHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjwxMCYmdGhpcy51bmV4cGVjdGVkKCksdC5wYXJhbT1udWxsLHRoaXMuZW50ZXJTY29wZSgwKSksdC5ib2R5PXRoaXMucGFyc2VCbG9jayghMSksdGhpcy5leGl0U2NvcGUoKSxlLmhhbmRsZXI9dGhpcy5maW5pc2hOb2RlKHQsIkNhdGNoQ2xhdXNlIil9cmV0dXJuIGUuZmluYWxpemVyPXRoaXMuZWF0KGQuX2ZpbmFsbHkpP3RoaXMucGFyc2VCbG9jaygpOm51bGwsIWUuaGFuZGxlciYmIWUuZmluYWxpemVyJiZ0aGlzLnJhaXNlKGUuc3RhcnQsIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2UiKSx0aGlzLmZpbmlzaE5vZGUoZSwiVHJ5U3RhdGVtZW50Iil9LHoucGFyc2VWYXJTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSx0LGkpe3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnBhcnNlVmFyKGUsITEsdCxpKSx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLCJWYXJpYWJsZURlY2xhcmF0aW9uIil9LHoucGFyc2VXaGlsZVN0YXRlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksZS50ZXN0PXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKSx0aGlzLmxhYmVscy5wdXNoKE9hKSxlLmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudCgid2hpbGUiKSx0aGlzLmxhYmVscy5wb3AoKSx0aGlzLmZpbmlzaE5vZGUoZSwiV2hpbGVTdGF0ZW1lbnQiKX0sei5wYXJzZVdpdGhTdGF0ZW1lbnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc3RyaWN0JiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIid3aXRoJyBpbiBzdHJpY3QgbW9kZSIpLHRoaXMubmV4dCgpLGUub2JqZWN0PXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKSxlLmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudCgid2l0aCIpLHRoaXMuZmluaXNoTm9kZShlLCJXaXRoU3RhdGVtZW50Iil9LHoucGFyc2VFbXB0eVN0YXRlbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKGUsIkVtcHR5U3RhdGVtZW50Iil9LHoucGFyc2VMYWJlbGVkU3RhdGVtZW50PWZ1bmN0aW9uKGUsdCxpLHMpe2Zvcih2YXIgbj0wLHI9dGhpcy5sYWJlbHM7bjxyLmxlbmd0aDtuKz0xKXt2YXIgYT1yW25dO2EubmFtZT09PXQmJnRoaXMucmFpc2UoaS5zdGFydCwiTGFiZWwgJyIrdCsiJyBpcyBhbHJlYWR5IGRlY2xhcmVkIil9Zm9yKHZhciBvPXRoaXMudHlwZS5pc0xvb3A/Imxvb3AiOnRoaXMudHlwZT09PWQuX3N3aXRjaD8ic3dpdGNoIjpudWxsLGg9dGhpcy5sYWJlbHMubGVuZ3RoLTE7aD49MDtoLS0pe3ZhciBsPXRoaXMubGFiZWxzW2hdO2lmKGwuc3RhdGVtZW50U3RhcnQ9PT1lLnN0YXJ0KWwuc3RhdGVtZW50U3RhcnQ9dGhpcy5zdGFydCxsLmtpbmQ9bztlbHNlIGJyZWFrfXJldHVybiB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOnQsa2luZDpvLHN0YXRlbWVudFN0YXJ0OnRoaXMuc3RhcnR9KSxlLmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudChzP3MuaW5kZXhPZigibGFiZWwiKT09PS0xP3MrImxhYmVsIjpzOiJsYWJlbCIpLHRoaXMubGFiZWxzLnBvcCgpLGUubGFiZWw9aSx0aGlzLmZpbmlzaE5vZGUoZSwiTGFiZWxlZFN0YXRlbWVudCIpfSx6LnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudD1mdW5jdGlvbihlLHQpe3JldHVybiBlLmV4cHJlc3Npb249dCx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLCJFeHByZXNzaW9uU3RhdGVtZW50Iil9LHoucGFyc2VCbG9jaz1mdW5jdGlvbihlLHQsaSl7Zm9yKGU9PT12b2lkIDAmJihlPSEwKSx0PT09dm9pZCAwJiYodD10aGlzLnN0YXJ0Tm9kZSgpKSx0LmJvZHk9W10sdGhpcy5leHBlY3QoZC5icmFjZUwpLGUmJnRoaXMuZW50ZXJTY29wZSgwKTt0aGlzLnR5cGUhPT1kLmJyYWNlUjspe3ZhciBzPXRoaXMucGFyc2VTdGF0ZW1lbnQobnVsbCk7dC5ib2R5LnB1c2gocyl9cmV0dXJuIGkmJih0aGlzLnN0cmljdD0hMSksdGhpcy5uZXh0KCksZSYmdGhpcy5leGl0U2NvcGUoKSx0aGlzLmZpbmlzaE5vZGUodCwiQmxvY2tTdGF0ZW1lbnQiKX0sei5wYXJzZUZvcj1mdW5jdGlvbihlLHQpe3JldHVybiBlLmluaXQ9dCx0aGlzLmV4cGVjdChkLnNlbWkpLGUudGVzdD10aGlzLnR5cGU9PT1kLnNlbWk/bnVsbDp0aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuZXhwZWN0KGQuc2VtaSksZS51cGRhdGU9dGhpcy50eXBlPT09ZC5wYXJlblI/bnVsbDp0aGlzLnBhcnNlRXhwcmVzc2lvbigpLHRoaXMuZXhwZWN0KGQucGFyZW5SKSxlLmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudCgiZm9yIiksdGhpcy5leGl0U2NvcGUoKSx0aGlzLmxhYmVscy5wb3AoKSx0aGlzLmZpbmlzaE5vZGUoZSwiRm9yU3RhdGVtZW50Iil9LHoucGFyc2VGb3JJbj1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMudHlwZT09PWQuX2luO3JldHVybiB0aGlzLm5leHQoKSx0LnR5cGU9PT0iVmFyaWFibGVEZWNsYXJhdGlvbiImJnQuZGVjbGFyYXRpb25zWzBdLmluaXQhPW51bGwmJighaXx8dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDh8fHRoaXMuc3RyaWN0fHx0LmtpbmQhPT0idmFyInx8dC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSE9PSJJZGVudGlmaWVyIikmJnRoaXMucmFpc2UodC5zdGFydCwoaT8iZm9yLWluIjoiZm9yLW9mIikrIiBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplciIpLGUubGVmdD10LGUucmlnaHQ9aT90aGlzLnBhcnNlRXhwcmVzc2lvbigpOnRoaXMucGFyc2VNYXliZUFzc2lnbigpLHRoaXMuZXhwZWN0KGQucGFyZW5SKSxlLmJvZHk9dGhpcy5wYXJzZVN0YXRlbWVudCgiZm9yIiksdGhpcy5leGl0U2NvcGUoKSx0aGlzLmxhYmVscy5wb3AoKSx0aGlzLmZpbmlzaE5vZGUoZSxpPyJGb3JJblN0YXRlbWVudCI6IkZvck9mU3RhdGVtZW50Iil9LHoucGFyc2VWYXI9ZnVuY3Rpb24oZSx0LGkscyl7Zm9yKGUuZGVjbGFyYXRpb25zPVtdLGUua2luZD1pOzspe3ZhciBuPXRoaXMuc3RhcnROb2RlKCk7aWYodGhpcy5wYXJzZVZhcklkKG4saSksdGhpcy5lYXQoZC5lcSk/bi5pbml0PXRoaXMucGFyc2VNYXliZUFzc2lnbih0KTohcyYmaT09PSJjb25zdCImJiEodGhpcy50eXBlPT09ZC5faW58fHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmdGhpcy5pc0NvbnRleHR1YWwoIm9mIikpP3RoaXMudW5leHBlY3RlZCgpOiFzJiZuLmlkLnR5cGUhPT0iSWRlbnRpZmllciImJiEodCYmKHRoaXMudHlwZT09PWQuX2lufHx0aGlzLmlzQ29udGV4dHVhbCgib2YiKSkpP3RoaXMucmFpc2UodGhpcy5sYXN0VG9rRW5kLCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZSIpOm4uaW5pdD1udWxsLGUuZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKG4sIlZhcmlhYmxlRGVjbGFyYXRvciIpKSwhdGhpcy5lYXQoZC5jb21tYSkpYnJlYWt9cmV0dXJuIGV9LHoucGFyc2VWYXJJZD1mdW5jdGlvbihlLHQpe2UuaWQ9dGhpcy5wYXJzZUJpbmRpbmdBdG9tKCksdGhpcy5jaGVja0xWYWxQYXR0ZXJuKGUuaWQsdD09PSJ2YXIiP1JhOlJ0LCExKX07dmFyIENzPTEsVmE9MixCdT00O3oucGFyc2VGdW5jdGlvbj1mdW5jdGlvbihlLHQsaSxzLG4pe3RoaXMuaW5pdEZ1bmN0aW9uKGUpLCh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTl8fHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmIXMpJiYodGhpcy50eXBlPT09ZC5zdGFyJiZ0JlZhJiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLmdlbmVyYXRvcj10aGlzLmVhdChkLnN0YXIpKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJihlLmFzeW5jPSEhcyksdCZDcyYmKGUuaWQ9dCZCdSYmdGhpcy50eXBlIT09ZC5uYW1lP251bGw6dGhpcy5wYXJzZUlkZW50KCksZS5pZCYmISh0JlZhKSYmdGhpcy5jaGVja0xWYWxTaW1wbGUoZS5pZCx0aGlzLnN0cmljdHx8ZS5nZW5lcmF0b3J8fGUuYXN5bmM/dGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFyP1JhOlJ0OlZ1KSk7dmFyIHI9dGhpcy55aWVsZFBvcyxhPXRoaXMuYXdhaXRQb3Msbz10aGlzLmF3YWl0SWRlbnRQb3M7cmV0dXJuIHRoaXMueWllbGRQb3M9MCx0aGlzLmF3YWl0UG9zPTAsdGhpcy5hd2FpdElkZW50UG9zPTAsdGhpcy5lbnRlclNjb3BlKFRhKGUuYXN5bmMsZS5nZW5lcmF0b3IpKSx0JkNzfHwoZS5pZD10aGlzLnR5cGU9PT1kLm5hbWU/dGhpcy5wYXJzZUlkZW50KCk6bnVsbCksdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKGUpLHRoaXMucGFyc2VGdW5jdGlvbkJvZHkoZSxpLCExLG4pLHRoaXMueWllbGRQb3M9cix0aGlzLmF3YWl0UG9zPWEsdGhpcy5hd2FpdElkZW50UG9zPW8sdGhpcy5maW5pc2hOb2RlKGUsdCZDcz8iRnVuY3Rpb25EZWNsYXJhdGlvbiI6IkZ1bmN0aW9uRXhwcmVzc2lvbiIpfSx6LnBhcnNlRnVuY3Rpb25QYXJhbXM9ZnVuY3Rpb24oZSl7dGhpcy5leHBlY3QoZC5wYXJlbkwpLGUucGFyYW1zPXRoaXMucGFyc2VCaW5kaW5nTGlzdChkLnBhcmVuUiwhMSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgpLHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCl9LHoucGFyc2VDbGFzcz1mdW5jdGlvbihlLHQpe3RoaXMubmV4dCgpO3ZhciBpPXRoaXMuc3RyaWN0O3RoaXMuc3RyaWN0PSEwLHRoaXMucGFyc2VDbGFzc0lkKGUsdCksdGhpcy5wYXJzZUNsYXNzU3VwZXIoZSk7dmFyIHM9dGhpcy5lbnRlckNsYXNzQm9keSgpLG49dGhpcy5zdGFydE5vZGUoKSxyPSExO2ZvcihuLmJvZHk9W10sdGhpcy5leHBlY3QoZC5icmFjZUwpO3RoaXMudHlwZSE9PWQuYnJhY2VSOyl7dmFyIGE9dGhpcy5wYXJzZUNsYXNzRWxlbWVudChlLnN1cGVyQ2xhc3MhPT1udWxsKTthJiYobi5ib2R5LnB1c2goYSksYS50eXBlPT09Ik1ldGhvZERlZmluaXRpb24iJiZhLmtpbmQ9PT0iY29uc3RydWN0b3IiPyhyJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoYS5zdGFydCwiRHVwbGljYXRlIGNvbnN0cnVjdG9yIGluIHRoZSBzYW1lIGNsYXNzIikscj0hMCk6YS5rZXkmJmEua2V5LnR5cGU9PT0iUHJpdmF0ZUlkZW50aWZpZXIiJiZpZyhzLGEpJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoYS5rZXkuc3RhcnQsIklkZW50aWZpZXIgJyMiK2Eua2V5Lm5hbWUrIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCIpKX1yZXR1cm4gdGhpcy5zdHJpY3Q9aSx0aGlzLm5leHQoKSxlLmJvZHk9dGhpcy5maW5pc2hOb2RlKG4sIkNsYXNzQm9keSIpLHRoaXMuZXhpdENsYXNzQm9keSgpLHRoaXMuZmluaXNoTm9kZShlLHQ/IkNsYXNzRGVjbGFyYXRpb24iOiJDbGFzc0V4cHJlc3Npb24iKX0sei5wYXJzZUNsYXNzRWxlbWVudD1mdW5jdGlvbihlKXtpZih0aGlzLmVhdChkLnNlbWkpKXJldHVybiBudWxsO3ZhciB0PXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbixpPXRoaXMuc3RhcnROb2RlKCkscz0iIixuPSExLHI9ITEsYT0ibWV0aG9kIixvPSExO2lmKHRoaXMuZWF0Q29udGV4dHVhbCgic3RhdGljIikpe2lmKHQ+PTEzJiZ0aGlzLmVhdChkLmJyYWNlTCkpcmV0dXJuIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGkpLGk7dGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpfHx0aGlzLnR5cGU9PT1kLnN0YXI/bz0hMDpzPSJzdGF0aWMifWlmKGkuc3RhdGljPW8sIXMmJnQ+PTgmJnRoaXMuZWF0Q29udGV4dHVhbCgiYXN5bmMiKSYmKCh0aGlzLmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0KCl8fHRoaXMudHlwZT09PWQuc3RhcikmJiF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpP3I9ITA6cz0iYXN5bmMiKSwhcyYmKHQ+PTl8fCFyKSYmdGhpcy5lYXQoZC5zdGFyKSYmKG49ITApLCFzJiYhciYmIW4pe3ZhciBoPXRoaXMudmFsdWU7KHRoaXMuZWF0Q29udGV4dHVhbCgiZ2V0Iil8fHRoaXMuZWF0Q29udGV4dHVhbCgic2V0IikpJiYodGhpcy5pc0NsYXNzRWxlbWVudE5hbWVTdGFydCgpP2E9aDpzPWgpfWlmKHM/KGkuY29tcHV0ZWQ9ITEsaS5rZXk9dGhpcy5zdGFydE5vZGVBdCh0aGlzLmxhc3RUb2tTdGFydCx0aGlzLmxhc3RUb2tTdGFydExvYyksaS5rZXkubmFtZT1zLHRoaXMuZmluaXNoTm9kZShpLmtleSwiSWRlbnRpZmllciIpKTp0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShpKSx0PDEzfHx0aGlzLnR5cGU9PT1kLnBhcmVuTHx8YSE9PSJtZXRob2QifHxufHxyKXt2YXIgbD0haS5zdGF0aWMmJlJuKGksImNvbnN0cnVjdG9yIiksYz1sJiZlO2wmJmEhPT0ibWV0aG9kIiYmdGhpcy5yYWlzZShpLmtleS5zdGFydCwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyIiksaS5raW5kPWw/ImNvbnN0cnVjdG9yIjphLHRoaXMucGFyc2VDbGFzc01ldGhvZChpLG4scixjKX1lbHNlIHRoaXMucGFyc2VDbGFzc0ZpZWxkKGkpO3JldHVybiBpfSx6LmlzQ2xhc3NFbGVtZW50TmFtZVN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHlwZT09PWQubmFtZXx8dGhpcy50eXBlPT09ZC5wcml2YXRlSWR8fHRoaXMudHlwZT09PWQubnVtfHx0aGlzLnR5cGU9PT1kLnN0cmluZ3x8dGhpcy50eXBlPT09ZC5icmFja2V0THx8dGhpcy50eXBlLmtleXdvcmR9LHoucGFyc2VDbGFzc0VsZW1lbnROYW1lPWZ1bmN0aW9uKGUpe3RoaXMudHlwZT09PWQucHJpdmF0ZUlkPyh0aGlzLnZhbHVlPT09ImNvbnN0cnVjdG9yIiYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJDbGFzc2VzIGNhbid0IGhhdmUgYW4gZWxlbWVudCBuYW1lZCAnI2NvbnN0cnVjdG9yJyIpLGUuY29tcHV0ZWQ9ITEsZS5rZXk9dGhpcy5wYXJzZVByaXZhdGVJZGVudCgpKTp0aGlzLnBhcnNlUHJvcGVydHlOYW1lKGUpfSx6LnBhcnNlQ2xhc3NNZXRob2Q9ZnVuY3Rpb24oZSx0LGkscyl7dmFyIG49ZS5rZXk7ZS5raW5kPT09ImNvbnN0cnVjdG9yIj8odCYmdGhpcy5yYWlzZShuLnN0YXJ0LCJDb25zdHJ1Y3RvciBjYW4ndCBiZSBhIGdlbmVyYXRvciIpLGkmJnRoaXMucmFpc2Uobi5zdGFydCwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kIikpOmUuc3RhdGljJiZSbihlLCJwcm90b3R5cGUiKSYmdGhpcy5yYWlzZShuLnN0YXJ0LCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUiKTt2YXIgcj1lLnZhbHVlPXRoaXMucGFyc2VNZXRob2QodCxpLHMpO3JldHVybiBlLmtpbmQ9PT0iZ2V0IiYmci5wYXJhbXMubGVuZ3RoIT09MCYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHIuc3RhcnQsImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXMiKSxlLmtpbmQ9PT0ic2V0IiYmci5wYXJhbXMubGVuZ3RoIT09MSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHIuc3RhcnQsInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbSIpLGUua2luZD09PSJzZXQiJiZyLnBhcmFtc1swXS50eXBlPT09IlJlc3RFbGVtZW50IiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHIucGFyYW1zWzBdLnN0YXJ0LCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtcyIpLHRoaXMuZmluaXNoTm9kZShlLCJNZXRob2REZWZpbml0aW9uIil9LHoucGFyc2VDbGFzc0ZpZWxkPWZ1bmN0aW9uKGUpe2lmKFJuKGUsImNvbnN0cnVjdG9yIik/dGhpcy5yYWlzZShlLmtleS5zdGFydCwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJyIpOmUuc3RhdGljJiZSbihlLCJwcm90b3R5cGUiKSYmdGhpcy5yYWlzZShlLmtleS5zdGFydCwiQ2xhc3NlcyBjYW4ndCBoYXZlIGEgc3RhdGljIGZpZWxkIG5hbWVkICdwcm90b3R5cGUnIiksdGhpcy5lYXQoZC5lcSkpe3ZhciB0PXRoaXMuY3VycmVudFRoaXNTY29wZSgpLGk9dC5pbkNsYXNzRmllbGRJbml0O3QuaW5DbGFzc0ZpZWxkSW5pdD0hMCxlLnZhbHVlPXRoaXMucGFyc2VNYXliZUFzc2lnbigpLHQuaW5DbGFzc0ZpZWxkSW5pdD1pfWVsc2UgZS52YWx1ZT1udWxsO3JldHVybiB0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLCJQcm9wZXJ0eURlZmluaXRpb24iKX0sei5wYXJzZUNsYXNzU3RhdGljQmxvY2s9ZnVuY3Rpb24oZSl7ZS5ib2R5PVtdO3ZhciB0PXRoaXMubGFiZWxzO2Zvcih0aGlzLmxhYmVscz1bXSx0aGlzLmVudGVyU2NvcGUoQXN8JGEpO3RoaXMudHlwZSE9PWQuYnJhY2VSOyl7dmFyIGk9dGhpcy5wYXJzZVN0YXRlbWVudChudWxsKTtlLmJvZHkucHVzaChpKX1yZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5leGl0U2NvcGUoKSx0aGlzLmxhYmVscz10LHRoaXMuZmluaXNoTm9kZShlLCJTdGF0aWNCbG9jayIpfSx6LnBhcnNlQ2xhc3NJZD1mdW5jdGlvbihlLHQpe3RoaXMudHlwZT09PWQubmFtZT8oZS5pZD10aGlzLnBhcnNlSWRlbnQoKSx0JiZ0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmlkLFJ0LCExKSk6KHQ9PT0hMCYmdGhpcy51bmV4cGVjdGVkKCksZS5pZD1udWxsKX0sei5wYXJzZUNsYXNzU3VwZXI9ZnVuY3Rpb24oZSl7ZS5zdXBlckNsYXNzPXRoaXMuZWF0KGQuX2V4dGVuZHMpP3RoaXMucGFyc2VFeHByU3Vic2NyaXB0cyhudWxsLCExKTpudWxsfSx6LmVudGVyQ2xhc3NCb2R5PWZ1bmN0aW9uKCl7dmFyIGU9e2RlY2xhcmVkOk9iamVjdC5jcmVhdGUobnVsbCksdXNlZDpbXX07cmV0dXJuIHRoaXMucHJpdmF0ZU5hbWVTdGFjay5wdXNoKGUpLGUuZGVjbGFyZWR9LHouZXhpdENsYXNzQm9keT1mdW5jdGlvbigpe3ZhciBlPXRoaXMucHJpdmF0ZU5hbWVTdGFjay5wb3AoKSx0PWUuZGVjbGFyZWQsaT1lLnVzZWQ7aWYodGhpcy5vcHRpb25zLmNoZWNrUHJpdmF0ZUZpZWxkcylmb3IodmFyIHM9dGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aCxuPXM9PT0wP251bGw6dGhpcy5wcml2YXRlTmFtZVN0YWNrW3MtMV0scj0wO3I8aS5sZW5ndGg7KytyKXt2YXIgYT1pW3JdO1NzKHQsYS5uYW1lKXx8KG4/bi51c2VkLnB1c2goYSk6dGhpcy5yYWlzZVJlY292ZXJhYmxlKGEuc3RhcnQsIlByaXZhdGUgZmllbGQgJyMiK2EubmFtZSsiJyBtdXN0IGJlIGRlY2xhcmVkIGluIGFuIGVuY2xvc2luZyBjbGFzcyIpKX19O2Z1bmN0aW9uIGlnKGUsdCl7dmFyIGk9dC5rZXkubmFtZSxzPWVbaV0sbj0idHJ1ZSI7cmV0dXJuIHQudHlwZT09PSJNZXRob2REZWZpbml0aW9uIiYmKHQua2luZD09PSJnZXQifHx0LmtpbmQ9PT0ic2V0IikmJihuPSh0LnN0YXRpYz8icyI6ImkiKSt0LmtpbmQpLHM9PT0iaWdldCImJm49PT0iaXNldCJ8fHM9PT0iaXNldCImJm49PT0iaWdldCJ8fHM9PT0ic2dldCImJm49PT0ic3NldCJ8fHM9PT0ic3NldCImJm49PT0ic2dldCI/KGVbaV09InRydWUiLCExKTpzPyEwOihlW2ldPW4sITEpfWZ1bmN0aW9uIFJuKGUsdCl7dmFyIGk9ZS5jb21wdXRlZCxzPWUua2V5O3JldHVybiFpJiYocy50eXBlPT09IklkZW50aWZpZXIiJiZzLm5hbWU9PT10fHxzLnR5cGU9PT0iTGl0ZXJhbCImJnMudmFsdWU9PT10KX16LnBhcnNlRXhwb3J0QWxsRGVjbGFyYXRpb249ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMSYmKHRoaXMuZWF0Q29udGV4dHVhbCgiYXMiKT8oZS5leHBvcnRlZD10aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpLHRoaXMuY2hlY2tFeHBvcnQodCxlLmV4cG9ydGVkLHRoaXMubGFzdFRva1N0YXJ0KSk6ZS5leHBvcnRlZD1udWxsKSx0aGlzLmV4cGVjdENvbnRleHR1YWwoImZyb20iKSx0aGlzLnR5cGUhPT1kLnN0cmluZyYmdGhpcy51bmV4cGVjdGVkKCksZS5zb3VyY2U9dGhpcy5wYXJzZUV4cHJBdG9tKCksdGhpcy5zZW1pY29sb24oKSx0aGlzLmZpbmlzaE5vZGUoZSwiRXhwb3J0QWxsRGVjbGFyYXRpb24iKX0sei5wYXJzZUV4cG9ydD1mdW5jdGlvbihlLHQpe2lmKHRoaXMubmV4dCgpLHRoaXMuZWF0KGQuc3RhcikpcmV0dXJuIHRoaXMucGFyc2VFeHBvcnRBbGxEZWNsYXJhdGlvbihlLHQpO2lmKHRoaXMuZWF0KGQuX2RlZmF1bHQpKXJldHVybiB0aGlzLmNoZWNrRXhwb3J0KHQsImRlZmF1bHQiLHRoaXMubGFzdFRva1N0YXJ0KSxlLmRlY2xhcmF0aW9uPXRoaXMucGFyc2VFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKSx0aGlzLmZpbmlzaE5vZGUoZSwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uIik7aWYodGhpcy5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudCgpKWUuZGVjbGFyYXRpb249dGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKGUpLGUuZGVjbGFyYXRpb24udHlwZT09PSJWYXJpYWJsZURlY2xhcmF0aW9uIj90aGlzLmNoZWNrVmFyaWFibGVFeHBvcnQodCxlLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucyk6dGhpcy5jaGVja0V4cG9ydCh0LGUuZGVjbGFyYXRpb24uaWQsZS5kZWNsYXJhdGlvbi5pZC5zdGFydCksZS5zcGVjaWZpZXJzPVtdLGUuc291cmNlPW51bGw7ZWxzZXtpZihlLmRlY2xhcmF0aW9uPW51bGwsZS5zcGVjaWZpZXJzPXRoaXMucGFyc2VFeHBvcnRTcGVjaWZpZXJzKHQpLHRoaXMuZWF0Q29udGV4dHVhbCgiZnJvbSIpKXRoaXMudHlwZSE9PWQuc3RyaW5nJiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLnNvdXJjZT10aGlzLnBhcnNlRXhwckF0b20oKTtlbHNle2Zvcih2YXIgaT0wLHM9ZS5zcGVjaWZpZXJzO2k8cy5sZW5ndGg7aSs9MSl7dmFyIG49c1tpXTt0aGlzLmNoZWNrVW5yZXNlcnZlZChuLmxvY2FsKSx0aGlzLmNoZWNrTG9jYWxFeHBvcnQobi5sb2NhbCksbi5sb2NhbC50eXBlPT09IkxpdGVyYWwiJiZ0aGlzLnJhaXNlKG4ubG9jYWwuc3RhcnQsIkEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IGBmcm9tYC4iKX1lLnNvdXJjZT1udWxsfXRoaXMuc2VtaWNvbG9uKCl9cmV0dXJuIHRoaXMuZmluaXNoTm9kZShlLCJFeHBvcnROYW1lZERlY2xhcmF0aW9uIil9LHoucGFyc2VFeHBvcnREZWNsYXJhdGlvbj1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudChudWxsKX0sei5wYXJzZUV4cG9ydERlZmF1bHREZWNsYXJhdGlvbj1mdW5jdGlvbigpe3ZhciBlO2lmKHRoaXMudHlwZT09PWQuX2Z1bmN0aW9ufHwoZT10aGlzLmlzQXN5bmNGdW5jdGlvbigpKSl7dmFyIHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksZSYmdGhpcy5uZXh0KCksdGhpcy5wYXJzZUZ1bmN0aW9uKHQsQ3N8QnUsITEsZSl9ZWxzZSBpZih0aGlzLnR5cGU9PT1kLl9jbGFzcyl7dmFyIGk9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGksIm51bGxhYmxlSUQiKX1lbHNle3ZhciBzPXRoaXMucGFyc2VNYXliZUFzc2lnbigpO3JldHVybiB0aGlzLnNlbWljb2xvbigpLHN9fSx6LmNoZWNrRXhwb3J0PWZ1bmN0aW9uKGUsdCxpKXtlJiYodHlwZW9mIHQhPSJzdHJpbmciJiYodD10LnR5cGU9PT0iSWRlbnRpZmllciI/dC5uYW1lOnQudmFsdWUpLFNzKGUsdCkmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShpLCJEdXBsaWNhdGUgZXhwb3J0ICciK3QrIiciKSxlW3RdPSEwKX0sei5jaGVja1BhdHRlcm5FeHBvcnQ9ZnVuY3Rpb24oZSx0KXt2YXIgaT10LnR5cGU7aWYoaT09PSJJZGVudGlmaWVyIil0aGlzLmNoZWNrRXhwb3J0KGUsdCx0LnN0YXJ0KTtlbHNlIGlmKGk9PT0iT2JqZWN0UGF0dGVybiIpZm9yKHZhciBzPTAsbj10LnByb3BlcnRpZXM7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUscil9ZWxzZSBpZihpPT09IkFycmF5UGF0dGVybiIpZm9yKHZhciBhPTAsbz10LmVsZW1lbnRzO2E8by5sZW5ndGg7YSs9MSl7dmFyIGg9b1thXTtoJiZ0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChlLGgpfWVsc2UgaT09PSJQcm9wZXJ0eSI/dGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZSx0LnZhbHVlKTppPT09IkFzc2lnbm1lbnRQYXR0ZXJuIj90aGlzLmNoZWNrUGF0dGVybkV4cG9ydChlLHQubGVmdCk6aT09PSJSZXN0RWxlbWVudCImJnRoaXMuY2hlY2tQYXR0ZXJuRXhwb3J0KGUsdC5hcmd1bWVudCl9LHouY2hlY2tWYXJpYWJsZUV4cG9ydD1mdW5jdGlvbihlLHQpe2lmKGUpZm9yKHZhciBpPTAscz10O2k8cy5sZW5ndGg7aSs9MSl7dmFyIG49c1tpXTt0aGlzLmNoZWNrUGF0dGVybkV4cG9ydChlLG4uaWQpfX0sei5zaG91bGRQYXJzZUV4cG9ydFN0YXRlbWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnR5cGUua2V5d29yZD09PSJ2YXIifHx0aGlzLnR5cGUua2V5d29yZD09PSJjb25zdCJ8fHRoaXMudHlwZS5rZXl3b3JkPT09ImNsYXNzInx8dGhpcy50eXBlLmtleXdvcmQ9PT0iZnVuY3Rpb24ifHx0aGlzLmlzTGV0KCl8fHRoaXMuaXNBc3luY0Z1bmN0aW9uKCl9LHoucGFyc2VFeHBvcnRTcGVjaWZpZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC5sb2NhbD10aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpLHQuZXhwb3J0ZWQ9dGhpcy5lYXRDb250ZXh0dWFsKCJhcyIpP3RoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk6dC5sb2NhbCx0aGlzLmNoZWNrRXhwb3J0KGUsdC5leHBvcnRlZCx0LmV4cG9ydGVkLnN0YXJ0KSx0aGlzLmZpbmlzaE5vZGUodCwiRXhwb3J0U3BlY2lmaWVyIil9LHoucGFyc2VFeHBvcnRTcGVjaWZpZXJzPWZ1bmN0aW9uKGUpe3ZhciB0PVtdLGk9ITA7Zm9yKHRoaXMuZXhwZWN0KGQuYnJhY2VMKTshdGhpcy5lYXQoZC5icmFjZVIpOyl7aWYoaSlpPSExO2Vsc2UgaWYodGhpcy5leHBlY3QoZC5jb21tYSksdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoZC5icmFjZVIpKWJyZWFrO3QucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKGUpKX1yZXR1cm4gdH0sei5wYXJzZUltcG9ydD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy50eXBlPT09ZC5zdHJpbmc/KGUuc3BlY2lmaWVycz10ZyxlLnNvdXJjZT10aGlzLnBhcnNlRXhwckF0b20oKSk6KGUuc3BlY2lmaWVycz10aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVycygpLHRoaXMuZXhwZWN0Q29udGV4dHVhbCgiZnJvbSIpLGUuc291cmNlPXRoaXMudHlwZT09PWQuc3RyaW5nP3RoaXMucGFyc2VFeHByQXRvbSgpOnRoaXMudW5leHBlY3RlZCgpKSx0aGlzLnNlbWljb2xvbigpLHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnREZWNsYXJhdGlvbiIpfSx6LnBhcnNlSW1wb3J0U3BlY2lmaWVyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gZS5pbXBvcnRlZD10aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpLHRoaXMuZWF0Q29udGV4dHVhbCgiYXMiKT9lLmxvY2FsPXRoaXMucGFyc2VJZGVudCgpOih0aGlzLmNoZWNrVW5yZXNlcnZlZChlLmltcG9ydGVkKSxlLmxvY2FsPWUuaW1wb3J0ZWQpLHRoaXMuY2hlY2tMVmFsU2ltcGxlKGUubG9jYWwsUnQpLHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnRTcGVjaWZpZXIiKX0sei5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiBlLmxvY2FsPXRoaXMucGFyc2VJZGVudCgpLHRoaXMuY2hlY2tMVmFsU2ltcGxlKGUubG9jYWwsUnQpLHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyIil9LHoucGFyc2VJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLmV4cGVjdENvbnRleHR1YWwoImFzIiksZS5sb2NhbD10aGlzLnBhcnNlSWRlbnQoKSx0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmxvY2FsLFJ0KSx0aGlzLmZpbmlzaE5vZGUoZSwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIil9LHoucGFyc2VJbXBvcnRTcGVjaWZpZXJzPWZ1bmN0aW9uKCl7dmFyIGU9W10sdD0hMDtpZih0aGlzLnR5cGU9PT1kLm5hbWUmJihlLnB1c2godGhpcy5wYXJzZUltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSksIXRoaXMuZWF0KGQuY29tbWEpKSlyZXR1cm4gZTtpZih0aGlzLnR5cGU9PT1kLnN0YXIpcmV0dXJuIGUucHVzaCh0aGlzLnBhcnNlSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkpLGU7Zm9yKHRoaXMuZXhwZWN0KGQuYnJhY2VMKTshdGhpcy5lYXQoZC5icmFjZVIpOyl7aWYodCl0PSExO2Vsc2UgaWYodGhpcy5leHBlY3QoZC5jb21tYSksdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoZC5icmFjZVIpKWJyZWFrO2UucHVzaCh0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKCkpfXJldHVybiBlfSx6LnBhcnNlTW9kdWxlRXhwb3J0TmFtZT1mdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTMmJnRoaXMudHlwZT09PWQuc3RyaW5nKXt2YXIgZT10aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnZhbHVlKTtyZXR1cm4gWW0udGVzdChlLnZhbHVlKSYmdGhpcy5yYWlzZShlLnN0YXJ0LCJBbiBleHBvcnQgbmFtZSBjYW5ub3QgaW5jbHVkZSBhIGxvbmUgc3Vycm9nYXRlLiIpLGV9cmV0dXJuIHRoaXMucGFyc2VJZGVudCghMCl9LHouYWRhcHREaXJlY3RpdmVQcm9sb2d1ZT1mdW5jdGlvbihlKXtmb3IodmFyIHQ9MDt0PGUubGVuZ3RoJiZ0aGlzLmlzRGlyZWN0aXZlQ2FuZGlkYXRlKGVbdF0pOysrdCllW3RdLmRpcmVjdGl2ZT1lW3RdLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsLTEpfSx6LmlzRGlyZWN0aXZlQ2FuZGlkYXRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTUmJmUudHlwZT09PSJFeHByZXNzaW9uU3RhdGVtZW50IiYmZS5leHByZXNzaW9uLnR5cGU9PT0iTGl0ZXJhbCImJnR5cGVvZiBlLmV4cHJlc3Npb24udmFsdWU9PSJzdHJpbmciJiYodGhpcy5pbnB1dFtlLnN0YXJ0XT09PSciJ3x8dGhpcy5pbnB1dFtlLnN0YXJ0XT09PSInIil9O3ZhciBhdD1QZS5wcm90b3R5cGU7YXQudG9Bc3NpZ25hYmxlPWZ1bmN0aW9uKGUsdCxpKXtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJmUpc3dpdGNoKGUudHlwZSl7Y2FzZSJJZGVudGlmaWVyIjp0aGlzLmluQXN5bmMmJmUubmFtZT09PSJhd2FpdCImJnRoaXMucmFpc2UoZS5zdGFydCwiQ2Fubm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uIik7YnJlYWs7Y2FzZSJPYmplY3RQYXR0ZXJuIjpjYXNlIkFycmF5UGF0dGVybiI6Y2FzZSJBc3NpZ25tZW50UGF0dGVybiI6Y2FzZSJSZXN0RWxlbWVudCI6YnJlYWs7Y2FzZSJPYmplY3RFeHByZXNzaW9uIjplLnR5cGU9Ik9iamVjdFBhdHRlcm4iLGkmJnRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKGksITApO2Zvcih2YXIgcz0wLG49ZS5wcm9wZXJ0aWVzO3M8bi5sZW5ndGg7cys9MSl7dmFyIHI9bltzXTt0aGlzLnRvQXNzaWduYWJsZShyLHQpLHIudHlwZT09PSJSZXN0RWxlbWVudCImJihyLmFyZ3VtZW50LnR5cGU9PT0iQXJyYXlQYXR0ZXJuInx8ci5hcmd1bWVudC50eXBlPT09Ik9iamVjdFBhdHRlcm4iKSYmdGhpcy5yYWlzZShyLmFyZ3VtZW50LnN0YXJ0LCJVbmV4cGVjdGVkIHRva2VuIil9YnJlYWs7Y2FzZSJQcm9wZXJ0eSI6ZS5raW5kIT09ImluaXQiJiZ0aGlzLnJhaXNlKGUua2V5LnN0YXJ0LCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXIiKSx0aGlzLnRvQXNzaWduYWJsZShlLnZhbHVlLHQpO2JyZWFrO2Nhc2UiQXJyYXlFeHByZXNzaW9uIjplLnR5cGU9IkFycmF5UGF0dGVybiIsaSYmdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMoaSwhMCksdGhpcy50b0Fzc2lnbmFibGVMaXN0KGUuZWxlbWVudHMsdCk7YnJlYWs7Y2FzZSJTcHJlYWRFbGVtZW50IjplLnR5cGU9IlJlc3RFbGVtZW50Iix0aGlzLnRvQXNzaWduYWJsZShlLmFyZ3VtZW50LHQpLGUuYXJndW1lbnQudHlwZT09PSJBc3NpZ25tZW50UGF0dGVybiImJnRoaXMucmFpc2UoZS5hcmd1bWVudC5zdGFydCwiUmVzdCBlbGVtZW50cyBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUiKTticmVhaztjYXNlIkFzc2lnbm1lbnRFeHByZXNzaW9uIjplLm9wZXJhdG9yIT09Ij0iJiZ0aGlzLnJhaXNlKGUubGVmdC5lbmQsIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuIiksZS50eXBlPSJBc3NpZ25tZW50UGF0dGVybiIsZGVsZXRlIGUub3BlcmF0b3IsdGhpcy50b0Fzc2lnbmFibGUoZS5sZWZ0LHQpO2JyZWFrO2Nhc2UiUGFyZW50aGVzaXplZEV4cHJlc3Npb24iOnRoaXMudG9Bc3NpZ25hYmxlKGUuZXhwcmVzc2lvbix0LGkpO2JyZWFrO2Nhc2UiQ2hhaW5FeHByZXNzaW9uIjp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZSIpO2JyZWFrO2Nhc2UiTWVtYmVyRXhwcmVzc2lvbiI6aWYoIXQpYnJlYWs7ZGVmYXVsdDp0aGlzLnJhaXNlKGUuc3RhcnQsIkFzc2lnbmluZyB0byBydmFsdWUiKX1lbHNlIGkmJnRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKGksITApO3JldHVybiBlfSxhdC50b0Fzc2lnbmFibGVMaXN0PWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPWUubGVuZ3RoLHM9MDtzPGk7cysrKXt2YXIgbj1lW3NdO24mJnRoaXMudG9Bc3NpZ25hYmxlKG4sdCl9aWYoaSl7dmFyIHI9ZVtpLTFdO3RoaXMub3B0aW9ucy5lY21hVmVyc2lvbj09PTYmJnQmJnImJnIudHlwZT09PSJSZXN0RWxlbWVudCImJnIuYXJndW1lbnQudHlwZSE9PSJJZGVudGlmaWVyIiYmdGhpcy51bmV4cGVjdGVkKHIuYXJndW1lbnQuc3RhcnQpfXJldHVybiBlfSxhdC5wYXJzZVNwcmVhZD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0LmFyZ3VtZW50PXRoaXMucGFyc2VNYXliZUFzc2lnbighMSxlKSx0aGlzLmZpbmlzaE5vZGUodCwiU3ByZWFkRWxlbWVudCIpfSxhdC5wYXJzZVJlc3RCaW5kaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPT09NiYmdGhpcy50eXBlIT09ZC5uYW1lJiZ0aGlzLnVuZXhwZWN0ZWQoKSxlLmFyZ3VtZW50PXRoaXMucGFyc2VCaW5kaW5nQXRvbSgpLHRoaXMuZmluaXNoTm9kZShlLCJSZXN0RWxlbWVudCIpfSxhdC5wYXJzZUJpbmRpbmdBdG9tPWZ1bmN0aW9uKCl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXN3aXRjaCh0aGlzLnR5cGUpe2Nhc2UgZC5icmFja2V0TDp2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSxlLmVsZW1lbnRzPXRoaXMucGFyc2VCaW5kaW5nTGlzdChkLmJyYWNrZXRSLCEwLCEwKSx0aGlzLmZpbmlzaE5vZGUoZSwiQXJyYXlQYXR0ZXJuIik7Y2FzZSBkLmJyYWNlTDpyZXR1cm4gdGhpcy5wYXJzZU9iaighMCl9cmV0dXJuIHRoaXMucGFyc2VJZGVudCgpfSxhdC5wYXJzZUJpbmRpbmdMaXN0PWZ1bmN0aW9uKGUsdCxpLHMpe2Zvcih2YXIgbj1bXSxyPSEwOyF0aGlzLmVhdChlKTspaWYocj9yPSExOnRoaXMuZXhwZWN0KGQuY29tbWEpLHQmJnRoaXMudHlwZT09PWQuY29tbWEpbi5wdXNoKG51bGwpO2Vsc2V7aWYoaSYmdGhpcy5hZnRlclRyYWlsaW5nQ29tbWEoZSkpYnJlYWs7aWYodGhpcy50eXBlPT09ZC5lbGxpcHNpcyl7dmFyIGE9dGhpcy5wYXJzZVJlc3RCaW5kaW5nKCk7dGhpcy5wYXJzZUJpbmRpbmdMaXN0SXRlbShhKSxuLnB1c2goYSksdGhpcy50eXBlPT09ZC5jb21tYSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudCIpLHRoaXMuZXhwZWN0KGUpO2JyZWFrfWVsc2Ugbi5wdXNoKHRoaXMucGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0ocykpfXJldHVybiBufSxhdC5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsdGhpcy5zdGFydExvYyk7cmV0dXJuIHRoaXMucGFyc2VCaW5kaW5nTGlzdEl0ZW0odCksdH0sYXQucGFyc2VCaW5kaW5nTGlzdEl0ZW09ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LGF0LnBhcnNlTWF5YmVEZWZhdWx0PWZ1bmN0aW9uKGUsdCxpKXtpZihpPWl8fHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjw2fHwhdGhpcy5lYXQoZC5lcSkpcmV0dXJuIGk7dmFyIHM9dGhpcy5zdGFydE5vZGVBdChlLHQpO3JldHVybiBzLmxlZnQ9aSxzLnJpZ2h0PXRoaXMucGFyc2VNYXliZUFzc2lnbigpLHRoaXMuZmluaXNoTm9kZShzLCJBc3NpZ25tZW50UGF0dGVybiIpfSxhdC5jaGVja0xWYWxTaW1wbGU9ZnVuY3Rpb24oZSx0LGkpe3Q9PT12b2lkIDAmJih0PUxuKTt2YXIgcz10IT09TG47c3dpdGNoKGUudHlwZSl7Y2FzZSJJZGVudGlmaWVyIjp0aGlzLnN0cmljdCYmdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0QmluZC50ZXN0KGUubmFtZSkmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LChzPyJCaW5kaW5nICI6IkFzc2lnbmluZyB0byAiKStlLm5hbWUrIiBpbiBzdHJpY3QgbW9kZSIpLHMmJih0PT09UnQmJmUubmFtZT09PSJsZXQiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwibGV0IGlzIGRpc2FsbG93ZWQgYXMgYSBsZXhpY2FsbHkgYm91bmQgbmFtZSIpLGkmJihTcyhpLGUubmFtZSkmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCJBcmd1bWVudCBuYW1lIGNsYXNoIiksaVtlLm5hbWVdPSEwKSx0IT09RHUmJnRoaXMuZGVjbGFyZU5hbWUoZS5uYW1lLHQsZS5zdGFydCkpO2JyZWFrO2Nhc2UiQ2hhaW5FeHByZXNzaW9uIjp0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiT3B0aW9uYWwgY2hhaW5pbmcgY2Fubm90IGFwcGVhciBpbiBsZWZ0LWhhbmQgc2lkZSIpO2JyZWFrO2Nhc2UiTWVtYmVyRXhwcmVzc2lvbiI6cyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24iKTticmVhaztjYXNlIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIjpyZXR1cm4gcyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUuc3RhcnQsIkJpbmRpbmcgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIiksdGhpcy5jaGVja0xWYWxTaW1wbGUoZS5leHByZXNzaW9uLHQsaSk7ZGVmYXVsdDp0aGlzLnJhaXNlKGUuc3RhcnQsKHM/IkJpbmRpbmciOiJBc3NpZ25pbmcgdG8iKSsiIHJ2YWx1ZSIpfX0sYXQuY2hlY2tMVmFsUGF0dGVybj1mdW5jdGlvbihlLHQsaSl7c3dpdGNoKHQ9PT12b2lkIDAmJih0PUxuKSxlLnR5cGUpe2Nhc2UiT2JqZWN0UGF0dGVybiI6Zm9yKHZhciBzPTAsbj1lLnByb3BlcnRpZXM7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHIsdCxpKX1icmVhaztjYXNlIkFycmF5UGF0dGVybiI6Zm9yKHZhciBhPTAsbz1lLmVsZW1lbnRzO2E8by5sZW5ndGg7YSs9MSl7dmFyIGg9b1thXTtoJiZ0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihoLHQsaSl9YnJlYWs7ZGVmYXVsdDp0aGlzLmNoZWNrTFZhbFNpbXBsZShlLHQsaSl9fSxhdC5jaGVja0xWYWxJbm5lclBhdHRlcm49ZnVuY3Rpb24oZSx0LGkpe3N3aXRjaCh0PT09dm9pZCAwJiYodD1MbiksZS50eXBlKXtjYXNlIlByb3BlcnR5Ijp0aGlzLmNoZWNrTFZhbElubmVyUGF0dGVybihlLnZhbHVlLHQsaSk7YnJlYWs7Y2FzZSJBc3NpZ25tZW50UGF0dGVybiI6dGhpcy5jaGVja0xWYWxQYXR0ZXJuKGUubGVmdCx0LGkpO2JyZWFrO2Nhc2UiUmVzdEVsZW1lbnQiOnRoaXMuY2hlY2tMVmFsUGF0dGVybihlLmFyZ3VtZW50LHQsaSk7YnJlYWs7ZGVmYXVsdDp0aGlzLmNoZWNrTFZhbFBhdHRlcm4oZSx0LGkpfX07dmFyIGR0PWZ1bmN0aW9uKHQsaSxzLG4scil7dGhpcy50b2tlbj10LHRoaXMuaXNFeHByPSEhaSx0aGlzLnByZXNlcnZlU3BhY2U9ISFzLHRoaXMub3ZlcnJpZGU9bix0aGlzLmdlbmVyYXRvcj0hIXJ9LGRlPXtiX3N0YXQ6bmV3IGR0KCJ7IiwhMSksYl9leHByOm5ldyBkdCgieyIsITApLGJfdG1wbDpuZXcgZHQoIiR7IiwhMSkscF9zdGF0Om5ldyBkdCgiKCIsITEpLHBfZXhwcjpuZXcgZHQoIigiLCEwKSxxX3RtcGw6bmV3IGR0KCJgIiwhMCwhMCxmdW5jdGlvbihlKXtyZXR1cm4gZS50cnlSZWFkVGVtcGxhdGVUb2tlbigpfSksZl9zdGF0Om5ldyBkdCgiZnVuY3Rpb24iLCExKSxmX2V4cHI6bmV3IGR0KCJmdW5jdGlvbiIsITApLGZfZXhwcl9nZW46bmV3IGR0KCJmdW5jdGlvbiIsITAsITEsbnVsbCwhMCksZl9nZW46bmV3IGR0KCJmdW5jdGlvbiIsITEsITEsbnVsbCwhMCl9LHppPVBlLnByb3RvdHlwZTt6aS5pbml0aWFsQ29udGV4dD1mdW5jdGlvbigpe3JldHVybltkZS5iX3N0YXRdfSx6aS5jdXJDb250ZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udGV4dFt0aGlzLmNvbnRleHQubGVuZ3RoLTFdfSx6aS5icmFjZUlzQmxvY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5jdXJDb250ZXh0KCk7cmV0dXJuIHQ9PT1kZS5mX2V4cHJ8fHQ9PT1kZS5mX3N0YXQ/ITA6ZT09PWQuY29sb24mJih0PT09ZGUuYl9zdGF0fHx0PT09ZGUuYl9leHByKT8hdC5pc0V4cHI6ZT09PWQuX3JldHVybnx8ZT09PWQubmFtZSYmdGhpcy5leHByQWxsb3dlZD9udC50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLHRoaXMuc3RhcnQpKTplPT09ZC5fZWxzZXx8ZT09PWQuc2VtaXx8ZT09PWQuZW9mfHxlPT09ZC5wYXJlblJ8fGU9PT1kLmFycm93PyEwOmU9PT1kLmJyYWNlTD90PT09ZGUuYl9zdGF0OmU9PT1kLl92YXJ8fGU9PT1kLl9jb25zdHx8ZT09PWQubmFtZT8hMTohdGhpcy5leHByQWxsb3dlZH0semkuaW5HZW5lcmF0b3JDb250ZXh0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuY29udGV4dC5sZW5ndGgtMTtlPj0xO2UtLSl7dmFyIHQ9dGhpcy5jb250ZXh0W2VdO2lmKHQudG9rZW49PT0iZnVuY3Rpb24iKXJldHVybiB0LmdlbmVyYXRvcn1yZXR1cm4hMX0semkudXBkYXRlQ29udGV4dD1mdW5jdGlvbihlKXt2YXIgdCxpPXRoaXMudHlwZTtpLmtleXdvcmQmJmU9PT1kLmRvdD90aGlzLmV4cHJBbGxvd2VkPSExOih0PWkudXBkYXRlQ29udGV4dCk/dC5jYWxsKHRoaXMsZSk6dGhpcy5leHByQWxsb3dlZD1pLmJlZm9yZUV4cHJ9LHppLm92ZXJyaWRlQ29udGV4dD1mdW5jdGlvbihlKXt0aGlzLmN1ckNvbnRleHQoKSE9PWUmJih0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aC0xXT1lKX0sZC5wYXJlblIudXBkYXRlQ29udGV4dD1kLmJyYWNlUi51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5jb250ZXh0Lmxlbmd0aD09PTEpe3RoaXMuZXhwckFsbG93ZWQ9ITA7cmV0dXJufXZhciBlPXRoaXMuY29udGV4dC5wb3AoKTtlPT09ZGUuYl9zdGF0JiZ0aGlzLmN1ckNvbnRleHQoKS50b2tlbj09PSJmdW5jdGlvbiImJihlPXRoaXMuY29udGV4dC5wb3AoKSksdGhpcy5leHByQWxsb3dlZD0hZS5pc0V4cHJ9LGQuYnJhY2VMLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSl7dGhpcy5jb250ZXh0LnB1c2godGhpcy5icmFjZUlzQmxvY2soZSk/ZGUuYl9zdGF0OmRlLmJfZXhwciksdGhpcy5leHByQWxsb3dlZD0hMH0sZC5kb2xsYXJCcmFjZUwudXBkYXRlQ29udGV4dD1mdW5jdGlvbigpe3RoaXMuY29udGV4dC5wdXNoKGRlLmJfdG1wbCksdGhpcy5leHByQWxsb3dlZD0hMH0sZC5wYXJlbkwudXBkYXRlQ29udGV4dD1mdW5jdGlvbihlKXt2YXIgdD1lPT09ZC5faWZ8fGU9PT1kLl9mb3J8fGU9PT1kLl93aXRofHxlPT09ZC5fd2hpbGU7dGhpcy5jb250ZXh0LnB1c2godD9kZS5wX3N0YXQ6ZGUucF9leHByKSx0aGlzLmV4cHJBbGxvd2VkPSEwfSxkLmluY0RlYy51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7fSxkLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0PWQuX2NsYXNzLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSl7ZS5iZWZvcmVFeHByJiZlIT09ZC5fZWxzZSYmIShlPT09ZC5zZW1pJiZ0aGlzLmN1ckNvbnRleHQoKSE9PWRlLnBfc3RhdCkmJiEoZT09PWQuX3JldHVybiYmbnQudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCx0aGlzLnN0YXJ0KSkpJiYhKChlPT09ZC5jb2xvbnx8ZT09PWQuYnJhY2VMKSYmdGhpcy5jdXJDb250ZXh0KCk9PT1kZS5iX3N0YXQpP3RoaXMuY29udGV4dC5wdXNoKGRlLmZfZXhwcik6dGhpcy5jb250ZXh0LnB1c2goZGUuZl9zdGF0KSx0aGlzLmV4cHJBbGxvd2VkPSExfSxkLmNvbG9uLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oKXt0aGlzLmN1ckNvbnRleHQoKS50b2tlbj09PSJmdW5jdGlvbiImJnRoaXMuY29udGV4dC5wb3AoKSx0aGlzLmV4cHJBbGxvd2VkPSEwfSxkLmJhY2tRdW90ZS51cGRhdGVDb250ZXh0PWZ1bmN0aW9uKCl7dGhpcy5jdXJDb250ZXh0KCk9PT1kZS5xX3RtcGw/dGhpcy5jb250ZXh0LnBvcCgpOnRoaXMuY29udGV4dC5wdXNoKGRlLnFfdG1wbCksdGhpcy5leHByQWxsb3dlZD0hMX0sZC5zdGFyLnVwZGF0ZUNvbnRleHQ9ZnVuY3Rpb24oZSl7aWYoZT09PWQuX2Z1bmN0aW9uKXt2YXIgdD10aGlzLmNvbnRleHQubGVuZ3RoLTE7dGhpcy5jb250ZXh0W3RdPT09ZGUuZl9leHByP3RoaXMuY29udGV4dFt0XT1kZS5mX2V4cHJfZ2VuOnRoaXMuY29udGV4dFt0XT1kZS5mX2dlbn10aGlzLmV4cHJBbGxvd2VkPSEwfSxkLm5hbWUudXBkYXRlQ29udGV4dD1mdW5jdGlvbihlKXt2YXIgdD0hMTt0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJmUhPT1kLmRvdCYmKHRoaXMudmFsdWU9PT0ib2YiJiYhdGhpcy5leHByQWxsb3dlZHx8dGhpcy52YWx1ZT09PSJ5aWVsZCImJnRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpJiYodD0hMCksdGhpcy5leHByQWxsb3dlZD10fTt2YXIgSD1QZS5wcm90b3R5cGU7SC5jaGVja1Byb3BDbGFzaD1mdW5jdGlvbihlLHQsaSl7aWYoISh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJmUudHlwZT09PSJTcHJlYWRFbGVtZW50IikmJiEodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiYoZS5jb21wdXRlZHx8ZS5tZXRob2R8fGUuc2hvcnRoYW5kKSkpe3ZhciBzPWUua2V5LG47c3dpdGNoKHMudHlwZSl7Y2FzZSJJZGVudGlmaWVyIjpuPXMubmFtZTticmVhaztjYXNlIkxpdGVyYWwiOm49U3RyaW5nKHMudmFsdWUpO2JyZWFrO2RlZmF1bHQ6cmV0dXJufXZhciByPWUua2luZDtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYpe249PT0iX19wcm90b19fIiYmcj09PSJpbml0IiYmKHQucHJvdG8mJihpP2kuZG91YmxlUHJvdG88MCYmKGkuZG91YmxlUHJvdG89cy5zdGFydCk6dGhpcy5yYWlzZVJlY292ZXJhYmxlKHMuc3RhcnQsIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHkiKSksdC5wcm90bz0hMCk7cmV0dXJufW49IiQiK247dmFyIGE9dFtuXTtpZihhKXt2YXIgbztyPT09ImluaXQiP289dGhpcy5zdHJpY3QmJmEuaW5pdHx8YS5nZXR8fGEuc2V0Om89YS5pbml0fHxhW3JdLG8mJnRoaXMucmFpc2VSZWNvdmVyYWJsZShzLnN0YXJ0LCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHkiKX1lbHNlIGE9dFtuXT17aW5pdDohMSxnZXQ6ITEsc2V0OiExfTthW3JdPSEwfX0sSC5wYXJzZUV4cHJlc3Npb249ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLnN0YXJ0LHM9dGhpcy5zdGFydExvYyxuPXRoaXMucGFyc2VNYXliZUFzc2lnbihlLHQpO2lmKHRoaXMudHlwZT09PWQuY29tbWEpe3ZhciByPXRoaXMuc3RhcnROb2RlQXQoaSxzKTtmb3Ioci5leHByZXNzaW9ucz1bbl07dGhpcy5lYXQoZC5jb21tYSk7KXIuZXhwcmVzc2lvbnMucHVzaCh0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSx0KSk7cmV0dXJuIHRoaXMuZmluaXNoTm9kZShyLCJTZXF1ZW5jZUV4cHJlc3Npb24iKX1yZXR1cm4gbn0sSC5wYXJzZU1heWJlQXNzaWduPWZ1bmN0aW9uKGUsdCxpKXtpZih0aGlzLmlzQ29udGV4dHVhbCgieWllbGQiKSl7aWYodGhpcy5pbkdlbmVyYXRvcilyZXR1cm4gdGhpcy5wYXJzZVlpZWxkKGUpO3RoaXMuZXhwckFsbG93ZWQ9ITF9dmFyIHM9ITEsbj0tMSxyPS0xLGE9LTE7dD8obj10LnBhcmVudGhlc2l6ZWRBc3NpZ24scj10LnRyYWlsaW5nQ29tbWEsYT10LmRvdWJsZVByb3RvLHQucGFyZW50aGVzaXplZEFzc2lnbj10LnRyYWlsaW5nQ29tbWE9LTEpOih0PW5ldyBUbixzPSEwKTt2YXIgbz10aGlzLnN0YXJ0LGg9dGhpcy5zdGFydExvYzsodGhpcy50eXBlPT09ZC5wYXJlbkx8fHRoaXMudHlwZT09PWQubmFtZSkmJih0aGlzLnBvdGVudGlhbEFycm93QXQ9dGhpcy5zdGFydCx0aGlzLnBvdGVudGlhbEFycm93SW5Gb3JBd2FpdD1lPT09ImF3YWl0Iik7dmFyIGw9dGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwoZSx0KTtpZihpJiYobD1pLmNhbGwodGhpcyxsLG8saCkpLHRoaXMudHlwZS5pc0Fzc2lnbil7dmFyIGM9dGhpcy5zdGFydE5vZGVBdChvLGgpO3JldHVybiBjLm9wZXJhdG9yPXRoaXMudmFsdWUsdGhpcy50eXBlPT09ZC5lcSYmKGw9dGhpcy50b0Fzc2lnbmFibGUobCwhMSx0KSksc3x8KHQucGFyZW50aGVzaXplZEFzc2lnbj10LnRyYWlsaW5nQ29tbWE9dC5kb3VibGVQcm90bz0tMSksdC5zaG9ydGhhbmRBc3NpZ24+PWwuc3RhcnQmJih0LnNob3J0aGFuZEFzc2lnbj0tMSksdGhpcy50eXBlPT09ZC5lcT90aGlzLmNoZWNrTFZhbFBhdHRlcm4obCk6dGhpcy5jaGVja0xWYWxTaW1wbGUobCksYy5sZWZ0PWwsdGhpcy5uZXh0KCksYy5yaWdodD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSksYT4tMSYmKHQuZG91YmxlUHJvdG89YSksdGhpcy5maW5pc2hOb2RlKGMsIkFzc2lnbm1lbnRFeHByZXNzaW9uIil9ZWxzZSBzJiZ0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyh0LCEwKTtyZXR1cm4gbj4tMSYmKHQucGFyZW50aGVzaXplZEFzc2lnbj1uKSxyPi0xJiYodC50cmFpbGluZ0NvbW1hPXIpLGx9LEgucGFyc2VNYXliZUNvbmRpdGlvbmFsPWZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcy5zdGFydCxzPXRoaXMuc3RhcnRMb2Msbj10aGlzLnBhcnNlRXhwck9wcyhlLHQpO2lmKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHQpKXJldHVybiBuO2lmKHRoaXMuZWF0KGQucXVlc3Rpb24pKXt2YXIgcj10aGlzLnN0YXJ0Tm9kZUF0KGkscyk7cmV0dXJuIHIudGVzdD1uLHIuY29uc2VxdWVudD10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmV4cGVjdChkLmNvbG9uKSxyLmFsdGVybmF0ZT10aGlzLnBhcnNlTWF5YmVBc3NpZ24oZSksdGhpcy5maW5pc2hOb2RlKHIsIkNvbmRpdGlvbmFsRXhwcmVzc2lvbiIpfXJldHVybiBufSxILnBhcnNlRXhwck9wcz1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMuc3RhcnQscz10aGlzLnN0YXJ0TG9jLG49dGhpcy5wYXJzZU1heWJlVW5hcnkodCwhMSwhMSxlKTtyZXR1cm4gdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnModCl8fG4uc3RhcnQ9PT1pJiZuLnR5cGU9PT0iQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iP246dGhpcy5wYXJzZUV4cHJPcChuLGkscywtMSxlKX0sSC5wYXJzZUV4cHJPcD1mdW5jdGlvbihlLHQsaSxzLG4pe3ZhciByPXRoaXMudHlwZS5iaW5vcDtpZihyIT1udWxsJiYoIW58fHRoaXMudHlwZSE9PWQuX2luKSYmcj5zKXt2YXIgYT10aGlzLnR5cGU9PT1kLmxvZ2ljYWxPUnx8dGhpcy50eXBlPT09ZC5sb2dpY2FsQU5ELG89dGhpcy50eXBlPT09ZC5jb2FsZXNjZTtvJiYocj1kLmxvZ2ljYWxBTkQuYmlub3ApO3ZhciBoPXRoaXMudmFsdWU7dGhpcy5uZXh0KCk7dmFyIGw9dGhpcy5zdGFydCxjPXRoaXMuc3RhcnRMb2MscD10aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsITEsITEsbiksbCxjLHIsbiksbT10aGlzLmJ1aWxkQmluYXJ5KHQsaSxlLHAsaCxhfHxvKTtyZXR1cm4oYSYmdGhpcy50eXBlPT09ZC5jb2FsZXNjZXx8byYmKHRoaXMudHlwZT09PWQubG9naWNhbE9SfHx0aGlzLnR5cGU9PT1kLmxvZ2ljYWxBTkQpKSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkxvZ2ljYWwgZXhwcmVzc2lvbnMgYW5kIGNvYWxlc2NlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBtaXhlZC4gV3JhcCBlaXRoZXIgYnkgcGFyZW50aGVzZXMiKSx0aGlzLnBhcnNlRXhwck9wKG0sdCxpLHMsbil9cmV0dXJuIGV9LEguYnVpbGRCaW5hcnk9ZnVuY3Rpb24oZSx0LGkscyxuLHIpe3MudHlwZT09PSJQcml2YXRlSWRlbnRpZmllciImJnRoaXMucmFpc2Uocy5zdGFydCwiUHJpdmF0ZSBpZGVudGlmaWVyIGNhbiBvbmx5IGJlIGxlZnQgc2lkZSBvZiBiaW5hcnkgZXhwcmVzc2lvbiIpO3ZhciBhPXRoaXMuc3RhcnROb2RlQXQoZSx0KTtyZXR1cm4gYS5sZWZ0PWksYS5vcGVyYXRvcj1uLGEucmlnaHQ9cyx0aGlzLmZpbmlzaE5vZGUoYSxyPyJMb2dpY2FsRXhwcmVzc2lvbiI6IkJpbmFyeUV4cHJlc3Npb24iKX0sSC5wYXJzZU1heWJlVW5hcnk9ZnVuY3Rpb24oZSx0LGkscyl7dmFyIG49dGhpcy5zdGFydCxyPXRoaXMuc3RhcnRMb2MsYTtpZih0aGlzLmlzQ29udGV4dHVhbCgiYXdhaXQiKSYmdGhpcy5jYW5Bd2FpdClhPXRoaXMucGFyc2VBd2FpdChzKSx0PSEwO2Vsc2UgaWYodGhpcy50eXBlLnByZWZpeCl7dmFyIG89dGhpcy5zdGFydE5vZGUoKSxoPXRoaXMudHlwZT09PWQuaW5jRGVjO28ub3BlcmF0b3I9dGhpcy52YWx1ZSxvLnByZWZpeD0hMCx0aGlzLm5leHQoKSxvLmFyZ3VtZW50PXRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsITAsaCxzKSx0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhlLCEwKSxoP3RoaXMuY2hlY2tMVmFsU2ltcGxlKG8uYXJndW1lbnQpOnRoaXMuc3RyaWN0JiZvLm9wZXJhdG9yPT09ImRlbGV0ZSImJm8uYXJndW1lbnQudHlwZT09PSJJZGVudGlmaWVyIj90aGlzLnJhaXNlUmVjb3ZlcmFibGUoby5zdGFydCwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGUiKTpvLm9wZXJhdG9yPT09ImRlbGV0ZSImJkZ1KG8uYXJndW1lbnQpP3RoaXMucmFpc2VSZWNvdmVyYWJsZShvLnN0YXJ0LCJQcml2YXRlIGZpZWxkcyBjYW4gbm90IGJlIGRlbGV0ZWQiKTp0PSEwLGE9dGhpcy5maW5pc2hOb2RlKG8saD8iVXBkYXRlRXhwcmVzc2lvbiI6IlVuYXJ5RXhwcmVzc2lvbiIpfWVsc2UgaWYoIXQmJnRoaXMudHlwZT09PWQucHJpdmF0ZUlkKShzfHx0aGlzLnByaXZhdGVOYW1lU3RhY2subGVuZ3RoPT09MCkmJnRoaXMub3B0aW9ucy5jaGVja1ByaXZhdGVGaWVsZHMmJnRoaXMudW5leHBlY3RlZCgpLGE9dGhpcy5wYXJzZVByaXZhdGVJZGVudCgpLHRoaXMudHlwZSE9PWQuX2luJiZ0aGlzLnVuZXhwZWN0ZWQoKTtlbHNle2lmKGE9dGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKGUscyksdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMoZSkpcmV0dXJuIGE7Zm9yKDt0aGlzLnR5cGUucG9zdGZpeCYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7KXt2YXIgbD10aGlzLnN0YXJ0Tm9kZUF0KG4scik7bC5vcGVyYXRvcj10aGlzLnZhbHVlLGwucHJlZml4PSExLGwuYXJndW1lbnQ9YSx0aGlzLmNoZWNrTFZhbFNpbXBsZShhKSx0aGlzLm5leHQoKSxhPXRoaXMuZmluaXNoTm9kZShsLCJVcGRhdGVFeHByZXNzaW9uIil9fWlmKCFpJiZ0aGlzLmVhdChkLnN0YXJzdGFyKSlpZih0KXRoaXMudW5leHBlY3RlZCh0aGlzLmxhc3RUb2tTdGFydCk7ZWxzZSByZXR1cm4gdGhpcy5idWlsZEJpbmFyeShuLHIsYSx0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCExLCExLHMpLCIqKiIsITEpO2Vsc2UgcmV0dXJuIGF9O2Z1bmN0aW9uIEZ1KGUpe3JldHVybiBlLnR5cGU9PT0iTWVtYmVyRXhwcmVzc2lvbiImJmUucHJvcGVydHkudHlwZT09PSJQcml2YXRlSWRlbnRpZmllciJ8fGUudHlwZT09PSJDaGFpbkV4cHJlc3Npb24iJiZGdShlLmV4cHJlc3Npb24pfUgucGFyc2VFeHByU3Vic2NyaXB0cz1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMuc3RhcnQscz10aGlzLnN0YXJ0TG9jLG49dGhpcy5wYXJzZUV4cHJBdG9tKGUsdCk7aWYobi50eXBlPT09IkFycm93RnVuY3Rpb25FeHByZXNzaW9uIiYmdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCx0aGlzLmxhc3RUb2tFbmQpIT09IikiKXJldHVybiBuO3ZhciByPXRoaXMucGFyc2VTdWJzY3JpcHRzKG4saSxzLCExLHQpO3JldHVybiBlJiZyLnR5cGU9PT0iTWVtYmVyRXhwcmVzc2lvbiImJihlLnBhcmVudGhlc2l6ZWRBc3NpZ24+PXIuc3RhcnQmJihlLnBhcmVudGhlc2l6ZWRBc3NpZ249LTEpLGUucGFyZW50aGVzaXplZEJpbmQ+PXIuc3RhcnQmJihlLnBhcmVudGhlc2l6ZWRCaW5kPS0xKSxlLnRyYWlsaW5nQ29tbWE+PXIuc3RhcnQmJihlLnRyYWlsaW5nQ29tbWE9LTEpKSxyfSxILnBhcnNlU3Vic2NyaXB0cz1mdW5jdGlvbihlLHQsaSxzLG4pe2Zvcih2YXIgcj10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJmUudHlwZT09PSJJZGVudGlmaWVyIiYmZS5uYW1lPT09ImFzeW5jIiYmdGhpcy5sYXN0VG9rRW5kPT09ZS5lbmQmJiF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpJiZlLmVuZC1lLnN0YXJ0PT09NSYmdGhpcy5wb3RlbnRpYWxBcnJvd0F0PT09ZS5zdGFydCxhPSExOzspe3ZhciBvPXRoaXMucGFyc2VTdWJzY3JpcHQoZSx0LGkscyxyLGEsbik7aWYoby5vcHRpb25hbCYmKGE9ITApLG89PT1lfHxvLnR5cGU9PT0iQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24iKXtpZihhKXt2YXIgaD10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7aC5leHByZXNzaW9uPW8sbz10aGlzLmZpbmlzaE5vZGUoaCwiQ2hhaW5FeHByZXNzaW9uIil9cmV0dXJuIG99ZT1vfX0sSC5zaG91bGRQYXJzZUFzeW5jQXJyb3c9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSYmdGhpcy5lYXQoZC5hcnJvdyl9LEgucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93PWZ1bmN0aW9uKGUsdCxpLHMpe3JldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoZSx0KSxpLCEwLHMpfSxILnBhcnNlU3Vic2NyaXB0PWZ1bmN0aW9uKGUsdCxpLHMsbixyLGEpe3ZhciBvPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEsaD1vJiZ0aGlzLmVhdChkLnF1ZXN0aW9uRG90KTtzJiZoJiZ0aGlzLnJhaXNlKHRoaXMubGFzdFRva1N0YXJ0LCJPcHRpb25hbCBjaGFpbmluZyBjYW5ub3QgYXBwZWFyIGluIHRoZSBjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb25zIik7dmFyIGw9dGhpcy5lYXQoZC5icmFja2V0TCk7aWYobHx8aCYmdGhpcy50eXBlIT09ZC5wYXJlbkwmJnRoaXMudHlwZSE9PWQuYmFja1F1b3RlfHx0aGlzLmVhdChkLmRvdCkpe3ZhciBjPXRoaXMuc3RhcnROb2RlQXQodCxpKTtjLm9iamVjdD1lLGw/KGMucHJvcGVydHk9dGhpcy5wYXJzZUV4cHJlc3Npb24oKSx0aGlzLmV4cGVjdChkLmJyYWNrZXRSKSk6dGhpcy50eXBlPT09ZC5wcml2YXRlSWQmJmUudHlwZSE9PSJTdXBlciI/Yy5wcm9wZXJ0eT10aGlzLnBhcnNlUHJpdmF0ZUlkZW50KCk6Yy5wcm9wZXJ0eT10aGlzLnBhcnNlSWRlbnQodGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQhPT0ibmV2ZXIiKSxjLmNvbXB1dGVkPSEhbCxvJiYoYy5vcHRpb25hbD1oKSxlPXRoaXMuZmluaXNoTm9kZShjLCJNZW1iZXJFeHByZXNzaW9uIil9ZWxzZSBpZighcyYmdGhpcy5lYXQoZC5wYXJlbkwpKXt2YXIgcD1uZXcgVG4sbT10aGlzLnlpZWxkUG9zLHk9dGhpcy5hd2FpdFBvcyxFPXRoaXMuYXdhaXRJZGVudFBvczt0aGlzLnlpZWxkUG9zPTAsdGhpcy5hd2FpdFBvcz0wLHRoaXMuYXdhaXRJZGVudFBvcz0wO3ZhciBnPXRoaXMucGFyc2VFeHByTGlzdChkLnBhcmVuUix0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgsITEscCk7aWYobiYmIWgmJnRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkpcmV0dXJuIHRoaXMuY2hlY2tQYXR0ZXJuRXJyb3JzKHAsITEpLHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCksdGhpcy5hd2FpdElkZW50UG9zPjAmJnRoaXMucmFpc2UodGhpcy5hd2FpdElkZW50UG9zLCJDYW5ub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb24iKSx0aGlzLnlpZWxkUG9zPW0sdGhpcy5hd2FpdFBvcz15LHRoaXMuYXdhaXRJZGVudFBvcz1FLHRoaXMucGFyc2VTdWJzY3JpcHRBc3luY0Fycm93KHQsaSxnLGEpO3RoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHAsITApLHRoaXMueWllbGRQb3M9bXx8dGhpcy55aWVsZFBvcyx0aGlzLmF3YWl0UG9zPXl8fHRoaXMuYXdhaXRQb3MsdGhpcy5hd2FpdElkZW50UG9zPUV8fHRoaXMuYXdhaXRJZGVudFBvczt2YXIgeD10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7eC5jYWxsZWU9ZSx4LmFyZ3VtZW50cz1nLG8mJih4Lm9wdGlvbmFsPWgpLGU9dGhpcy5maW5pc2hOb2RlKHgsIkNhbGxFeHByZXNzaW9uIil9ZWxzZSBpZih0aGlzLnR5cGU9PT1kLmJhY2tRdW90ZSl7KGh8fHIpJiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIk9wdGlvbmFsIGNoYWluaW5nIGNhbm5vdCBhcHBlYXIgaW4gdGhlIHRhZyBvZiB0YWdnZWQgdGVtcGxhdGUgZXhwcmVzc2lvbnMiKTt2YXIgdj10aGlzLnN0YXJ0Tm9kZUF0KHQsaSk7di50YWc9ZSx2LnF1YXNpPXRoaXMucGFyc2VUZW1wbGF0ZSh7aXNUYWdnZWQ6ITB9KSxlPXRoaXMuZmluaXNoTm9kZSh2LCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24iKX1yZXR1cm4gZX0sSC5wYXJzZUV4cHJBdG9tPWZ1bmN0aW9uKGUsdCxpKXt0aGlzLnR5cGU9PT1kLnNsYXNoJiZ0aGlzLnJlYWRSZWdleHAoKTt2YXIgcyxuPXRoaXMucG90ZW50aWFsQXJyb3dBdD09PXRoaXMuc3RhcnQ7c3dpdGNoKHRoaXMudHlwZSl7Y2FzZSBkLl9zdXBlcjpyZXR1cm4gdGhpcy5hbGxvd1N1cGVyfHx0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIidzdXBlcicga2V5d29yZCBvdXRzaWRlIGEgbWV0aG9kIikscz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMubmV4dCgpLHRoaXMudHlwZT09PWQucGFyZW5MJiYhdGhpcy5hbGxvd0RpcmVjdFN1cGVyJiZ0aGlzLnJhaXNlKHMuc3RhcnQsInN1cGVyKCkgY2FsbCBvdXRzaWRlIGNvbnN0cnVjdG9yIG9mIGEgc3ViY2xhc3MiKSx0aGlzLnR5cGUhPT1kLmRvdCYmdGhpcy50eXBlIT09ZC5icmFja2V0TCYmdGhpcy50eXBlIT09ZC5wYXJlbkwmJnRoaXMudW5leHBlY3RlZCgpLHRoaXMuZmluaXNoTm9kZShzLCJTdXBlciIpO2Nhc2UgZC5fdGhpczpyZXR1cm4gcz10aGlzLnN0YXJ0Tm9kZSgpLHRoaXMubmV4dCgpLHRoaXMuZmluaXNoTm9kZShzLCJUaGlzRXhwcmVzc2lvbiIpO2Nhc2UgZC5uYW1lOnZhciByPXRoaXMuc3RhcnQsYT10aGlzLnN0YXJ0TG9jLG89dGhpcy5jb250YWluc0VzYyxoPXRoaXMucGFyc2VJZGVudCghMSk7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04JiYhbyYmaC5uYW1lPT09ImFzeW5jIiYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkmJnRoaXMuZWF0KGQuX2Z1bmN0aW9uKSlyZXR1cm4gdGhpcy5vdmVycmlkZUNvbnRleHQoZGUuZl9leHByKSx0aGlzLnBhcnNlRnVuY3Rpb24odGhpcy5zdGFydE5vZGVBdChyLGEpLDAsITEsITAsdCk7aWYobiYmIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpe2lmKHRoaXMuZWF0KGQuYXJyb3cpKXJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQocixhKSxbaF0sITEsdCk7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04JiZoLm5hbWU9PT0iYXN5bmMiJiZ0aGlzLnR5cGU9PT1kLm5hbWUmJiFvJiYoIXRoaXMucG90ZW50aWFsQXJyb3dJbkZvckF3YWl0fHx0aGlzLnZhbHVlIT09Im9mInx8dGhpcy5jb250YWluc0VzYykpcmV0dXJuIGg9dGhpcy5wYXJzZUlkZW50KCExKSwodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKXx8IXRoaXMuZWF0KGQuYXJyb3cpKSYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHIsYSksW2hdLCEwLHQpfXJldHVybiBoO2Nhc2UgZC5yZWdleHA6dmFyIGw9dGhpcy52YWx1ZTtyZXR1cm4gcz10aGlzLnBhcnNlTGl0ZXJhbChsLnZhbHVlKSxzLnJlZ2V4PXtwYXR0ZXJuOmwucGF0dGVybixmbGFnczpsLmZsYWdzfSxzO2Nhc2UgZC5udW06Y2FzZSBkLnN0cmluZzpyZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSk7Y2FzZSBkLl9udWxsOmNhc2UgZC5fdHJ1ZTpjYXNlIGQuX2ZhbHNlOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCkscy52YWx1ZT10aGlzLnR5cGU9PT1kLl9udWxsP251bGw6dGhpcy50eXBlPT09ZC5fdHJ1ZSxzLnJhdz10aGlzLnR5cGUua2V5d29yZCx0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUocywiTGl0ZXJhbCIpO2Nhc2UgZC5wYXJlbkw6dmFyIGM9dGhpcy5zdGFydCxwPXRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihuLHQpO3JldHVybiBlJiYoZS5wYXJlbnRoZXNpemVkQXNzaWduPDAmJiF0aGlzLmlzU2ltcGxlQXNzaWduVGFyZ2V0KHApJiYoZS5wYXJlbnRoZXNpemVkQXNzaWduPWMpLGUucGFyZW50aGVzaXplZEJpbmQ8MCYmKGUucGFyZW50aGVzaXplZEJpbmQ9YykpLHA7Y2FzZSBkLmJyYWNrZXRMOnJldHVybiBzPXRoaXMuc3RhcnROb2RlKCksdGhpcy5uZXh0KCkscy5lbGVtZW50cz10aGlzLnBhcnNlRXhwckxpc3QoZC5icmFja2V0UiwhMCwhMCxlKSx0aGlzLmZpbmlzaE5vZGUocywiQXJyYXlFeHByZXNzaW9uIik7Y2FzZSBkLmJyYWNlTDpyZXR1cm4gdGhpcy5vdmVycmlkZUNvbnRleHQoZGUuYl9leHByKSx0aGlzLnBhcnNlT2JqKCExLGUpO2Nhc2UgZC5fZnVuY3Rpb246cmV0dXJuIHM9dGhpcy5zdGFydE5vZGUoKSx0aGlzLm5leHQoKSx0aGlzLnBhcnNlRnVuY3Rpb24ocywwKTtjYXNlIGQuX2NsYXNzOnJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwhMSk7Y2FzZSBkLl9uZXc6cmV0dXJuIHRoaXMucGFyc2VOZXcoKTtjYXNlIGQuYmFja1F1b3RlOnJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKTtjYXNlIGQuX2ltcG9ydDpyZXR1cm4gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMT90aGlzLnBhcnNlRXhwckltcG9ydChpKTp0aGlzLnVuZXhwZWN0ZWQoKTtkZWZhdWx0OnJldHVybiB0aGlzLnBhcnNlRXhwckF0b21EZWZhdWx0KCl9fSxILnBhcnNlRXhwckF0b21EZWZhdWx0PWZ1bmN0aW9uKCl7dGhpcy51bmV4cGVjdGVkKCl9LEgucGFyc2VFeHBySW1wb3J0PWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuc3RhcnROb2RlKCk7dGhpcy5jb250YWluc0VzYyYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkIGltcG9ydCIpO3ZhciBpPXRoaXMucGFyc2VJZGVudCghMCk7aWYodGhpcy50eXBlPT09ZC5wYXJlbkwmJiFlKXJldHVybiB0aGlzLnBhcnNlRHluYW1pY0ltcG9ydCh0KTtpZih0aGlzLnR5cGU9PT1kLmRvdClyZXR1cm4gdC5tZXRhPWksdGhpcy5wYXJzZUltcG9ydE1ldGEodCk7dGhpcy51bmV4cGVjdGVkKCl9LEgucGFyc2VEeW5hbWljSW1wb3J0PWZ1bmN0aW9uKGUpe2lmKHRoaXMubmV4dCgpLGUuc291cmNlPXRoaXMucGFyc2VNYXliZUFzc2lnbigpLCF0aGlzLmVhdChkLnBhcmVuUikpe3ZhciB0PXRoaXMuc3RhcnQ7dGhpcy5lYXQoZC5jb21tYSkmJnRoaXMuZWF0KGQucGFyZW5SKT90aGlzLnJhaXNlUmVjb3ZlcmFibGUodCwiVHJhaWxpbmcgY29tbWEgaXMgbm90IGFsbG93ZWQgaW4gaW1wb3J0KCkiKTp0aGlzLnVuZXhwZWN0ZWQodCl9cmV0dXJuIHRoaXMuZmluaXNoTm9kZShlLCJJbXBvcnRFeHByZXNzaW9uIil9LEgucGFyc2VJbXBvcnRNZXRhPWZ1bmN0aW9uKGUpe3RoaXMubmV4dCgpO3ZhciB0PXRoaXMuY29udGFpbnNFc2M7cmV0dXJuIGUucHJvcGVydHk9dGhpcy5wYXJzZUlkZW50KCEwKSxlLnByb3BlcnR5Lm5hbWUhPT0ibWV0YSImJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnByb3BlcnR5LnN0YXJ0LCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBpbXBvcnQgaXMgJ2ltcG9ydC5tZXRhJyIpLHQmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCInaW1wb3J0Lm1ldGEnIG11c3Qgbm90IGNvbnRhaW4gZXNjYXBlZCBjaGFyYWN0ZXJzIiksdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUhPT0ibW9kdWxlIiYmIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCJDYW5ub3QgdXNlICdpbXBvcnQubWV0YScgb3V0c2lkZSBhIG1vZHVsZSIpLHRoaXMuZmluaXNoTm9kZShlLCJNZXRhUHJvcGVydHkiKX0sSC5wYXJzZUxpdGVyYWw9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdC52YWx1ZT1lLHQucmF3PXRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCx0aGlzLmVuZCksdC5yYXcuY2hhckNvZGVBdCh0LnJhdy5sZW5ndGgtMSk9PT0xMTAmJih0LmJpZ2ludD10LnJhdy5zbGljZSgwLC0xKS5yZXBsYWNlKC9fL2csIiIpKSx0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUodCwiTGl0ZXJhbCIpfSxILnBhcnNlUGFyZW5FeHByZXNzaW9uPWZ1bmN0aW9uKCl7dGhpcy5leHBlY3QoZC5wYXJlbkwpO3ZhciBlPXRoaXMucGFyc2VFeHByZXNzaW9uKCk7cmV0dXJuIHRoaXMuZXhwZWN0KGQucGFyZW5SKSxlfSxILnNob3VsZFBhcnNlQXJyb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCl9LEgucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbj1mdW5jdGlvbihlLHQpe3ZhciBpPXRoaXMuc3RhcnQscz10aGlzLnN0YXJ0TG9jLG4scj10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTg7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXt0aGlzLm5leHQoKTt2YXIgYT10aGlzLnN0YXJ0LG89dGhpcy5zdGFydExvYyxoPVtdLGw9ITAsYz0hMSxwPW5ldyBUbixtPXRoaXMueWllbGRQb3MseT10aGlzLmF3YWl0UG9zLEU7Zm9yKHRoaXMueWllbGRQb3M9MCx0aGlzLmF3YWl0UG9zPTA7dGhpcy50eXBlIT09ZC5wYXJlblI7KWlmKGw/bD0hMTp0aGlzLmV4cGVjdChkLmNvbW1hKSxyJiZ0aGlzLmFmdGVyVHJhaWxpbmdDb21tYShkLnBhcmVuUiwhMCkpe2M9ITA7YnJlYWt9ZWxzZSBpZih0aGlzLnR5cGU9PT1kLmVsbGlwc2lzKXtFPXRoaXMuc3RhcnQsaC5wdXNoKHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVJlc3RCaW5kaW5nKCkpKSx0aGlzLnR5cGU9PT1kLmNvbW1hJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50Iik7YnJlYWt9ZWxzZSBoLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKCExLHAsdGhpcy5wYXJzZVBhcmVuSXRlbSkpO3ZhciBnPXRoaXMubGFzdFRva0VuZCx4PXRoaXMubGFzdFRva0VuZExvYztpZih0aGlzLmV4cGVjdChkLnBhcmVuUiksZSYmdGhpcy5zaG91bGRQYXJzZUFycm93KGgpJiZ0aGlzLmVhdChkLmFycm93KSlyZXR1cm4gdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocCwhMSksdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKSx0aGlzLnlpZWxkUG9zPW0sdGhpcy5hd2FpdFBvcz15LHRoaXMucGFyc2VQYXJlbkFycm93TGlzdChpLHMsaCx0KTsoIWgubGVuZ3RofHxjKSYmdGhpcy51bmV4cGVjdGVkKHRoaXMubGFzdFRva1N0YXJ0KSxFJiZ0aGlzLnVuZXhwZWN0ZWQoRSksdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocCwhMCksdGhpcy55aWVsZFBvcz1tfHx0aGlzLnlpZWxkUG9zLHRoaXMuYXdhaXRQb3M9eXx8dGhpcy5hd2FpdFBvcyxoLmxlbmd0aD4xPyhuPXRoaXMuc3RhcnROb2RlQXQoYSxvKSxuLmV4cHJlc3Npb25zPWgsdGhpcy5maW5pc2hOb2RlQXQobiwiU2VxdWVuY2VFeHByZXNzaW9uIixnLHgpKTpuPWhbMF19ZWxzZSBuPXRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtpZih0aGlzLm9wdGlvbnMucHJlc2VydmVQYXJlbnMpe3ZhciB2PXRoaXMuc3RhcnROb2RlQXQoaSxzKTtyZXR1cm4gdi5leHByZXNzaW9uPW4sdGhpcy5maW5pc2hOb2RlKHYsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIil9ZWxzZSByZXR1cm4gbn0sSC5wYXJzZVBhcmVuSXRlbT1mdW5jdGlvbihlKXtyZXR1cm4gZX0sSC5wYXJzZVBhcmVuQXJyb3dMaXN0PWZ1bmN0aW9uKGUsdCxpLHMpe3JldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoZSx0KSxpLCExLHMpfTt2YXIgc2c9W107SC5wYXJzZU5ldz1mdW5jdGlvbigpe3RoaXMuY29udGFpbnNFc2MmJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBuZXciKTt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO2lmKHRoaXMubmV4dCgpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmdGhpcy50eXBlPT09ZC5kb3Qpe3ZhciB0PXRoaXMuc3RhcnROb2RlQXQoZS5zdGFydCxlLnN0YXJ0TG9jKTt0Lm5hbWU9Im5ldyIsZS5tZXRhPXRoaXMuZmluaXNoTm9kZSh0LCJJZGVudGlmaWVyIiksdGhpcy5uZXh0KCk7dmFyIGk9dGhpcy5jb250YWluc0VzYztyZXR1cm4gZS5wcm9wZXJ0eT10aGlzLnBhcnNlSWRlbnQoITApLGUucHJvcGVydHkubmFtZSE9PSJ0YXJnZXQiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5wcm9wZXJ0eS5zdGFydCwiVGhlIG9ubHkgdmFsaWQgbWV0YSBwcm9wZXJ0eSBmb3IgbmV3IGlzICduZXcudGFyZ2V0JyIpLGkmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShlLnN0YXJ0LCInbmV3LnRhcmdldCcgbXVzdCBub3QgY29udGFpbiBlc2NhcGVkIGNoYXJhY3RlcnMiKSx0aGlzLmFsbG93TmV3RG90VGFyZ2V0fHx0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiJ25ldy50YXJnZXQnIGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zIGFuZCBjbGFzcyBzdGF0aWMgYmxvY2siKSx0aGlzLmZpbmlzaE5vZGUoZSwiTWV0YVByb3BlcnR5Iil9dmFyIHM9dGhpcy5zdGFydCxuPXRoaXMuc3RhcnRMb2M7cmV0dXJuIGUuY2FsbGVlPXRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbShudWxsLCExLCEwKSxzLG4sITAsITEpLHRoaXMuZWF0KGQucGFyZW5MKT9lLmFyZ3VtZW50cz10aGlzLnBhcnNlRXhwckxpc3QoZC5wYXJlblIsdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj04LCExKTplLmFyZ3VtZW50cz1zZyx0aGlzLmZpbmlzaE5vZGUoZSwiTmV3RXhwcmVzc2lvbiIpfSxILnBhcnNlVGVtcGxhdGVFbGVtZW50PWZ1bmN0aW9uKGUpe3ZhciB0PWUuaXNUYWdnZWQsaT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLnR5cGU9PT1kLmludmFsaWRUZW1wbGF0ZT8odHx8dGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkJhZCBlc2NhcGUgc2VxdWVuY2UgaW4gdW50YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbCIpLGkudmFsdWU9e3Jhdzp0aGlzLnZhbHVlLGNvb2tlZDpudWxsfSk6aS52YWx1ZT17cmF3OnRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCx0aGlzLmVuZCkucmVwbGFjZSgvXHJcbj8vZyxgCmApLGNvb2tlZDp0aGlzLnZhbHVlfSx0aGlzLm5leHQoKSxpLnRhaWw9dGhpcy50eXBlPT09ZC5iYWNrUXVvdGUsdGhpcy5maW5pc2hOb2RlKGksIlRlbXBsYXRlRWxlbWVudCIpfSxILnBhcnNlVGVtcGxhdGU9ZnVuY3Rpb24oZSl7ZT09PXZvaWQgMCYmKGU9e30pO3ZhciB0PWUuaXNUYWdnZWQ7dD09PXZvaWQgMCYmKHQ9ITEpO3ZhciBpPXRoaXMuc3RhcnROb2RlKCk7dGhpcy5uZXh0KCksaS5leHByZXNzaW9ucz1bXTt2YXIgcz10aGlzLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDp0fSk7Zm9yKGkucXVhc2lzPVtzXTshcy50YWlsOyl0aGlzLnR5cGU9PT1kLmVvZiYmdGhpcy5yYWlzZSh0aGlzLnBvcywiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIGxpdGVyYWwiKSx0aGlzLmV4cGVjdChkLmRvbGxhckJyYWNlTCksaS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VFeHByZXNzaW9uKCkpLHRoaXMuZXhwZWN0KGQuYnJhY2VSKSxpLnF1YXNpcy5wdXNoKHM9dGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6dH0pKTtyZXR1cm4gdGhpcy5uZXh0KCksdGhpcy5maW5pc2hOb2RlKGksIlRlbXBsYXRlTGl0ZXJhbCIpfSxILmlzQXN5bmNQcm9wPWZ1bmN0aW9uKGUpe3JldHVybiFlLmNvbXB1dGVkJiZlLmtleS50eXBlPT09IklkZW50aWZpZXIiJiZlLmtleS5uYW1lPT09ImFzeW5jIiYmKHRoaXMudHlwZT09PWQubmFtZXx8dGhpcy50eXBlPT09ZC5udW18fHRoaXMudHlwZT09PWQuc3RyaW5nfHx0aGlzLnR5cGU9PT1kLmJyYWNrZXRMfHx0aGlzLnR5cGUua2V5d29yZHx8dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiZ0aGlzLnR5cGU9PT1kLnN0YXIpJiYhbnQudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCx0aGlzLnN0YXJ0KSl9LEgucGFyc2VPYmo9ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLnN0YXJ0Tm9kZSgpLHM9ITAsbj17fTtmb3IoaS5wcm9wZXJ0aWVzPVtdLHRoaXMubmV4dCgpOyF0aGlzLmVhdChkLmJyYWNlUik7KXtpZihzKXM9ITE7ZWxzZSBpZih0aGlzLmV4cGVjdChkLmNvbW1hKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTUmJnRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGQuYnJhY2VSKSlicmVhazt2YXIgcj10aGlzLnBhcnNlUHJvcGVydHkoZSx0KTtlfHx0aGlzLmNoZWNrUHJvcENsYXNoKHIsbix0KSxpLnByb3BlcnRpZXMucHVzaChyKX1yZXR1cm4gdGhpcy5maW5pc2hOb2RlKGksZT8iT2JqZWN0UGF0dGVybiI6Ik9iamVjdEV4cHJlc3Npb24iKX0sSC5wYXJzZVByb3BlcnR5PWZ1bmN0aW9uKGUsdCl7dmFyIGk9dGhpcy5zdGFydE5vZGUoKSxzLG4scixhO2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmdGhpcy5lYXQoZC5lbGxpcHNpcykpcmV0dXJuIGU/KGkuYXJndW1lbnQ9dGhpcy5wYXJzZUlkZW50KCExKSx0aGlzLnR5cGU9PT1kLmNvbW1hJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50IiksdGhpcy5maW5pc2hOb2RlKGksIlJlc3RFbGVtZW50IikpOihpLmFyZ3VtZW50PXRoaXMucGFyc2VNYXliZUFzc2lnbighMSx0KSx0aGlzLnR5cGU9PT1kLmNvbW1hJiZ0JiZ0LnRyYWlsaW5nQ29tbWE8MCYmKHQudHJhaWxpbmdDb21tYT10aGlzLnN0YXJ0KSx0aGlzLmZpbmlzaE5vZGUoaSwiU3ByZWFkRWxlbWVudCIpKTt0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJihpLm1ldGhvZD0hMSxpLnNob3J0aGFuZD0hMSwoZXx8dCkmJihyPXRoaXMuc3RhcnQsYT10aGlzLnN0YXJ0TG9jKSxlfHwocz10aGlzLmVhdChkLnN0YXIpKSk7dmFyIG89dGhpcy5jb250YWluc0VzYztyZXR1cm4gdGhpcy5wYXJzZVByb3BlcnR5TmFtZShpKSwhZSYmIW8mJnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCYmIXMmJnRoaXMuaXNBc3luY1Byb3AoaSk/KG49ITAscz10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJnRoaXMuZWF0KGQuc3RhciksdGhpcy5wYXJzZVByb3BlcnR5TmFtZShpKSk6bj0hMSx0aGlzLnBhcnNlUHJvcGVydHlWYWx1ZShpLGUscyxuLHIsYSx0LG8pLHRoaXMuZmluaXNoTm9kZShpLCJQcm9wZXJ0eSIpfSxILnBhcnNlR2V0dGVyU2V0dGVyPWZ1bmN0aW9uKGUpe2Uua2luZD1lLmtleS5uYW1lLHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUoZSksZS52YWx1ZT10aGlzLnBhcnNlTWV0aG9kKCExKTt2YXIgdD1lLmtpbmQ9PT0iZ2V0Ij8wOjE7aWYoZS52YWx1ZS5wYXJhbXMubGVuZ3RoIT09dCl7dmFyIGk9ZS52YWx1ZS5zdGFydDtlLmtpbmQ9PT0iZ2V0Ij90aGlzLnJhaXNlUmVjb3ZlcmFibGUoaSwiZ2V0dGVyIHNob3VsZCBoYXZlIG5vIHBhcmFtcyIpOnRoaXMucmFpc2VSZWNvdmVyYWJsZShpLCJzZXR0ZXIgc2hvdWxkIGhhdmUgZXhhY3RseSBvbmUgcGFyYW0iKX1lbHNlIGUua2luZD09PSJzZXQiJiZlLnZhbHVlLnBhcmFtc1swXS50eXBlPT09IlJlc3RFbGVtZW50IiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKGUudmFsdWUucGFyYW1zWzBdLnN0YXJ0LCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtcyIpfSxILnBhcnNlUHJvcGVydHlWYWx1ZT1mdW5jdGlvbihlLHQsaSxzLG4scixhLG8peyhpfHxzKSYmdGhpcy50eXBlPT09ZC5jb2xvbiYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5lYXQoZC5jb2xvbik/KGUudmFsdWU9dD90aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhcnQsdGhpcy5zdGFydExvYyk6dGhpcy5wYXJzZU1heWJlQXNzaWduKCExLGEpLGUua2luZD0iaW5pdCIpOnRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmdGhpcy50eXBlPT09ZC5wYXJlbkw/KHQmJnRoaXMudW5leHBlY3RlZCgpLGUua2luZD0iaW5pdCIsZS5tZXRob2Q9ITAsZS52YWx1ZT10aGlzLnBhcnNlTWV0aG9kKGkscykpOiF0JiYhbyYmdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj01JiYhZS5jb21wdXRlZCYmZS5rZXkudHlwZT09PSJJZGVudGlmaWVyIiYmKGUua2V5Lm5hbWU9PT0iZ2V0Inx8ZS5rZXkubmFtZT09PSJzZXQiKSYmdGhpcy50eXBlIT09ZC5jb21tYSYmdGhpcy50eXBlIT09ZC5icmFjZVImJnRoaXMudHlwZSE9PWQuZXE/KChpfHxzKSYmdGhpcy51bmV4cGVjdGVkKCksdGhpcy5wYXJzZUdldHRlclNldHRlcihlKSk6dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02JiYhZS5jb21wdXRlZCYmZS5rZXkudHlwZT09PSJJZGVudGlmaWVyIj8oKGl8fHMpJiZ0aGlzLnVuZXhwZWN0ZWQoKSx0aGlzLmNoZWNrVW5yZXNlcnZlZChlLmtleSksZS5rZXkubmFtZT09PSJhd2FpdCImJiF0aGlzLmF3YWl0SWRlbnRQb3MmJih0aGlzLmF3YWl0SWRlbnRQb3M9biksZS5raW5kPSJpbml0Iix0P2UudmFsdWU9dGhpcy5wYXJzZU1heWJlRGVmYXVsdChuLHIsdGhpcy5jb3B5Tm9kZShlLmtleSkpOnRoaXMudHlwZT09PWQuZXEmJmE/KGEuc2hvcnRoYW5kQXNzaWduPDAmJihhLnNob3J0aGFuZEFzc2lnbj10aGlzLnN0YXJ0KSxlLnZhbHVlPXRoaXMucGFyc2VNYXliZURlZmF1bHQobixyLHRoaXMuY29weU5vZGUoZS5rZXkpKSk6ZS52YWx1ZT10aGlzLmNvcHlOb2RlKGUua2V5KSxlLnNob3J0aGFuZD0hMCk6dGhpcy51bmV4cGVjdGVkKCl9LEgucGFyc2VQcm9wZXJ0eU5hbWU9ZnVuY3Rpb24oZSl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXtpZih0aGlzLmVhdChkLmJyYWNrZXRMKSlyZXR1cm4gZS5jb21wdXRlZD0hMCxlLmtleT10aGlzLnBhcnNlTWF5YmVBc3NpZ24oKSx0aGlzLmV4cGVjdChkLmJyYWNrZXRSKSxlLmtleTtlLmNvbXB1dGVkPSExfXJldHVybiBlLmtleT10aGlzLnR5cGU9PT1kLm51bXx8dGhpcy50eXBlPT09ZC5zdHJpbmc/dGhpcy5wYXJzZUV4cHJBdG9tKCk6dGhpcy5wYXJzZUlkZW50KHRoaXMub3B0aW9ucy5hbGxvd1Jlc2VydmVkIT09Im5ldmVyIil9LEguaW5pdEZ1bmN0aW9uPWZ1bmN0aW9uKGUpe2UuaWQ9bnVsbCx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTYmJihlLmdlbmVyYXRvcj1lLmV4cHJlc3Npb249ITEpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCYmKGUuYXN5bmM9ITEpfSxILnBhcnNlTWV0aG9kPWZ1bmN0aW9uKGUsdCxpKXt2YXIgcz10aGlzLnN0YXJ0Tm9kZSgpLG49dGhpcy55aWVsZFBvcyxyPXRoaXMuYXdhaXRQb3MsYT10aGlzLmF3YWl0SWRlbnRQb3M7cmV0dXJuIHRoaXMuaW5pdEZ1bmN0aW9uKHMpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmKHMuZ2VuZXJhdG9yPWUpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OCYmKHMuYXN5bmM9ISF0KSx0aGlzLnlpZWxkUG9zPTAsdGhpcy5hd2FpdFBvcz0wLHRoaXMuYXdhaXRJZGVudFBvcz0wLHRoaXMuZW50ZXJTY29wZShUYSh0LHMuZ2VuZXJhdG9yKXwkYXwoaT9PdTowKSksdGhpcy5leHBlY3QoZC5wYXJlbkwpLHMucGFyYW1zPXRoaXMucGFyc2VCaW5kaW5nTGlzdChkLnBhcmVuUiwhMSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgpLHRoaXMuY2hlY2tZaWVsZEF3YWl0SW5EZWZhdWx0UGFyYW1zKCksdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShzLCExLCEwLCExKSx0aGlzLnlpZWxkUG9zPW4sdGhpcy5hd2FpdFBvcz1yLHRoaXMuYXdhaXRJZGVudFBvcz1hLHRoaXMuZmluaXNoTm9kZShzLCJGdW5jdGlvbkV4cHJlc3Npb24iKX0sSC5wYXJzZUFycm93RXhwcmVzc2lvbj1mdW5jdGlvbihlLHQsaSxzKXt2YXIgbj10aGlzLnlpZWxkUG9zLHI9dGhpcy5hd2FpdFBvcyxhPXRoaXMuYXdhaXRJZGVudFBvcztyZXR1cm4gdGhpcy5lbnRlclNjb3BlKFRhKGksITEpfFR1KSx0aGlzLmluaXRGdW5jdGlvbihlKSx0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTgmJihlLmFzeW5jPSEhaSksdGhpcy55aWVsZFBvcz0wLHRoaXMuYXdhaXRQb3M9MCx0aGlzLmF3YWl0SWRlbnRQb3M9MCxlLnBhcmFtcz10aGlzLnRvQXNzaWduYWJsZUxpc3QodCwhMCksdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShlLCEwLCExLHMpLHRoaXMueWllbGRQb3M9bix0aGlzLmF3YWl0UG9zPXIsdGhpcy5hd2FpdElkZW50UG9zPWEsdGhpcy5maW5pc2hOb2RlKGUsIkFycm93RnVuY3Rpb25FeHByZXNzaW9uIil9LEgucGFyc2VGdW5jdGlvbkJvZHk9ZnVuY3Rpb24oZSx0LGkscyl7dmFyIG49dCYmdGhpcy50eXBlIT09ZC5icmFjZUwscj10aGlzLnN0cmljdCxhPSExO2lmKG4pZS5ib2R5PXRoaXMucGFyc2VNYXliZUFzc2lnbihzKSxlLmV4cHJlc3Npb249ITAsdGhpcy5jaGVja1BhcmFtcyhlLCExKTtlbHNle3ZhciBvPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NyYmIXRoaXMuaXNTaW1wbGVQYXJhbUxpc3QoZS5wYXJhbXMpOyghcnx8bykmJihhPXRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMuZW5kKSxhJiZvJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZS5zdGFydCwiSWxsZWdhbCAndXNlIHN0cmljdCcgZGlyZWN0aXZlIGluIGZ1bmN0aW9uIHdpdGggbm9uLXNpbXBsZSBwYXJhbWV0ZXIgbGlzdCIpKTt2YXIgaD10aGlzLmxhYmVsczt0aGlzLmxhYmVscz1bXSxhJiYodGhpcy5zdHJpY3Q9ITApLHRoaXMuY2hlY2tQYXJhbXMoZSwhciYmIWEmJiF0JiYhaSYmdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChlLnBhcmFtcykpLHRoaXMuc3RyaWN0JiZlLmlkJiZ0aGlzLmNoZWNrTFZhbFNpbXBsZShlLmlkLER1KSxlLmJvZHk9dGhpcy5wYXJzZUJsb2NrKCExLHZvaWQgMCxhJiYhciksZS5leHByZXNzaW9uPSExLHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShlLmJvZHkuYm9keSksdGhpcy5sYWJlbHM9aH10aGlzLmV4aXRTY29wZSgpfSxILmlzU2ltcGxlUGFyYW1MaXN0PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0wLGk9ZTt0PGkubGVuZ3RoO3QrPTEpe3ZhciBzPWlbdF07aWYocy50eXBlIT09IklkZW50aWZpZXIiKXJldHVybiExfXJldHVybiEwfSxILmNoZWNrUGFyYW1zPWZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBpPU9iamVjdC5jcmVhdGUobnVsbCkscz0wLG49ZS5wYXJhbXM7czxuLmxlbmd0aDtzKz0xKXt2YXIgcj1uW3NdO3RoaXMuY2hlY2tMVmFsSW5uZXJQYXR0ZXJuKHIsUmEsdD9udWxsOmkpfX0sSC5wYXJzZUV4cHJMaXN0PWZ1bmN0aW9uKGUsdCxpLHMpe2Zvcih2YXIgbj1bXSxyPSEwOyF0aGlzLmVhdChlKTspe2lmKHIpcj0hMTtlbHNlIGlmKHRoaXMuZXhwZWN0KGQuY29tbWEpLHQmJnRoaXMuYWZ0ZXJUcmFpbGluZ0NvbW1hKGUpKWJyZWFrO3ZhciBhPXZvaWQgMDtpJiZ0aGlzLnR5cGU9PT1kLmNvbW1hP2E9bnVsbDp0aGlzLnR5cGU9PT1kLmVsbGlwc2lzPyhhPXRoaXMucGFyc2VTcHJlYWQocykscyYmdGhpcy50eXBlPT09ZC5jb21tYSYmcy50cmFpbGluZ0NvbW1hPDAmJihzLnRyYWlsaW5nQ29tbWE9dGhpcy5zdGFydCkpOmE9dGhpcy5wYXJzZU1heWJlQXNzaWduKCExLHMpLG4ucHVzaChhKX1yZXR1cm4gbn0sSC5jaGVja1VucmVzZXJ2ZWQ9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zdGFydCxpPWUuZW5kLHM9ZS5uYW1lO2lmKHRoaXMuaW5HZW5lcmF0b3ImJnM9PT0ieWllbGQiJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodCwiQ2Fubm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yIiksdGhpcy5pbkFzeW5jJiZzPT09ImF3YWl0IiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHQsIkNhbm5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvbiIpLHRoaXMuY3VycmVudFRoaXNTY29wZSgpLmluQ2xhc3NGaWVsZEluaXQmJnM9PT0iYXJndW1lbnRzIiYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHQsIkNhbm5vdCB1c2UgJ2FyZ3VtZW50cycgaW4gY2xhc3MgZmllbGQgaW5pdGlhbGl6ZXIiKSx0aGlzLmluQ2xhc3NTdGF0aWNCbG9jayYmKHM9PT0iYXJndW1lbnRzInx8cz09PSJhd2FpdCIpJiZ0aGlzLnJhaXNlKHQsIkNhbm5vdCB1c2UgIitzKyIgaW4gY2xhc3Mgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrIiksdGhpcy5rZXl3b3Jkcy50ZXN0KHMpJiZ0aGlzLnJhaXNlKHQsIlVuZXhwZWN0ZWQga2V5d29yZCAnIitzKyInIiksISh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248NiYmdGhpcy5pbnB1dC5zbGljZSh0LGkpLmluZGV4T2YoIlxcIikhPT0tMSkpe3ZhciBuPXRoaXMuc3RyaWN0P3RoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdDp0aGlzLnJlc2VydmVkV29yZHM7bi50ZXN0KHMpJiYoIXRoaXMuaW5Bc3luYyYmcz09PSJhd2FpdCImJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0LCJDYW5ub3QgdXNlIGtleXdvcmQgJ2F3YWl0JyBvdXRzaWRlIGFuIGFzeW5jIGZ1bmN0aW9uIiksdGhpcy5yYWlzZVJlY292ZXJhYmxlKHQsIlRoZSBrZXl3b3JkICciK3MrIicgaXMgcmVzZXJ2ZWQiKSl9fSxILnBhcnNlSWRlbnQ9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5wYXJzZUlkZW50Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoISFlKSx0aGlzLmZpbmlzaE5vZGUodCwiSWRlbnRpZmllciIpLGV8fCh0aGlzLmNoZWNrVW5yZXNlcnZlZCh0KSx0Lm5hbWU9PT0iYXdhaXQiJiYhdGhpcy5hd2FpdElkZW50UG9zJiYodGhpcy5hd2FpdElkZW50UG9zPXQuc3RhcnQpKSx0fSxILnBhcnNlSWRlbnROb2RlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy50eXBlPT09ZC5uYW1lP2UubmFtZT10aGlzLnZhbHVlOnRoaXMudHlwZS5rZXl3b3JkPyhlLm5hbWU9dGhpcy50eXBlLmtleXdvcmQsKGUubmFtZT09PSJjbGFzcyJ8fGUubmFtZT09PSJmdW5jdGlvbiIpJiYodGhpcy5sYXN0VG9rRW5kIT09dGhpcy5sYXN0VG9rU3RhcnQrMXx8dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubGFzdFRva1N0YXJ0KSE9PTQ2KSYmdGhpcy5jb250ZXh0LnBvcCgpLHRoaXMudHlwZT1kLm5hbWUpOnRoaXMudW5leHBlY3RlZCgpLGV9LEgucGFyc2VQcml2YXRlSWRlbnQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLnR5cGU9PT1kLnByaXZhdGVJZD9lLm5hbWU9dGhpcy52YWx1ZTp0aGlzLnVuZXhwZWN0ZWQoKSx0aGlzLm5leHQoKSx0aGlzLmZpbmlzaE5vZGUoZSwiUHJpdmF0ZUlkZW50aWZpZXIiKSx0aGlzLm9wdGlvbnMuY2hlY2tQcml2YXRlRmllbGRzJiYodGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aD09PTA/dGhpcy5yYWlzZShlLnN0YXJ0LCJQcml2YXRlIGZpZWxkICcjIitlLm5hbWUrIicgbXVzdCBiZSBkZWNsYXJlZCBpbiBhbiBlbmNsb3NpbmcgY2xhc3MiKTp0aGlzLnByaXZhdGVOYW1lU3RhY2tbdGhpcy5wcml2YXRlTmFtZVN0YWNrLmxlbmd0aC0xXS51c2VkLnB1c2goZSkpLGV9LEgucGFyc2VZaWVsZD1mdW5jdGlvbihlKXt0aGlzLnlpZWxkUG9zfHwodGhpcy55aWVsZFBvcz10aGlzLnN0YXJ0KTt2YXIgdD10aGlzLnN0YXJ0Tm9kZSgpO3JldHVybiB0aGlzLm5leHQoKSx0aGlzLnR5cGU9PT1kLnNlbWl8fHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCl8fHRoaXMudHlwZSE9PWQuc3RhciYmIXRoaXMudHlwZS5zdGFydHNFeHByPyh0LmRlbGVnYXRlPSExLHQuYXJndW1lbnQ9bnVsbCk6KHQuZGVsZWdhdGU9dGhpcy5lYXQoZC5zdGFyKSx0LmFyZ3VtZW50PXRoaXMucGFyc2VNYXliZUFzc2lnbihlKSksdGhpcy5maW5pc2hOb2RlKHQsIllpZWxkRXhwcmVzc2lvbiIpfSxILnBhcnNlQXdhaXQ9ZnVuY3Rpb24oZSl7dGhpcy5hd2FpdFBvc3x8KHRoaXMuYXdhaXRQb3M9dGhpcy5zdGFydCk7dmFyIHQ9dGhpcy5zdGFydE5vZGUoKTtyZXR1cm4gdGhpcy5uZXh0KCksdC5hcmd1bWVudD10aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCEwLCExLGUpLHRoaXMuZmluaXNoTm9kZSh0LCJBd2FpdEV4cHJlc3Npb24iKX07dmFyIE9uPVBlLnByb3RvdHlwZTtPbi5yYWlzZT1mdW5jdGlvbihlLHQpe3ZhciBpPU51KHRoaXMuaW5wdXQsZSk7dCs9IiAoIitpLmxpbmUrIjoiK2kuY29sdW1uKyIpIjt2YXIgcz1uZXcgU3ludGF4RXJyb3IodCk7dGhyb3cgcy5wb3M9ZSxzLmxvYz1pLHMucmFpc2VkQXQ9dGhpcy5wb3Msc30sT24ucmFpc2VSZWNvdmVyYWJsZT1Pbi5yYWlzZSxPbi5jdXJQb3NpdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpcmV0dXJuIG5ldyBrcyh0aGlzLmN1ckxpbmUsdGhpcy5wb3MtdGhpcy5saW5lU3RhcnQpfTt2YXIgWHQ9UGUucHJvdG90eXBlLG5nPWZ1bmN0aW9uKHQpe3RoaXMuZmxhZ3M9dCx0aGlzLnZhcj1bXSx0aGlzLmxleGljYWw9W10sdGhpcy5mdW5jdGlvbnM9W10sdGhpcy5pbkNsYXNzRmllbGRJbml0PSExfTtYdC5lbnRlclNjb3BlPWZ1bmN0aW9uKGUpe3RoaXMuc2NvcGVTdGFjay5wdXNoKG5ldyBuZyhlKSl9LFh0LmV4aXRTY29wZT1mdW5jdGlvbigpe3RoaXMuc2NvcGVTdGFjay5wb3AoKX0sWHQudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuZmxhZ3MmRml8fCF0aGlzLmluTW9kdWxlJiZlLmZsYWdzJndzfSxYdC5kZWNsYXJlTmFtZT1mdW5jdGlvbihlLHQsaSl7dmFyIHM9ITE7aWYodD09PVJ0KXt2YXIgbj10aGlzLmN1cnJlbnRTY29wZSgpO3M9bi5sZXhpY2FsLmluZGV4T2YoZSk+LTF8fG4uZnVuY3Rpb25zLmluZGV4T2YoZSk+LTF8fG4udmFyLmluZGV4T2YoZSk+LTEsbi5sZXhpY2FsLnB1c2goZSksdGhpcy5pbk1vZHVsZSYmbi5mbGFncyZ3cyYmZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tlXX1lbHNlIGlmKHQ9PT1NdSl7dmFyIHI9dGhpcy5jdXJyZW50U2NvcGUoKTtyLmxleGljYWwucHVzaChlKX1lbHNlIGlmKHQ9PT1WdSl7dmFyIGE9dGhpcy5jdXJyZW50U2NvcGUoKTt0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXI/cz1hLmxleGljYWwuaW5kZXhPZihlKT4tMTpzPWEubGV4aWNhbC5pbmRleE9mKGUpPi0xfHxhLnZhci5pbmRleE9mKGUpPi0xLGEuZnVuY3Rpb25zLnB1c2goZSl9ZWxzZSBmb3IodmFyIG89dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xO28+PTA7LS1vKXt2YXIgaD10aGlzLnNjb3BlU3RhY2tbb107aWYoaC5sZXhpY2FsLmluZGV4T2YoZSk+LTEmJiEoaC5mbGFncyZSdSYmaC5sZXhpY2FsWzBdPT09ZSl8fCF0aGlzLnRyZWF0RnVuY3Rpb25zQXNWYXJJblNjb3BlKGgpJiZoLmZ1bmN0aW9ucy5pbmRleE9mKGUpPi0xKXtzPSEwO2JyZWFrfWlmKGgudmFyLnB1c2goZSksdGhpcy5pbk1vZHVsZSYmaC5mbGFncyZ3cyYmZGVsZXRlIHRoaXMudW5kZWZpbmVkRXhwb3J0c1tlXSxoLmZsYWdzJkxhKWJyZWFrfXMmJnRoaXMucmFpc2VSZWNvdmVyYWJsZShpLCJJZGVudGlmaWVyICciK2UrIicgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCIpfSxYdC5jaGVja0xvY2FsRXhwb3J0PWZ1bmN0aW9uKGUpe3RoaXMuc2NvcGVTdGFja1swXS5sZXhpY2FsLmluZGV4T2YoZS5uYW1lKT09PS0xJiZ0aGlzLnNjb3BlU3RhY2tbMF0udmFyLmluZGV4T2YoZS5uYW1lKT09PS0xJiYodGhpcy51bmRlZmluZWRFeHBvcnRzW2UubmFtZV09ZSl9LFh0LmN1cnJlbnRTY29wZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xXX0sWHQuY3VycmVudFZhclNjb3BlPWZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuc2NvcGVTdGFjay5sZW5ndGgtMTs7ZS0tKXt2YXIgdD10aGlzLnNjb3BlU3RhY2tbZV07aWYodC5mbGFncyZMYSlyZXR1cm4gdH19LFh0LmN1cnJlbnRUaGlzU2NvcGU9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5zY29wZVN0YWNrLmxlbmd0aC0xOztlLS0pe3ZhciB0PXRoaXMuc2NvcGVTdGFja1tlXTtpZih0LmZsYWdzJkxhJiYhKHQuZmxhZ3MmVHUpKXJldHVybiB0fX07dmFyIFZuPWZ1bmN0aW9uKHQsaSxzKXt0aGlzLnR5cGU9IiIsdGhpcy5zdGFydD1pLHRoaXMuZW5kPTAsdC5vcHRpb25zLmxvY2F0aW9ucyYmKHRoaXMubG9jPW5ldyAkbih0LHMpKSx0Lm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSYmKHRoaXMuc291cmNlRmlsZT10Lm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSksdC5vcHRpb25zLnJhbmdlcyYmKHRoaXMucmFuZ2U9W2ksMF0pfSxJcz1QZS5wcm90b3R5cGU7SXMuc3RhcnROb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBWbih0aGlzLHRoaXMuc3RhcnQsdGhpcy5zdGFydExvYyl9LElzLnN0YXJ0Tm9kZUF0PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBWbih0aGlzLGUsdCl9O2Z1bmN0aW9uIHp1KGUsdCxpLHMpe3JldHVybiBlLnR5cGU9dCxlLmVuZD1pLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9cyksdGhpcy5vcHRpb25zLnJhbmdlcyYmKGUucmFuZ2VbMV09aSksZX1Jcy5maW5pc2hOb2RlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHp1LmNhbGwodGhpcyxlLHQsdGhpcy5sYXN0VG9rRW5kLHRoaXMubGFzdFRva0VuZExvYyl9LElzLmZpbmlzaE5vZGVBdD1mdW5jdGlvbihlLHQsaSxzKXtyZXR1cm4genUuY2FsbCh0aGlzLGUsdCxpLHMpfSxJcy5jb3B5Tm9kZT1mdW5jdGlvbihlKXt2YXIgdD1uZXcgVm4odGhpcyxlLnN0YXJ0LHRoaXMuc3RhcnRMb2MpO2Zvcih2YXIgaSBpbiBlKXRbaV09ZVtpXTtyZXR1cm4gdH07dmFyIGp1PSJBU0NJSSBBU0NJSV9IZXhfRGlnaXQgQUhleCBBbHBoYWJldGljIEFscGhhIEFueSBBc3NpZ25lZCBCaWRpX0NvbnRyb2wgQmlkaV9DIEJpZGlfTWlycm9yZWQgQmlkaV9NIENhc2VfSWdub3JhYmxlIENJIENhc2VkIENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkIENXQ0YgQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQgQ1dDTSBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0wgQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCBDV0tDRiBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCBDV1QgQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVIERhc2ggRGVmYXVsdF9JZ25vcmFibGVfQ29kZV9Qb2ludCBESSBEZXByZWNhdGVkIERlcCBEaWFjcml0aWMgRGlhIEVtb2ppIEVtb2ppX0NvbXBvbmVudCBFbW9qaV9Nb2RpZmllciBFbW9qaV9Nb2RpZmllcl9CYXNlIEVtb2ppX1ByZXNlbnRhdGlvbiBFeHRlbmRlciBFeHQgR3JhcGhlbWVfQmFzZSBHcl9CYXNlIEdyYXBoZW1lX0V4dGVuZCBHcl9FeHQgSGV4X0RpZ2l0IEhleCBJRFNfQmluYXJ5X09wZXJhdG9yIElEU0IgSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVCBJRF9Db250aW51ZSBJREMgSURfU3RhcnQgSURTIElkZW9ncmFwaGljIElkZW8gSm9pbl9Db250cm9sIEpvaW5fQyBMb2dpY2FsX09yZGVyX0V4Y2VwdGlvbiBMT0UgTG93ZXJjYXNlIExvd2VyIE1hdGggTm9uY2hhcmFjdGVyX0NvZGVfUG9pbnQgTkNoYXIgUGF0dGVybl9TeW50YXggUGF0X1N5biBQYXR0ZXJuX1doaXRlX1NwYWNlIFBhdF9XUyBRdW90YXRpb25fTWFyayBRTWFyayBSYWRpY2FsIFJlZ2lvbmFsX0luZGljYXRvciBSSSBTZW50ZW5jZV9UZXJtaW5hbCBTVGVybSBTb2Z0X0RvdHRlZCBTRCBUZXJtaW5hbF9QdW5jdHVhdGlvbiBUZXJtIFVuaWZpZWRfSWRlb2dyYXBoIFVJZGVvIFVwcGVyY2FzZSBVcHBlciBWYXJpYXRpb25fU2VsZWN0b3IgVlMgV2hpdGVfU3BhY2Ugc3BhY2UgWElEX0NvbnRpbnVlIFhJREMgWElEX1N0YXJ0IFhJRFMiLFV1PWp1KyIgRXh0ZW5kZWRfUGljdG9ncmFwaGljIixHdT1VdSxXdT1HdSsiIEVCYXNlIEVDb21wIEVNb2QgRVByZXMgRXh0UGljdCIscXU9V3Uscmc9cXUsYWc9ezk6anUsMTA6VXUsMTE6R3UsMTI6V3UsMTM6cXUsMTQ6cmd9LG9nPSJCYXNpY19FbW9qaSBFbW9qaV9LZXljYXBfU2VxdWVuY2UgUkdJX0Vtb2ppX01vZGlmaWVyX1NlcXVlbmNlIFJHSV9FbW9qaV9GbGFnX1NlcXVlbmNlIFJHSV9FbW9qaV9UYWdfU2VxdWVuY2UgUkdJX0Vtb2ppX1pXSl9TZXF1ZW5jZSBSR0lfRW1vamkiLGhnPXs5OiIiLDEwOiIiLDExOiIiLDEyOiIiLDEzOiIiLDE0Om9nfSxIdT0iQ2FzZWRfTGV0dGVyIExDIENsb3NlX1B1bmN0dWF0aW9uIFBlIENvbm5lY3Rvcl9QdW5jdHVhdGlvbiBQYyBDb250cm9sIENjIGNudHJsIEN1cnJlbmN5X1N5bWJvbCBTYyBEYXNoX1B1bmN0dWF0aW9uIFBkIERlY2ltYWxfTnVtYmVyIE5kIGRpZ2l0IEVuY2xvc2luZ19NYXJrIE1lIEZpbmFsX1B1bmN0dWF0aW9uIFBmIEZvcm1hdCBDZiBJbml0aWFsX1B1bmN0dWF0aW9uIFBpIExldHRlciBMIExldHRlcl9OdW1iZXIgTmwgTGluZV9TZXBhcmF0b3IgWmwgTG93ZXJjYXNlX0xldHRlciBMbCBNYXJrIE0gQ29tYmluaW5nX01hcmsgTWF0aF9TeW1ib2wgU20gTW9kaWZpZXJfTGV0dGVyIExtIE1vZGlmaWVyX1N5bWJvbCBTayBOb25zcGFjaW5nX01hcmsgTW4gTnVtYmVyIE4gT3Blbl9QdW5jdHVhdGlvbiBQcyBPdGhlciBDIE90aGVyX0xldHRlciBMbyBPdGhlcl9OdW1iZXIgTm8gT3RoZXJfUHVuY3R1YXRpb24gUG8gT3RoZXJfU3ltYm9sIFNvIFBhcmFncmFwaF9TZXBhcmF0b3IgWnAgUHJpdmF0ZV9Vc2UgQ28gUHVuY3R1YXRpb24gUCBwdW5jdCBTZXBhcmF0b3IgWiBTcGFjZV9TZXBhcmF0b3IgWnMgU3BhY2luZ19NYXJrIE1jIFN1cnJvZ2F0ZSBDcyBTeW1ib2wgUyBUaXRsZWNhc2VfTGV0dGVyIEx0IFVuYXNzaWduZWQgQ24gVXBwZXJjYXNlX0xldHRlciBMdSIsS3U9IkFkbGFtIEFkbG0gQWhvbSBBbmF0b2xpYW5fSGllcm9nbHlwaHMgSGx1dyBBcmFiaWMgQXJhYiBBcm1lbmlhbiBBcm1uIEF2ZXN0YW4gQXZzdCBCYWxpbmVzZSBCYWxpIEJhbXVtIEJhbXUgQmFzc2FfVmFoIEJhc3MgQmF0YWsgQmF0ayBCZW5nYWxpIEJlbmcgQmhhaWtzdWtpIEJoa3MgQm9wb21vZm8gQm9wbyBCcmFobWkgQnJhaCBCcmFpbGxlIEJyYWkgQnVnaW5lc2UgQnVnaSBCdWhpZCBCdWhkIENhbmFkaWFuX0Fib3JpZ2luYWwgQ2FucyBDYXJpYW4gQ2FyaSBDYXVjYXNpYW5fQWxiYW5pYW4gQWdoYiBDaGFrbWEgQ2FrbSBDaGFtIENoYW0gQ2hlcm9rZWUgQ2hlciBDb21tb24gWnl5eSBDb3B0aWMgQ29wdCBRYWFjIEN1bmVpZm9ybSBYc3V4IEN5cHJpb3QgQ3BydCBDeXJpbGxpYyBDeXJsIERlc2VyZXQgRHNydCBEZXZhbmFnYXJpIERldmEgRHVwbG95YW4gRHVwbCBFZ3lwdGlhbl9IaWVyb2dseXBocyBFZ3lwIEVsYmFzYW4gRWxiYSBFdGhpb3BpYyBFdGhpIEdlb3JnaWFuIEdlb3IgR2xhZ29saXRpYyBHbGFnIEdvdGhpYyBHb3RoIEdyYW50aGEgR3JhbiBHcmVlayBHcmVrIEd1amFyYXRpIEd1anIgR3VybXVraGkgR3VydSBIYW4gSGFuaSBIYW5ndWwgSGFuZyBIYW51bm9vIEhhbm8gSGF0cmFuIEhhdHIgSGVicmV3IEhlYnIgSGlyYWdhbmEgSGlyYSBJbXBlcmlhbF9BcmFtYWljIEFybWkgSW5oZXJpdGVkIFppbmggUWFhaSBJbnNjcmlwdGlvbmFsX1BhaGxhdmkgUGhsaSBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuIFBydGkgSmF2YW5lc2UgSmF2YSBLYWl0aGkgS3RoaSBLYW5uYWRhIEtuZGEgS2F0YWthbmEgS2FuYSBLYXlhaF9MaSBLYWxpIEtoYXJvc2h0aGkgS2hhciBLaG1lciBLaG1yIEtob2praSBLaG9qIEtodWRhd2FkaSBTaW5kIExhbyBMYW9vIExhdGluIExhdG4gTGVwY2hhIExlcGMgTGltYnUgTGltYiBMaW5lYXJfQSBMaW5hIExpbmVhcl9CIExpbmIgTGlzdSBMaXN1IEx5Y2lhbiBMeWNpIEx5ZGlhbiBMeWRpIE1haGFqYW5pIE1haGogTWFsYXlhbGFtIE1seW0gTWFuZGFpYyBNYW5kIE1hbmljaGFlYW4gTWFuaSBNYXJjaGVuIE1hcmMgTWFzYXJhbV9Hb25kaSBHb25tIE1lZXRlaV9NYXllayBNdGVpIE1lbmRlX0tpa2FrdWkgTWVuZCBNZXJvaXRpY19DdXJzaXZlIE1lcmMgTWVyb2l0aWNfSGllcm9nbHlwaHMgTWVybyBNaWFvIFBscmQgTW9kaSBNb25nb2xpYW4gTW9uZyBNcm8gTXJvbyBNdWx0YW5pIE11bHQgTXlhbm1hciBNeW1yIE5hYmF0YWVhbiBOYmF0IE5ld19UYWlfTHVlIFRhbHUgTmV3YSBOZXdhIE5rbyBOa29vIE51c2h1IE5zaHUgT2doYW0gT2dhbSBPbF9DaGlraSBPbGNrIE9sZF9IdW5nYXJpYW4gSHVuZyBPbGRfSXRhbGljIEl0YWwgT2xkX05vcnRoX0FyYWJpYW4gTmFyYiBPbGRfUGVybWljIFBlcm0gT2xkX1BlcnNpYW4gWHBlbyBPbGRfU291dGhfQXJhYmlhbiBTYXJiIE9sZF9UdXJraWMgT3JraCBPcml5YSBPcnlhIE9zYWdlIE9zZ2UgT3NtYW55YSBPc21hIFBhaGF3aF9IbW9uZyBIbW5nIFBhbG15cmVuZSBQYWxtIFBhdV9DaW5fSGF1IFBhdWMgUGhhZ3NfUGEgUGhhZyBQaG9lbmljaWFuIFBobnggUHNhbHRlcl9QYWhsYXZpIFBobHAgUmVqYW5nIFJqbmcgUnVuaWMgUnVuciBTYW1hcml0YW4gU2FtciBTYXVyYXNodHJhIFNhdXIgU2hhcmFkYSBTaHJkIFNoYXZpYW4gU2hhdyBTaWRkaGFtIFNpZGQgU2lnbldyaXRpbmcgU2dudyBTaW5oYWxhIFNpbmggU29yYV9Tb21wZW5nIFNvcmEgU295b21ibyBTb3lvIFN1bmRhbmVzZSBTdW5kIFN5bG90aV9OYWdyaSBTeWxvIFN5cmlhYyBTeXJjIFRhZ2Fsb2cgVGdsZyBUYWdiYW53YSBUYWdiIFRhaV9MZSBUYWxlIFRhaV9UaGFtIExhbmEgVGFpX1ZpZXQgVGF2dCBUYWtyaSBUYWtyIFRhbWlsIFRhbWwgVGFuZ3V0IFRhbmcgVGVsdWd1IFRlbHUgVGhhYW5hIFRoYWEgVGhhaSBUaGFpIFRpYmV0YW4gVGlidCBUaWZpbmFnaCBUZm5nIFRpcmh1dGEgVGlyaCBVZ2FyaXRpYyBVZ2FyIFZhaSBWYWlpIFdhcmFuZ19DaXRpIFdhcmEgWWkgWWlpaSBaYW5hYmF6YXJfU3F1YXJlIFphbmIiLFF1PUt1KyIgRG9ncmEgRG9nciBHdW5qYWxhX0dvbmRpIEdvbmcgSGFuaWZpX1JvaGluZ3lhIFJvaGcgTWFrYXNhciBNYWthIE1lZGVmYWlkcmluIE1lZGYgT2xkX1NvZ2RpYW4gU29nbyBTb2dkaWFuIFNvZ2QiLFl1PVF1KyIgRWx5bWFpYyBFbHltIE5hbmRpbmFnYXJpIE5hbmQgTnlpYWtlbmdfUHVhY2h1ZV9IbW9uZyBIbW5wIFdhbmNobyBXY2hvIixYdT1ZdSsiIENob3Jhc21pYW4gQ2hycyBEaWFrIERpdmVzX0FrdXJ1IEtoaXRhbl9TbWFsbF9TY3JpcHQgS2l0cyBZZXppIFllemlkaSIsWnU9WHUrIiBDeXByb19NaW5vYW4gQ3BtbiBPbGRfVXlnaHVyIE91Z3IgVGFuZ3NhIFRuc2EgVG90byBWaXRoa3VxaSBWaXRoIixsZz1adSsiIEhya3QgS2F0YWthbmFfT3JfSGlyYWdhbmEgS2F3aSBOYWdfTXVuZGFyaSBOYWdtIFVua25vd24gWnp6eiIsdWc9ezk6S3UsMTA6UXUsMTE6WXUsMTI6WHUsMTM6WnUsMTQ6bGd9LEp1PXt9O2Z1bmN0aW9uIGNnKGUpe3ZhciB0PUp1W2VdPXtiaW5hcnk6UXQoYWdbZV0rIiAiK0h1KSxiaW5hcnlPZlN0cmluZ3M6UXQoaGdbZV0pLG5vbkJpbmFyeTp7R2VuZXJhbF9DYXRlZ29yeTpRdChIdSksU2NyaXB0OlF0KHVnW2VdKX19O3Qubm9uQmluYXJ5LlNjcmlwdF9FeHRlbnNpb25zPXQubm9uQmluYXJ5LlNjcmlwdCx0Lm5vbkJpbmFyeS5nYz10Lm5vbkJpbmFyeS5HZW5lcmFsX0NhdGVnb3J5LHQubm9uQmluYXJ5LnNjPXQubm9uQmluYXJ5LlNjcmlwdCx0Lm5vbkJpbmFyeS5zY3g9dC5ub25CaW5hcnkuU2NyaXB0X0V4dGVuc2lvbnN9Zm9yKHZhciBNYT0wLGVjPVs5LDEwLDExLDEyLDEzLDE0XTtNYTxlYy5sZW5ndGg7TWErPTEpe3ZhciBwZz1lY1tNYV07Y2cocGcpfXZhciBEPVBlLnByb3RvdHlwZSx3dD1mdW5jdGlvbih0KXt0aGlzLnBhcnNlcj10LHRoaXMudmFsaWRGbGFncz0iZ2ltIisodC5vcHRpb25zLmVjbWFWZXJzaW9uPj02PyJ1eSI6IiIpKyh0Lm9wdGlvbnMuZWNtYVZlcnNpb24+PTk/InMiOiIiKSsodC5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMz8iZCI6IiIpKyh0Lm9wdGlvbnMuZWNtYVZlcnNpb24+PTE1PyJ2IjoiIiksdGhpcy51bmljb2RlUHJvcGVydGllcz1KdVt0Lm9wdGlvbnMuZWNtYVZlcnNpb24+PTE0PzE0OnQub3B0aW9ucy5lY21hVmVyc2lvbl0sdGhpcy5zb3VyY2U9IiIsdGhpcy5mbGFncz0iIix0aGlzLnN0YXJ0PTAsdGhpcy5zd2l0Y2hVPSExLHRoaXMuc3dpdGNoVj0hMSx0aGlzLnN3aXRjaE49ITEsdGhpcy5wb3M9MCx0aGlzLmxhc3RJbnRWYWx1ZT0wLHRoaXMubGFzdFN0cmluZ1ZhbHVlPSIiLHRoaXMubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlPSExLHRoaXMubnVtQ2FwdHVyaW5nUGFyZW5zPTAsdGhpcy5tYXhCYWNrUmVmZXJlbmNlPTAsdGhpcy5ncm91cE5hbWVzPVtdLHRoaXMuYmFja1JlZmVyZW5jZU5hbWVzPVtdfTt3dC5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24odCxpLHMpe3ZhciBuPXMuaW5kZXhPZigidiIpIT09LTEscj1zLmluZGV4T2YoInUiKSE9PS0xO3RoaXMuc3RhcnQ9dHwwLHRoaXMuc291cmNlPWkrIiIsdGhpcy5mbGFncz1zLG4mJnRoaXMucGFyc2VyLm9wdGlvbnMuZWNtYVZlcnNpb24+PTE1Pyh0aGlzLnN3aXRjaFU9ITAsdGhpcy5zd2l0Y2hWPSEwLHRoaXMuc3dpdGNoTj0hMCk6KHRoaXMuc3dpdGNoVT1yJiZ0aGlzLnBhcnNlci5vcHRpb25zLmVjbWFWZXJzaW9uPj02LHRoaXMuc3dpdGNoVj0hMSx0aGlzLnN3aXRjaE49ciYmdGhpcy5wYXJzZXIub3B0aW9ucy5lY21hVmVyc2lvbj49OSl9LHd0LnByb3RvdHlwZS5yYWlzZT1mdW5jdGlvbih0KXt0aGlzLnBhcnNlci5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiAvIit0aGlzLnNvdXJjZSsiLzogIit0KX0sd3QucHJvdG90eXBlLmF0PWZ1bmN0aW9uKHQsaSl7aT09PXZvaWQgMCYmKGk9ITEpO3ZhciBzPXRoaXMuc291cmNlLG49cy5sZW5ndGg7aWYodD49bilyZXR1cm4tMTt2YXIgcj1zLmNoYXJDb2RlQXQodCk7aWYoIShpfHx0aGlzLnN3aXRjaFUpfHxyPD01NTI5NXx8cj49NTczNDR8fHQrMT49bilyZXR1cm4gcjt2YXIgYT1zLmNoYXJDb2RlQXQodCsxKTtyZXR1cm4gYT49NTYzMjAmJmE8PTU3MzQzPyhyPDwxMCkrYS01NjYxMzg4ODpyfSx3dC5wcm90b3R5cGUubmV4dEluZGV4PWZ1bmN0aW9uKHQsaSl7aT09PXZvaWQgMCYmKGk9ITEpO3ZhciBzPXRoaXMuc291cmNlLG49cy5sZW5ndGg7aWYodD49bilyZXR1cm4gbjt2YXIgcj1zLmNoYXJDb2RlQXQodCksYTtyZXR1cm4hKGl8fHRoaXMuc3dpdGNoVSl8fHI8PTU1Mjk1fHxyPj01NzM0NHx8dCsxPj1ufHwoYT1zLmNoYXJDb2RlQXQodCsxKSk8NTYzMjB8fGE+NTczNDM/dCsxOnQrMn0sd3QucHJvdG90eXBlLmN1cnJlbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT12b2lkIDAmJih0PSExKSx0aGlzLmF0KHRoaXMucG9zLHQpfSx3dC5wcm90b3R5cGUubG9va2FoZWFkPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dm9pZCAwJiYodD0hMSksdGhpcy5hdCh0aGlzLm5leHRJbmRleCh0aGlzLnBvcyx0KSx0KX0sd3QucHJvdG90eXBlLmFkdmFuY2U9ZnVuY3Rpb24odCl7dD09PXZvaWQgMCYmKHQ9ITEpLHRoaXMucG9zPXRoaXMubmV4dEluZGV4KHRoaXMucG9zLHQpfSx3dC5wcm90b3R5cGUuZWF0PWZ1bmN0aW9uKHQsaSl7cmV0dXJuIGk9PT12b2lkIDAmJihpPSExKSx0aGlzLmN1cnJlbnQoaSk9PT10Pyh0aGlzLmFkdmFuY2UoaSksITApOiExfSx3dC5wcm90b3R5cGUuZWF0Q2hhcnM9ZnVuY3Rpb24odCxpKXtpPT09dm9pZCAwJiYoaT0hMSk7Zm9yKHZhciBzPXRoaXMucG9zLG49MCxyPXQ7bjxyLmxlbmd0aDtuKz0xKXt2YXIgYT1yW25dLG89dGhpcy5hdChzLGkpO2lmKG89PT0tMXx8byE9PWEpcmV0dXJuITE7cz10aGlzLm5leHRJbmRleChzLGkpfXJldHVybiB0aGlzLnBvcz1zLCEwfSxELnZhbGlkYXRlUmVnRXhwRmxhZ3M9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUudmFsaWRGbGFncyxpPWUuZmxhZ3Mscz0hMSxuPSExLHI9MDtyPGkubGVuZ3RoO3IrKyl7dmFyIGE9aS5jaGFyQXQocik7dC5pbmRleE9mKGEpPT09LTEmJnRoaXMucmFpc2UoZS5zdGFydCwiSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24gZmxhZyIpLGkuaW5kZXhPZihhLHIrMSk+LTEmJnRoaXMucmFpc2UoZS5zdGFydCwiRHVwbGljYXRlIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnIiksYT09PSJ1IiYmKHM9ITApLGE9PT0idiImJihuPSEwKX10aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTE1JiZzJiZuJiZ0aGlzLnJhaXNlKGUuc3RhcnQsIkludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWciKX0sRC52YWxpZGF0ZVJlZ0V4cFBhdHRlcm49ZnVuY3Rpb24oZSl7dGhpcy5yZWdleHBfcGF0dGVybihlKSwhZS5zd2l0Y2hOJiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTkmJmUuZ3JvdXBOYW1lcy5sZW5ndGg+MCYmKGUuc3dpdGNoTj0hMCx0aGlzLnJlZ2V4cF9wYXR0ZXJuKGUpKX0sRC5yZWdleHBfcGF0dGVybj1mdW5jdGlvbihlKXtlLnBvcz0wLGUubGFzdEludFZhbHVlPTAsZS5sYXN0U3RyaW5nVmFsdWU9IiIsZS5sYXN0QXNzZXJ0aW9uSXNRdWFudGlmaWFibGU9ITEsZS5udW1DYXB0dXJpbmdQYXJlbnM9MCxlLm1heEJhY2tSZWZlcmVuY2U9MCxlLmdyb3VwTmFtZXMubGVuZ3RoPTAsZS5iYWNrUmVmZXJlbmNlTmFtZXMubGVuZ3RoPTAsdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oZSksZS5wb3MhPT1lLnNvdXJjZS5sZW5ndGgmJihlLmVhdCg0MSkmJmUucmFpc2UoIlVubWF0Y2hlZCAnKSciKSwoZS5lYXQoOTMpfHxlLmVhdCgxMjUpKSYmZS5yYWlzZSgiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzIikpLGUubWF4QmFja1JlZmVyZW5jZT5lLm51bUNhcHR1cmluZ1BhcmVucyYmZS5yYWlzZSgiSW52YWxpZCBlc2NhcGUiKTtmb3IodmFyIHQ9MCxpPWUuYmFja1JlZmVyZW5jZU5hbWVzO3Q8aS5sZW5ndGg7dCs9MSl7dmFyIHM9aVt0XTtlLmdyb3VwTmFtZXMuaW5kZXhPZihzKT09PS0xJiZlLnJhaXNlKCJJbnZhbGlkIG5hbWVkIGNhcHR1cmUgcmVmZXJlbmNlZCIpfX0sRC5yZWdleHBfZGlzanVuY3Rpb249ZnVuY3Rpb24oZSl7Zm9yKHRoaXMucmVnZXhwX2FsdGVybmF0aXZlKGUpO2UuZWF0KDEyNCk7KXRoaXMucmVnZXhwX2FsdGVybmF0aXZlKGUpO3RoaXMucmVnZXhwX2VhdFF1YW50aWZpZXIoZSwhMCkmJmUucmFpc2UoIk5vdGhpbmcgdG8gcmVwZWF0IiksZS5lYXQoMTIzKSYmZS5yYWlzZSgiTG9uZSBxdWFudGlmaWVyIGJyYWNrZXRzIil9LEQucmVnZXhwX2FsdGVybmF0aXZlPWZ1bmN0aW9uKGUpe2Zvcig7ZS5wb3M8ZS5zb3VyY2UubGVuZ3RoJiZ0aGlzLnJlZ2V4cF9lYXRUZXJtKGUpOyk7fSxELnJlZ2V4cF9lYXRUZXJtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnJlZ2V4cF9lYXRBc3NlcnRpb24oZSk/KGUubGFzdEFzc2VydGlvbklzUXVhbnRpZmlhYmxlJiZ0aGlzLnJlZ2V4cF9lYXRRdWFudGlmaWVyKGUpJiZlLnN3aXRjaFUmJmUucmFpc2UoIkludmFsaWQgcXVhbnRpZmllciIpLCEwKTooZS5zd2l0Y2hVP3RoaXMucmVnZXhwX2VhdEF0b20oZSk6dGhpcy5yZWdleHBfZWF0RXh0ZW5kZWRBdG9tKGUpKT8odGhpcy5yZWdleHBfZWF0UXVhbnRpZmllcihlKSwhMCk6ITF9LEQucmVnZXhwX2VhdEFzc2VydGlvbj1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZihlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZT0hMSxlLmVhdCg5NCl8fGUuZWF0KDM2KSlyZXR1cm4hMDtpZihlLmVhdCg5Mikpe2lmKGUuZWF0KDY2KXx8ZS5lYXQoOTgpKXJldHVybiEwO2UucG9zPXR9aWYoZS5lYXQoNDApJiZlLmVhdCg2Mykpe3ZhciBpPSExO2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49OSYmKGk9ZS5lYXQoNjApKSxlLmVhdCg2MSl8fGUuZWF0KDMzKSlyZXR1cm4gdGhpcy5yZWdleHBfZGlzanVuY3Rpb24oZSksZS5lYXQoNDEpfHxlLnJhaXNlKCJVbnRlcm1pbmF0ZWQgZ3JvdXAiKSxlLmxhc3RBc3NlcnRpb25Jc1F1YW50aWZpYWJsZT0haSwhMH1yZXR1cm4gZS5wb3M9dCwhMX0sRC5yZWdleHBfZWF0UXVhbnRpZmllcj1mdW5jdGlvbihlLHQpe3JldHVybiB0PT09dm9pZCAwJiYodD0hMSksdGhpcy5yZWdleHBfZWF0UXVhbnRpZmllclByZWZpeChlLHQpPyhlLmVhdCg2MyksITApOiExfSxELnJlZ2V4cF9lYXRRdWFudGlmaWVyUHJlZml4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuZWF0KDQyKXx8ZS5lYXQoNDMpfHxlLmVhdCg2Myl8fHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoZSx0KX0sRC5yZWdleHBfZWF0QnJhY2VkUXVhbnRpZmllcj1mdW5jdGlvbihlLHQpe3ZhciBpPWUucG9zO2lmKGUuZWF0KDEyMykpe3ZhciBzPTAsbj0tMTtpZih0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRGlnaXRzKGUpJiYocz1lLmxhc3RJbnRWYWx1ZSxlLmVhdCg0NCkmJnRoaXMucmVnZXhwX2VhdERlY2ltYWxEaWdpdHMoZSkmJihuPWUubGFzdEludFZhbHVlKSxlLmVhdCgxMjUpKSlyZXR1cm4gbiE9PS0xJiZuPHMmJiF0JiZlLnJhaXNlKCJudW1iZXJzIG91dCBvZiBvcmRlciBpbiB7fSBxdWFudGlmaWVyIiksITA7ZS5zd2l0Y2hVJiYhdCYmZS5yYWlzZSgiSW5jb21wbGV0ZSBxdWFudGlmaWVyIiksZS5wb3M9aX1yZXR1cm4hMX0sRC5yZWdleHBfZWF0QXRvbT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWdleHBfZWF0UGF0dGVybkNoYXJhY3RlcnMoZSl8fGUuZWF0KDQ2KXx8dGhpcy5yZWdleHBfZWF0UmV2ZXJzZVNvbGlkdXNBdG9tRXNjYXBlKGUpfHx0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzcyhlKXx8dGhpcy5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cChlKXx8dGhpcy5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXAoZSl9LEQucmVnZXhwX2VhdFJldmVyc2VTb2xpZHVzQXRvbUVzY2FwZT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZihlLmVhdCg5Mikpe2lmKHRoaXMucmVnZXhwX2VhdEF0b21Fc2NhcGUoZSkpcmV0dXJuITA7ZS5wb3M9dH1yZXR1cm4hMX0sRC5yZWdleHBfZWF0VW5jYXB0dXJpbmdHcm91cD1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZihlLmVhdCg0MCkpe2lmKGUuZWF0KDYzKSYmZS5lYXQoNTgpKXtpZih0aGlzLnJlZ2V4cF9kaXNqdW5jdGlvbihlKSxlLmVhdCg0MSkpcmV0dXJuITA7ZS5yYWlzZSgiVW50ZXJtaW5hdGVkIGdyb3VwIil9ZS5wb3M9dH1yZXR1cm4hMX0sRC5yZWdleHBfZWF0Q2FwdHVyaW5nR3JvdXA9ZnVuY3Rpb24oZSl7aWYoZS5lYXQoNDApKXtpZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTk/dGhpcy5yZWdleHBfZ3JvdXBTcGVjaWZpZXIoZSk6ZS5jdXJyZW50KCk9PT02MyYmZS5yYWlzZSgiSW52YWxpZCBncm91cCIpLHRoaXMucmVnZXhwX2Rpc2p1bmN0aW9uKGUpLGUuZWF0KDQxKSlyZXR1cm4gZS5udW1DYXB0dXJpbmdQYXJlbnMrPTEsITA7ZS5yYWlzZSgiVW50ZXJtaW5hdGVkIGdyb3VwIil9cmV0dXJuITF9LEQucmVnZXhwX2VhdEV4dGVuZGVkQXRvbT1mdW5jdGlvbihlKXtyZXR1cm4gZS5lYXQoNDYpfHx0aGlzLnJlZ2V4cF9lYXRSZXZlcnNlU29saWR1c0F0b21Fc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzKGUpfHx0aGlzLnJlZ2V4cF9lYXRVbmNhcHR1cmluZ0dyb3VwKGUpfHx0aGlzLnJlZ2V4cF9lYXRDYXB0dXJpbmdHcm91cChlKXx8dGhpcy5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXIoZSl8fHRoaXMucmVnZXhwX2VhdEV4dGVuZGVkUGF0dGVybkNoYXJhY3RlcihlKX0sRC5yZWdleHBfZWF0SW52YWxpZEJyYWNlZFF1YW50aWZpZXI9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdEJyYWNlZFF1YW50aWZpZXIoZSwhMCkmJmUucmFpc2UoIk5vdGhpbmcgdG8gcmVwZWF0IiksITF9LEQucmVnZXhwX2VhdFN5bnRheENoYXJhY3Rlcj1mdW5jdGlvbihlKXt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4gdGModCk/KGUubGFzdEludFZhbHVlPXQsZS5hZHZhbmNlKCksITApOiExfTtmdW5jdGlvbiB0YyhlKXtyZXR1cm4gZT09PTM2fHxlPj00MCYmZTw9NDN8fGU9PT00Nnx8ZT09PTYzfHxlPj05MSYmZTw9OTR8fGU+PTEyMyYmZTw9MTI1fUQucmVnZXhwX2VhdFBhdHRlcm5DaGFyYWN0ZXJzPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLnBvcyxpPTA7KGk9ZS5jdXJyZW50KCkpIT09LTEmJiF0YyhpKTspZS5hZHZhbmNlKCk7cmV0dXJuIGUucG9zIT09dH0sRC5yZWdleHBfZWF0RXh0ZW5kZWRQYXR0ZXJuQ2hhcmFjdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiB0IT09LTEmJnQhPT0zNiYmISh0Pj00MCYmdDw9NDMpJiZ0IT09NDYmJnQhPT02MyYmdCE9PTkxJiZ0IT09OTQmJnQhPT0xMjQ/KGUuYWR2YW5jZSgpLCEwKTohMX0sRC5yZWdleHBfZ3JvdXBTcGVjaWZpZXI9ZnVuY3Rpb24oZSl7aWYoZS5lYXQoNjMpKXtpZih0aGlzLnJlZ2V4cF9lYXRHcm91cE5hbWUoZSkpe2UuZ3JvdXBOYW1lcy5pbmRleE9mKGUubGFzdFN0cmluZ1ZhbHVlKSE9PS0xJiZlLnJhaXNlKCJEdXBsaWNhdGUgY2FwdHVyZSBncm91cCBuYW1lIiksZS5ncm91cE5hbWVzLnB1c2goZS5sYXN0U3RyaW5nVmFsdWUpO3JldHVybn1lLnJhaXNlKCJJbnZhbGlkIGdyb3VwIil9fSxELnJlZ2V4cF9lYXRHcm91cE5hbWU9ZnVuY3Rpb24oZSl7aWYoZS5sYXN0U3RyaW5nVmFsdWU9IiIsZS5lYXQoNjApKXtpZih0aGlzLnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyTmFtZShlKSYmZS5lYXQoNjIpKXJldHVybiEwO2UucmFpc2UoIkludmFsaWQgY2FwdHVyZSBncm91cCBuYW1lIil9cmV0dXJuITF9LEQucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJOYW1lPWZ1bmN0aW9uKGUpe2lmKGUubGFzdFN0cmluZ1ZhbHVlPSIiLHRoaXMucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydChlKSl7Zm9yKGUubGFzdFN0cmluZ1ZhbHVlKz1ZdChlLmxhc3RJbnRWYWx1ZSk7dGhpcy5yZWdleHBfZWF0UmVnRXhwSWRlbnRpZmllclBhcnQoZSk7KWUubGFzdFN0cmluZ1ZhbHVlKz1ZdChlLmxhc3RJbnRWYWx1ZSk7cmV0dXJuITB9cmV0dXJuITF9LEQucmVnZXhwX2VhdFJlZ0V4cElkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcyxpPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEscz1lLmN1cnJlbnQoaSk7cmV0dXJuIGUuYWR2YW5jZShpKSxzPT09OTImJnRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShlLGkpJiYocz1lLmxhc3RJbnRWYWx1ZSksZGcocyk/KGUubGFzdEludFZhbHVlPXMsITApOihlLnBvcz10LCExKX07ZnVuY3Rpb24gZGcoZSl7cmV0dXJuIFR0KGUsITApfHxlPT09MzZ8fGU9PT05NX1ELnJlZ2V4cF9lYXRSZWdFeHBJZGVudGlmaWVyUGFydD1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcyxpPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEscz1lLmN1cnJlbnQoaSk7cmV0dXJuIGUuYWR2YW5jZShpKSxzPT09OTImJnRoaXMucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZShlLGkpJiYocz1lLmxhc3RJbnRWYWx1ZSksZmcocyk/KGUubGFzdEludFZhbHVlPXMsITApOihlLnBvcz10LCExKX07ZnVuY3Rpb24gZmcoZSl7cmV0dXJuIERpKGUsITApfHxlPT09MzZ8fGU9PT05NXx8ZT09PTgyMDR8fGU9PT04MjA1fUQucmVnZXhwX2VhdEF0b21Fc2NhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdEJhY2tSZWZlcmVuY2UoZSl8fHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzRXNjYXBlKGUpfHx0aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGUoZSl8fGUuc3dpdGNoTiYmdGhpcy5yZWdleHBfZWF0S0dyb3VwTmFtZShlKT8hMDooZS5zd2l0Y2hVJiYoZS5jdXJyZW50KCk9PT05OSYmZS5yYWlzZSgiSW52YWxpZCB1bmljb2RlIGVzY2FwZSIpLGUucmFpc2UoIkludmFsaWQgZXNjYXBlIikpLCExKX0sRC5yZWdleHBfZWF0QmFja1JlZmVyZW5jZT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZih0aGlzLnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlKGUpKXt2YXIgaT1lLmxhc3RJbnRWYWx1ZTtpZihlLnN3aXRjaFUpcmV0dXJuIGk+ZS5tYXhCYWNrUmVmZXJlbmNlJiYoZS5tYXhCYWNrUmVmZXJlbmNlPWkpLCEwO2lmKGk8PWUubnVtQ2FwdHVyaW5nUGFyZW5zKXJldHVybiEwO2UucG9zPXR9cmV0dXJuITF9LEQucmVnZXhwX2VhdEtHcm91cE5hbWU9ZnVuY3Rpb24oZSl7aWYoZS5lYXQoMTA3KSl7aWYodGhpcy5yZWdleHBfZWF0R3JvdXBOYW1lKGUpKXJldHVybiBlLmJhY2tSZWZlcmVuY2VOYW1lcy5wdXNoKGUubGFzdFN0cmluZ1ZhbHVlKSwhMDtlLnJhaXNlKCJJbnZhbGlkIG5hbWVkIHJlZmVyZW5jZSIpfXJldHVybiExfSxELnJlZ2V4cF9lYXRDaGFyYWN0ZXJFc2NhcGU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdENvbnRyb2xFc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENDb250cm9sTGV0dGVyKGUpfHx0aGlzLnJlZ2V4cF9lYXRaZXJvKGUpfHx0aGlzLnJlZ2V4cF9lYXRIZXhFc2NhcGVTZXF1ZW5jZShlKXx8dGhpcy5yZWdleHBfZWF0UmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlKGUsITEpfHwhZS5zd2l0Y2hVJiZ0aGlzLnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlKGUpfHx0aGlzLnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZShlKX0sRC5yZWdleHBfZWF0Q0NvbnRyb2xMZXR0ZXI9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3M7aWYoZS5lYXQoOTkpKXtpZih0aGlzLnJlZ2V4cF9lYXRDb250cm9sTGV0dGVyKGUpKXJldHVybiEwO2UucG9zPXR9cmV0dXJuITF9LEQucmVnZXhwX2VhdFplcm89ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY3VycmVudCgpPT09NDgmJiFNbihlLmxvb2thaGVhZCgpKT8oZS5sYXN0SW50VmFsdWU9MCxlLmFkdmFuY2UoKSwhMCk6ITF9LEQucmVnZXhwX2VhdENvbnRyb2xFc2NhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jdXJyZW50KCk7cmV0dXJuIHQ9PT0xMTY/KGUubGFzdEludFZhbHVlPTksZS5hZHZhbmNlKCksITApOnQ9PT0xMTA/KGUubGFzdEludFZhbHVlPTEwLGUuYWR2YW5jZSgpLCEwKTp0PT09MTE4PyhlLmxhc3RJbnRWYWx1ZT0xMSxlLmFkdmFuY2UoKSwhMCk6dD09PTEwMj8oZS5sYXN0SW50VmFsdWU9MTIsZS5hZHZhbmNlKCksITApOnQ9PT0xMTQ/KGUubGFzdEludFZhbHVlPTEzLGUuYWR2YW5jZSgpLCEwKTohMX0sRC5yZWdleHBfZWF0Q29udHJvbExldHRlcj1mdW5jdGlvbihlKXt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4gaWModCk/KGUubGFzdEludFZhbHVlPXQlMzIsZS5hZHZhbmNlKCksITApOiExfTtmdW5jdGlvbiBpYyhlKXtyZXR1cm4gZT49NjUmJmU8PTkwfHxlPj05NyYmZTw9MTIyfUQucmVnZXhwX2VhdFJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZT1mdW5jdGlvbihlLHQpe3Q9PT12b2lkIDAmJih0PSExKTt2YXIgaT1lLnBvcyxzPXR8fGUuc3dpdGNoVTtpZihlLmVhdCgxMTcpKXtpZih0aGlzLnJlZ2V4cF9lYXRGaXhlZEhleERpZ2l0cyhlLDQpKXt2YXIgbj1lLmxhc3RJbnRWYWx1ZTtpZihzJiZuPj01NTI5NiYmbjw9NTYzMTkpe3ZhciByPWUucG9zO2lmKGUuZWF0KDkyKSYmZS5lYXQoMTE3KSYmdGhpcy5yZWdleHBfZWF0Rml4ZWRIZXhEaWdpdHMoZSw0KSl7dmFyIGE9ZS5sYXN0SW50VmFsdWU7aWYoYT49NTYzMjAmJmE8PTU3MzQzKXJldHVybiBlLmxhc3RJbnRWYWx1ZT0obi01NTI5NikqMTAyNCsoYS01NjMyMCkrNjU1MzYsITB9ZS5wb3M9cixlLmxhc3RJbnRWYWx1ZT1ufXJldHVybiEwfWlmKHMmJmUuZWF0KDEyMykmJnRoaXMucmVnZXhwX2VhdEhleERpZ2l0cyhlKSYmZS5lYXQoMTI1KSYmbWcoZS5sYXN0SW50VmFsdWUpKXJldHVybiEwO3MmJmUucmFpc2UoIkludmFsaWQgdW5pY29kZSBlc2NhcGUiKSxlLnBvcz1pfXJldHVybiExfTtmdW5jdGlvbiBtZyhlKXtyZXR1cm4gZT49MCYmZTw9MTExNDExMX1ELnJlZ2V4cF9lYXRJZGVudGl0eUVzY2FwZT1mdW5jdGlvbihlKXtpZihlLnN3aXRjaFUpcmV0dXJuIHRoaXMucmVnZXhwX2VhdFN5bnRheENoYXJhY3RlcihlKT8hMDplLmVhdCg0Nyk/KGUubGFzdEludFZhbHVlPTQ3LCEwKTohMTt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4gdCE9PTk5JiYoIWUuc3dpdGNoTnx8dCE9PTEwNyk/KGUubGFzdEludFZhbHVlPXQsZS5hZHZhbmNlKCksITApOiExfSxELnJlZ2V4cF9lYXREZWNpbWFsRXNjYXBlPWZ1bmN0aW9uKGUpe2UubGFzdEludFZhbHVlPTA7dmFyIHQ9ZS5jdXJyZW50KCk7aWYodD49NDkmJnQ8PTU3KXtkbyBlLmxhc3RJbnRWYWx1ZT0xMCplLmxhc3RJbnRWYWx1ZSsodC00OCksZS5hZHZhbmNlKCk7d2hpbGUoKHQ9ZS5jdXJyZW50KCkpPj00OCYmdDw9NTcpO3JldHVybiEwfXJldHVybiExfTt2YXIgc2M9MCxPdD0xLG90PTI7RC5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jdXJyZW50KCk7aWYoZ2codCkpcmV0dXJuIGUubGFzdEludFZhbHVlPS0xLGUuYWR2YW5jZSgpLE90O3ZhciBpPSExO2lmKGUuc3dpdGNoVSYmdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05JiYoKGk9dD09PTgwKXx8dD09PTExMikpe2UubGFzdEludFZhbHVlPS0xLGUuYWR2YW5jZSgpO3ZhciBzO2lmKGUuZWF0KDEyMykmJihzPXRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbihlKSkmJmUuZWF0KDEyNSkpcmV0dXJuIGkmJnM9PT1vdCYmZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSBuYW1lIikscztlLnJhaXNlKCJJbnZhbGlkIHByb3BlcnR5IG5hbWUiKX1yZXR1cm4gc2N9O2Z1bmN0aW9uIGdnKGUpe3JldHVybiBlPT09MTAwfHxlPT09Njh8fGU9PT0xMTV8fGU9PT04M3x8ZT09PTExOXx8ZT09PTg3fUQucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlRXhwcmVzc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZih0aGlzLnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlOYW1lKGUpJiZlLmVhdCg2MSkpe3ZhciBpPWUubGFzdFN0cmluZ1ZhbHVlO2lmKHRoaXMucmVnZXhwX2VhdFVuaWNvZGVQcm9wZXJ0eVZhbHVlKGUpKXt2YXIgcz1lLmxhc3RTdHJpbmdWYWx1ZTtyZXR1cm4gdGhpcy5yZWdleHBfdmFsaWRhdGVVbmljb2RlUHJvcGVydHlOYW1lQW5kVmFsdWUoZSxpLHMpLE90fX1pZihlLnBvcz10LHRoaXMucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZShlKSl7dmFyIG49ZS5sYXN0U3RyaW5nVmFsdWU7cmV0dXJuIHRoaXMucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZU9yVmFsdWUoZSxuKX1yZXR1cm4gc2N9LEQucmVnZXhwX3ZhbGlkYXRlVW5pY29kZVByb3BlcnR5TmFtZUFuZFZhbHVlPWZ1bmN0aW9uKGUsdCxpKXtTcyhlLnVuaWNvZGVQcm9wZXJ0aWVzLm5vbkJpbmFyeSx0KXx8ZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSBuYW1lIiksZS51bmljb2RlUHJvcGVydGllcy5ub25CaW5hcnlbdF0udGVzdChpKXx8ZS5yYWlzZSgiSW52YWxpZCBwcm9wZXJ0eSB2YWx1ZSIpfSxELnJlZ2V4cF92YWxpZGF0ZVVuaWNvZGVQcm9wZXJ0eU5hbWVPclZhbHVlPWZ1bmN0aW9uKGUsdCl7aWYoZS51bmljb2RlUHJvcGVydGllcy5iaW5hcnkudGVzdCh0KSlyZXR1cm4gT3Q7aWYoZS5zd2l0Y2hWJiZlLnVuaWNvZGVQcm9wZXJ0aWVzLmJpbmFyeU9mU3RyaW5ncy50ZXN0KHQpKXJldHVybiBvdDtlLnJhaXNlKCJJbnZhbGlkIHByb3BlcnR5IG5hbWUiKX0sRC5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5TmFtZT1mdW5jdGlvbihlKXt2YXIgdD0wO2ZvcihlLmxhc3RTdHJpbmdWYWx1ZT0iIjtuYyh0PWUuY3VycmVudCgpKTspZS5sYXN0U3RyaW5nVmFsdWUrPVl0KHQpLGUuYWR2YW5jZSgpO3JldHVybiBlLmxhc3RTdHJpbmdWYWx1ZSE9PSIifTtmdW5jdGlvbiBuYyhlKXtyZXR1cm4gaWMoZSl8fGU9PT05NX1ELnJlZ2V4cF9lYXRVbmljb2RlUHJvcGVydHlWYWx1ZT1mdW5jdGlvbihlKXt2YXIgdD0wO2ZvcihlLmxhc3RTdHJpbmdWYWx1ZT0iIjt5Zyh0PWUuY3VycmVudCgpKTspZS5sYXN0U3RyaW5nVmFsdWUrPVl0KHQpLGUuYWR2YW5jZSgpO3JldHVybiBlLmxhc3RTdHJpbmdWYWx1ZSE9PSIifTtmdW5jdGlvbiB5ZyhlKXtyZXR1cm4gbmMoZSl8fE1uKGUpfUQucmVnZXhwX2VhdExvbmVVbmljb2RlUHJvcGVydHlOYW1lT3JWYWx1ZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5yZWdleHBfZWF0VW5pY29kZVByb3BlcnR5VmFsdWUoZSl9LEQucmVnZXhwX2VhdENoYXJhY3RlckNsYXNzPWZ1bmN0aW9uKGUpe2lmKGUuZWF0KDkxKSl7dmFyIHQ9ZS5lYXQoOTQpLGk9dGhpcy5yZWdleHBfY2xhc3NDb250ZW50cyhlKTtyZXR1cm4gZS5lYXQoOTMpfHxlLnJhaXNlKCJVbnRlcm1pbmF0ZWQgY2hhcmFjdGVyIGNsYXNzIiksdCYmaT09PW90JiZlLnJhaXNlKCJOZWdhdGVkIGNoYXJhY3RlciBjbGFzcyBtYXkgY29udGFpbiBzdHJpbmdzIiksITB9cmV0dXJuITF9LEQucmVnZXhwX2NsYXNzQ29udGVudHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY3VycmVudCgpPT09OTM/T3Q6ZS5zd2l0Y2hWP3RoaXMucmVnZXhwX2NsYXNzU2V0RXhwcmVzc2lvbihlKToodGhpcy5yZWdleHBfbm9uRW1wdHlDbGFzc1JhbmdlcyhlKSxPdCl9LEQucmVnZXhwX25vbkVtcHR5Q2xhc3NSYW5nZXM9ZnVuY3Rpb24oZSl7Zm9yKDt0aGlzLnJlZ2V4cF9lYXRDbGFzc0F0b20oZSk7KXt2YXIgdD1lLmxhc3RJbnRWYWx1ZTtpZihlLmVhdCg0NSkmJnRoaXMucmVnZXhwX2VhdENsYXNzQXRvbShlKSl7dmFyIGk9ZS5sYXN0SW50VmFsdWU7ZS5zd2l0Y2hVJiYodD09PS0xfHxpPT09LTEpJiZlLnJhaXNlKCJJbnZhbGlkIGNoYXJhY3RlciBjbGFzcyIpLHQhPT0tMSYmaSE9PS0xJiZ0PmkmJmUucmFpc2UoIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKX19fSxELnJlZ2V4cF9lYXRDbGFzc0F0b209ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3M7aWYoZS5lYXQoOTIpKXtpZih0aGlzLnJlZ2V4cF9lYXRDbGFzc0VzY2FwZShlKSlyZXR1cm4hMDtpZihlLnN3aXRjaFUpe3ZhciBpPWUuY3VycmVudCgpOyhpPT09OTl8fG9jKGkpKSYmZS5yYWlzZSgiSW52YWxpZCBjbGFzcyBlc2NhcGUiKSxlLnJhaXNlKCJJbnZhbGlkIGVzY2FwZSIpfWUucG9zPXR9dmFyIHM9ZS5jdXJyZW50KCk7cmV0dXJuIHMhPT05Mz8oZS5sYXN0SW50VmFsdWU9cyxlLmFkdmFuY2UoKSwhMCk6ITF9LEQucmVnZXhwX2VhdENsYXNzRXNjYXBlPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDk4KSlyZXR1cm4gZS5sYXN0SW50VmFsdWU9OCwhMDtpZihlLnN3aXRjaFUmJmUuZWF0KDQ1KSlyZXR1cm4gZS5sYXN0SW50VmFsdWU9NDUsITA7aWYoIWUuc3dpdGNoVSYmZS5lYXQoOTkpKXtpZih0aGlzLnJlZ2V4cF9lYXRDbGFzc0NvbnRyb2xMZXR0ZXIoZSkpcmV0dXJuITA7ZS5wb3M9dH1yZXR1cm4gdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyQ2xhc3NFc2NhcGUoZSl8fHRoaXMucmVnZXhwX2VhdENoYXJhY3RlckVzY2FwZShlKX0sRC5yZWdleHBfY2xhc3NTZXRFeHByZXNzaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PU90LGk7aWYoIXRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UoZSkpaWYoaT10aGlzLnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQoZSkpe2k9PT1vdCYmKHQ9b3QpO2Zvcih2YXIgcz1lLnBvcztlLmVhdENoYXJzKFszOCwzOF0pOyl7aWYoZS5jdXJyZW50KCkhPT0zOCYmKGk9dGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKGUpKSl7aSE9PW90JiYodD1PdCk7Y29udGludWV9ZS5yYWlzZSgiSW52YWxpZCBjaGFyYWN0ZXIgaW4gY2hhcmFjdGVyIGNsYXNzIil9aWYocyE9PWUucG9zKXJldHVybiB0O2Zvcig7ZS5lYXRDaGFycyhbNDUsNDVdKTspdGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKGUpfHxlLnJhaXNlKCJJbnZhbGlkIGNoYXJhY3RlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKTtpZihzIT09ZS5wb3MpcmV0dXJuIHR9ZWxzZSBlLnJhaXNlKCJJbnZhbGlkIGNoYXJhY3RlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKTtmb3IoOzspaWYoIXRoaXMucmVnZXhwX2VhdENsYXNzU2V0UmFuZ2UoZSkpe2lmKGk9dGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRPcGVyYW5kKGUpLCFpKXJldHVybiB0O2k9PT1vdCYmKHQ9b3QpfX0sRC5yZWdleHBfZWF0Q2xhc3NTZXRSYW5nZT1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZih0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihlKSl7dmFyIGk9ZS5sYXN0SW50VmFsdWU7aWYoZS5lYXQoNDUpJiZ0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldENoYXJhY3RlcihlKSl7dmFyIHM9ZS5sYXN0SW50VmFsdWU7cmV0dXJuIGkhPT0tMSYmcyE9PS0xJiZpPnMmJmUucmFpc2UoIlJhbmdlIG91dCBvZiBvcmRlciBpbiBjaGFyYWN0ZXIgY2xhc3MiKSwhMH1lLnBvcz10fXJldHVybiExfSxELnJlZ2V4cF9lYXRDbGFzc1NldE9wZXJhbmQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyKGUpP090OnRoaXMucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb24oZSl8fHRoaXMucmVnZXhwX2VhdE5lc3RlZENsYXNzKGUpfSxELnJlZ2V4cF9lYXROZXN0ZWRDbGFzcz1mdW5jdGlvbihlKXt2YXIgdD1lLnBvcztpZihlLmVhdCg5MSkpe3ZhciBpPWUuZWF0KDk0KSxzPXRoaXMucmVnZXhwX2NsYXNzQ29udGVudHMoZSk7aWYoZS5lYXQoOTMpKXJldHVybiBpJiZzPT09b3QmJmUucmFpc2UoIk5lZ2F0ZWQgY2hhcmFjdGVyIGNsYXNzIG1heSBjb250YWluIHN0cmluZ3MiKSxzO2UucG9zPXR9aWYoZS5lYXQoOTIpKXt2YXIgbj10aGlzLnJlZ2V4cF9lYXRDaGFyYWN0ZXJDbGFzc0VzY2FwZShlKTtpZihuKXJldHVybiBuO2UucG9zPXR9cmV0dXJuIG51bGx9LEQucmVnZXhwX2VhdENsYXNzU3RyaW5nRGlzanVuY3Rpb249ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3M7aWYoZS5lYXRDaGFycyhbOTIsMTEzXSkpe2lmKGUuZWF0KDEyMykpe3ZhciBpPXRoaXMucmVnZXhwX2NsYXNzU3RyaW5nRGlzanVuY3Rpb25Db250ZW50cyhlKTtpZihlLmVhdCgxMjUpKXJldHVybiBpfWVsc2UgZS5yYWlzZSgiSW52YWxpZCBlc2NhcGUiKTtlLnBvcz10fXJldHVybiBudWxsfSxELnJlZ2V4cF9jbGFzc1N0cmluZ0Rpc2p1bmN0aW9uQ29udGVudHM9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKGUpO2UuZWF0KDEyNCk7KXRoaXMucmVnZXhwX2NsYXNzU3RyaW5nKGUpPT09b3QmJih0PW90KTtyZXR1cm4gdH0sRC5yZWdleHBfY2xhc3NTdHJpbmc9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTA7dGhpcy5yZWdleHBfZWF0Q2xhc3NTZXRDaGFyYWN0ZXIoZSk7KXQrKztyZXR1cm4gdD09PTE/T3Q6b3R9LEQucmVnZXhwX2VhdENsYXNzU2V0Q2hhcmFjdGVyPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDkyKSlyZXR1cm4gdGhpcy5yZWdleHBfZWF0Q2hhcmFjdGVyRXNjYXBlKGUpfHx0aGlzLnJlZ2V4cF9lYXRDbGFzc1NldFJlc2VydmVkUHVuY3R1YXRvcihlKT8hMDplLmVhdCg5OCk/KGUubGFzdEludFZhbHVlPTgsITApOihlLnBvcz10LCExKTt2YXIgaT1lLmN1cnJlbnQoKTtyZXR1cm4gaTwwfHxpPT09ZS5sb29rYWhlYWQoKSYmeGcoaSl8fGJnKGkpPyExOihlLmFkdmFuY2UoKSxlLmxhc3RJbnRWYWx1ZT1pLCEwKX07ZnVuY3Rpb24geGcoZSl7cmV0dXJuIGU9PT0zM3x8ZT49MzUmJmU8PTM4fHxlPj00MiYmZTw9NDR8fGU9PT00Nnx8ZT49NTgmJmU8PTY0fHxlPT09OTR8fGU9PT05Nnx8ZT09PTEyNn1mdW5jdGlvbiBiZyhlKXtyZXR1cm4gZT09PTQwfHxlPT09NDF8fGU9PT00NXx8ZT09PTQ3fHxlPj05MSYmZTw9OTN8fGU+PTEyMyYmZTw9MTI1fUQucmVnZXhwX2VhdENsYXNzU2V0UmVzZXJ2ZWRQdW5jdHVhdG9yPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiB2Zyh0KT8oZS5sYXN0SW50VmFsdWU9dCxlLmFkdmFuY2UoKSwhMCk6ITF9O2Z1bmN0aW9uIHZnKGUpe3JldHVybiBlPT09MzN8fGU9PT0zNXx8ZT09PTM3fHxlPT09Mzh8fGU9PT00NHx8ZT09PTQ1fHxlPj01OCYmZTw9NjJ8fGU9PT02NHx8ZT09PTk2fHxlPT09MTI2fUQucmVnZXhwX2VhdENsYXNzQ29udHJvbExldHRlcj1mdW5jdGlvbihlKXt2YXIgdD1lLmN1cnJlbnQoKTtyZXR1cm4gTW4odCl8fHQ9PT05NT8oZS5sYXN0SW50VmFsdWU9dCUzMixlLmFkdmFuY2UoKSwhMCk6ITF9LEQucmVnZXhwX2VhdEhleEVzY2FwZVNlcXVlbmNlPWZ1bmN0aW9uKGUpe3ZhciB0PWUucG9zO2lmKGUuZWF0KDEyMCkpe2lmKHRoaXMucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzKGUsMikpcmV0dXJuITA7ZS5zd2l0Y2hVJiZlLnJhaXNlKCJJbnZhbGlkIGVzY2FwZSIpLGUucG9zPXR9cmV0dXJuITF9LEQucmVnZXhwX2VhdERlY2ltYWxEaWdpdHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3MsaT0wO2ZvcihlLmxhc3RJbnRWYWx1ZT0wO01uKGk9ZS5jdXJyZW50KCkpOyllLmxhc3RJbnRWYWx1ZT0xMCplLmxhc3RJbnRWYWx1ZSsoaS00OCksZS5hZHZhbmNlKCk7cmV0dXJuIGUucG9zIT09dH07ZnVuY3Rpb24gTW4oZSl7cmV0dXJuIGU+PTQ4JiZlPD01N31ELnJlZ2V4cF9lYXRIZXhEaWdpdHM9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5wb3MsaT0wO2ZvcihlLmxhc3RJbnRWYWx1ZT0wO3JjKGk9ZS5jdXJyZW50KCkpOyllLmxhc3RJbnRWYWx1ZT0xNiplLmxhc3RJbnRWYWx1ZSthYyhpKSxlLmFkdmFuY2UoKTtyZXR1cm4gZS5wb3MhPT10fTtmdW5jdGlvbiByYyhlKXtyZXR1cm4gZT49NDgmJmU8PTU3fHxlPj02NSYmZTw9NzB8fGU+PTk3JiZlPD0xMDJ9ZnVuY3Rpb24gYWMoZSl7cmV0dXJuIGU+PTY1JiZlPD03MD8xMCsoZS02NSk6ZT49OTcmJmU8PTEwMj8xMCsoZS05Nyk6ZS00OH1ELnJlZ2V4cF9lYXRMZWdhY3lPY3RhbEVzY2FwZVNlcXVlbmNlPWZ1bmN0aW9uKGUpe2lmKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSkpe3ZhciB0PWUubGFzdEludFZhbHVlO2lmKHRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSkpe3ZhciBpPWUubGFzdEludFZhbHVlO3Q8PTMmJnRoaXMucmVnZXhwX2VhdE9jdGFsRGlnaXQoZSk/ZS5sYXN0SW50VmFsdWU9dCo2NCtpKjgrZS5sYXN0SW50VmFsdWU6ZS5sYXN0SW50VmFsdWU9dCo4K2l9ZWxzZSBlLmxhc3RJbnRWYWx1ZT10O3JldHVybiEwfXJldHVybiExfSxELnJlZ2V4cF9lYXRPY3RhbERpZ2l0PWZ1bmN0aW9uKGUpe3ZhciB0PWUuY3VycmVudCgpO3JldHVybiBvYyh0KT8oZS5sYXN0SW50VmFsdWU9dC00OCxlLmFkdmFuY2UoKSwhMCk6KGUubGFzdEludFZhbHVlPTAsITEpfTtmdW5jdGlvbiBvYyhlKXtyZXR1cm4gZT49NDgmJmU8PTU1fUQucmVnZXhwX2VhdEZpeGVkSGV4RGlnaXRzPWZ1bmN0aW9uKGUsdCl7dmFyIGk9ZS5wb3M7ZS5sYXN0SW50VmFsdWU9MDtmb3IodmFyIHM9MDtzPHQ7KytzKXt2YXIgbj1lLmN1cnJlbnQoKTtpZighcmMobikpcmV0dXJuIGUucG9zPWksITE7ZS5sYXN0SW50VmFsdWU9MTYqZS5sYXN0SW50VmFsdWUrYWMobiksZS5hZHZhbmNlKCl9cmV0dXJuITB9O3ZhciBEYT1mdW5jdGlvbih0KXt0aGlzLnR5cGU9dC50eXBlLHRoaXMudmFsdWU9dC52YWx1ZSx0aGlzLnN0YXJ0PXQuc3RhcnQsdGhpcy5lbmQ9dC5lbmQsdC5vcHRpb25zLmxvY2F0aW9ucyYmKHRoaXMubG9jPW5ldyAkbih0LHQuc3RhcnRMb2MsdC5lbmRMb2MpKSx0Lm9wdGlvbnMucmFuZ2VzJiYodGhpcy5yYW5nZT1bdC5zdGFydCx0LmVuZF0pfSxlZT1QZS5wcm90b3R5cGU7ZWUubmV4dD1mdW5jdGlvbihlKXshZSYmdGhpcy50eXBlLmtleXdvcmQmJnRoaXMuY29udGFpbnNFc2MmJnRoaXMucmFpc2VSZWNvdmVyYWJsZSh0aGlzLnN0YXJ0LCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCAiK3RoaXMudHlwZS5rZXl3b3JkKSx0aGlzLm9wdGlvbnMub25Ub2tlbiYmdGhpcy5vcHRpb25zLm9uVG9rZW4obmV3IERhKHRoaXMpKSx0aGlzLmxhc3RUb2tFbmQ9dGhpcy5lbmQsdGhpcy5sYXN0VG9rU3RhcnQ9dGhpcy5zdGFydCx0aGlzLmxhc3RUb2tFbmRMb2M9dGhpcy5lbmRMb2MsdGhpcy5sYXN0VG9rU3RhcnRMb2M9dGhpcy5zdGFydExvYyx0aGlzLm5leHRUb2tlbigpfSxlZS5nZXRUb2tlbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHQoKSxuZXcgRGEodGhpcyl9LHR5cGVvZiBTeW1ib2w8InUiJiYoZWVbU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7cmV0dXJue25leHQ6ZnVuY3Rpb24oKXt2YXIgdD1lLmdldFRva2VuKCk7cmV0dXJue2RvbmU6dC50eXBlPT09ZC5lb2YsdmFsdWU6dH19fX0pLGVlLm5leHRUb2tlbj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY3VyQ29udGV4dCgpO2lmKCghZXx8IWUucHJlc2VydmVTcGFjZSkmJnRoaXMuc2tpcFNwYWNlKCksdGhpcy5zdGFydD10aGlzLnBvcyx0aGlzLm9wdGlvbnMubG9jYXRpb25zJiYodGhpcy5zdGFydExvYz10aGlzLmN1clBvc2l0aW9uKCkpLHRoaXMucG9zPj10aGlzLmlucHV0Lmxlbmd0aClyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihkLmVvZik7aWYoZS5vdmVycmlkZSlyZXR1cm4gZS5vdmVycmlkZSh0aGlzKTt0aGlzLnJlYWRUb2tlbih0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpfSxlZS5yZWFkVG9rZW49ZnVuY3Rpb24oZSl7cmV0dXJuIFR0KGUsdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02KXx8ZT09PTkyP3RoaXMucmVhZFdvcmQoKTp0aGlzLmdldFRva2VuRnJvbUNvZGUoZSl9LGVlLmZ1bGxDaGFyQ29kZUF0UG9zPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtpZihlPD01NTI5NXx8ZT49NTYzMjApcmV0dXJuIGU7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO3JldHVybiB0PD01NjMxOXx8dD49NTczNDQ/ZTooZTw8MTApK3QtNTY2MTM4ODh9LGVlLnNraXBCbG9ja0NvbW1lbnQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLm9wdGlvbnMub25Db21tZW50JiZ0aGlzLmN1clBvc2l0aW9uKCksdD10aGlzLnBvcyxpPXRoaXMuaW5wdXQuaW5kZXhPZigiKi8iLHRoaXMucG9zKz0yKTtpZihpPT09LTEmJnRoaXMucmFpc2UodGhpcy5wb3MtMiwiVW50ZXJtaW5hdGVkIGNvbW1lbnQiKSx0aGlzLnBvcz1pKzIsdGhpcy5vcHRpb25zLmxvY2F0aW9ucylmb3IodmFyIHM9dm9pZCAwLG49dDsocz1BdSh0aGlzLmlucHV0LG4sdGhpcy5wb3MpKT4tMTspKyt0aGlzLmN1ckxpbmUsbj10aGlzLmxpbmVTdGFydD1zO3RoaXMub3B0aW9ucy5vbkNvbW1lbnQmJnRoaXMub3B0aW9ucy5vbkNvbW1lbnQoITAsdGhpcy5pbnB1dC5zbGljZSh0KzIsaSksdCx0aGlzLnBvcyxlLHRoaXMuY3VyUG9zaXRpb24oKSl9LGVlLnNraXBMaW5lQ29tbWVudD1mdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5wb3MsaT10aGlzLm9wdGlvbnMub25Db21tZW50JiZ0aGlzLmN1clBvc2l0aW9uKCkscz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrPWUpO3RoaXMucG9zPHRoaXMuaW5wdXQubGVuZ3RoJiYhQmkocyk7KXM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5wb3MpO3RoaXMub3B0aW9ucy5vbkNvbW1lbnQmJnRoaXMub3B0aW9ucy5vbkNvbW1lbnQoITEsdGhpcy5pbnB1dC5zbGljZSh0K2UsdGhpcy5wb3MpLHQsdGhpcy5wb3MsaSx0aGlzLmN1clBvc2l0aW9uKCkpfSxlZS5za2lwU3BhY2U9ZnVuY3Rpb24oKXtlOmZvcig7dGhpcy5wb3M8dGhpcy5pbnB1dC5sZW5ndGg7KXt2YXIgZT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO3N3aXRjaChlKXtjYXNlIDMyOmNhc2UgMTYwOisrdGhpcy5wb3M7YnJlYWs7Y2FzZSAxMzp0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk9PT0xMCYmKyt0aGlzLnBvcztjYXNlIDEwOmNhc2UgODIzMjpjYXNlIDgyMzM6Kyt0aGlzLnBvcyx0aGlzLm9wdGlvbnMubG9jYXRpb25zJiYoKyt0aGlzLmN1ckxpbmUsdGhpcy5saW5lU3RhcnQ9dGhpcy5wb3MpO2JyZWFrO2Nhc2UgNDc6c3dpdGNoKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKSl7Y2FzZSA0Mjp0aGlzLnNraXBCbG9ja0NvbW1lbnQoKTticmVhaztjYXNlIDQ3OnRoaXMuc2tpcExpbmVDb21tZW50KDIpO2JyZWFrO2RlZmF1bHQ6YnJlYWsgZX1icmVhaztkZWZhdWx0OmlmKGU+OCYmZTwxNHx8ZT49NTc2MCYmQ3UudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKSkrK3RoaXMucG9zO2Vsc2UgYnJlYWsgZX19fSxlZS5maW5pc2hUb2tlbj1mdW5jdGlvbihlLHQpe3RoaXMuZW5kPXRoaXMucG9zLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJih0aGlzLmVuZExvYz10aGlzLmN1clBvc2l0aW9uKCkpO3ZhciBpPXRoaXMudHlwZTt0aGlzLnR5cGU9ZSx0aGlzLnZhbHVlPXQsdGhpcy51cGRhdGVDb250ZXh0KGkpfSxlZS5yZWFkVG9rZW5fZG90PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO2lmKGU+PTQ4JiZlPD01NylyZXR1cm4gdGhpcy5yZWFkTnVtYmVyKCEwKTt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMik7cmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NiYmZT09PTQ2JiZ0PT09NDY/KHRoaXMucG9zKz0zLHRoaXMuZmluaXNoVG9rZW4oZC5lbGxpcHNpcykpOigrK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZC5kb3QpKX0sZWUucmVhZFRva2VuX3NsYXNoPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO3JldHVybiB0aGlzLmV4cHJBbGxvd2VkPygrK3RoaXMucG9zLHRoaXMucmVhZFJlZ2V4cCgpKTplPT09NjE/dGhpcy5maW5pc2hPcChkLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKGQuc2xhc2gsMSl9LGVlLnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHA9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpLGk9MSxzPWU9PT00Mj9kLnN0YXI6ZC5tb2R1bG87cmV0dXJuIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49NyYmZT09PTQyJiZ0PT09NDImJigrK2kscz1kLnN0YXJzdGFyLHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpKSx0PT09NjE/dGhpcy5maW5pc2hPcChkLmFzc2lnbixpKzEpOnRoaXMuZmluaXNoT3AocyxpKX0sZWUucmVhZFRva2VuX3BpcGVfYW1wPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKTtpZih0PT09ZSl7aWYodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj0xMil7dmFyIGk9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpO2lmKGk9PT02MSlyZXR1cm4gdGhpcy5maW5pc2hPcChkLmFzc2lnbiwzKX1yZXR1cm4gdGhpcy5maW5pc2hPcChlPT09MTI0P2QubG9naWNhbE9SOmQubG9naWNhbEFORCwyKX1yZXR1cm4gdD09PTYxP3RoaXMuZmluaXNoT3AoZC5hc3NpZ24sMik6dGhpcy5maW5pc2hPcChlPT09MTI0P2QuYml0d2lzZU9SOmQuYml0d2lzZUFORCwxKX0sZWUucmVhZFRva2VuX2NhcmV0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO3JldHVybiBlPT09NjE/dGhpcy5maW5pc2hPcChkLmFzc2lnbiwyKTp0aGlzLmZpbmlzaE9wKGQuYml0d2lzZVhPUiwxKX0sZWUucmVhZFRva2VuX3BsdXNfbWluPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKTtyZXR1cm4gdD09PWU/dD09PTQ1JiYhdGhpcy5pbk1vZHVsZSYmdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpPT09NjImJih0aGlzLmxhc3RUb2tFbmQ9PT0wfHxudC50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLHRoaXMucG9zKSkpPyh0aGlzLnNraXBMaW5lQ29tbWVudCgzKSx0aGlzLnNraXBTcGFjZSgpLHRoaXMubmV4dFRva2VuKCkpOnRoaXMuZmluaXNoT3AoZC5pbmNEZWMsMik6dD09PTYxP3RoaXMuZmluaXNoT3AoZC5hc3NpZ24sMik6dGhpcy5maW5pc2hPcChkLnBsdXNNaW4sMSl9LGVlLnJlYWRUb2tlbl9sdF9ndD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSksaT0xO3JldHVybiB0PT09ZT8oaT1lPT09NjImJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKT09PTYyPzM6Mix0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MraSk9PT02MT90aGlzLmZpbmlzaE9wKGQuYXNzaWduLGkrMSk6dGhpcy5maW5pc2hPcChkLmJpdFNoaWZ0LGkpKTp0PT09MzMmJmU9PT02MCYmIXRoaXMuaW5Nb2R1bGUmJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysyKT09PTQ1JiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMyk9PT00NT8odGhpcy5za2lwTGluZUNvbW1lbnQoNCksdGhpcy5za2lwU3BhY2UoKSx0aGlzLm5leHRUb2tlbigpKToodD09PTYxJiYoaT0yKSx0aGlzLmZpbmlzaE9wKGQucmVsYXRpb25hbCxpKSl9LGVlLnJlYWRUb2tlbl9lcV9leGNsPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcysxKTtyZXR1cm4gdD09PTYxP3RoaXMuZmluaXNoT3AoZC5lcXVhbGl0eSx0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMik9PT02MT8zOjIpOmU9PT02MSYmdD09PTYyJiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTY/KHRoaXMucG9zKz0yLHRoaXMuZmluaXNoVG9rZW4oZC5hcnJvdykpOnRoaXMuZmluaXNoT3AoZT09PTYxP2QuZXE6ZC5wcmVmaXgsMSl9LGVlLnJlYWRUb2tlbl9xdWVzdGlvbj1mdW5jdGlvbigpe3ZhciBlPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbjtpZihlPj0xMSl7dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO2lmKHQ9PT00Nil7dmFyIGk9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzIpO2lmKGk8NDh8fGk+NTcpcmV0dXJuIHRoaXMuZmluaXNoT3AoZC5xdWVzdGlvbkRvdCwyKX1pZih0PT09NjMpe2lmKGU+PTEyKXt2YXIgcz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMik7aWYocz09PTYxKXJldHVybiB0aGlzLmZpbmlzaE9wKGQuYXNzaWduLDMpfXJldHVybiB0aGlzLmZpbmlzaE9wKGQuY29hbGVzY2UsMil9fXJldHVybiB0aGlzLmZpbmlzaE9wKGQucXVlc3Rpb24sMSl9LGVlLnJlYWRUb2tlbl9udW1iZXJTaWduPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uLHQ9MzU7aWYoZT49MTMmJigrK3RoaXMucG9zLHQ9dGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpLFR0KHQsITApfHx0PT09OTIpKXJldHVybiB0aGlzLmZpbmlzaFRva2VuKGQucHJpdmF0ZUlkLHRoaXMucmVhZFdvcmQxKCkpO3RoaXMucmFpc2UodGhpcy5wb3MsIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICciK1l0KHQpKyInIil9LGVlLmdldFRva2VuRnJvbUNvZGU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2UgNDY6cmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpO2Nhc2UgNDA6cmV0dXJuKyt0aGlzLnBvcyx0aGlzLmZpbmlzaFRva2VuKGQucGFyZW5MKTtjYXNlIDQxOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihkLnBhcmVuUik7Y2FzZSA1OTpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZC5zZW1pKTtjYXNlIDQ0OnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihkLmNvbW1hKTtjYXNlIDkxOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihkLmJyYWNrZXRMKTtjYXNlIDkzOnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihkLmJyYWNrZXRSKTtjYXNlIDEyMzpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZC5icmFjZUwpO2Nhc2UgMTI1OnJldHVybisrdGhpcy5wb3MsdGhpcy5maW5pc2hUb2tlbihkLmJyYWNlUik7Y2FzZSA1ODpyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZC5jb2xvbik7Y2FzZSA5NjppZih0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248NilicmVhaztyZXR1cm4rK3RoaXMucG9zLHRoaXMuZmluaXNoVG9rZW4oZC5iYWNrUXVvdGUpO2Nhc2UgNDg6dmFyIHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKzEpO2lmKHQ9PT0xMjB8fHQ9PT04OClyZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpO2lmKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49Nil7aWYodD09PTExMXx8dD09PTc5KXJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcig4KTtpZih0PT09OTh8fHQ9PT02NilyZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMil9Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6cmV0dXJuIHRoaXMucmVhZE51bWJlcighMSk7Y2FzZSAzNDpjYXNlIDM5OnJldHVybiB0aGlzLnJlYWRTdHJpbmcoZSk7Y2FzZSA0NzpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fc2xhc2goKTtjYXNlIDM3OmNhc2UgNDI6cmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChlKTtjYXNlIDEyNDpjYXNlIDM4OnJldHVybiB0aGlzLnJlYWRUb2tlbl9waXBlX2FtcChlKTtjYXNlIDk0OnJldHVybiB0aGlzLnJlYWRUb2tlbl9jYXJldCgpO2Nhc2UgNDM6Y2FzZSA0NTpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fcGx1c19taW4oZSk7Y2FzZSA2MDpjYXNlIDYyOnJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChlKTtjYXNlIDYxOmNhc2UgMzM6cmV0dXJuIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woZSk7Y2FzZSA2MzpyZXR1cm4gdGhpcy5yZWFkVG9rZW5fcXVlc3Rpb24oKTtjYXNlIDEyNjpyZXR1cm4gdGhpcy5maW5pc2hPcChkLnByZWZpeCwxKTtjYXNlIDM1OnJldHVybiB0aGlzLnJlYWRUb2tlbl9udW1iZXJTaWduKCl9dGhpcy5yYWlzZSh0aGlzLnBvcywiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJyIrWXQoZSkrIiciKX0sZWUuZmluaXNoT3A9ZnVuY3Rpb24oZSx0KXt2YXIgaT10aGlzLmlucHV0LnNsaWNlKHRoaXMucG9zLHRoaXMucG9zK3QpO3JldHVybiB0aGlzLnBvcys9dCx0aGlzLmZpbmlzaFRva2VuKGUsaSl9LGVlLnJlYWRSZWdleHA9ZnVuY3Rpb24oKXtmb3IodmFyIGUsdCxpPXRoaXMucG9zOzspe3RoaXMucG9zPj10aGlzLmlucHV0Lmxlbmd0aCYmdGhpcy5yYWlzZShpLCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uIik7dmFyIHM9dGhpcy5pbnB1dC5jaGFyQXQodGhpcy5wb3MpO2lmKG50LnRlc3QocykmJnRoaXMucmFpc2UoaSwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbiIpLGUpZT0hMTtlbHNle2lmKHM9PT0iWyIpdD0hMDtlbHNlIGlmKHM9PT0iXSImJnQpdD0hMTtlbHNlIGlmKHM9PT0iLyImJiF0KWJyZWFrO2U9cz09PSJcXCJ9Kyt0aGlzLnBvc312YXIgbj10aGlzLmlucHV0LnNsaWNlKGksdGhpcy5wb3MpOysrdGhpcy5wb3M7dmFyIHI9dGhpcy5wb3MsYT10aGlzLnJlYWRXb3JkMSgpO3RoaXMuY29udGFpbnNFc2MmJnRoaXMudW5leHBlY3RlZChyKTt2YXIgbz10aGlzLnJlZ2V4cFN0YXRlfHwodGhpcy5yZWdleHBTdGF0ZT1uZXcgd3QodGhpcykpO28ucmVzZXQoaSxuLGEpLHRoaXMudmFsaWRhdGVSZWdFeHBGbGFncyhvKSx0aGlzLnZhbGlkYXRlUmVnRXhwUGF0dGVybihvKTt2YXIgaD1udWxsO3RyeXtoPW5ldyBSZWdFeHAobixhKX1jYXRjaHt9cmV0dXJuIHRoaXMuZmluaXNoVG9rZW4oZC5yZWdleHAse3BhdHRlcm46bixmbGFnczphLHZhbHVlOmh9KX0sZWUucmVhZEludD1mdW5jdGlvbihlLHQsaSl7Zm9yKHZhciBzPXRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTImJnQ9PT12b2lkIDAsbj1pJiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpPT09NDgscj10aGlzLnBvcyxhPTAsbz0wLGg9MCxsPXQ/PzEvMDtoPGw7KytoLCsrdGhpcy5wb3Mpe3ZhciBjPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcykscD12b2lkIDA7aWYocyYmYz09PTk1KXtuJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGluIGxlZ2FjeSBvY3RhbCBudW1lcmljIGxpdGVyYWxzIiksbz09PTk1JiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIk51bWVyaWMgc2VwYXJhdG9yIG11c3QgYmUgZXhhY3RseSBvbmUgdW5kZXJzY29yZSIpLGg9PT0wJiZ0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5wb3MsIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBmaXJzdCBvZiBkaWdpdHMiKSxvPWM7Y29udGludWV9aWYoYz49OTc/cD1jLTk3KzEwOmM+PTY1P3A9Yy02NSsxMDpjPj00OCYmYzw9NTc/cD1jLTQ4OnA9MS8wLHA+PWUpYnJlYWs7bz1jLGE9YSplK3B9cmV0dXJuIHMmJm89PT05NSYmdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMucG9zLTEsIk51bWVyaWMgc2VwYXJhdG9yIGlzIG5vdCBhbGxvd2VkIGF0IHRoZSBsYXN0IG9mIGRpZ2l0cyIpLHRoaXMucG9zPT09cnx8dCE9bnVsbCYmdGhpcy5wb3MtciE9PXQ/bnVsbDphfTtmdW5jdGlvbiBFZyhlLHQpe3JldHVybiB0P3BhcnNlSW50KGUsOCk6cGFyc2VGbG9hdChlLnJlcGxhY2UoL18vZywiIikpfWZ1bmN0aW9uIGhjKGUpe3JldHVybiB0eXBlb2YgQmlnSW50IT0iZnVuY3Rpb24iP251bGw6QmlnSW50KGUucmVwbGFjZSgvXy9nLCIiKSl9ZWUucmVhZFJhZGl4TnVtYmVyPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucG9zO3RoaXMucG9zKz0yO3ZhciBpPXRoaXMucmVhZEludChlKTtyZXR1cm4gaT09bnVsbCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0KzIsIkV4cGVjdGVkIG51bWJlciBpbiByYWRpeCAiK2UpLHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbj49MTEmJnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk9PT0xMTA/KGk9aGModGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSksKyt0aGlzLnBvcyk6VHQodGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpKSYmdGhpcy5yYWlzZSh0aGlzLnBvcywiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXIiKSx0aGlzLmZpbmlzaFRva2VuKGQubnVtLGkpfSxlZS5yZWFkTnVtYmVyPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMucG9zOyFlJiZ0aGlzLnJlYWRJbnQoMTAsdm9pZCAwLCEwKT09PW51bGwmJnRoaXMucmFpc2UodCwiSW52YWxpZCBudW1iZXIiKTt2YXIgaT10aGlzLnBvcy10Pj0yJiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodCk9PT00ODtpJiZ0aGlzLnN0cmljdCYmdGhpcy5yYWlzZSh0LCJJbnZhbGlkIG51bWJlciIpO3ZhciBzPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7aWYoIWkmJiFlJiZ0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24+PTExJiZzPT09MTEwKXt2YXIgbj1oYyh0aGlzLmlucHV0LnNsaWNlKHQsdGhpcy5wb3MpKTtyZXR1cm4rK3RoaXMucG9zLFR0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkmJnRoaXMucmFpc2UodGhpcy5wb3MsIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyIiksdGhpcy5maW5pc2hUb2tlbihkLm51bSxuKX1pJiYvWzg5XS8udGVzdCh0aGlzLmlucHV0LnNsaWNlKHQsdGhpcy5wb3MpKSYmKGk9ITEpLHM9PT00NiYmIWkmJigrK3RoaXMucG9zLHRoaXMucmVhZEludCgxMCkscz10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpKSwocz09PTY5fHxzPT09MTAxKSYmIWkmJihzPXRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSwocz09PTQzfHxzPT09NDUpJiYrK3RoaXMucG9zLHRoaXMucmVhZEludCgxMCk9PT1udWxsJiZ0aGlzLnJhaXNlKHQsIkludmFsaWQgbnVtYmVyIikpLFR0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkmJnRoaXMucmFpc2UodGhpcy5wb3MsIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyIik7dmFyIHI9RWcodGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSxpKTtyZXR1cm4gdGhpcy5maW5pc2hUb2tlbihkLm51bSxyKX0sZWUucmVhZENvZGVQb2ludD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyksdDtpZihlPT09MTIzKXt0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb248NiYmdGhpcy51bmV4cGVjdGVkKCk7dmFyIGk9Kyt0aGlzLnBvczt0PXRoaXMucmVhZEhleENoYXIodGhpcy5pbnB1dC5pbmRleE9mKCJ9Iix0aGlzLnBvcyktdGhpcy5wb3MpLCsrdGhpcy5wb3MsdD4xMTE0MTExJiZ0aGlzLmludmFsaWRTdHJpbmdUb2tlbihpLCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHMiKX1lbHNlIHQ9dGhpcy5yZWFkSGV4Q2hhcig0KTtyZXR1cm4gdH0sZWUucmVhZFN0cmluZz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9IiIsaT0rK3RoaXMucG9zOzspe3RoaXMucG9zPj10aGlzLmlucHV0Lmxlbmd0aCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50Iik7dmFyIHM9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtpZihzPT09ZSlicmVhaztzPT09OTI/KHQrPXRoaXMuaW5wdXQuc2xpY2UoaSx0aGlzLnBvcyksdCs9dGhpcy5yZWFkRXNjYXBlZENoYXIoITEpLGk9dGhpcy5wb3MpOnM9PT04MjMyfHxzPT09ODIzMz8odGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPDEwJiZ0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnQiKSwrK3RoaXMucG9zLHRoaXMub3B0aW9ucy5sb2NhdGlvbnMmJih0aGlzLmN1ckxpbmUrKyx0aGlzLmxpbmVTdGFydD10aGlzLnBvcykpOihCaShzKSYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50IiksKyt0aGlzLnBvcyl9cmV0dXJuIHQrPXRoaXMuaW5wdXQuc2xpY2UoaSx0aGlzLnBvcysrKSx0aGlzLmZpbmlzaFRva2VuKGQuc3RyaW5nLHQpfTt2YXIgbGM9e307ZWUudHJ5UmVhZFRlbXBsYXRlVG9rZW49ZnVuY3Rpb24oKXt0aGlzLmluVGVtcGxhdGVFbGVtZW50PSEwO3RyeXt0aGlzLnJlYWRUbXBsVG9rZW4oKX1jYXRjaChlKXtpZihlPT09bGMpdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtlbHNlIHRocm93IGV9dGhpcy5pblRlbXBsYXRlRWxlbWVudD0hMX0sZWUuaW52YWxpZFN0cmluZ1Rva2VuPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5pblRlbXBsYXRlRWxlbWVudCYmdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj05KXRocm93IGxjO3RoaXMucmFpc2UoZSx0KX0sZWUucmVhZFRtcGxUb2tlbj1mdW5jdGlvbigpe2Zvcih2YXIgZT0iIix0PXRoaXMucG9zOzspe3RoaXMucG9zPj10aGlzLmlucHV0Lmxlbmd0aCYmdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGUiKTt2YXIgaT10aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO2lmKGk9PT05Nnx8aT09PTM2JiZ0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MrMSk9PT0xMjMpcmV0dXJuIHRoaXMucG9zPT09dGhpcy5zdGFydCYmKHRoaXMudHlwZT09PWQudGVtcGxhdGV8fHRoaXMudHlwZT09PWQuaW52YWxpZFRlbXBsYXRlKT9pPT09MzY/KHRoaXMucG9zKz0yLHRoaXMuZmluaXNoVG9rZW4oZC5kb2xsYXJCcmFjZUwpKTooKyt0aGlzLnBvcyx0aGlzLmZpbmlzaFRva2VuKGQuYmFja1F1b3RlKSk6KGUrPXRoaXMuaW5wdXQuc2xpY2UodCx0aGlzLnBvcyksdGhpcy5maW5pc2hUb2tlbihkLnRlbXBsYXRlLGUpKTtpZihpPT09OTIpZSs9dGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSxlKz10aGlzLnJlYWRFc2NhcGVkQ2hhcighMCksdD10aGlzLnBvcztlbHNlIGlmKEJpKGkpKXtzd2l0Y2goZSs9dGhpcy5pbnB1dC5zbGljZSh0LHRoaXMucG9zKSwrK3RoaXMucG9zLGkpe2Nhc2UgMTM6dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKT09PTEwJiYrK3RoaXMucG9zO2Nhc2UgMTA6ZSs9YApgO2JyZWFrO2RlZmF1bHQ6ZSs9U3RyaW5nLmZyb21DaGFyQ29kZShpKTticmVha310aGlzLm9wdGlvbnMubG9jYXRpb25zJiYoKyt0aGlzLmN1ckxpbmUsdGhpcy5saW5lU3RhcnQ9dGhpcy5wb3MpLHQ9dGhpcy5wb3N9ZWxzZSsrdGhpcy5wb3N9fSxlZS5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW49ZnVuY3Rpb24oKXtmb3IoO3RoaXMucG9zPHRoaXMuaW5wdXQubGVuZ3RoO3RoaXMucG9zKyspc3dpdGNoKHRoaXMuaW5wdXRbdGhpcy5wb3NdKXtjYXNlIlxcIjorK3RoaXMucG9zO2JyZWFrO2Nhc2UiJCI6aWYodGhpcy5pbnB1dFt0aGlzLnBvcysxXSE9PSJ7IilicmVhaztjYXNlImAiOnJldHVybiB0aGlzLmZpbmlzaFRva2VuKGQuaW52YWxpZFRlbXBsYXRlLHRoaXMuaW5wdXQuc2xpY2UodGhpcy5zdGFydCx0aGlzLnBvcykpfXRoaXMucmFpc2UodGhpcy5zdGFydCwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlIil9LGVlLnJlYWRFc2NhcGVkQ2hhcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7c3dpdGNoKCsrdGhpcy5wb3MsdCl7Y2FzZSAxMTA6cmV0dXJuYApgO2Nhc2UgMTE0OnJldHVybiJcciI7Y2FzZSAxMjA6cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkSGV4Q2hhcigyKSk7Y2FzZSAxMTc6cmV0dXJuIFl0KHRoaXMucmVhZENvZGVQb2ludCgpKTtjYXNlIDExNjpyZXR1cm4iCSI7Y2FzZSA5ODpyZXR1cm4iXGIiO2Nhc2UgMTE4OnJldHVybiJcdiI7Y2FzZSAxMDI6cmV0dXJuIlxmIjtjYXNlIDEzOnRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk9PT0xMCYmKyt0aGlzLnBvcztjYXNlIDEwOnJldHVybiB0aGlzLm9wdGlvbnMubG9jYXRpb25zJiYodGhpcy5saW5lU3RhcnQ9dGhpcy5wb3MsKyt0aGlzLmN1ckxpbmUpLCIiO2Nhc2UgNTY6Y2FzZSA1NzppZih0aGlzLnN0cmljdCYmdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MtMSwiSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UiKSxlKXt2YXIgaT10aGlzLnBvcy0xO3RoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGksIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlIHN0cmluZyIpfWRlZmF1bHQ6aWYodD49NDgmJnQ8PTU1KXt2YXIgcz10aGlzLmlucHV0LnN1YnN0cih0aGlzLnBvcy0xLDMpLm1hdGNoKC9eWzAtN10rLylbMF0sbj1wYXJzZUludChzLDgpO3JldHVybiBuPjI1NSYmKHM9cy5zbGljZSgwLC0xKSxuPXBhcnNlSW50KHMsOCkpLHRoaXMucG9zKz1zLmxlbmd0aC0xLHQ9dGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSwocyE9PSIwInx8dD09PTU2fHx0PT09NTcpJiYodGhpcy5zdHJpY3R8fGUpJiZ0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcy0xLXMubGVuZ3RoLGU/Ik9jdGFsIGxpdGVyYWwgaW4gdGVtcGxhdGUgc3RyaW5nIjoiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZSIpLFN0cmluZy5mcm9tQ2hhckNvZGUobil9cmV0dXJuIEJpKHQpPyIiOlN0cmluZy5mcm9tQ2hhckNvZGUodCl9fSxlZS5yZWFkSGV4Q2hhcj1mdW5jdGlvbihlKXt2YXIgdD10aGlzLnBvcyxpPXRoaXMucmVhZEludCgxNixlKTtyZXR1cm4gaT09PW51bGwmJnRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKHQsIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlIiksaX0sZWUucmVhZFdvcmQxPWZ1bmN0aW9uKCl7dGhpcy5jb250YWluc0VzYz0hMTtmb3IodmFyIGU9IiIsdD0hMCxpPXRoaXMucG9zLHM9dGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uPj02O3RoaXMucG9zPHRoaXMuaW5wdXQubGVuZ3RoOyl7dmFyIG49dGhpcy5mdWxsQ2hhckNvZGVBdFBvcygpO2lmKERpKG4scykpdGhpcy5wb3MrPW48PTY1NTM1PzE6MjtlbHNlIGlmKG49PT05Mil7dGhpcy5jb250YWluc0VzYz0hMCxlKz10aGlzLmlucHV0LnNsaWNlKGksdGhpcy5wb3MpO3ZhciByPXRoaXMucG9zO3RoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKSE9PTExNyYmdGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4odGhpcy5wb3MsIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXHVYWFhYIiksKyt0aGlzLnBvczt2YXIgYT10aGlzLnJlYWRDb2RlUG9pbnQoKTsodD9UdDpEaSkoYSxzKXx8dGhpcy5pbnZhbGlkU3RyaW5nVG9rZW4ociwiSW52YWxpZCBVbmljb2RlIGVzY2FwZSIpLGUrPVl0KGEpLGk9dGhpcy5wb3N9ZWxzZSBicmVhazt0PSExfXJldHVybiBlK3RoaXMuaW5wdXQuc2xpY2UoaSx0aGlzLnBvcyl9LGVlLnJlYWRXb3JkPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5yZWFkV29yZDEoKSx0PWQubmFtZTtyZXR1cm4gdGhpcy5rZXl3b3Jkcy50ZXN0KGUpJiYodD1QYVtlXSksdGhpcy5maW5pc2hUb2tlbih0LGUpfTt2YXIgU2c9IjguMTEuMiI7UGUuYWNvcm49e1BhcnNlcjpQZSx2ZXJzaW9uOlNnLGRlZmF1bHRPcHRpb25zOl9hLFBvc2l0aW9uOmtzLFNvdXJjZUxvY2F0aW9uOiRuLGdldExpbmVJbmZvOk51LE5vZGU6Vm4sVG9rZW5UeXBlOnJlLHRva1R5cGVzOmQsa2V5d29yZFR5cGVzOlBhLFRva0NvbnRleHQ6ZHQsdG9rQ29udGV4dHM6ZGUsaXNJZGVudGlmaWVyQ2hhcjpEaSxpc0lkZW50aWZpZXJTdGFydDpUdCxUb2tlbjpEYSxpc05ld0xpbmU6QmksbGluZUJyZWFrOm50LGxpbmVCcmVha0c6SG0sbm9uQVNDSUl3aGl0ZXNwYWNlOkN1fTtmdW5jdGlvbiBrZyhlLHQpe3JldHVybiBQZS5wYXJzZShlLHQpfWNsYXNzIHdne2NvbnN0cnVjdG9yKCl7dGhpcy5zaG91bGRfc2tpcD0hMSx0aGlzLnNob3VsZF9yZW1vdmU9ITEsdGhpcy5yZXBsYWNlbWVudD1udWxsLHRoaXMuY29udGV4dD17c2tpcDooKT0+dGhpcy5zaG91bGRfc2tpcD0hMCxyZW1vdmU6KCk9PnRoaXMuc2hvdWxkX3JlbW92ZT0hMCxyZXBsYWNlOnQ9PnRoaXMucmVwbGFjZW1lbnQ9dH19cmVwbGFjZSh0LGkscyxuKXt0JiZpJiYocyE9bnVsbD90W2ldW3NdPW46dFtpXT1uKX1yZW1vdmUodCxpLHMpe3QmJmkmJihzIT1udWxsP3RbaV0uc3BsaWNlKHMsMSk6ZGVsZXRlIHRbaV0pfX1jbGFzcyBBZyBleHRlbmRzIHdne2NvbnN0cnVjdG9yKHQsaSl7c3VwZXIoKSx0aGlzLnNob3VsZF9za2lwPSExLHRoaXMuc2hvdWxkX3JlbW92ZT0hMSx0aGlzLnJlcGxhY2VtZW50PW51bGwsdGhpcy5jb250ZXh0PXtza2lwOigpPT50aGlzLnNob3VsZF9za2lwPSEwLHJlbW92ZTooKT0+dGhpcy5zaG91bGRfcmVtb3ZlPSEwLHJlcGxhY2U6cz0+dGhpcy5yZXBsYWNlbWVudD1zfSx0aGlzLmVudGVyPXQsdGhpcy5sZWF2ZT1pfXZpc2l0KHQsaSxzLG4pe2lmKHQpe2lmKHRoaXMuZW50ZXIpe2NvbnN0IGE9dGhpcy5zaG91bGRfc2tpcCxvPXRoaXMuc2hvdWxkX3JlbW92ZSxoPXRoaXMucmVwbGFjZW1lbnQ7dGhpcy5zaG91bGRfc2tpcD0hMSx0aGlzLnNob3VsZF9yZW1vdmU9ITEsdGhpcy5yZXBsYWNlbWVudD1udWxsLHRoaXMuZW50ZXIuY2FsbCh0aGlzLmNvbnRleHQsdCxpLHMsbiksdGhpcy5yZXBsYWNlbWVudCYmKHQ9dGhpcy5yZXBsYWNlbWVudCx0aGlzLnJlcGxhY2UoaSxzLG4sdCkpLHRoaXMuc2hvdWxkX3JlbW92ZSYmdGhpcy5yZW1vdmUoaSxzLG4pO2NvbnN0IGw9dGhpcy5zaG91bGRfc2tpcCxjPXRoaXMuc2hvdWxkX3JlbW92ZTtpZih0aGlzLnNob3VsZF9za2lwPWEsdGhpcy5zaG91bGRfcmVtb3ZlPW8sdGhpcy5yZXBsYWNlbWVudD1oLGwpcmV0dXJuIHQ7aWYoYylyZXR1cm4gbnVsbH1sZXQgcjtmb3IociBpbiB0KXtjb25zdCBhPXRbcl07aWYoYSYmdHlwZW9mIGE9PSJvYmplY3QiKWlmKEFycmF5LmlzQXJyYXkoYSkpe2NvbnN0IG89YTtmb3IobGV0IGg9MDtoPG8ubGVuZ3RoO2grPTEpe2NvbnN0IGw9b1toXTt1YyhsKSYmKHRoaXMudmlzaXQobCx0LHIsaCl8fGgtLSl9fWVsc2UgdWMoYSkmJnRoaXMudmlzaXQoYSx0LHIsbnVsbCl9aWYodGhpcy5sZWF2ZSl7Y29uc3QgYT10aGlzLnJlcGxhY2VtZW50LG89dGhpcy5zaG91bGRfcmVtb3ZlO3RoaXMucmVwbGFjZW1lbnQ9bnVsbCx0aGlzLnNob3VsZF9yZW1vdmU9ITEsdGhpcy5sZWF2ZS5jYWxsKHRoaXMuY29udGV4dCx0LGkscyxuKSx0aGlzLnJlcGxhY2VtZW50JiYodD10aGlzLnJlcGxhY2VtZW50LHRoaXMucmVwbGFjZShpLHMsbix0KSksdGhpcy5zaG91bGRfcmVtb3ZlJiZ0aGlzLnJlbW92ZShpLHMsbik7Y29uc3QgaD10aGlzLnNob3VsZF9yZW1vdmU7aWYodGhpcy5yZXBsYWNlbWVudD1hLHRoaXMuc2hvdWxkX3JlbW92ZT1vLGgpcmV0dXJuIG51bGx9fXJldHVybiB0fX1mdW5jdGlvbiB1YyhlKXtyZXR1cm4gZSE9PW51bGwmJnR5cGVvZiBlPT0ib2JqZWN0IiYmInR5cGUiaW4gZSYmdHlwZW9mIGUudHlwZT09InN0cmluZyJ9ZnVuY3Rpb24gQ2coZSx7ZW50ZXI6dCxsZWF2ZTppfSl7cmV0dXJuIG5ldyBBZyh0LGkpLnZpc2l0KGUsbnVsbCl9Y29uc3QgSWc9ImZ1bmN0aW9uIHJlcXVpcmUoaWQpIHtcbglpZiAoaWQgaW4gX19yZXBsX2xvb2t1cCkgcmV0dXJuIF9fcmVwbF9sb29rdXBbaWRdO1xuCXRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcXVpcmUgbW9kdWxlcyBkeW5hbWljYWxseSAoJHtpZH0pYCk7XG59Ijt2YXIgUGc9e25hbWU6ImNvbW1vbmpzIix0cmFuc2Zvcm06KGUsdCk9PntpZigvXGIocmVxdWlyZXxtb2R1bGV8ZXhwb3J0cylcYi8udGVzdChlKSl0cnl7Y29uc3QgaT1rZyhlLHtlY21hVmVyc2lvbjoibGF0ZXN0In0pLHM9W107Q2coaSx7ZW50ZXI6bz0+e2lmKG8udHlwZT09PSJDYWxsRXhwcmVzc2lvbiImJm8uY2FsbGVlLm5hbWU9PT0icmVxdWlyZSIpe2lmKG8uYXJndW1lbnRzLmxlbmd0aCE9PTEpcmV0dXJuO2NvbnN0IGg9by5hcmd1bWVudHNbMF07aWYoaC50eXBlIT09IkxpdGVyYWwifHx0eXBlb2YgaC52YWx1ZSE9InN0cmluZyIpcmV0dXJuO3MucHVzaChoLnZhbHVlKX19fSk7Y29uc3Qgbj1zLm1hcCgobyxoKT0+YGltcG9ydCBfX3JlcGxfJHtofSBmcm9tICcke299JztgKS5qb2luKGAKYCkscj1gY29uc3QgX19yZXBsX2xvb2t1cCA9IHsgJHtzLm1hcCgobyxoKT0+YCcke299JzogX19yZXBsXyR7aH1gKS5qb2luKCIsICIpfSB9O2A7cmV0dXJue2NvZGU6W24scixJZywiY29uc3QgZXhwb3J0cyA9IHt9OyBjb25zdCBtb2R1bGUgPSB7IGV4cG9ydHMgfTsiLGUsImV4cG9ydCBkZWZhdWx0IG1vZHVsZS5leHBvcnRzOyJdLmpvaW4oYAoKYCksbWFwOm51bGx9fWNhdGNoe3JldHVybiBudWxsfX19LF9nPXtuYW1lOiJnbHNsIix0cmFuc2Zvcm06KGUsdCk9PntpZih0LmVuZHNXaXRoKCIuZ2xzbCIpKXJldHVybntjb2RlOmBleHBvcnQgZGVmYXVsdCAke0pTT04uc3RyaW5naWZ5KGUpfTtgLG1hcDpudWxsfX19LE5nPXtuYW1lOiJqc29uIix0cmFuc2Zvcm06KGUsdCk9PntpZih0LmVuZHNXaXRoKCIuanNvbiIpKXJldHVybntjb2RlOmBleHBvcnQgZGVmYXVsdCAke2V9O2AsbWFwOm51bGx9fX07ZnVuY3Rpb24gJGcoZSl7cmV0dXJuIGUucmVwbGFjZSgvWy1bXF0ve30oKSorPy5cXF4kfF0vZywiXFwkJiIpfWZ1bmN0aW9uIExnKGUpe3JldHVybiB0eXBlb2YgZT09ImZ1bmN0aW9uIj9lOmZ1bmN0aW9uKCl7cmV0dXJuIGV9fWZ1bmN0aW9uIFRnKGUsdCl7cmV0dXJuIHQubGVuZ3RoLWUubGVuZ3RofWZ1bmN0aW9uIFJnKGUpe3JldHVybiBPYmplY3Qua2V5cyhlKS5yZWR1Y2UoZnVuY3Rpb24odCxpKXtyZXR1cm4gdFtpXT1MZyhlW2ldKSx0fSx7fSl9ZnVuY3Rpb24gT2coZSl7Y29uc3QgdD1SZyhlKSxpPU9iamVjdC5rZXlzKHQpLnNvcnQoVGcpLm1hcCgkZykscz1uZXcgUmVnRXhwKCJcXGIoIitpLmpvaW4oInwiKSsiKVxcYiIsImciKTtyZXR1cm57bmFtZToicmVwbGFjZSIsdHJhbnNmb3JtOmZ1bmN0aW9uKHIsYSl7bGV0IG89ITE7cmV0dXJuIHI9ci5yZXBsYWNlKHMsKGgsbCk9PihvPSEwLFN0cmluZyh0W2xdKGEpKSkpLG8/e2NvZGU6cixtYXA6bnVsbH06bnVsbH19fXZhciBjYztsZXQgcGMsQXQsZ2ksZGM7Y29uc3QgVmc9bmV3IFByb21pc2UoZT0+e2RjPWV9KTtzZWxmLmFkZEV2ZW50TGlzdGVuZXIoIm1lc3NhZ2UiLGFzeW5jIGU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2UiaW5pdCI6eyh7cGFja2FnZXNfdXJsOnBjLHN2ZWx0ZV91cmw6QXR9PWUuZGF0YSk7Y29uc3R7dmVyc2lvbjp0fT1hd2FpdCBmZXRjaChgJHtBdH0vcGFja2FnZS5qc29uYCkudGhlbihpPT5pLmpzb24oKSk7aWYoY29uc29sZS5sb2coYFVzaW5nIFN2ZWx0ZSBjb21waWxlciB2ZXJzaW9uICR7dH1gKSx0LnN0YXJ0c1dpdGgoIjQiKSl7Y29uc3QgaT1hd2FpdCBmZXRjaChgJHtBdH0vY29tcGlsZXIuY2pzYCkudGhlbihzPT5zLnRleHQoKSk7KDAsZXZhbCkoaStgCi8vIyBzb3VyY2VVUkw9Y29tcGlsZXIuY2pzQGArdCl9ZWxzZSB0cnl7aW1wb3J0U2NyaXB0cyhgJHtBdH0vY29tcGlsZXIuanNgKX1jYXRjaHtzZWxmLnN2ZWx0ZT1hd2FpdCBpbXBvcnQoYCR7QXR9L2NvbXBpbGVyLm1qc2ApfWRjKCk7YnJlYWt9Y2FzZSJidW5kbGUiOnthd2FpdCBWZztjb25zdHt1aWQ6dCxmaWxlczppfT1lLmRhdGE7aWYoaS5sZW5ndGg9PT0wKXJldHVybjtnaT10LHNldFRpbWVvdXQoYXN5bmMoKT0+e2lmKGdpIT09dClyZXR1cm47Y29uc3Qgcz1hd2FpdCBqZyh7dWlkOnQsZmlsZXM6aX0pO0pTT04uc3RyaW5naWZ5KHMuZXJyb3IpIT09SlNPTi5zdHJpbmdpZnkoUHMpJiZzJiZ0PT09Z2kmJnBvc3RNZXNzYWdlKHMpfSk7YnJlYWt9fX0pO2xldCBmYz17ZG9tOm5ldyBNYXAsc3NyOm5ldyBNYXB9O2NvbnN0IFBzPXthYm9ydGVkOiEwfSxfcz1uZXcgTWFwO2FzeW5jIGZ1bmN0aW9uIEJhKGUsdCl7aWYoX3MuaGFzKGUpKXJldHVybiBfcy5nZXQoZSk7aWYoYXdhaXQgeGMoNTApLHQhPT1naSl0aHJvdyBQcztjb25zdCBpPWZldGNoKGUpLnRoZW4oYXN5bmMgcz0+e2lmKCFzLm9rKXRocm93IG5ldyBFcnJvcihhd2FpdCBzLnRleHQoKSk7cmV0dXJue3VybDpzLnVybCxib2R5OmF3YWl0IHMudGV4dCgpfX0pLmNhdGNoKHM9Pnt0aHJvdyBfcy5kZWxldGUoZSksc30pO3JldHVybiBfcy5zZXQoZSxpKSxpfWFzeW5jIGZ1bmN0aW9uIEZhKGUsdCl7Y29uc3QgaT1hd2FpdCBCYShlLHQpO3JldHVybiBpPT1udWxsP3ZvaWQgMDppLnVybH1mdW5jdGlvbiB6YShlLHQsaSl7Y29uc3Qgcz1zZWxmLnN2ZWx0ZS5WRVJTSU9OLm1hdGNoKC9eKFxkKylcLihcZCspXC4oXGQrKS8pO3JldHVybitzWzFdLWV8fCtzWzJdLXR8fCtzWzNdLWl9ZnVuY3Rpb24gTWcoKXtyZXR1cm4gemEoNCwwLDApPj0wfWZ1bmN0aW9uIERnKCl7cmV0dXJuIHphKDMsNCw0KTw9MH1mdW5jdGlvbiBCZygpe3JldHVybiB6YSgzLDE0LDApPj0wfWFzeW5jIGZ1bmN0aW9uIEZnKGUsdCxpLHMpe2lmKHR5cGVvZiBlLnN2ZWx0ZT09InN0cmluZyImJnQ9PT0iLiIpcmV0dXJuIGUuc3ZlbHRlO2lmKGUuZXhwb3J0cyl0cnl7Y29uc3Rbbl09Rm0oZSx0LHticm93c2VyOiEwLGNvbmRpdGlvbnM6WyJzdmVsdGUiLCJwcm9kdWN0aW9uIl19KT8/W107cmV0dXJuIG59Y2F0Y2h7dGhyb3dgbm8gbWF0Y2hlZCBleHBvcnQgcGF0aCB3YXMgZm91bmQgaW4gIiR7Y2N9L3BhY2thZ2UuanNvbiJgfWlmKHQ9PT0iLiIpe2xldCBuPXdhKGUse2ZpZWxkczpbImJyb3dzZXIiLCJtb2R1bGUiLCJtYWluIl19KTtpZih0eXBlb2Ygbj09Im9iamVjdCImJiFBcnJheS5pc0FycmF5KG4pKXtjb25zdCByPW5bIi4iXTtpZihyPT09ITEpcmV0dXJuImRhdGE6dGV4dC9qYXZhc2NyaXB0LGV4cG9ydCB7fSI7bj1yPz93YShlLHtmaWVsZHM6WyJtb2R1bGUiLCJtYWluIl19KX1pZighbil7Zm9yKGNvbnN0IHIgb2ZbImluZGV4Lm1qcyIsImluZGV4LmpzIl0pdHJ5e2NvbnN0IGE9bmV3IFVSTChyLGAke3N9L2ApLmhyZWY7cmV0dXJuIGF3YWl0IEZhKGEsaSk/PyIifWNhdGNoe310aHJvd2Bjb3VsZCBub3QgZmluZCBlbnRyeSBwb2ludCBpbiAiJHtjY30vcGFja2FnZS5qc29uImB9cmV0dXJuIG59cmV0dXJuIHR5cGVvZiBlLmJyb3dzZXI9PSJvYmplY3QiP3dhKGUse2Jyb3dzZXI6dH0pOnR9YXN5bmMgZnVuY3Rpb24gemcoZSx0LGkscyl7bGV0IG47Y29uc3Qgcj1uZXcgU2V0LGE9W10sbz1bXSxoPW5ldyBNYXAsbD17bmFtZToic3ZlbHRlLXJlcGwiLGFzeW5jIHJlc29sdmVJZChjLHApe2lmKGUhPT1naSl0aHJvdyBQcztjb25zdCBtPU1nKCk7aWYoYz09PSJzdmVsdGUiKXJldHVybiBtP2Ake0F0fS9zcmMvcnVudGltZS9pbmRleC5qc2A6YCR7QXR9L2luZGV4Lm1qc2A7aWYoYy5zdGFydHNXaXRoKCJzdmVsdGUvIikpe2NvbnN0IHk9Yy5zbGljZSg3KTtyZXR1cm4gbT9gJHtBdH0vc3JjL3J1bnRpbWUvJHt5fS9pbmRleC5qc2A6RGcoKT9gJHtBdH0vJHt5fS5tanNgOmAke0F0fS8ke3l9L2luZGV4Lm1qc2B9aWYocy5oYXMoYykmJighcHx8cy5oYXMocCkpKXJldHVybiBjO2lmKHMuaGFzKGMrIi5qcyIpKXJldHVybiBjKyIuanMiO2lmKHMuaGFzKGMrIi5qc29uIikpcmV0dXJuIGMrIi5qc29uIjtpZihjLmVuZHNXaXRoKCIvIikmJihjPWMuc2xpY2UoMCwtMSkpLC9eaHR0cHM/Oi8udGVzdChjKSlyZXR1cm4gYztpZihjLnN0YXJ0c1dpdGgoIi4iKSlpZihwJiZzLmhhcyhwKSl7Y29uc29sZS5lcnJvcihgQ2Fubm90IGZpbmQgZmlsZSAiJHtjfSIgaW1wb3J0ZWQgYnkgIiR7cH0iIGluIHRoZSBSRVBMYCk7cmV0dXJufWVsc2V7Y29uc3QgeT1uZXcgVVJMKGMscCkuaHJlZjtyZXR1cm4gc2VsZi5wb3N0TWVzc2FnZSh7dHlwZToic3RhdHVzIix1aWQ6ZSxtZXNzYWdlOmByZXNvbHZpbmcgJHt5fWB9KSxhd2FpdCBGYSh5LGUpfWVsc2V7c2VsZi5wb3N0TWVzc2FnZSh7dHlwZToic3RhdHVzIix1aWQ6ZSxtZXNzYWdlOmByZXNvbHZpbmcgJHtjfWB9KTtjb25zdCB5PS9eKCg/OkBbXi9dK1wvKT9bXi9dKykoXC8uKyk/JC8uZXhlYyhjKTtpZigheSlyZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBpbXBvcnQgIiR7Y30iYCk7Y29uc3QgRT15WzFdLGc9YC4ke3lbMl0/PyIifWA7cCYmcy5oYXMocCkmJnIuYWRkKEUpO2NvbnN0IHg9YXN5bmMoKT0+e3ZhciBiO3RyeXtjb25zdCBTPWF3YWl0IEZhKGAke3BjfS8ke0V9L3BhY2thZ2UuanNvbmAsZSk7aWYoIVMpdGhyb3cgbmV3IEVycm9yO2NvbnN0IGs9KGI9YXdhaXQgQmEoUyxlKSk9PW51bGw/dm9pZCAwOmIuYm9keSxDPUpTT04ucGFyc2Uoaz8/JyIiJyksUD1TLnJlcGxhY2UoL1wvcGFja2FnZVwuanNvbiQvLCIiKTtyZXR1cm57cGtnOkMscGtnX3VybF9iYXNlOlB9fWNhdGNoe3Rocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgIiR7RX0iIGZyb20gdW5wa2cuIERvZXMgdGhlIHBhY2thZ2UgZXhpc3Q/YCl9fSx7cGtnOnYscGtnX3VybF9iYXNlOnd9PWF3YWl0IHgoKTt0cnl7Y29uc3QgYj1hd2FpdCBGZyh2LGcsZSx3KTtyZXR1cm4gbmV3IFVSTChiKyIiLGAke3d9L2ApLmhyZWZ9Y2F0Y2goYil7dGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW1wb3J0ICIke2N9IjogJHtifS5gKX19fSxhc3luYyBsb2FkKGMpe2lmKGUhPT1naSl0aHJvdyBQcztjb25zdCBwPXMuZ2V0KGMpO2lmKHApcmV0dXJuIHAuc291cmNlO19zLmhhcyhjKXx8c2VsZi5wb3N0TWVzc2FnZSh7dHlwZToic3RhdHVzIix1aWQ6ZSxtZXNzYWdlOmBmZXRjaGluZyAke2N9YH0pO2NvbnN0IG09YXdhaXQgQmEoYyxlKTtyZXR1cm4gbT09bnVsbD92b2lkIDA6bS5ib2R5fSx0cmFuc2Zvcm0oYyxwKXt2YXIgZyx4O2lmKGUhPT1naSl0aHJvdyBQcztpZihzZWxmLnBvc3RNZXNzYWdlKHt0eXBlOiJzdGF0dXMiLHVpZDplLG1lc3NhZ2U6YGJ1bmRsaW5nICR7cH1gfSksIS9cLnN2ZWx0ZSQvLnRlc3QocCkpcmV0dXJuIG51bGw7Y29uc3QgbT0oZz1wLnNwbGl0KCIvIikucG9wKCkpPT1udWxsP3ZvaWQgMDpnLnNwbGl0KCIuIilbMF0seT1pLmdldChwKSxFPXkmJnkuY29kZT09PWM/eS5yZXN1bHQ6c2VsZi5zdmVsdGUuY29tcGlsZShjLHtnZW5lcmF0ZTp0LGRldjohMCxmaWxlbmFtZTptKyIuc3ZlbHRlIiwuLi5CZygpJiZ7bG9vcEd1YXJkVGltZW91dDoxMDB9fSk7cmV0dXJuIGguc2V0KHAse2NvZGU6YyxyZXN1bHQ6RX0pLCh4PUUud2FybmluZ3N8fEUuc3RhdHMud2FybmluZ3MpPT1udWxsfHx4LmZvckVhY2godj0+e2RlbGV0ZSB2LnRvU3RyaW5nLGEucHVzaCh2KX0pLEUuanN9fTt0cnl7cmV0dXJuIG49YXdhaXQgTW0oe2lucHV0OiIuL0FwcC5zdmVsdGUiLHBsdWdpbnM6W2wsUGcsTmcsX2csT2coeyJwcm9jZXNzLmVudi5OT0RFX0VOViI6SlNPTi5zdHJpbmdpZnkoInByb2R1Y3Rpb24iKX0pXSxpbmxpbmVEeW5hbWljSW1wb3J0czohMCxvbndhcm4oYyl7by5wdXNoKHttZXNzYWdlOmMubWVzc2FnZX0pfX0pLHtidW5kbGU6bixpbXBvcnRzOkFycmF5LmZyb20ociksY2FjaGU6aCxlcnJvcjpudWxsLHdhcm5pbmdzOmEsYWxsX3dhcm5pbmdzOm99fWNhdGNoKGMpe3JldHVybntlcnJvcjpjLGltcG9ydHM6bnVsbCxidW5kbGU6bnVsbCxjYWNoZTpoLHdhcm5pbmdzOmEsYWxsX3dhcm5pbmdzOm99fX1hc3luYyBmdW5jdGlvbiBqZyh7dWlkOmUsZmlsZXM6dH0pe3ZhciBuLHIsYSxvLGg7Y29uc29sZS5jbGVhcigpLGNvbnNvbGUubG9nKGBydW5uaW5nIFN2ZWx0ZSBjb21waWxlciB2ZXJzaW9uICVjJHtzZWxmLnN2ZWx0ZS5WRVJTSU9OfWAsImZvbnQtd2VpZ2h0OiBib2xkIik7Y29uc3QgaT1uZXcgTWFwO3QuZm9yRWFjaChsPT57Y29uc3QgYz1gLi8ke2wubmFtZX0uJHtsLnR5cGV9YDtpLnNldChjLGwpfSk7bGV0IHM9YXdhaXQgemcoZSwiZG9tIixmYy5kb20saSk7dHJ5e2lmKHMuZXJyb3IpdGhyb3cgcy5lcnJvcjtmYy5kb209cy5jYWNoZTtjb25zdCBsPShyPWF3YWl0KChuPXMuYnVuZGxlKT09bnVsbD92b2lkIDA6bi5nZW5lcmF0ZSh7Zm9ybWF0OiJpaWZlIixuYW1lOiJTdmVsdGVDb21wb25lbnQiLGV4cG9ydHM6Im5hbWVkIixzb3VyY2VtYXA6ImlubGluZSJ9KSkpPT1udWxsP3ZvaWQgMDpyLm91dHB1dFswXSxjPW51bGwscD1jPyhoPShvPWF3YWl0KChhPWMuYnVuZGxlKT09bnVsbD92b2lkIDA6YS5nZW5lcmF0ZSh7Zm9ybWF0OiJpaWZlIixuYW1lOiJTdmVsdGVDb21wb25lbnQiLGV4cG9ydHM6Im5hbWVkIixzb3VyY2VtYXA6ImlubGluZSJ9KSkpPT1udWxsP3ZvaWQgMDpvLm91dHB1dCk9PW51bGw/dm9pZCAwOmhbMF06bnVsbDtyZXR1cm57dWlkOmUsZG9tOmwsc3NyOnAsaW1wb3J0czpzLmltcG9ydHMsd2FybmluZ3M6cy53YXJuaW5ncyxlcnJvcjpudWxsfX1jYXRjaChsKXtjb25zb2xlLmVycm9yKGwpO2NvbnN0IGM9bDtyZXR1cm4gZGVsZXRlIGMudG9TdHJpbmcse3VpZDplLGRvbTpudWxsLHNzcjpudWxsLGltcG9ydHM6bnVsbCx3YXJuaW5nczpzLndhcm5pbmdzLGVycm9yOk9iamVjdC5hc3NpZ24oe30sYyx7bWVzc2FnZTpjLm1lc3NhZ2Usc3RhY2s6Yy5zdGFja30pfX19fSkoKTsK";
var L = typeof window < "u" && window.Blob && new Blob([atob(H)], { type: "text/javascript;charset=utf-8" });
function S(l) {
  let Z;
  try {
    if (Z = L && (window.URL || window.webkitURL).createObjectURL(L), !Z)
      throw "";
    const b = new Worker(Z, {
      name: l == null ? void 0 : l.name
    });
    return b.addEventListener("error", () => {
      (window.URL || window.webkitURL).revokeObjectURL(Z);
    }), b;
  } catch {
    return new Worker(
      "data:application/javascript;base64," + H,
      {
        name: l == null ? void 0 : l.name
      }
    );
  } finally {
    Z && (window.URL || window.webkitURL).revokeObjectURL(Z);
  }
}
var p = /* @__PURE__ */ new Map();
var a = 1;
var i = class {
  /** @param {{ packages_url: string; svelte_url: string; onstatus: (val: string | null) => void}} param0 */
  constructor({ packages_url: Z, svelte_url: b, onstatus: W2 }) {
    y(this, "worker");
    const m = `${Z}:${b}`;
    if (!p.has(m)) {
      const d = new S();
      d.postMessage({ type: "init", packages_url: Z, svelte_url: b }), p.set(m, d);
    }
    this.worker = p.get(m), this.handlers = /* @__PURE__ */ new Map(), this.worker.addEventListener(
      "message",
      /**
       *
       * @param {MessageEvent<import('./workers/workers').BundleMessageData>} event
       * @returns
       */
      (d) => {
        const V = this.handlers.get(d.data.uid);
        if (V) {
          if (d.data.type === "status") {
            W2(d.data.message);
            return;
          }
          W2(null), V(d.data), this.handlers.delete(d.data.uid);
        }
      }
    );
  }
  /**
   *
   * @param {import('./types').File[]} files
   * @returns
   */
  bundle(Z) {
    return new Promise((b) => {
      this.handlers.set(a, b), this.worker.postMessage({
        uid: a,
        type: "bundle",
        files: Z
      }), a += 1;
    });
  }
  destroy() {
    this.worker.terminate();
  }
};
var x = {
  packagesUrl: "https://unpkg.com",
  svelteUrl: "https://unpkg.com/svelte",
  injectedJS: "",
  injectedCSS: "",
  onstatus: (l) => {
    console.log(l);
  },
  files: void 0,
  urls: []
};
async function h(l) {
  var R;
  const { packagesUrl: Z, svelteUrl: b, injectedJS: W2, injectedCSS: m, onstatus: d, files: V, urls: u } = { ...x, ...l };
  let c = V;
  u && !c && (c = u.map((G) => ({
    name: G.split("/").pop().replace(/\..+$/, ""),
    type: G.split(".").pop(),
    url: G
  })));
  const J = new i({
    packages_url: Z,
    svelte_url: b,
    onstatus: d
  });
  for (const G of c)
    G.url && !G.source && (G.source = await fetch(G.url).then((s) => s.text()), console.log(G.source), delete G.url), G.modified === void 0 && (G.modified = true);
  console.log(c);
  let X = c.find((G) => G.name === "App");
  X || (c.length === 1 ? (X = c[0], X.name = "App") : (X = {
    name: "App",
    type: "svelte",
    modified: true,
    source: `
            <script>
            ` + c.map((G) => `import ${G.name} from '${G.name}.${G.type}'`).join(`
`) + `
            <\/script>
            ` + c.map((G) => `<${G.name} />`).join(`
`) + `
            `
  }, c.push(X)));
  const Y = await J.bundle(c), z = `
				${W2}

				${m && `{
		const style = document.createElement('style');
		style.textContent = ${JSON.stringify(m)};
		document.head.appendChild(style);
	}`}

				const styles = document.querySelectorAll('style[id^=svelte-]');

				let i = styles.length;
				while (i--) styles[i].parentNode.removeChild(styles[i]);

				// if (window.component) {
				// 	try {
				// 		window.component.$destroy();
				// 	} catch (err) {
				// 		console.error(err);
				// 	}
				// }

				// document.body.innerHTML = '';
				// window.location.hash = '';
				// window._svelteTransitionManager = null;

				${(R = Y.dom) == null ? void 0 : R.code}

				// window.component = new SvelteComponent.default({
				// 	target: document.body
				// });
				
				return SvelteComponent.default;
			`, N = new Function("AppConstructor", z);
  return {
    dom: Y.dom,
    render: N
  };
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i2 = e.call(t, r || "default");
    if ("object" != _typeof(i2)) return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-array.js
function toArray(input) {
  return Array.isArray(input) ? input.slice(0) : [input];
}
function isMaybeReadonlyArray(x2) {
  return Array.isArray(x2);
}
function arrayFilterNotEmpty(value) {
  if (value === null || value === void 0) {
    return false;
  }
  return true;
}
function countUntilNotMatching(ar, matchingFn) {
  var count = 0;
  var idx = -1;
  for (var item of ar) {
    idx = idx + 1;
    var matching = matchingFn(item, idx);
    if (matching) {
      count = count + 1;
    } else {
      break;
    }
  }
  return count;
}
function appendToArray(ar, add2) {
  var addSize = add2.length;
  if (addSize === 0) {
    return;
  }
  var baseSize = ar.length;
  ar.length = baseSize + add2.length;
  for (var i2 = 0; i2 < addSize; ++i2) {
    ar[baseSize + i2] = add2[i2];
  }
}
function uniqueArray(arrArg) {
  return arrArg.filter(function(elem, pos, arr) {
    return arr.indexOf(elem) === pos;
  });
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-revision.js
function getHeightOfRevision(revision) {
  var useChars = "";
  for (var index2 = 0; index2 < revision.length; index2++) {
    var char = revision[index2];
    if (char === "-") {
      return parseInt(useChars, 10);
    }
    useChars += char;
  }
  throw new Error("malformatted revision: " + revision);
}
function createRevision(databaseInstanceToken, previousDocData) {
  var newRevisionHeight = !previousDocData ? 1 : getHeightOfRevision(previousDocData._rev) + 1;
  return newRevisionHeight + "-" + databaseInstanceToken;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-object.js
function objectPathMonad(objectPath) {
  var split = objectPath.split(".");
  var splitLength = split.length;
  if (splitLength === 1) {
    return (obj) => obj[objectPath];
  }
  return (obj) => {
    var currentVal = obj;
    for (var i2 = 0; i2 < splitLength; ++i2) {
      var subPath = split[i2];
      currentVal = currentVal[subPath];
      if (typeof currentVal === "undefined") {
        return currentVal;
      }
    }
    return currentVal;
  };
}
function flatClone(obj) {
  return Object.assign({}, obj);
}
function firstPropertyNameOfObject(obj) {
  return Object.keys(obj)[0];
}
function sortObject(obj, noArraySort = false) {
  if (!obj) return obj;
  if (!noArraySort && Array.isArray(obj)) {
    return obj.sort((a2, b) => {
      if (typeof a2 === "string" && typeof b === "string") return a2.localeCompare(b);
      if (typeof a2 === "object") return 1;
      else return -1;
    }).map((i2) => sortObject(i2, noArraySort));
  }
  if (typeof obj === "object" && !Array.isArray(obj)) {
    var out = {};
    Object.keys(obj).sort((a2, b) => a2.localeCompare(b)).forEach((key) => {
      out[key] = sortObject(obj[key], noArraySort);
    });
    return out;
  }
  return obj;
}
function deepClone(src) {
  if (!src) {
    return src;
  }
  if (src === null || typeof src !== "object") {
    return src;
  }
  if (Array.isArray(src)) {
    var ret = new Array(src.length);
    var i2 = ret.length;
    while (i2--) {
      ret[i2] = deepClone(src[i2]);
    }
    return ret;
  }
  var dest = {};
  for (var key in src) {
    dest[key] = deepClone(src[key]);
  }
  return dest;
}
var clone = deepClone;
function overwriteGetterForCaching(obj, getterName, value) {
  Object.defineProperty(obj, getterName, {
    get: function() {
      return value;
    }
  });
  return value;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-document.js
var RX_META_LWT_MINIMUM = 1;
function getDefaultRxDocumentMeta() {
  return {
    /**
     * Set this to 1 to not waste performance
     * while calling new Date()..
     * The storage wrappers will anyway update
     * the lastWrite time while calling transformDocumentDataFromRxDBToRxStorage()
     */
    lwt: RX_META_LWT_MINIMUM
  };
}
function getDefaultRevision() {
  return "";
}
function stripMetaDataFromDocument(docData) {
  return Object.assign({}, docData, {
    _meta: void 0,
    _deleted: void 0,
    _rev: void 0
  });
}
function areRxDocumentArraysEqual(primaryPath, ar1, ar2) {
  if (ar1.length !== ar2.length) {
    return false;
  }
  var i2 = 0;
  var len = ar1.length;
  while (i2 < len) {
    var row1 = ar1[i2];
    var row2 = ar2[i2];
    i2++;
    if (row1._rev !== row2._rev || row1[primaryPath] !== row2[primaryPath]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/ohash@1.1.4/node_modules/ohash/dist/index.mjs
var defaults = Object.freeze({
  ignoreUnknown: false,
  respectType: false,
  respectFunctionNames: false,
  respectFunctionProperties: false,
  unorderedObjects: true,
  unorderedArrays: false,
  unorderedSets: false,
  excludeKeys: void 0,
  excludeValues: void 0,
  replacer: void 0
});
var defaultPrototypesKeys = Object.freeze([
  "prototype",
  "__proto__",
  "constructor"
]);
var nativeFunc = "[native code] }";
var nativeFuncLength = nativeFunc.length;
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var WordArray = class _WordArray {
  constructor(words, sigBytes) {
    __publicField$1(this, "words");
    __publicField$1(this, "sigBytes");
    words = this.words = words || [];
    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;
  }
  toString(encoder) {
    return (encoder || Hex).stringify(this);
  }
  concat(wordArray) {
    this.clamp();
    if (this.sigBytes % 4) {
      for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
        const thatByte = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
        this.words[this.sigBytes + i2 >>> 2] |= thatByte << 24 - (this.sigBytes + i2) % 4 * 8;
      }
    } else {
      for (let j = 0; j < wordArray.sigBytes; j += 4) {
        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];
      }
    }
    this.sigBytes += wordArray.sigBytes;
    return this;
  }
  clamp() {
    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;
    this.words.length = Math.ceil(this.sigBytes / 4);
  }
  clone() {
    return new _WordArray([...this.words]);
  }
};
var Hex = {
  stringify(wordArray) {
    const hexChars = [];
    for (let i2 = 0; i2 < wordArray.sigBytes; i2++) {
      const bite = wordArray.words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));
    }
    return hexChars.join("");
  }
};
var Latin1 = {
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i2 = 0; i2 < latin1StrLength; i2++) {
      words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
var Utf8 = {
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
var BufferedBlockAlgorithm = class {
  constructor() {
    __publicField$1(this, "_data", new WordArray());
    __publicField$1(this, "_nDataBytes", 0);
    __publicField$1(this, "_minBufferSize", 0);
    __publicField$1(this, "blockSize", 512 / 32);
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    if (typeof data === "string") {
      data = Utf8.parse(data);
    }
    this._data.concat(data);
    this._nDataBytes += data.sigBytes;
  }
  _doProcessBlock(_dataWords, _offset) {
  }
  _process(doFlush) {
    let processedWords;
    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * this.blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {
        this._doProcessBlock(this._data.words, offset);
      }
      processedWords = this._data.words.splice(0, nWordsReady);
      this._data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
};
var Hasher = class extends BufferedBlockAlgorithm {
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
  }
};
var __defProp2 = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var H2 = [
  1779033703,
  -1150833019,
  1013904242,
  -1521486534,
  1359893119,
  -1694144372,
  528734635,
  1541459225
];
var K = [
  1116352408,
  1899447441,
  -1245643825,
  -373957723,
  961987163,
  1508970993,
  -1841331548,
  -1424204075,
  -670586216,
  310598401,
  607225278,
  1426881987,
  1925078388,
  -2132889090,
  -1680079193,
  -1046744716,
  -459576895,
  -272742522,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  -1740746414,
  -1473132947,
  -1341970488,
  -1084653625,
  -958395405,
  -710438585,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  -2117940946,
  -1838011259,
  -1564481375,
  -1474664885,
  -1035236496,
  -949202525,
  -778901479,
  -694614492,
  -200395387,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  -2067236844,
  -1933114872,
  -1866530822,
  -1538233109,
  -1090935817,
  -965641998
];
var W = [];
var SHA256 = class extends Hasher {
  constructor() {
    super(...arguments);
    __publicField(this, "_hash", new WordArray([...H2]));
  }
  /**
   * Resets the internal state of the hash object to initial values.
   */
  reset() {
    super.reset();
    this._hash = new WordArray([...H2]);
  }
  _doProcessBlock(M, offset) {
    const H22 = this._hash.words;
    let a2 = H22[0];
    let b = H22[1];
    let c = H22[2];
    let d = H22[3];
    let e = H22[4];
    let f = H22[5];
    let g = H22[6];
    let h2 = H22[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        W[i2] = M[offset + i2] | 0;
      } else {
        const gamma0x = W[i2 - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W[i2 - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W[i2] = gamma0 + W[i2 - 7] + gamma1 + W[i2 - 16];
      }
      const ch = e & f ^ ~e & g;
      const maj = a2 & b ^ a2 & c ^ b & c;
      const sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
      const t1 = h2 + sigma1 + ch + K[i2] + W[i2];
      const t2 = sigma0 + maj;
      h2 = g;
      g = f;
      f = e;
      e = d + t1 | 0;
      d = c;
      c = b;
      b = a2;
      a2 = t1 + t2 | 0;
    }
    H22[0] = H22[0] + a2 | 0;
    H22[1] = H22[1] + b | 0;
    H22[2] = H22[2] + c | 0;
    H22[3] = H22[3] + d | 0;
    H22[4] = H22[4] + e | 0;
    H22[5] = H22[5] + f | 0;
    H22[6] = H22[6] + g | 0;
    H22[7] = H22[7] + h2 | 0;
  }
  /**
   * Finishes the hash calculation and returns the hash as a WordArray.
   *
   * @param {string} messageUpdate - Additional message content to include in the hash.
   * @returns {WordArray} The finalised hash as a WordArray.
   */
  finalize(messageUpdate) {
    super.finalize(messageUpdate);
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = this._data.sigBytes * 8;
    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(
      nBitsTotal / 4294967296
    );
    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    this._data.sigBytes = this._data.words.length * 4;
    this._process();
    return this._hash;
  }
};
function sha256(message) {
  return new SHA256().finalize(message).toString();
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-hash.js
function jsSha256(input) {
  return Promise.resolve(sha256(input));
}
async function nativeSha256(input) {
  var data = new TextEncoder().encode(input);
  var hashBuffer = await crypto.subtle.digest("SHA-256", data);
  var hash2 = Array.prototype.map.call(new Uint8Array(hashBuffer), (x2) => ("00" + x2.toString(16)).slice(-2)).join("");
  return hash2;
}
var canUseCryptoSubtle = typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined" && typeof crypto.subtle.digest === "function";
var defaultHashSha256 = canUseCryptoSubtle ? nativeSha256 : jsSha256;

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-promise.js
function nextTick() {
  return new Promise((res) => setTimeout(res, 0));
}
function promiseWait(ms = 0) {
  return new Promise((res) => setTimeout(res, ms));
}
var PROMISE_RESOLVE_TRUE = Promise.resolve(true);
var PROMISE_RESOLVE_FALSE = Promise.resolve(false);
var PROMISE_RESOLVE_NULL = Promise.resolve(null);
var PROMISE_RESOLVE_VOID = Promise.resolve();
function requestIdlePromiseNoQueue(timeout = 1e4) {
  if (typeof requestIdleCallback === "function") {
    return new Promise((res) => {
      requestIdleCallback(() => res(), {
        timeout
      });
    });
  } else {
    return promiseWait(0);
  }
}
var idlePromiseQueue = PROMISE_RESOLVE_VOID;
function requestIdlePromise(timeout = void 0) {
  idlePromiseQueue = idlePromiseQueue.then(() => {
    return requestIdlePromiseNoQueue(timeout);
  });
  return idlePromiseQueue;
}
function promiseSeries(tasks, initial) {
  return tasks.reduce((current, next2) => current.then(next2), Promise.resolve(initial));
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-regex.js
var REGEX_ALL_DOTS = /\./g;

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-string.js
var COUCH_NAME_CHARS = "abcdefghijklmnopqrstuvwxyz";
function randomCouchString(length = 10) {
  var text2 = "";
  for (var i2 = 0; i2 < length; i2++) {
    text2 += COUCH_NAME_CHARS.charAt(Math.floor(Math.random() * COUCH_NAME_CHARS.length));
  }
  return text2;
}
function ucfirst(str) {
  str += "";
  var f = str.charAt(0).toUpperCase();
  return f + str.substr(1);
}
function trimDots(str) {
  while (str.charAt(0) === ".") {
    str = str.substr(1);
  }
  while (str.slice(-1) === ".") {
    str = str.slice(0, -1);
  }
  return str;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-object-deep-equal.js
function deepEqual(a2, b) {
  if (a2 === b) return true;
  if (a2 && b && typeof a2 == "object" && typeof b == "object") {
    if (a2.constructor !== b.constructor) return false;
    var length;
    var i2;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b.length) return false;
      for (i2 = length; i2-- !== 0; ) if (!deepEqual(a2[i2], b[i2])) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b.source && a2.flags === b.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b.toString();
    var keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;
    for (i2 = length; i2-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!deepEqual(a2[key], b[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b !== b;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-object-dot-prop.js
var isObject = (value) => {
  var type5 = typeof value;
  return value !== null && (type5 === "object" || type5 === "function");
};
var disallowedKeys = /* @__PURE__ */ new Set(["__proto__", "prototype", "constructor"]);
var digits = new Set("0123456789");
function getPathSegments(path) {
  var parts = [];
  var currentSegment = "";
  var currentPart = "start";
  var isIgnoring = false;
  for (var character of path) {
    switch (character) {
      case "\\": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (isIgnoring) {
          currentSegment += character;
        }
        currentPart = "property";
        isIgnoring = !isIgnoring;
        break;
      }
      case ".": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "property";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (disallowedKeys.has(currentSegment)) {
          return [];
        }
        parts.push(currentSegment);
        currentSegment = "";
        currentPart = "property";
        break;
      }
      case "[": {
        if (currentPart === "index") {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          currentPart = "index";
          break;
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += character;
          break;
        }
        if (currentPart === "property") {
          if (disallowedKeys.has(currentSegment)) {
            return [];
          }
          parts.push(currentSegment);
          currentSegment = "";
        }
        currentPart = "index";
        break;
      }
      case "]": {
        if (currentPart === "index") {
          parts.push(Number.parseInt(currentSegment, 10));
          currentSegment = "";
          currentPart = "indexEnd";
          break;
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
      }
      default: {
        if (currentPart === "index" && !digits.has(character)) {
          throw new Error("Invalid character in an index");
        }
        if (currentPart === "indexEnd") {
          throw new Error("Invalid character after an index");
        }
        if (currentPart === "start") {
          currentPart = "property";
        }
        if (isIgnoring) {
          isIgnoring = false;
          currentSegment += "\\";
        }
        currentSegment += character;
      }
    }
  }
  if (isIgnoring) {
    currentSegment += "\\";
  }
  switch (currentPart) {
    case "property": {
      if (disallowedKeys.has(currentSegment)) {
        return [];
      }
      parts.push(currentSegment);
      break;
    }
    case "index": {
      throw new Error("Index was not closed");
    }
    case "start": {
      parts.push("");
      break;
    }
  }
  return parts;
}
function isStringIndex(object, key) {
  if (typeof key !== "number" && Array.isArray(object)) {
    var index2 = Number.parseInt(key, 10);
    return Number.isInteger(index2) && object[index2] === object[key];
  }
  return false;
}
function assertNotStringIndex(object, key) {
  if (isStringIndex(object, key)) {
    throw new Error("Cannot use string index");
  }
}
function getProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!path.includes(".") && !path.includes("[")) {
    return object[path];
  }
  if (!isObject(object) || typeof path !== "string") {
    return value === void 0 ? object : value;
  }
  var pathArray = getPathSegments(path);
  if (pathArray.length === 0) {
    return value;
  }
  for (var index2 = 0; index2 < pathArray.length; index2++) {
    var key = pathArray[index2];
    if (isStringIndex(object, key)) {
      object = index2 === pathArray.length - 1 ? void 0 : null;
    } else {
      object = object[key];
    }
    if (object === void 0 || object === null) {
      if (index2 !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === void 0 ? value : object;
}
function setProperty(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject(object) || typeof path !== "string") {
    return object;
  }
  var root = object;
  var pathArray = getPathSegments(path);
  for (var index2 = 0; index2 < pathArray.length; index2++) {
    var key = pathArray[index2];
    assertNotStringIndex(object, key);
    if (index2 === pathArray.length - 1) {
      object[key] = value;
    } else if (!isObject(object[key])) {
      object[key] = typeof pathArray[index2 + 1] === "number" ? [] : {};
    }
    object = object[key];
  }
  return root;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-map.js
function getFromMapOrThrow(map2, key) {
  var val = map2.get(key);
  if (typeof val === "undefined") {
    throw new Error("missing value from map " + key);
  }
  return val;
}
function getFromMapOrCreate(map2, index2, creator, ifWasThere) {
  var value = map2.get(index2);
  if (typeof value === "undefined") {
    value = creator();
    map2.set(index2, value);
  } else if (ifWasThere) {
    ifWasThere(value);
  }
  return value;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-error.js
function pluginMissing(pluginKey) {
  var keyParts = pluginKey.split("-");
  var pluginName = "RxDB";
  keyParts.forEach((part) => {
    pluginName += ucfirst(part);
  });
  pluginName += "Plugin";
  return new Error("You are using a function which must be overwritten by a plugin.\n        You should either prevent the usage of this function or add the plugin via:\n            import { " + pluginName + " } from 'rxdb/plugins/" + pluginKey + "';\n            addRxPlugin(" + pluginName + ");\n        ");
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-time.js
var _lastNow = 0;
function now() {
  var ret = Date.now();
  ret = ret + 0.01;
  if (ret <= _lastNow) {
    ret = _lastNow + 0.01;
  }
  var twoDecimals = parseFloat(ret.toFixed(2));
  _lastNow = twoDecimals;
  return twoDecimals;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-other.js
function ensureNotFalsy(obj, message) {
  if (!obj) {
    if (!message) {
      message = "";
    }
    throw new Error("ensureNotFalsy() is falsy: " + message);
  }
  return obj;
}
var RXJS_SHARE_REPLAY_DEFAULTS = {
  bufferSize: 1,
  refCount: true
};

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-rxdb-version.js
var RXDB_VERSION = "15.34.1";

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/utils/utils-global.js
var RXDB_UTILS_GLOBAL = {};
var PREMIUM_FLAG_HASH = "6da4936d1425ff3a5c44c02342c6daf791d266be3ae8479b8ec59e261df41b93";

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(t) {
  try {
    return -1 !== Function.toString.call(t).indexOf("[native code]");
  } catch (n2) {
    return "function" == typeof t;
  }
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
    return !!t;
  })();
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(t, e, r) {
  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p2 = new (t.bind.apply(t, o))();
  return r && _setPrototypeOf(p2, r.prototype), p2;
}

// node_modules/.pnpm/@babel+runtime@7.25.6/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(t) {
  var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
    if (null === t2 || !_isNativeFunction(t2)) return t2;
    if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== r) {
      if (r.has(t2)) return r.get(t2);
      r.set(t2, Wrapper);
    }
    function Wrapper() {
      return _construct(t2, arguments, _getPrototypeOf(this).constructor);
    }
    return Wrapper.prototype = Object.create(t2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), _setPrototypeOf(Wrapper, t2);
  }, _wrapNativeSuper(t);
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/overwritable.js
var overwritable = {
  /**
   * if this method is overwritten with one
   * that returns true, we do additional checks
   * which help the developer but have bad performance
   */
  isDevMode() {
    return false;
  },
  /**
   * Deep freezes and object when in dev-mode.
   * Deep-Freezing has the same performance as deep-cloning, so we only do that in dev-mode.
   * Also, we can ensure the readonly state via typescript
   * @link https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
   */
  deepFreezeWhenDevMode(obj) {
    return obj;
  },
  /**
   * overwritten to map error-codes to text-messages
   */
  tunnelErrorMessage(message) {
    return "RxDB Error-Code " + message + ".\n        Error messages are not included in RxDB core to reduce build size.\n        ";
  }
};

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-error.js
function parametersToString(parameters) {
  var ret = "";
  if (Object.keys(parameters).length === 0) return ret;
  ret += "Given parameters: {\n";
  ret += Object.keys(parameters).map((k) => {
    var paramStr = "[object Object]";
    try {
      if (k === "errors") {
        paramStr = parameters[k].map((err) => JSON.stringify(err, Object.getOwnPropertyNames(err)));
      } else {
        paramStr = JSON.stringify(parameters[k], function(_k, v) {
          return v === void 0 ? null : v;
        }, 2);
      }
    } catch (e) {
    }
    return k + ":" + paramStr;
  }).join("\n");
  ret += "}";
  return ret;
}
function messageForError(message, code, parameters) {
  return "RxError (" + code + "):\n" + message + "\n" + parametersToString(parameters);
}
var RxError = /* @__PURE__ */ function(_Error) {
  function RxError2(code, message, parameters = {}) {
    var _this;
    var mes = messageForError(message, code, parameters);
    _this = _Error.call(this, mes) || this;
    _this.code = code;
    _this.message = mes;
    _this.url = getErrorUrl(code);
    _this.parameters = parameters;
    _this.rxdb = true;
    return _this;
  }
  _inheritsLoose(RxError2, _Error);
  var _proto = RxError2.prototype;
  _proto.toString = function toString2() {
    return this.message;
  };
  return _createClass(RxError2, [{
    key: "name",
    get: function() {
      return "RxError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return false;
    }
  }]);
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var RxTypeError = /* @__PURE__ */ function(_TypeError) {
  function RxTypeError2(code, message, parameters = {}) {
    var _this2;
    var mes = messageForError(message, code, parameters);
    _this2 = _TypeError.call(this, mes) || this;
    _this2.code = code;
    _this2.message = mes;
    _this2.url = getErrorUrl(code);
    _this2.parameters = parameters;
    _this2.rxdb = true;
    return _this2;
  }
  _inheritsLoose(RxTypeError2, _TypeError);
  var _proto2 = RxTypeError2.prototype;
  _proto2.toString = function toString2() {
    return this.message;
  };
  return _createClass(RxTypeError2, [{
    key: "name",
    get: function() {
      return "RxTypeError (" + this.code + ")";
    }
  }, {
    key: "typeError",
    get: function() {
      return true;
    }
  }]);
}(/* @__PURE__ */ _wrapNativeSuper(TypeError));
function getErrorUrl(code) {
  return "https://rxdb.info/errors.html?console=errors#" + code;
}
function errorUrlHint(code) {
  return "\n You can find out more about this error here: " + getErrorUrl(code) + " ";
}
function newRxError(code, parameters) {
  return new RxError(code, overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);
}
function newRxTypeError(code, parameters) {
  return new RxTypeError(code, overwritable.tunnelErrorMessage(code) + errorUrlHint(code), parameters);
}
function isBulkWriteConflictError(err) {
  if (err && err.status === 409) {
    return err;
  } else {
    return false;
  }
}
var STORAGE_WRITE_ERROR_CODE_TO_MESSAGE = {
  409: "document write conflict",
  422: "schema validation error",
  510: "attachment data missing"
};
function rxStorageWriteErrorToRxError(err) {
  return newRxError("COL20", {
    name: STORAGE_WRITE_ERROR_CODE_TO_MESSAGE[err.status],
    document: err.documentId,
    writeError: err
  });
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/hooks.js
var HOOKS = {
  /**
   * Runs before a plugin is added.
   * Use this to block the usage of non-compatible plugins.
   */
  preAddRxPlugin: [],
  /**
   * functions that run before the database is created
   */
  preCreateRxDatabase: [],
  /**
   * runs after the database is created and prepared
   * but before the instance is returned to the user
   * @async
   */
  createRxDatabase: [],
  preCreateRxCollection: [],
  createRxCollection: [],
  createRxState: [],
  /**
  * runs at the end of the destroy-process of a collection
  * @async
  */
  postDestroyRxCollection: [],
  /**
   * Runs after a collection is removed.
   * @async
   */
  postRemoveRxCollection: [],
  /**
    * functions that get the json-schema as input
    * to do additionally checks/manipulation
    */
  preCreateRxSchema: [],
  /**
   * functions that run after the RxSchema is created
   * gets RxSchema as attribute
   */
  createRxSchema: [],
  preCreateRxQuery: [],
  /**
   * Runs before a query is send to the
   * prepareQuery function of the storage engine.
   */
  prePrepareQuery: [],
  createRxDocument: [],
  /**
   * runs after a RxDocument is created,
   * cannot be async
   */
  postCreateRxDocument: [],
  /**
   * Runs before a RxStorageInstance is created
   * gets the params of createStorageInstance()
   * as attribute so you can manipulate them.
   * Notice that you have to clone stuff before mutating the inputs.
   */
  preCreateRxStorageInstance: [],
  preStorageWrite: [],
  /**
   * runs on the document-data before the document is migrated
   * {
   *   doc: Object, // original doc-data
   *   migrated: // migrated doc-data after run through migration-strategies
   * }
   */
  preMigrateDocument: [],
  /**
   * runs after the migration of a document has been done
   */
  postMigrateDocument: [],
  /**
   * runs at the beginning of the destroy-process of a database
   */
  preDestroyRxDatabase: [],
  /**
   * runs after a database has been removed
   * @async
   */
  postRemoveRxDatabase: [],
  postCleanup: [],
  /**
   * runs before the replication writes the rows to master
   * but before the rows have been modified
   * @async
   */
  preReplicationMasterWrite: [],
  /**
   * runs after the replication has been sent to the server
   * but before the new documents have been handled
   * @async
   */
  preReplicationMasterWriteDocumentsHandle: []
};
function runPluginHooks(hookKey, obj) {
  if (HOOKS[hookKey].length > 0) {
    HOOKS[hookKey].forEach((fun) => fun(obj));
  }
}
function runAsyncPluginHooks(hookKey, obj) {
  return Promise.all(HOOKS[hookKey].map((fun) => fun(obj)));
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-schema-helper.js
function getSchemaByObjectPath(rxJsonSchema, path) {
  var usePath = path;
  usePath = usePath.replace(REGEX_ALL_DOTS, ".properties.");
  usePath = "properties." + usePath;
  usePath = trimDots(usePath);
  var ret = getProperty(rxJsonSchema, usePath);
  return ret;
}
function fillPrimaryKey(primaryPath, jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData;
  }
  var newPrimary = getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData);
  var existingPrimary = documentData[primaryPath];
  if (existingPrimary && existingPrimary !== newPrimary) {
    throw newRxError("DOC19", {
      args: {
        documentData,
        existingPrimary,
        newPrimary
      },
      schema: jsonSchema
    });
  }
  documentData[primaryPath] = newPrimary;
  return documentData;
}
function getPrimaryFieldOfPrimaryKey(primaryKey) {
  if (typeof primaryKey === "string") {
    return primaryKey;
  } else {
    return primaryKey.key;
  }
}
function getComposedPrimaryKeyOfDocumentData(jsonSchema, documentData) {
  if (typeof jsonSchema.primaryKey === "string") {
    return documentData[jsonSchema.primaryKey];
  }
  var compositePrimary = jsonSchema.primaryKey;
  return compositePrimary.fields.map((field) => {
    var value = getProperty(documentData, field);
    if (typeof value === "undefined") {
      throw newRxError("DOC18", {
        args: {
          field,
          documentData
        }
      });
    }
    return value;
  }).join(compositePrimary.separator);
}
function normalizeRxJsonSchema(jsonSchema) {
  var normalizedSchema = sortObject(jsonSchema, true);
  return normalizedSchema;
}
function getDefaultIndex(primaryPath) {
  return ["_deleted", primaryPath];
}
function fillWithDefaultSettings(schemaObj) {
  schemaObj = flatClone(schemaObj);
  var primaryPath = getPrimaryFieldOfPrimaryKey(schemaObj.primaryKey);
  schemaObj.properties = flatClone(schemaObj.properties);
  schemaObj.additionalProperties = false;
  if (!Object.prototype.hasOwnProperty.call(schemaObj, "keyCompression")) {
    schemaObj.keyCompression = false;
  }
  schemaObj.indexes = schemaObj.indexes ? schemaObj.indexes.slice(0) : [];
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.encrypted = schemaObj.encrypted ? schemaObj.encrypted.slice(0) : [];
  schemaObj.properties._rev = {
    type: "string",
    minLength: 1
  };
  schemaObj.properties._attachments = {
    type: "object"
  };
  schemaObj.properties._deleted = {
    type: "boolean"
  };
  schemaObj.properties._meta = RX_META_SCHEMA;
  schemaObj.required = schemaObj.required ? schemaObj.required.slice(0) : [];
  schemaObj.required.push("_deleted");
  schemaObj.required.push("_rev");
  schemaObj.required.push("_meta");
  schemaObj.required.push("_attachments");
  var finalFields = getFinalFields(schemaObj);
  appendToArray(schemaObj.required, finalFields);
  schemaObj.required = schemaObj.required.filter((field) => !field.includes(".")).filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  schemaObj.version = schemaObj.version || 0;
  var useIndexes = schemaObj.indexes.map((index2) => {
    var arIndex = isMaybeReadonlyArray(index2) ? index2.slice(0) : [index2];
    if (!arIndex.includes(primaryPath)) {
      arIndex.push(primaryPath);
    }
    if (arIndex[0] !== "_deleted") {
      arIndex.unshift("_deleted");
    }
    return arIndex;
  });
  if (useIndexes.length === 0) {
    useIndexes.push(getDefaultIndex(primaryPath));
  }
  useIndexes.push(["_meta.lwt", primaryPath]);
  if (schemaObj.internalIndexes) {
    schemaObj.internalIndexes.map((idx) => {
      useIndexes.push(idx);
    });
  }
  var hasIndex = /* @__PURE__ */ new Set();
  useIndexes.filter((index2) => {
    var indexStr = index2.join(",");
    if (hasIndex.has(indexStr)) {
      return false;
    } else {
      hasIndex.add(indexStr);
      return true;
    }
  });
  schemaObj.indexes = useIndexes;
  return schemaObj;
}
var RX_META_SCHEMA = {
  type: "object",
  properties: {
    /**
     * The last-write time.
     * Unix time in milliseconds.
     */
    lwt: {
      type: "number",
      /**
       * We use 1 as minimum so that the value is never falsy.
       */
      minimum: RX_META_LWT_MINIMUM,
      maximum: 1e15,
      multipleOf: 0.01
    }
  },
  /**
   * Additional properties are allowed
   * and can be used by plugins to set various flags.
   */
  additionalProperties: true,
  required: ["lwt"]
};
function getFinalFields(jsonSchema) {
  var ret = Object.keys(jsonSchema.properties).filter((key) => jsonSchema.properties[key].final);
  var primaryPath = getPrimaryFieldOfPrimaryKey(jsonSchema.primaryKey);
  ret.push(primaryPath);
  if (typeof jsonSchema.primaryKey !== "string") {
    jsonSchema.primaryKey.fields.forEach((field) => ret.push(field));
  }
  return ret;
}
function fillObjectWithDefaults(rxSchema, obj) {
  var defaultKeys = Object.keys(rxSchema.defaultValues);
  for (var i2 = 0; i2 < defaultKeys.length; ++i2) {
    var key = defaultKeys[i2];
    if (!Object.prototype.hasOwnProperty.call(obj, key) || typeof obj[key] === "undefined") {
      obj[key] = rxSchema.defaultValues[key];
    }
  }
  return obj;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-schema.js
var RxSchema = /* @__PURE__ */ function() {
  function RxSchema2(jsonSchema, hashFunction) {
    this.jsonSchema = jsonSchema;
    this.hashFunction = hashFunction;
    this.indexes = getIndexes(this.jsonSchema);
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);
    this.finalFields = getFinalFields(this.jsonSchema);
  }
  var _proto = RxSchema2.prototype;
  _proto.validateChange = function validateChange(dataBefore, dataAfter) {
    this.finalFields.forEach((fieldName) => {
      if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {
        throw newRxError("DOC9", {
          dataBefore,
          dataAfter,
          fieldName,
          schema: this.jsonSchema
        });
      }
    });
  };
  _proto.getDocumentPrototype = function getDocumentPrototype2() {
    var proto = {};
    var pathProperties = getSchemaByObjectPath(this.jsonSchema, "");
    Object.keys(pathProperties).forEach((key) => {
      var fullPath = key;
      proto.__defineGetter__(key, function() {
        if (!this.get || typeof this.get !== "function") {
          return void 0;
        }
        var ret = this.get(fullPath);
        return ret;
      });
      Object.defineProperty(proto, key + "$", {
        get: function() {
          return this.get$(fullPath);
        },
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(proto, key + "$$", {
        get: function() {
          return this.get$$(fullPath);
        },
        enumerable: false,
        configurable: false
      });
      Object.defineProperty(proto, key + "_", {
        get: function() {
          return this.populate(fullPath);
        },
        enumerable: false,
        configurable: false
      });
    });
    overwriteGetterForCaching(this, "getDocumentPrototype", () => proto);
    return proto;
  };
  _proto.getPrimaryOfDocumentData = function getPrimaryOfDocumentData(documentData) {
    return getComposedPrimaryKeyOfDocumentData(this.jsonSchema, documentData);
  };
  return _createClass(RxSchema2, [{
    key: "version",
    get: function() {
      return this.jsonSchema.version;
    }
  }, {
    key: "defaultValues",
    get: function() {
      var values = {};
      Object.entries(this.jsonSchema.properties).filter(([, v]) => Object.prototype.hasOwnProperty.call(v, "default")).forEach(([k, v]) => values[k] = v.default);
      return overwriteGetterForCaching(this, "defaultValues", values);
    }
    /**
     * @overrides itself on the first call
     *
     * TODO this should be a pure function that
     * caches the hash in a WeakMap.
     */
  }, {
    key: "hash",
    get: function() {
      return overwriteGetterForCaching(this, "hash", this.hashFunction(JSON.stringify(this.jsonSchema)));
    }
  }]);
}();
function getIndexes(jsonSchema) {
  return (jsonSchema.indexes || []).map((index2) => isMaybeReadonlyArray(index2) ? index2 : [index2]);
}
function createRxSchema(jsonSchema, hashFunction, runPreCreateHooks = true) {
  if (runPreCreateHooks) {
    runPluginHooks("preCreateRxSchema", jsonSchema);
  }
  var useJsonSchema = fillWithDefaultSettings(jsonSchema);
  useJsonSchema = normalizeRxJsonSchema(useJsonSchema);
  overwritable.deepFreezeWhenDevMode(useJsonSchema);
  var schema = new RxSchema(useJsonSchema, hashFunction);
  runPluginHooks("createRxSchema", schema);
  return schema;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source2) {
  return isFunction(source2 === null || source2 === void 0 ? void 0 : source2.lift);
}
function operate(init3) {
  return function(source2) {
    if (hasLift(source2)) {
      return source2.lift(function(liftedSource) {
        try {
          return init3(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/.pnpm/tslib@2.7.0/node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y2, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y2 = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i2 >= o.length) o = void 0;
      return { value: o && o[i2++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r = i2.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n2, f) {
    if (g[n2]) {
      i2[n2] = function(v) {
        return new Promise(function(a2, b) {
          q.push([n2, v, a2, b]) > 1 || resume(n2, v);
        });
      };
      if (f) i2[n2] = f(i2[n2]);
    }
  }
  function resume(n2, v) {
    try {
      step(g[n2](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o[n2] && function(v) {
      return new Promise(function(resolve2, reject) {
        v = o[n2](v), settle(resolve2, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve2, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve2({ value: v2, done: d });
    }, reject);
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
};

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index2 = arr.indexOf(item);
    0 <= index2 && arr.splice(index2, 1);
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown2) {
    var _a;
    if (teardown2 && teardown2 !== this) {
      if (this.closed) {
        execFinalizer(teardown2);
      } else {
        if (teardown2 instanceof Subscription2) {
          if (teardown2.closed || teardown2._hasParent(this)) {
            return;
          }
          teardown2._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown2);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown2) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown2);
    if (teardown2 instanceof Subscription2) {
      teardown2._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty = new Subscription2();
    empty.closed = true;
    return empty;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate2 = timeoutProvider.delegate;
    if (delegate2 === null || delegate2 === void 0 ? void 0 : delegate2.setTimeout) {
      return delegate2.setTimeout.apply(delegate2, __spreadArray([handler, timeout], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate2 = timeoutProvider.delegate;
    return ((delegate2 === null || delegate2 === void 0 ? void 0 : delegate2.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next2, error, complete) {
    return new SafeSubscriber(next2, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x2) {
  return x2;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source2 = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source2) : source2 ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next2, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next2(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve2
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve2, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve2(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
  if (delay === void 0) {
    delay = 0;
  }
  if (repeat === void 0) {
    repeat = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat) {
      parentSubscription.add(this.schedule(null, delay));
    } else {
      this.unsubscribe();
    }
  }, delay);
  parentSubscription.add(scheduleSubscription);
  if (!repeat) {
    return scheduleSubscription;
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source2, subscriber) {
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay);
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return operate(function(source2, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source2.subscribe(subscriber);
    }, delay));
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index2++));
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source2, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
  var buffer = [];
  var active = 0;
  var index2 = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer.push(value);
  };
  var doInnerSub = function(value) {
    expand && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index2++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source2.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map(function(b, ii) {
        return resultSelector(a2, b, i2, ii);
      })(innerFrom(project(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source2, subscriber) {
    return mergeInternals(source2, subscriber, project, concurrent);
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray(args[0]) ? args[0] : args;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source2) {
    return new AnonymousSubject(destination, source2);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source2) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source2;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source2, subscriber) {
    var previousKey;
    var first = true;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first || !comparator(previousKey, currentKey)) {
        first = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b) {
  return a2 === b;
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source2, subscriber) {
    var index2 = 0;
    source2.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index2++) && subscriber.next(value);
    }));
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  args = argsOrArgArray(args);
  return operate(function(source2, subscriber) {
    mergeAll(concurrent)(from(__spreadArray([source2], __read(args)), scheduler)).subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now3 = _timestampProvider.now();
      var last2 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now3; i2 += 2) {
        last2 = i2;
      }
      last2 && _buffer.splice(0, last2 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset2 = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset2();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source2, subscriber) {
      refCount++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount--;
        if (refCount === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset2, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset2, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source2).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset2, on2) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on2 === true) {
    reset2();
    return;
  }
  if (on2 === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset2();
    }
  });
  return innerFrom(on2.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount
  });
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source2, subscriber) {
    (scheduler ? concat(values, source2, scheduler) : concat(values, source2)).subscribe(subscriber);
  });
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-change-event.js
function getDocumentDataOfRxChangeEvent(rxChangeEvent) {
  if (rxChangeEvent.documentData) {
    return rxChangeEvent.documentData;
  } else {
    return rxChangeEvent.previousDocumentData;
  }
}
function rxChangeEventToEventReduceChangeEvent(rxChangeEvent) {
  switch (rxChangeEvent.operation) {
    case "INSERT":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: rxChangeEvent.documentData,
        previous: null
      };
    case "UPDATE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData),
        previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData : "UNKNOWN"
      };
    case "DELETE":
      return {
        operation: rxChangeEvent.operation,
        id: rxChangeEvent.documentId,
        doc: null,
        previous: rxChangeEvent.previousDocumentData
      };
  }
}

// node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/util.js
function lastOfArray(ar) {
  return ar[ar.length - 1];
}
function isObject2(value) {
  const type5 = typeof value;
  return value !== null && (type5 === "object" || type5 === "function");
}
function getProperty2(object, path, value) {
  if (Array.isArray(path)) {
    path = path.join(".");
  }
  if (!isObject2(object) || typeof path !== "string") {
    return value === void 0 ? object : value;
  }
  const pathArray = path.split(".");
  if (pathArray.length === 0) {
    return value;
  }
  for (let index2 = 0; index2 < pathArray.length; index2++) {
    const key = pathArray[index2];
    if (isStringIndex2(object, key)) {
      object = index2 === pathArray.length - 1 ? void 0 : null;
    } else {
      object = object[key];
    }
    if (object === void 0 || object === null) {
      if (index2 !== pathArray.length - 1) {
        return value;
      }
      break;
    }
  }
  return object === void 0 ? value : object;
}
function isStringIndex2(object, key) {
  if (typeof key !== "number" && Array.isArray(object)) {
    const index2 = Number.parseInt(key, 10);
    return Number.isInteger(index2) && object[index2] === object[key];
  }
  return false;
}

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/states/state-resolver.js
var hasLimit = (input) => {
  return !!input.queryParams.limit;
};
var isFindOne = (input) => {
  return input.queryParams.limit === 1;
};
var hasSkip = (input) => {
  if (input.queryParams.skip && input.queryParams.skip > 0) {
    return true;
  } else {
    return false;
  }
};
var isDelete = (input) => {
  return input.changeEvent.operation === "DELETE";
};
var isInsert = (input) => {
  return input.changeEvent.operation === "INSERT";
};
var isUpdate = (input) => {
  return input.changeEvent.operation === "UPDATE";
};
var wasLimitReached = (input) => {
  return hasLimit(input) && input.previousResults.length >= input.queryParams.limit;
};
var sortParamsChanged = (input) => {
  const sortFields = input.queryParams.sortFields;
  const prev = input.changeEvent.previous;
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  if (!prev) {
    return true;
  }
  for (let i2 = 0; i2 < sortFields.length; i2++) {
    const field = sortFields[i2];
    const beforeData = getProperty2(prev, field);
    const afterData = getProperty2(doc, field);
    if (beforeData !== afterData) {
      return true;
    }
  }
  return false;
};
var wasInResult = (input) => {
  const id = input.changeEvent.id;
  if (input.keyDocumentMap) {
    const has2 = input.keyDocumentMap.has(id);
    return has2;
  } else {
    const primary = input.queryParams.primaryKey;
    const results = input.previousResults;
    for (let i2 = 0; i2 < results.length; i2++) {
      const item = results[i2];
      if (item[primary] === id) {
        return true;
      }
    }
    return false;
  }
};
var wasFirst = (input) => {
  const first = input.previousResults[0];
  if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
var wasLast = (input) => {
  const last2 = lastOfArray(input.previousResults);
  if (last2 && last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  } else {
    return false;
  }
};
var wasSortedBeforeFirst = (input) => {
  const prev = input.changeEvent.previous;
  if (!prev) {
    return false;
  }
  const first = input.previousResults[0];
  if (!first) {
    return false;
  }
  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev, first);
  return comp < 0;
};
var wasSortedAfterLast = (input) => {
  const prev = input.changeEvent.previous;
  if (!prev) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(prev, last2);
  return comp > 0;
};
var isSortedBeforeFirst = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const first = input.previousResults[0];
  if (!first) {
    return false;
  }
  if (first[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, first);
  return comp < 0;
};
var isSortedAfterLast = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const last2 = lastOfArray(input.previousResults);
  if (!last2) {
    return false;
  }
  if (last2[input.queryParams.primaryKey] === input.changeEvent.id) {
    return true;
  }
  const comp = input.queryParams.sortComparator(doc, last2);
  return comp > 0;
};
var wasMatching = (input) => {
  const prev = input.changeEvent.previous;
  if (!prev) {
    return false;
  }
  return input.queryParams.queryMatcher(prev);
};
var doesMatchNow = (input) => {
  const doc = input.changeEvent.doc;
  if (!doc) {
    return false;
  }
  const ret = input.queryParams.queryMatcher(doc);
  return ret;
};
var wasResultsEmpty = (input) => {
  return input.previousResults.length === 0;
};

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/states/index.js
var stateResolveFunctionByIndex = {
  0: isInsert,
  1: isUpdate,
  2: isDelete,
  3: hasLimit,
  4: isFindOne,
  5: hasSkip,
  6: wasResultsEmpty,
  7: wasLimitReached,
  8: wasFirst,
  9: wasLast,
  10: sortParamsChanged,
  11: wasInResult,
  12: wasSortedBeforeFirst,
  13: wasSortedAfterLast,
  14: isSortedBeforeFirst,
  15: isSortedAfterLast,
  16: wasMatching,
  17: doesMatchNow
};

// node_modules/.pnpm/array-push-at-sort-position@4.0.1/node_modules/array-push-at-sort-position/dist/esm/index.js
function pushAtSortPosition(array, item, compareFunction, low) {
  var length = array.length;
  var high = length - 1;
  var mid = 0;
  if (length === 0) {
    array.push(item);
    return 0;
  }
  var lastMidDoc;
  while (low <= high) {
    mid = low + (high - low >> 1);
    lastMidDoc = array[mid];
    if (compareFunction(lastMidDoc, item) <= 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (compareFunction(lastMidDoc, item) <= 0) {
    mid++;
  }
  array.splice(mid, 0, item);
  return mid;
}

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/actions/action-functions.js
var doNothing = (_input) => {
};
var insertFirst = (input) => {
  input.previousResults.unshift(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
var insertLast = (input) => {
  input.previousResults.push(input.changeEvent.doc);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.set(input.changeEvent.id, input.changeEvent.doc);
  }
};
var removeFirstItem = (input) => {
  const first = input.previousResults.shift();
  if (input.keyDocumentMap && first) {
    input.keyDocumentMap.delete(first[input.queryParams.primaryKey]);
  }
};
var removeLastItem = (input) => {
  const last2 = input.previousResults.pop();
  if (input.keyDocumentMap && last2) {
    input.keyDocumentMap.delete(last2[input.queryParams.primaryKey]);
  }
};
var removeFirstInsertLast = (input) => {
  removeFirstItem(input);
  insertLast(input);
};
var removeLastInsertFirst = (input) => {
  removeLastItem(input);
  insertFirst(input);
};
var removeFirstInsertFirst = (input) => {
  removeFirstItem(input);
  insertFirst(input);
};
var removeLastInsertLast = (input) => {
  removeLastItem(input);
  insertLast(input);
};
var removeExisting = (input) => {
  if (input.keyDocumentMap) {
    input.keyDocumentMap.delete(input.changeEvent.id);
  }
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i2 = 0; i2 < results.length; i2++) {
    const item = results[i2];
    if (item[primary] === input.changeEvent.id) {
      results.splice(i2, 1);
      break;
    }
  }
};
var replaceExisting = (input) => {
  const doc = input.changeEvent.doc;
  const primary = input.queryParams.primaryKey;
  const results = input.previousResults;
  for (let i2 = 0; i2 < results.length; i2++) {
    const item = results[i2];
    if (item[primary] === input.changeEvent.id) {
      results[i2] = doc;
      if (input.keyDocumentMap) {
        input.keyDocumentMap.set(input.changeEvent.id, doc);
      }
      break;
    }
  }
};
var alwaysWrong = (input) => {
  const wrongHuman = {
    _id: "wrongHuman" + (/* @__PURE__ */ new Date()).getTime()
  };
  input.previousResults.length = 0;
  input.previousResults.push(wrongHuman);
  if (input.keyDocumentMap) {
    input.keyDocumentMap.clear();
    input.keyDocumentMap.set(wrongHuman._id, wrongHuman);
  }
};
var insertAtSortPosition = (input) => {
  const docId = input.changeEvent.id;
  const doc = input.changeEvent.doc;
  if (input.keyDocumentMap) {
    if (input.keyDocumentMap.has(docId)) {
      return;
    }
    input.keyDocumentMap.set(docId, doc);
  } else {
    const isDocInResults = input.previousResults.find((d) => d[input.queryParams.primaryKey] === docId);
    if (isDocInResults) {
      return;
    }
  }
  pushAtSortPosition(input.previousResults, doc, input.queryParams.sortComparator, 0);
};
var removeExistingAndInsertAtSortPosition = (input) => {
  removeExisting(input);
  insertAtSortPosition(input);
};
var runFullQueryAgain = (_input) => {
  throw new Error("Action runFullQueryAgain must be implemented by yourself");
};
var unknownAction = (_input) => {
  throw new Error("Action unknownAction should never be called");
};

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/actions/index.js
var orderedActionList = [
  "doNothing",
  "insertFirst",
  "insertLast",
  "removeFirstItem",
  "removeLastItem",
  "removeFirstInsertLast",
  "removeLastInsertFirst",
  "removeFirstInsertFirst",
  "removeLastInsertLast",
  "removeExisting",
  "replaceExisting",
  "alwaysWrong",
  "insertAtSortPosition",
  "removeExistingAndInsertAtSortPosition",
  "runFullQueryAgain",
  "unknownAction"
];
var actionFunctions = {
  doNothing,
  insertFirst,
  insertLast,
  removeFirstItem,
  removeLastItem,
  removeFirstInsertLast,
  removeLastInsertFirst,
  removeFirstInsertFirst,
  removeLastInsertLast,
  removeExisting,
  replaceExisting,
  alwaysWrong,
  insertAtSortPosition,
  removeExistingAndInsertAtSortPosition,
  runFullQueryAgain,
  unknownAction
};

// node_modules/.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/dist/esm/src/minimal-string/string-format.js
var CHAR_CODE_OFFSET = 40;
function getNumberOfChar(char) {
  const charCode = char.charCodeAt(0);
  return charCode - CHAR_CODE_OFFSET;
}

// node_modules/.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/dist/esm/src/util.js
function booleanToBooleanString(b) {
  if (b) {
    return "1";
  } else {
    return "0";
  }
}
function makeid(length = 6) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i2 = 0; i2 < length; i2++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
var nodeIdPrefix = makeid(4);
function splitStringToChunks(str, chunkSize) {
  const chunks = [];
  for (let i2 = 0, charsLength = str.length; i2 < charsLength; i2 += chunkSize) {
    chunks.push(str.substring(i2, i2 + chunkSize));
  }
  return chunks;
}

// node_modules/.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/dist/esm/src/minimal-string/minimal-string-to-simple-bdd.js
function minimalStringToSimpleBdd(str) {
  const nodesById = /* @__PURE__ */ new Map();
  const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);
  const lastLeafNodeChar = 2 + leafNodeAmount * 2;
  const leafNodeChars = str.substring(2, lastLeafNodeChar);
  const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);
  for (let i2 = 0; i2 < leafNodeChunks.length; i2++) {
    const chunk = leafNodeChunks[i2];
    const id = chunk.charAt(0);
    const value = getNumberOfChar(chunk.charAt(1));
    nodesById.set(id, value);
  }
  const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);
  const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);
  for (let i2 = 0; i2 < internalNodeChunks.length; i2++) {
    const chunk = internalNodeChunks[i2];
    const id = chunk.charAt(0);
    const idOf0Branch = chunk.charAt(1);
    const idOf1Branch = chunk.charAt(2);
    const level = getNumberOfChar(chunk.charAt(3));
    if (!nodesById.has(idOf0Branch)) {
      throw new Error("missing node with id " + idOf0Branch);
    }
    if (!nodesById.has(idOf1Branch)) {
      throw new Error("missing node with id " + idOf1Branch);
    }
    const node0 = nodesById.get(idOf0Branch);
    const node1 = nodesById.get(idOf1Branch);
    const node = {
      l: level,
      // level is first for prettier json output
      0: node0,
      1: node1
    };
    nodesById.set(id, node);
  }
  const last3 = str.slice(-3);
  const idOf0 = last3.charAt(0);
  const idOf1 = last3.charAt(1);
  const levelOfRoot = getNumberOfChar(last3.charAt(2));
  const nodeOf0 = nodesById.get(idOf0);
  const nodeOf1 = nodesById.get(idOf1);
  const rootNode = {
    l: levelOfRoot,
    0: nodeOf0,
    1: nodeOf1
  };
  return rootNode;
}

// node_modules/.pnpm/binary-decision-diagram@3.2.0/node_modules/binary-decision-diagram/dist/esm/src/minimal-string/resolve-with-simple-bdd.js
function resolveWithSimpleBdd(simpleBdd2, fns, input) {
  let currentNode = simpleBdd2;
  let currentLevel = simpleBdd2.l;
  while (true) {
    const booleanResult = fns[currentLevel](input);
    const branchKey = booleanToBooleanString(booleanResult);
    currentNode = currentNode[branchKey];
    if (typeof currentNode === "number" || typeof currentNode === "string") {
      return currentNode;
    } else {
      currentLevel = currentNode.l;
    }
  }
}

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/bdd/bdd.generated.js
var minimalBddString = "14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9\x7Fae9\xA1bf9\xA2bq9\xA3cg9\xA4ck9\xA5cn9\xA6nd9\xA7np9\xA8nq9\xA9nf9\xAAng9\xABnm9\xACnk9\xADmr9\xAEms9\xAFmt9\xB0mj9\xB1mk9\xB2ml9\xB3mn9\xB4mc8\xB5\xB3{8\xB6\xAF}8\xB7\xB0\xA48\xB8\xB3\xA78\xB9mn8\xBA\xB3\xAB8\xBB\xB3m8\xBCm\xB44\xBDz\xB24\xBE\xB3w4\xBFz\xB54\xC0\xAF\xB64\xC1\xB0\xB74\xC2\xB3\xBA4\xC3\xB3\xB84\xC4m\xB94\xC5v\xA47\xC6yn7\xC7\xC0\xC17\xC8~\x7F7\xC9\xA5\xA47\xCA\xC3\xC47\xCB\xA8n7\xCC\xBA\xB97\xCD\xAD\xB07\xCE\xAEm7\xCF\xAF\xB07\xD0\xB1m7\xD1\xB3m7\xD2\xBCm5\xD3\xC4m5\xD4\xB9m5\xD5\xBD\xB05\xD6\xBEm5\xD7\xBF\xB05\xD8\xC7\xCF5\xD9\xC2m5\xDA\xCA\xD15\xDB\xB1m5\xDC\xBAm5\xDD\xCC\xD15\xDE\xD5\xCD2\xDF|\x7F2\xE0\xA1u2\xE1\xA3\xC52\xE2\xD6\xCE2\xE3\xA6\xC62\xE4\xA9x2\xE5\xAA\xC62\xE6\xD7\xD82\xE7|\xC82\xE8\xA1\xA22\xE9\xA3\xC92\xEA\xA4\xA52\xEB\xD9\xDA2\xEC\xA6\xCB2\xED\xA9n2\xEE\xAAn2\xEF\xDB\xD02\xF0\xDC\xDD2\xF1\xACn2\xF2\xD2\xD3/\xF3an/\xF4bn/\xF5cn/\xF6\xDE\xE2/\xF7\xDF\xE3/\xF8\xE0\xE4/\xF9\xE1\xE5/\xFA\xE6\xEB/\xFB\xE7\xEC/\xFC\xE8\xED/\xFD\xE9\xEE/\xFE\xCD\xCE/\xFF\xCF\xD1/\u0100\xF2\xD4,\u0101cn,\u0102\xF6\xEF,\u0103\xA4\xF1,\u0104\xFA\xF0,\u0105\xEA\xF1,\u0106\xFE\xD0,\u0107\xFF\xD1,\u0108ac0\u0109bc0\u010A\xF3\xF50\u010B\xF4\u01010\u010C\xDF\xE10\u010D\xE0\xA40\u010E\xE7\xE90\u010F\xE8\xEA0\u0110\xF7\xF90\u0111\xF8\u01030\u0112\xFB\xFD0\u0113\xFC\u01050\u0114m\xD2-\u0115m\u0100-\u0116\xDE\xE6-\u0117\u010C\u010E-\u0118\u010D\u010F-\u0119\u0102\u0104-\u011A\u0110\u0112-\u011B\u0111\u0113-\u011C\xB2\xBB-\u011D\xCD\xCF-\u011E\u0106\u0107-\u011F\xB2\xB3-\u0120\u0114\u01083\u0121\u0115\u010A3\u0122\u0116\u01173\u0123\u0119\u011A3\u0124\u0122\u011D(\u0125\u011C\u011F(\u0126\u0123\u011E(\u0127\u0120\u0121+\u0128\u0109\u010B+\u0129\u0124\u0126+\u012A\u0118\u011B+\u012B\u0127\u01281\u012C\u0129\u012A1\u012D\u012C\u012B*\u012E\u0125m*\u012D\u012E.";
var simpleBdd;
function getSimpleBdd() {
  if (!simpleBdd) {
    simpleBdd = minimalStringToSimpleBdd(minimalBddString);
  }
  return simpleBdd;
}
var resolveInput = (input) => {
  return resolveWithSimpleBdd(getSimpleBdd(), stateResolveFunctionByIndex, input);
};

// node_modules/.pnpm/event-reduce-js@5.2.7/node_modules/event-reduce-js/dist/esm/src/index.js
function calculateActionName(input) {
  const resolvedActionId = resolveInput(input);
  return orderedActionList[resolvedActionId];
}
function runAction(action2, queryParams, changeEvent, previousResults, keyDocumentMap) {
  const fn = actionFunctions[action2];
  fn({
    queryParams,
    changeEvent,
    previousResults,
    keyDocumentMap
  });
  return previousResults;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/query-planner.js
var INDEX_MAX = String.fromCharCode(65535);
var INDEX_MIN = Number.MIN_SAFE_INTEGER;
function getQueryPlan(schema, query) {
  var selector = query.selector;
  var indexes = schema.indexes ? schema.indexes.slice(0) : [];
  if (query.index) {
    indexes = [query.index];
  }
  var hasDescSorting = !!query.sort.find((sortField) => Object.values(sortField)[0] === "desc");
  var sortIrrelevevantFields = /* @__PURE__ */ new Set();
  Object.keys(selector).forEach((fieldName) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    if (schemaPart && schemaPart.type === "boolean" && Object.prototype.hasOwnProperty.call(selector[fieldName], "$eq")) {
      sortIrrelevevantFields.add(fieldName);
    }
  });
  var optimalSortIndex = query.sort.map((sortField) => Object.keys(sortField)[0]);
  var optimalSortIndexCompareString = optimalSortIndex.filter((f) => !sortIrrelevevantFields.has(f)).join(",");
  var currentBestQuality = -1;
  var currentBestQueryPlan;
  indexes.forEach((index2) => {
    var inclusiveEnd = true;
    var inclusiveStart = true;
    var opts = index2.map((indexField) => {
      var matcher = selector[indexField];
      var operators = matcher ? Object.keys(matcher) : [];
      var matcherOpts = {};
      if (!matcher || !operators.length) {
        var startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;
        matcherOpts = {
          startKey,
          endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,
          inclusiveStart: true,
          inclusiveEnd: true
        };
      } else {
        operators.forEach((operator) => {
          if (LOGICAL_OPERATORS.has(operator)) {
            var operatorValue = matcher[operator];
            var partialOpts = getMatcherQueryOpts(operator, operatorValue);
            matcherOpts = Object.assign(matcherOpts, partialOpts);
          }
        });
      }
      if (typeof matcherOpts.startKey === "undefined") {
        matcherOpts.startKey = INDEX_MIN;
      }
      if (typeof matcherOpts.endKey === "undefined") {
        matcherOpts.endKey = INDEX_MAX;
      }
      if (typeof matcherOpts.inclusiveStart === "undefined") {
        matcherOpts.inclusiveStart = true;
      }
      if (typeof matcherOpts.inclusiveEnd === "undefined") {
        matcherOpts.inclusiveEnd = true;
      }
      if (inclusiveStart && !matcherOpts.inclusiveStart) {
        inclusiveStart = false;
      }
      if (inclusiveEnd && !matcherOpts.inclusiveEnd) {
        inclusiveEnd = false;
      }
      return matcherOpts;
    });
    var startKeys = opts.map((opt) => opt.startKey);
    var endKeys = opts.map((opt) => opt.endKey);
    var queryPlan = {
      index: index2,
      startKeys,
      endKeys,
      inclusiveEnd,
      inclusiveStart,
      sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index2.filter((f) => !sortIrrelevevantFields.has(f)).join(","),
      selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index2, query.selector, startKeys, endKeys)
    };
    var quality = rateQueryPlan(schema, query, queryPlan);
    if (quality >= currentBestQuality || query.index) {
      currentBestQuality = quality;
      currentBestQueryPlan = queryPlan;
    }
  });
  if (!currentBestQueryPlan) {
    throw newRxError("SNH", {
      query
    });
  }
  return currentBestQueryPlan;
}
var LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte", "$lt", "$lte"]);
var LOWER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$gt", "$gte"]);
var UPPER_BOUND_LOGICAL_OPERATORS = /* @__PURE__ */ new Set(["$eq", "$lt", "$lte"]);
function isSelectorSatisfiedByIndex(index2, selector, startKeys, endKeys) {
  var selectorEntries = Object.entries(selector);
  var hasNonMatchingOperator = selectorEntries.find(([fieldName2, operation2]) => {
    if (!index2.includes(fieldName2)) {
      return true;
    }
    var hasNonLogicOperator = Object.entries(operation2).find(([op, _value]) => !LOGICAL_OPERATORS.has(op));
    return hasNonLogicOperator;
  });
  if (hasNonMatchingOperator) {
    return false;
  }
  if (selector.$and || selector.$or) {
    return false;
  }
  var satisfieldLowerBound = [];
  var lowerOperatorFieldNames = /* @__PURE__ */ new Set();
  for (var [fieldName, operation] of Object.entries(selector)) {
    if (!index2.includes(fieldName)) {
      return false;
    }
    var lowerLogicOps = Object.keys(operation).filter((key) => LOWER_BOUND_LOGICAL_OPERATORS.has(key));
    if (lowerLogicOps.length > 1) {
      return false;
    }
    var hasLowerLogicOp = lowerLogicOps[0];
    if (hasLowerLogicOp) {
      lowerOperatorFieldNames.add(fieldName);
    }
    if (hasLowerLogicOp !== "$eq") {
      if (satisfieldLowerBound.length > 0) {
        return false;
      } else {
        satisfieldLowerBound.push(hasLowerLogicOp);
      }
    }
  }
  var satisfieldUpperBound = [];
  var upperOperatorFieldNames = /* @__PURE__ */ new Set();
  for (var [_fieldName, _operation] of Object.entries(selector)) {
    if (!index2.includes(_fieldName)) {
      return false;
    }
    var upperLogicOps = Object.keys(_operation).filter((key) => UPPER_BOUND_LOGICAL_OPERATORS.has(key));
    if (upperLogicOps.length > 1) {
      return false;
    }
    var hasUperLogicOp = upperLogicOps[0];
    if (hasUperLogicOp) {
      upperOperatorFieldNames.add(_fieldName);
    }
    if (hasUperLogicOp !== "$eq") {
      if (satisfieldUpperBound.length > 0) {
        return false;
      } else {
        satisfieldUpperBound.push(hasUperLogicOp);
      }
    }
  }
  var i2 = 0;
  for (var _fieldName2 of index2) {
    for (var set2 of [lowerOperatorFieldNames, upperOperatorFieldNames]) {
      if (!set2.has(_fieldName2) && set2.size > 0) {
        return false;
      }
      set2.delete(_fieldName2);
    }
    var startKey = startKeys[i2];
    var endKey = endKeys[i2];
    if (startKey !== endKey && lowerOperatorFieldNames.size > 0 && upperOperatorFieldNames.size > 0) {
      return false;
    }
    i2++;
  }
  return true;
}
function getMatcherQueryOpts(operator, operatorValue) {
  switch (operator) {
    case "$eq":
      return {
        startKey: operatorValue,
        endKey: operatorValue,
        inclusiveEnd: true,
        inclusiveStart: true
      };
    case "$lte":
      return {
        endKey: operatorValue,
        inclusiveEnd: true
      };
    case "$gte":
      return {
        startKey: operatorValue,
        inclusiveStart: true
      };
    case "$lt":
      return {
        endKey: operatorValue,
        inclusiveEnd: false
      };
    case "$gt":
      return {
        startKey: operatorValue,
        inclusiveStart: false
      };
    default:
      throw new Error("SNH");
  }
}
function rateQueryPlan(schema, query, queryPlan) {
  var quality = 0;
  var addQuality = (value) => {
    if (value > 0) {
      quality = quality + value;
    }
  };
  var pointsPerMatchingKey = 10;
  var nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);
  addQuality(nonMinKeyCount * pointsPerMatchingKey);
  var nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue) => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);
  addQuality(nonMaxKeyCount * pointsPerMatchingKey);
  var equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {
    if (keyValue === queryPlan.endKeys[idx]) {
      return true;
    } else {
      return false;
    }
  });
  addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);
  var pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;
  addQuality(pointsIfNoReSortMustBeDone);
  return quality;
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/util.js
var MingoError = class extends Error {
};
var MAX_INT = 2147483647;
var MIN_INT = -2147483648;
var MAX_LONG = Number.MAX_SAFE_INTEGER;
var MIN_LONG = Number.MIN_SAFE_INTEGER;
var MISSING = Symbol("missing");
var CYCLE_FOUND_ERROR = Object.freeze(
  new Error("mingo: cycle detected while processing object/array")
);
var OBJECT_TAG = "[object Object]";
var OBJECT_TYPE_RE = /^\[object ([a-zA-Z0-9]+)\]$/;
var DEFAULT_HASH_FUNCTION = (value) => {
  const s = stringify(value);
  let hash2 = 0;
  let i2 = s.length;
  while (i2)
    hash2 = (hash2 << 5) - hash2 ^ s.charCodeAt(--i2);
  return hash2 >>> 0;
};
var JS_SIMPLE_TYPES = /* @__PURE__ */ new Set([
  "null",
  "undefined",
  "boolean",
  "number",
  "string",
  "date",
  "regexp"
]);
var SORT_ORDER_BY_TYPE = {
  null: 0,
  undefined: 0,
  number: 1,
  string: 2,
  object: 3,
  array: 4,
  boolean: 5,
  date: 6,
  regexp: 7,
  function: 8
};
var compare = (a2, b) => {
  if (a2 === MISSING)
    a2 = void 0;
  if (b === MISSING)
    b = void 0;
  const [u, v] = [a2, b].map(
    (n2) => SORT_ORDER_BY_TYPE[getType(n2).toLowerCase()]
  );
  if (u !== v)
    return u - v;
  if (u === 1 || u === 2 || u === 6) {
    if (a2 < b)
      return -1;
    if (a2 > b)
      return 1;
    return 0;
  }
  if (isEqual(a2, b))
    return 0;
  if (a2 < b)
    return -1;
  if (a2 > b)
    return 1;
  return 0;
};
function assert(condition, message) {
  if (!condition)
    throw new MingoError(message);
}
var getType = (v) => OBJECT_TYPE_RE.exec(Object.prototype.toString.call(v))[1];
var isBoolean = (v) => typeof v === "boolean";
var isString = (v) => typeof v === "string";
var isNumber = (v) => !isNaN(v) && typeof v === "number";
var isArray2 = Array.isArray;
var isObject3 = (v) => {
  if (!v)
    return false;
  const proto = Object.getPrototypeOf(v);
  return (proto === Object.prototype || proto === null) && OBJECT_TAG === Object.prototype.toString.call(v);
};
var isObjectLike = (v) => v === Object(v);
var isDate = (v) => v instanceof Date;
var isRegExp = (v) => v instanceof RegExp;
var isFunction2 = (v) => typeof v === "function";
var isNil = (v) => v === null || v === void 0;
var inArray = (arr, item) => arr.includes(item);
var notInArray = (arr, item) => !inArray(arr, item);
var truthy = (arg, strict = true) => !!arg || strict && arg === "";
var isEmpty = (x2) => isNil(x2) || isString(x2) && !x2 || x2 instanceof Array && x2.length === 0 || isObject3(x2) && Object.keys(x2).length === 0;
var isMissing = (v) => v === MISSING;
var ensureArray = (x2) => x2 instanceof Array ? x2 : [x2];
var has = (obj, prop2) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop2);
var isTypedArray = (v) => typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView(v);
var INSTANCE_CLONE = [isDate, isRegExp, isTypedArray];
var cloneInternal = (val, refs) => {
  if (isNil(val))
    return val;
  if (refs.has(val))
    throw CYCLE_FOUND_ERROR;
  const ctor = val.constructor;
  if (INSTANCE_CLONE.some((f) => f(val)))
    return new ctor(val);
  try {
    refs.add(val);
    if (isArray2(val))
      return val.map((v) => cloneInternal(v, refs));
    if (isObject3(val)) {
      const res = {};
      for (const k in val)
        res[k] = cloneInternal(val[k], refs);
      return res;
    }
  } finally {
    refs.delete(val);
  }
  return val;
};
var cloneDeep = (obj) => cloneInternal(obj, /* @__PURE__ */ new Set());
var mergeable = (left, right) => isObject3(left) && isObject3(right) || isArray2(left) && isArray2(right);
function merge3(target, obj, options) {
  options = options || { flatten: false };
  if (isMissing(target) || isNil(target))
    return obj;
  if (isMissing(obj) || isNil(obj))
    return target;
  if (!mergeable(target, obj)) {
    if (options.skipValidation)
      return obj || target;
    throw Error("mismatched types. must both be array or object");
  }
  options.skipValidation = true;
  if (isArray2(target)) {
    const result = target;
    const input = obj;
    if (options.flatten) {
      let i2 = 0;
      let j = 0;
      while (i2 < result.length && j < input.length) {
        result[i2] = merge3(result[i2++], input[j++], options);
      }
      while (j < input.length) {
        result.push(obj[j++]);
      }
    } else {
      into(result, input);
    }
  } else {
    for (const k in obj) {
      target[k] = merge3(
        target[k],
        obj[k],
        options
      );
    }
  }
  return target;
}
function buildHashIndex(arr, hashFunction = DEFAULT_HASH_FUNCTION) {
  const map2 = /* @__PURE__ */ new Map();
  arr.forEach((o, i2) => {
    const h2 = hashCode(o, hashFunction);
    if (map2.has(h2)) {
      if (!map2.get(h2).some((j) => isEqual(arr[j], o))) {
        map2.get(h2).push(i2);
      }
    } else {
      map2.set(h2, [i2]);
    }
  });
  return map2;
}
function intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (input.some((arr) => arr.length == 0))
    return [];
  if (input.length === 1)
    return Array.from(input);
  const sortedIndex = sortBy(
    input.map((a2, i2) => [i2, a2.length]),
    (a2) => a2[1]
  );
  const smallest = input[sortedIndex[0][0]];
  const map2 = buildHashIndex(smallest, hashFunction);
  const rmap = /* @__PURE__ */ new Map();
  const results = new Array();
  map2.forEach((v, k) => {
    const lhs = v.map((j) => smallest[j]);
    const res = lhs.map((_) => 0);
    const stable = lhs.map((_) => [sortedIndex[0][0], 0]);
    let found = false;
    for (let i2 = 1; i2 < input.length; i2++) {
      const [currIndex, _] = sortedIndex[i2];
      const arr = input[currIndex];
      if (!rmap.has(i2))
        rmap.set(i2, buildHashIndex(arr));
      if (rmap.get(i2).has(k)) {
        const rhs = rmap.get(i2).get(k).map((j) => arr[j]);
        found = lhs.map(
          (s, n2) => rhs.some((t, m) => {
            const p2 = res[n2];
            if (isEqual(s, t)) {
              res[n2]++;
              if (currIndex < stable[n2][0]) {
                stable[n2] = [currIndex, rmap.get(i2).get(k)[m]];
              }
            }
            return p2 < res[n2];
          })
        ).some(Boolean);
      }
      if (!found)
        return;
    }
    if (found) {
      into(
        results,
        res.map((n2, i2) => {
          return n2 === input.length - 1 ? [lhs[i2], stable[i2]] : MISSING;
        }).filter((n2) => n2 !== MISSING)
      );
    }
  });
  return results.sort((a2, b) => {
    const [_i, [u, m]] = a2;
    const [_j, [v, n2]] = b;
    const r = compare(u, v);
    if (r !== 0)
      return r;
    return compare(m, n2);
  }).map((v) => v[0]);
}
function flatten(xs, depth = 0) {
  const arr = new Array();
  function flatten2(ys, n2) {
    for (let i2 = 0, len = ys.length; i2 < len; i2++) {
      if (isArray2(ys[i2]) && (n2 > 0 || n2 < 0)) {
        flatten2(ys[i2], Math.max(-1, n2 - 1));
      } else {
        arr.push(ys[i2]);
      }
    }
  }
  flatten2(xs, depth);
  return arr;
}
var getMembersOf = (value) => {
  let [proto, names] = [
    Object.getPrototypeOf(value),
    Object.getOwnPropertyNames(value)
  ];
  let activeProto = proto;
  while (!names.length && proto !== Object.prototype && proto !== Array.prototype) {
    activeProto = proto;
    names = Object.getOwnPropertyNames(proto);
    proto = Object.getPrototypeOf(proto);
  }
  const o = {};
  names.forEach((k) => o[k] = value[k]);
  return [o, activeProto];
};
function isEqual(a2, b) {
  if (a2 === b || Object.is(a2, b))
    return true;
  const ctor = !!a2 && a2.constructor || a2;
  if (a2 === null || b === null || a2 === void 0 || b === void 0 || ctor !== b.constructor || ctor === Function) {
    return false;
  }
  if (ctor === Array || ctor === Object) {
    const aKeys = Object.keys(a2);
    const bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length)
      return false;
    if ((/* @__PURE__ */ new Set([...aKeys, ...bKeys])).size != aKeys.length)
      return false;
    for (const k of aKeys)
      if (!isEqual(a2[k], b[k]))
        return false;
    return true;
  }
  const proto = Object.getPrototypeOf(a2);
  const cmp2 = isTypedArray(a2) || proto !== Object.prototype && proto !== Array.prototype && Object.prototype.hasOwnProperty.call(proto, "toString");
  return cmp2 && a2.toString() === b.toString();
}
var toString = (v, cycle) => {
  if (v === null)
    return "null";
  if (v === void 0)
    return "undefined";
  const ctor = v.constructor;
  switch (ctor) {
    case RegExp:
    case Number:
    case Boolean:
    case Function:
    case Symbol:
      return v.toString();
    case String:
      return JSON.stringify(v);
    case Date:
      return v.toISOString();
  }
  if (isTypedArray(v))
    return ctor.name + "[" + v.toString() + "]";
  if (cycle.has(v))
    throw CYCLE_FOUND_ERROR;
  try {
    cycle.add(v);
    if (isArray2(v)) {
      return "[" + v.map((s) => toString(s, cycle)).join(",") + "]";
    }
    if (ctor === Object) {
      return "{" + Object.keys(v).sort().map((k) => k + ":" + toString(v[k], cycle)).join(",") + "}";
    }
    const proto = Object.getPrototypeOf(v);
    if (proto !== Object.prototype && proto !== Array.prototype && Object.prototype.hasOwnProperty.call(proto, "toString")) {
      return ctor.name + "(" + JSON.stringify(v.toString()) + ")";
    }
    const [members, _] = getMembersOf(v);
    return ctor.name + toString(members, cycle);
  } finally {
    cycle.delete(v);
  }
};
var stringify = (value) => toString(value, /* @__PURE__ */ new Set());
function hashCode(value, hashFunction) {
  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;
  if (isNil(value))
    return null;
  return hashFunction(value).toString();
}
function sortBy(collection, keyFn, comparator = compare) {
  if (isEmpty(collection))
    return collection;
  const sorted = new Array();
  const result = new Array();
  for (let i2 = 0; i2 < collection.length; i2++) {
    const obj = collection[i2];
    const key = keyFn(obj, i2);
    if (isNil(key)) {
      result.push(obj);
    } else {
      sorted.push([key, obj]);
    }
  }
  sorted.sort((a2, b) => comparator(a2[0], b[0]));
  return into(
    result,
    sorted.map((o) => o[1])
  );
}
function groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {
  if (collection.length < 1)
    return /* @__PURE__ */ new Map();
  const lookup = /* @__PURE__ */ new Map();
  const result = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < collection.length; i2++) {
    const obj = collection[i2];
    const key = keyFn(obj, i2);
    const hash2 = hashCode(key, hashFunction);
    if (hash2 === null) {
      if (result.has(null)) {
        result.get(null).push(obj);
      } else {
        result.set(null, [obj]);
      }
    } else {
      const existingKey = lookup.has(hash2) ? lookup.get(hash2).find((k) => isEqual(k, key)) : null;
      if (isNil(existingKey)) {
        result.set(key, [obj]);
        if (lookup.has(hash2)) {
          lookup.get(hash2).push(key);
        } else {
          lookup.set(hash2, [key]);
        }
      } else {
        result.get(existingKey).push(obj);
      }
    }
  }
  return result;
}
var MAX_ARRAY_PUSH = 5e4;
function into(target, ...rest) {
  if (target instanceof Array) {
    return rest.reduce(
      (acc, arr) => {
        let i2 = Math.ceil(arr.length / MAX_ARRAY_PUSH);
        let begin = 0;
        while (i2-- > 0) {
          Array.prototype.push.apply(
            acc,
            arr.slice(begin, begin + MAX_ARRAY_PUSH)
          );
          begin += MAX_ARRAY_PUSH;
        }
        return acc;
      },
      target
    );
  } else {
    return rest.filter(isObjectLike).reduce((acc, item) => {
      Object.assign(acc, item);
      return acc;
    }, target);
  }
}
function getValue(obj, key) {
  return isObjectLike(obj) ? obj[key] : void 0;
}
function unwrap(arr, depth) {
  if (depth < 1)
    return arr;
  while (depth-- && arr.length === 1)
    arr = arr[0];
  return arr;
}
function resolve(obj, selector, options) {
  let depth = 0;
  function resolve2(o, path) {
    let value = o;
    for (let i2 = 0; i2 < path.length; i2++) {
      const field = path[i2];
      const isText = /^\d+$/.exec(field) === null;
      if (isText && value instanceof Array) {
        if (i2 === 0 && depth > 0)
          break;
        depth += 1;
        const subpath = path.slice(i2);
        value = value.reduce((acc, item) => {
          const v = resolve2(item, subpath);
          if (v !== void 0)
            acc.push(v);
          return acc;
        }, []);
        break;
      } else {
        value = getValue(value, field);
      }
      if (value === void 0)
        break;
    }
    return value;
  }
  const result = JS_SIMPLE_TYPES.has(getType(obj).toLowerCase()) ? obj : resolve2(obj, selector.split("."));
  return result instanceof Array && options?.unwrapArray ? unwrap(result, depth) : result;
}
function resolveGraph(obj, selector, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  const isIndex = /^\d+$/.exec(key) !== null;
  const hasNext = names.length > 1;
  let result;
  let value;
  if (obj instanceof Array) {
    if (isIndex) {
      result = getValue(obj, Number(key));
      if (hasNext) {
        result = resolveGraph(result, next2, options);
      }
      result = [result];
    } else {
      result = [];
      for (const item of obj) {
        value = resolveGraph(item, selector, options);
        if (options?.preserveMissing) {
          if (value === void 0) {
            value = MISSING;
          }
          result.push(value);
        } else if (value !== void 0) {
          result.push(value);
        }
      }
    }
  } else {
    value = getValue(obj, key);
    if (hasNext) {
      value = resolveGraph(value, next2, options);
    }
    if (value === void 0)
      return void 0;
    result = options?.preserveKeys ? { ...obj } : {};
    result[key] = value;
  }
  return result;
}
function filterMissing(obj) {
  if (obj instanceof Array) {
    for (let i2 = obj.length - 1; i2 >= 0; i2--) {
      if (obj[i2] === MISSING) {
        obj.splice(i2, 1);
      } else {
        filterMissing(obj[i2]);
      }
    }
  } else if (isObject3(obj)) {
    for (const k in obj) {
      if (has(obj, k)) {
        filterMissing(obj[k]);
      }
    }
  }
}
var NUMBER_RE = /^\d+$/;
function walk(obj, selector, fn, options) {
  const names = selector.split(".");
  const key = names[0];
  const next2 = names.slice(1).join(".");
  if (names.length === 1) {
    if (isObject3(obj) || isArray2(obj) && NUMBER_RE.test(key)) {
      fn(obj, key);
    }
  } else {
    if (options?.buildGraph && isNil(obj[key])) {
      obj[key] = {};
    }
    const item = obj[key];
    if (!item)
      return;
    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));
    if (item instanceof Array && options?.descendArray && !isNextArrayIndex) {
      item.forEach((e) => walk(e, next2, fn, options));
    } else {
      walk(item, next2, fn, options);
    }
  }
}
function setValue(obj, selector, value) {
  walk(
    obj,
    selector,
    (item, key) => {
      item[key] = isFunction2(value) ? value(item[key]) : value;
    },
    { buildGraph: true }
  );
}
function removeValue(obj, selector, options) {
  walk(
    obj,
    selector,
    (item, key) => {
      if (item instanceof Array) {
        if (/^\d+$/.test(key)) {
          item.splice(parseInt(key), 1);
        } else if (options && options.descendArray) {
          for (const elem of item) {
            if (isObject3(elem)) {
              delete elem[key];
            }
          }
        }
      } else if (isObject3(item)) {
        delete item[key];
      }
    },
    options
  );
}
var OPERATOR_NAME_PATTERN = /^\$[a-zA-Z0-9_]+$/;
function isOperator(name) {
  return OPERATOR_NAME_PATTERN.test(name);
}
function normalize(expr) {
  if (JS_SIMPLE_TYPES.has(getType(expr).toLowerCase())) {
    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };
  }
  if (isObjectLike(expr)) {
    const exprObj = expr;
    if (!Object.keys(exprObj).some(isOperator)) {
      return { $eq: expr };
    }
    if (has(expr, "$regex")) {
      const newExpr = { ...expr };
      newExpr["$regex"] = new RegExp(
        expr["$regex"],
        expr["$options"]
      );
      delete newExpr["$options"];
      return newExpr;
    }
  }
  return expr;
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/core.js
var ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {
  ProcessingMode2["CLONE_ALL"] = "CLONE_ALL";
  ProcessingMode2["CLONE_INPUT"] = "CLONE_INPUT";
  ProcessingMode2["CLONE_OUTPUT"] = "CLONE_OUTPUT";
  ProcessingMode2["CLONE_OFF"] = "CLONE_OFF";
  return ProcessingMode2;
})(ProcessingMode || {});
var ComputeOptions = class _ComputeOptions {
  constructor(_opts, _root, _local, timestamp = Date.now()) {
    this._opts = _opts;
    this._root = _root;
    this._local = _local;
    this.timestamp = timestamp;
    this.update(_root, _local);
  }
  /**
   * Initialize new ComputeOptions.
   *
   * @param options
   * @param root
   * @param local
   * @returns {ComputeOptions}
   */
  static init(options, root, local) {
    return options instanceof _ComputeOptions ? new _ComputeOptions(
      options._opts,
      isNil(options.root) ? root : options.root,
      Object.assign({}, options.local, local)
    ) : new _ComputeOptions(options, root, local);
  }
  /** Updates the internal mutable state. */
  update(root, local) {
    this._root = root;
    this._local = local ? Object.assign({}, local, {
      variables: Object.assign({}, this._local?.variables, local?.variables)
    }) : local;
    return this;
  }
  getOptions() {
    return Object.freeze({
      ...this._opts,
      context: Context.from(this._opts.context)
    });
  }
  get root() {
    return this._root;
  }
  get local() {
    return this._local;
  }
  get idKey() {
    return this._opts.idKey;
  }
  get collation() {
    return this._opts?.collation;
  }
  get processingMode() {
    return this._opts?.processingMode || "CLONE_OFF";
  }
  get useStrictMode() {
    return this._opts?.useStrictMode;
  }
  get scriptEnabled() {
    return this._opts?.scriptEnabled;
  }
  get useGlobalContext() {
    return this._opts?.useGlobalContext;
  }
  get hashFunction() {
    return this._opts?.hashFunction;
  }
  get collectionResolver() {
    return this._opts?.collectionResolver;
  }
  get jsonSchemaValidator() {
    return this._opts?.jsonSchemaValidator;
  }
  get variables() {
    return this._opts?.variables;
  }
  get context() {
    return this._opts?.context;
  }
};
function initOptions(options) {
  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({
    idKey: "_id",
    scriptEnabled: true,
    useStrictMode: true,
    useGlobalContext: true,
    processingMode: "CLONE_OFF",
    ...options,
    context: options?.context ? Context.from(options?.context) : Context.init({})
  });
}
var OperatorType = /* @__PURE__ */ ((OperatorType2) => {
  OperatorType2["ACCUMULATOR"] = "accumulator";
  OperatorType2["EXPRESSION"] = "expression";
  OperatorType2["PIPELINE"] = "pipeline";
  OperatorType2["PROJECTION"] = "projection";
  OperatorType2["QUERY"] = "query";
  OperatorType2["WINDOW"] = "window";
  return OperatorType2;
})(OperatorType || {});
var Context = class _Context {
  constructor(ops) {
    this.operators = {
      [
        "accumulator"
        /* ACCUMULATOR */
      ]: {},
      [
        "expression"
        /* EXPRESSION */
      ]: {},
      [
        "pipeline"
        /* PIPELINE */
      ]: {},
      [
        "projection"
        /* PROJECTION */
      ]: {},
      [
        "query"
        /* QUERY */
      ]: {},
      [
        "window"
        /* WINDOW */
      ]: {}
    };
    for (const [type5, operators] of Object.entries(ops)) {
      this.addOperators(type5, operators);
    }
  }
  static init(ops = {}) {
    return new _Context(ops);
  }
  static from(ctx) {
    return new _Context(ctx.operators);
  }
  addOperators(type5, ops) {
    for (const [name, fn] of Object.entries(ops)) {
      if (!this.getOperator(type5, name)) {
        this.operators[type5][name] = fn;
      }
    }
    return this;
  }
  // register
  addAccumulatorOps(ops) {
    return this.addOperators("accumulator", ops);
  }
  addExpressionOps(ops) {
    return this.addOperators("expression", ops);
  }
  addQueryOps(ops) {
    return this.addOperators("query", ops);
  }
  addPipelineOps(ops) {
    return this.addOperators("pipeline", ops);
  }
  addProjectionOps(ops) {
    return this.addOperators("projection", ops);
  }
  addWindowOps(ops) {
    return this.addOperators("window", ops);
  }
  // getters
  getOperator(type5, name) {
    return type5 in this.operators ? this.operators[type5][name] || null : null;
  }
};
var GLOBAL_CONTEXT = Context.init();
function useOperators(type5, operators) {
  for (const [name, fn] of Object.entries(operators)) {
    assert(
      isFunction2(fn) && isOperator(name),
      `'${name}' is not a valid operator`
    );
    const currentFn = getOperator(type5, name, null);
    assert(
      !currentFn || fn === currentFn,
      `${name} already exists for '${type5}' operators. Cannot change operator function once registered.`
    );
  }
  switch (type5) {
    case "accumulator":
      GLOBAL_CONTEXT.addAccumulatorOps(operators);
      break;
    case "expression":
      GLOBAL_CONTEXT.addExpressionOps(operators);
      break;
    case "pipeline":
      GLOBAL_CONTEXT.addPipelineOps(operators);
      break;
    case "projection":
      GLOBAL_CONTEXT.addProjectionOps(operators);
      break;
    case "query":
      GLOBAL_CONTEXT.addQueryOps(operators);
      break;
    case "window":
      GLOBAL_CONTEXT.addWindowOps(operators);
      break;
  }
}
function getOperator(type5, operator, options) {
  const { context: ctx, useGlobalContext: fallback2 } = options || {};
  const fn = ctx ? ctx.getOperator(type5, operator) : null;
  return !fn && fallback2 ? GLOBAL_CONTEXT.getOperator(type5, operator) : fn;
}
var systemVariables = {
  $$ROOT(_obj, _expr, options) {
    return options.root;
  },
  $$CURRENT(obj, _expr, _options) {
    return obj;
  },
  $$REMOVE(_obj, _expr, _options) {
    return void 0;
  },
  $$NOW(_obj, _expr, options) {
    return new Date(options.timestamp);
  }
};
var redactVariables = {
  $$KEEP(obj, _expr, _options) {
    return obj;
  },
  $$PRUNE(_obj, _expr, _options) {
    return void 0;
  },
  $$DESCEND(obj, expr, options) {
    if (!has(expr, "$cond"))
      return obj;
    let result;
    for (const [key, current] of Object.entries(obj)) {
      if (isObjectLike(current)) {
        if (current instanceof Array) {
          const array = [];
          for (let elem of current) {
            if (isObject3(elem)) {
              elem = redact(elem, expr, options.update(elem));
            }
            if (!isNil(elem)) {
              array.push(elem);
            }
          }
          result = array;
        } else {
          result = redact(
            current,
            expr,
            options.update(current)
          );
        }
        if (isNil(result)) {
          delete obj[key];
        } else {
          obj[key] = result;
        }
      }
    }
    return obj;
  }
};
function computeValue(obj, expr, operator, options) {
  const copts = ComputeOptions.init(options, obj);
  operator = operator || "";
  if (isOperator(operator)) {
    const callExpression = getOperator(
      "expression",
      operator,
      options
    );
    if (callExpression)
      return callExpression(obj, expr, copts);
    const callAccumulator = getOperator(
      "accumulator",
      operator,
      options
    );
    if (callAccumulator) {
      if (!(obj instanceof Array)) {
        obj = computeValue(obj, expr, null, copts);
        expr = null;
      }
      assert(obj instanceof Array, `'${operator}' target must be an array.`);
      return callAccumulator(
        obj,
        expr,
        // reset the root object for accumulators.
        copts.update(null, copts.local)
      );
    }
    throw new MingoError(`operator '${operator}' is not registered`);
  }
  if (isString(expr) && expr.length > 0 && expr[0] === "$") {
    if (has(redactVariables, expr)) {
      return expr;
    }
    let context2 = copts.root;
    const arr = expr.split(".");
    if (has(systemVariables, arr[0])) {
      context2 = systemVariables[arr[0]](
        obj,
        null,
        copts
      );
      expr = expr.slice(arr[0].length + 1);
    } else if (arr[0].slice(0, 2) === "$$") {
      context2 = Object.assign(
        {},
        copts.variables,
        // global vars
        // current item is added before local variables because the binding may be changed.
        { this: obj },
        copts.local?.variables
        // local vars
      );
      const prefix = arr[0].slice(2);
      assert(
        has(context2, prefix),
        `Use of undefined variable: ${prefix}`
      );
      expr = expr.slice(2);
    } else {
      expr = expr.slice(1);
    }
    if (expr === "")
      return context2;
    return resolve(context2, expr);
  }
  if (isArray2(expr)) {
    return expr.map((item) => computeValue(obj, item, null, copts));
  } else if (isObject3(expr)) {
    const result = {};
    for (const [key, val] of Object.entries(expr)) {
      result[key] = computeValue(obj, val, key, copts);
      if ([
        "expression",
        "accumulator"
        /* ACCUMULATOR */
      ].some(
        (t) => !!getOperator(t, key, options)
      )) {
        assert(
          Object.keys(expr).length === 1,
          "Invalid aggregation expression '" + JSON.stringify(expr) + "'"
        );
        return result[key];
      }
    }
    return result;
  }
  return expr;
}
function redact(obj, expr, options) {
  const result = computeValue(obj, expr, null, options);
  return has(redactVariables, result) ? redactVariables[result](obj, expr, options) : result;
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/lazy.js
function Lazy(source2) {
  return source2 instanceof Iterator2 ? source2 : new Iterator2(source2);
}
function compose(...iterators) {
  let index2 = 0;
  return Lazy(() => {
    while (index2 < iterators.length) {
      const o = iterators[index2].next();
      if (!o.done)
        return o;
      index2++;
    }
    return { done: true };
  });
}
function isGenerator(o) {
  return !!o && typeof o === "object" && o?.next instanceof Function;
}
function dropItem(array, i2) {
  const rest = array.slice(i2 + 1);
  array.splice(i2);
  Array.prototype.push.apply(array, rest);
}
var DONE = new Error();
function createCallback(nextFn, iteratees, buffer) {
  let done = false;
  let index2 = -1;
  let bufferIndex = 0;
  return function(storeResult) {
    try {
      outer:
        while (!done) {
          let o = nextFn();
          index2++;
          let i2 = -1;
          const size = iteratees.length;
          let innerDone = false;
          while (++i2 < size) {
            const r = iteratees[i2];
            switch (r.action) {
              case 0:
                o = r.func(o, index2);
                break;
              case 1:
                if (!r.func(o, index2))
                  continue outer;
                break;
              case 2:
                --r.count;
                if (!r.count)
                  innerDone = true;
                break;
              case 3:
                --r.count;
                if (!r.count)
                  dropItem(iteratees, i2);
                continue outer;
              default:
                break outer;
            }
          }
          done = innerDone;
          if (storeResult) {
            buffer[bufferIndex++] = o;
          } else {
            return { value: o, done: false };
          }
        }
    } catch (e) {
      if (e !== DONE)
        throw e;
    }
    done = true;
    return { done };
  };
}
var Iterator2 = class {
  /**
   * @param {*} source An iterable object or function.
   *    Array - return one element per cycle
   *    Object{next:Function} - call next() for the next value (this also handles generator functions)
   *    Function - call to return the next value
   * @param {Function} fn An optional transformation function
   */
  constructor(source2) {
    this.iteratees = [];
    this.yieldedValues = [];
    this.isDone = false;
    let nextVal;
    if (source2 instanceof Function) {
      source2 = { next: source2 };
    }
    if (isGenerator(source2)) {
      const src = source2;
      nextVal = () => {
        const o = src.next();
        if (o.done)
          throw DONE;
        return o.value;
      };
    } else if (source2 instanceof Array) {
      const data = source2;
      const size = data.length;
      let index2 = 0;
      nextVal = () => {
        if (index2 < size)
          return data[index2++];
        throw DONE;
      };
    } else if (!(source2 instanceof Function)) {
      throw new MingoError(
        `Lazy must be initialized with an array, generator, or function.`
      );
    }
    this.getNext = createCallback(nextVal, this.iteratees, this.yieldedValues);
  }
  /**
   * Add an iteratee to this lazy sequence
   */
  push(action2, value) {
    if (typeof value === "function") {
      this.iteratees.push({ action: action2, func: value });
    } else if (typeof value === "number") {
      this.iteratees.push({ action: action2, count: value });
    }
    return this;
  }
  next() {
    return this.getNext();
  }
  // Iteratees methods
  /**
   * Transform each item in the sequence to a new value
   * @param {Function} f
   */
  map(f) {
    return this.push(0, f);
  }
  /**
   * Select only items matching the given predicate
   * @param {Function} pred
   */
  filter(predicate) {
    return this.push(1, predicate);
  }
  /**
   * Take given numbe for values from sequence
   * @param {Number} n A number greater than 0
   */
  take(n2) {
    return n2 > 0 ? this.push(2, n2) : this;
  }
  /**
   * Drop a number of values from the sequence
   * @param {Number} n Number of items to drop greater than 0
   */
  drop(n2) {
    return n2 > 0 ? this.push(3, n2) : this;
  }
  // Transformations
  /**
   * Returns a new lazy object with results of the transformation
   * The entire sequence is realized.
   *
   * @param {Callback<Source, RawArray>} fn Tranform function of type (Array) => (Any)
   */
  transform(fn) {
    const self3 = this;
    let iter;
    return Lazy(() => {
      if (!iter) {
        iter = Lazy(fn(self3.value()));
      }
      return iter.next();
    });
  }
  // Terminal methods
  /**
   * Returns the fully realized values of the iterators.
   * The return value will be an array unless `lazy.first()` was used.
   * The realized values are cached for subsequent calls.
   */
  value() {
    if (!this.isDone) {
      this.isDone = this.getNext(true).done;
    }
    return this.yieldedValues;
  }
  /**
   * Execute the funcion for each value. Will stop when an execution returns false.
   * @param {Function} f
   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true
   */
  each(f) {
    for (; ; ) {
      const o = this.next();
      if (o.done)
        break;
      if (f(o.value) === false)
        return false;
    }
    return true;
  }
  /**
   * Returns the reduction of sequence according the reducing function
   *
   * @param {*} f a reducing function
   * @param {*} initialValue
   */
  reduce(f, initialValue) {
    let o = this.next();
    if (initialValue === void 0 && !o.done) {
      initialValue = o.value;
      o = this.next();
    }
    while (!o.done) {
      initialValue = f(initialValue, o.value);
      o = this.next();
    }
    return initialValue;
  }
  /**
   * Returns the number of matched items in the sequence
   */
  size() {
    return this.reduce(
      (acc, _) => ++acc,
      0
    );
  }
  [Symbol.iterator]() {
    return this;
  }
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/aggregator.js
var Aggregator = class {
  constructor(pipeline, options) {
    this.pipeline = pipeline;
    this.options = initOptions(options);
  }
  /**
   * Returns an `Lazy` iterator for processing results of pipeline
   *
   * @param {*} collection An array or iterator object
   * @returns {Iterator} an iterator object
   */
  stream(collection) {
    let iterator2 = Lazy(collection);
    const mode = this.options.processingMode;
    if (mode == ProcessingMode.CLONE_ALL || mode == ProcessingMode.CLONE_INPUT) {
      iterator2.map(cloneDeep);
    }
    const pipelineOperators = new Array();
    if (!isEmpty(this.pipeline)) {
      for (const operator of this.pipeline) {
        const operatorKeys = Object.keys(operator);
        const opName = operatorKeys[0];
        const call = getOperator(
          OperatorType.PIPELINE,
          opName,
          this.options
        );
        assert(
          operatorKeys.length === 1 && !!call,
          `invalid pipeline operator ${opName}`
        );
        pipelineOperators.push(opName);
        iterator2 = call(iterator2, operator[opName], this.options);
      }
    }
    if (mode == ProcessingMode.CLONE_OUTPUT || mode == ProcessingMode.CLONE_ALL && !!intersection([["$group", "$unwind"], pipelineOperators]).length) {
      iterator2.map(cloneDeep);
    }
    return iterator2;
  }
  /**
   * Return the results of the aggregation as an array.
   *
   * @param {*} collection
   * @param {*} query
   */
  run(collection) {
    return this.stream(collection).value();
  }
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/cursor.js
var Cursor = class {
  constructor(source2, predicate, projection, options) {
    this.source = source2;
    this.predicate = predicate;
    this.projection = projection;
    this.options = options;
    this.operators = [];
    this.result = null;
    this.buffer = [];
  }
  /** Returns the iterator from running the query */
  fetch() {
    if (this.result)
      return this.result;
    if (isObject3(this.projection)) {
      this.operators.push({ $project: this.projection });
    }
    this.result = Lazy(this.source).filter(this.predicate);
    if (this.operators.length > 0) {
      this.result = new Aggregator(this.operators, this.options).stream(
        this.result
      );
    }
    return this.result;
  }
  /** Returns an iterator with the buffered data included */
  fetchAll() {
    const buffered = Lazy([...this.buffer]);
    this.buffer = [];
    return compose(buffered, this.fetch());
  }
  /**
   * Return remaining objects in the cursor as an array. This method exhausts the cursor
   * @returns {Array}
   */
  all() {
    return this.fetchAll().value();
  }
  /**
   * Returns the number of objects return in the cursor. This method exhausts the cursor
   * @returns {Number}
   */
  count() {
    return this.all().length;
  }
  /**
   * Returns a cursor that begins returning results only after passing or skipping a number of documents.
   * @param {Number} n the number of results to skip.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  skip(n2) {
    this.operators.push({ $skip: n2 });
    return this;
  }
  /**
   * Constrains the size of a cursor's result set.
   * @param {Number} n the number of results to limit to.
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  limit(n2) {
    this.operators.push({ $limit: n2 });
    return this;
  }
  /**
   * Returns results ordered according to a sort specification.
   * @param {Object} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending
   * @return {Cursor} Returns the cursor, so you can chain this call.
   */
  sort(modifier) {
    this.operators.push({ $sort: modifier });
    return this;
  }
  /**
   * Specifies the collation for the cursor returned by the `mingo.Query.find`
   * @param {*} spec
   */
  collation(spec) {
    this.options = { ...this.options, collation: spec };
    return this;
  }
  /**
   * Returns the next document in a cursor.
   * @returns {Object | Boolean}
   */
  next() {
    if (this.buffer.length > 0) {
      return this.buffer.pop();
    }
    const o = this.fetch().next();
    if (o.done)
      return;
    return o.value;
  }
  /**
   * Returns true if the cursor has documents and can be iterated.
   * @returns {boolean}
   */
  hasNext() {
    if (this.buffer.length > 0)
      return true;
    const o = this.fetch().next();
    if (o.done)
      return false;
    this.buffer.push(o.value);
    return true;
  }
  /**
   * Applies a function to each document in a cursor and collects the return values in an array.
   * @param fn
   * @returns {Array}
   */
  map(fn) {
    return this.all().map(fn);
  }
  /**
   * Applies a JavaScript function for every document in a cursor.
   * @param fn
   */
  forEach(fn) {
    this.all().forEach(fn);
  }
  [Symbol.iterator]() {
    return this.fetchAll();
  }
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/query.js
var Query = class {
  constructor(condition, options) {
    this.condition = condition;
    this.options = initOptions(options);
    this.compiled = [];
    this.compile();
  }
  compile() {
    assert(
      isObject3(this.condition),
      `query criteria must be an object: ${JSON.stringify(this.condition)}`
    );
    const whereOperator = {};
    for (const [field, expr] of Object.entries(this.condition)) {
      if ("$where" === field) {
        Object.assign(whereOperator, { field, expr });
      } else if (inArray(["$and", "$or", "$nor", "$expr", "$jsonSchema"], field)) {
        this.processOperator(field, field, expr);
      } else {
        assert(!isOperator(field), `unknown top level operator: ${field}`);
        for (const [operator, val] of Object.entries(
          normalize(expr)
        )) {
          this.processOperator(field, operator, val);
        }
      }
      if (whereOperator.field) {
        this.processOperator(
          whereOperator.field,
          whereOperator.field,
          whereOperator.expr
        );
      }
    }
  }
  processOperator(field, operator, value) {
    const call = getOperator(
      OperatorType.QUERY,
      operator,
      this.options
    );
    if (!call) {
      throw new MingoError(`unknown query operator ${operator}`);
    }
    const fn = call(field, value, this.options);
    this.compiled.push(fn);
  }
  /**
   * Checks if the object passes the query criteria. Returns true if so, false otherwise.
   *
   * @param obj The object to test
   * @returns {boolean} True or false
   */
  test(obj) {
    for (let i2 = 0, len = this.compiled.length; i2 < len; i2++) {
      if (!this.compiled[i2](obj)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a cursor to select matching documents from the input source.
   *
   * @param source A source providing a sequence of documents
   * @param projection An optional projection criteria
   * @returns {Cursor} A Cursor for iterating over the results
   */
  find(collection, projection) {
    return new Cursor(
      collection,
      (x2) => this.test(x2),
      projection || {},
      this.options
    );
  }
  /**
   * Remove matched documents from the collection returning the remainder
   *
   * @param collection An array of documents
   * @returns {Array} A new array with matching elements removed
   */
  remove(collection) {
    return collection.reduce((acc, obj) => {
      if (!this.test(obj))
        acc.push(obj);
      return acc;
    }, []);
  }
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/date/_internal.js
var MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;
var DURATION_IN_MILLIS = {
  week: MILLIS_PER_DAY * 7,
  day: MILLIS_PER_DAY,
  hour: 1e3 * 60 * 60,
  minute: 1e3 * 60,
  second: 1e3,
  millisecond: 1
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/window/_internal.js
var MILLIS_PER_UNIT = {
  week: MILLIS_PER_DAY * 7,
  day: MILLIS_PER_DAY,
  hour: MILLIS_PER_DAY / 24,
  minute: 6e4,
  second: 1e3,
  millisecond: 1
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/pipeline/sort.js
var $sort = (collection, sortKeys, options) => {
  if (isEmpty(sortKeys) || !isObject3(sortKeys))
    return collection;
  let cmp2 = compare;
  const collationSpec = options.collation;
  if (isObject3(collationSpec) && isString(collationSpec.locale)) {
    cmp2 = collationComparator(collationSpec);
  }
  return collection.transform((coll) => {
    const modifiers = Object.keys(sortKeys);
    for (const key of modifiers.reverse()) {
      const groups = groupBy(
        coll,
        (obj) => resolve(obj, key),
        options.hashFunction
      );
      const sortedKeys = Array.from(groups.keys()).sort(cmp2);
      if (sortKeys[key] === -1)
        sortedKeys.reverse();
      coll = [];
      sortedKeys.reduce(
        (acc, key2) => into(acc, groups.get(key2)),
        coll
      );
    }
    return coll;
  });
};
var COLLATION_STRENGTH = {
  // Only strings that differ in base letters compare as unequal. Examples: a ≠ b, a = á, a = A.
  1: "base",
  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.
  // Examples: a ≠ b, a ≠ á, a = A.
  2: "accent",
  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.
  // Other differences may also be taken into consideration. Examples: a ≠ b, a ≠ á, a ≠ A
  3: "variant"
  // case - Only strings that differ in base letters or case compare as unequal. Examples: a ≠ b, a = á, a ≠ A.
};
function collationComparator(spec) {
  const localeOpt = {
    sensitivity: COLLATION_STRENGTH[spec.strength || 3],
    caseFirst: spec.caseFirst === "off" ? "false" : spec.caseFirst || "false",
    numeric: spec.numericOrdering || false,
    ignorePunctuation: spec.alternate === "shifted"
  };
  if ((spec.caseLevel || false) === true) {
    if (localeOpt.sensitivity === "base")
      localeOpt.sensitivity = "case";
    if (localeOpt.sensitivity === "accent")
      localeOpt.sensitivity = "variant";
  }
  const collator = new Intl.Collator(spec.locale, localeOpt);
  return (a2, b) => {
    if (!isString(a2) || !isString(b))
      return compare(a2, b);
    const i2 = collator.compare(a2, b);
    if (i2 < 0)
      return -1;
    if (i2 > 0)
      return 1;
    return 0;
  };
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/_predicates.js
function createQueryOperator(predicate) {
  const f = (selector, value, options) => {
    const opts = { unwrapArray: true };
    const depth = Math.max(1, selector.split(".").length - 1);
    return (obj) => {
      const lhs = resolve(obj, selector, opts);
      return predicate(lhs, value, { ...options, depth });
    };
  };
  f.op = "query";
  return f;
}
function createExpressionOperator(predicate) {
  return (obj, expr, options) => {
    const args = computeValue(obj, expr, null, options);
    return predicate(...args);
  };
}
function $eq(a2, b, options) {
  if (isEqual(a2, b))
    return true;
  if (isNil(a2) && isNil(b))
    return true;
  if (a2 instanceof Array) {
    const eq = isEqual.bind(null, b);
    return a2.some(eq) || flatten(a2, options?.depth).some(eq);
  }
  return false;
}
function $ne(a2, b, options) {
  return !$eq(a2, b, options);
}
function $in(a2, b, options) {
  if (isNil(a2))
    return b.some((v) => v === null);
  return intersection([ensureArray(a2), b], options?.hashFunction).length > 0;
}
function $nin(a2, b, options) {
  return !$in(a2, b, options);
}
function $lt(a2, b, _options) {
  return compare2(a2, b, (x2, y2) => compare(x2, y2) < 0);
}
function $lte(a2, b, _options) {
  return compare2(a2, b, (x2, y2) => compare(x2, y2) <= 0);
}
function $gt(a2, b, _options) {
  return compare2(a2, b, (x2, y2) => compare(x2, y2) > 0);
}
function $gte(a2, b, _options) {
  return compare2(a2, b, (x2, y2) => compare(x2, y2) >= 0);
}
function $mod(a2, b, _options) {
  return ensureArray(a2).some(
    (x2) => b.length === 2 && x2 % b[0] === b[1]
  );
}
function $regex(a2, b, options) {
  const lhs = ensureArray(a2);
  const match = (x2) => isString(x2) && truthy(b.exec(x2), options?.useStrictMode);
  return lhs.some(match) || flatten(lhs, 1).some(match);
}
function $exists(a2, b, _options) {
  return (b === false || b === 0) && a2 === void 0 || (b === true || b === 1) && a2 !== void 0;
}
function $all(values, queries, options) {
  if (!isArray2(values) || !isArray2(queries) || !values.length || !queries.length) {
    return false;
  }
  let matched = true;
  for (const query of queries) {
    if (!matched)
      break;
    if (isObject3(query) && inArray(Object.keys(query), "$elemMatch")) {
      matched = $elemMatch(values, query["$elemMatch"], options);
    } else if (query instanceof RegExp) {
      matched = values.some((s) => typeof s === "string" && query.test(s));
    } else {
      matched = values.some((v) => isEqual(query, v));
    }
  }
  return matched;
}
function $size(a2, b, _options) {
  return Array.isArray(a2) && a2.length === b;
}
function isNonBooleanOperator(name) {
  return isOperator(name) && ["$and", "$or", "$nor"].indexOf(name) === -1;
}
function $elemMatch(a2, b, options) {
  if (isArray2(a2) && !isEmpty(a2)) {
    let format = (x2) => x2;
    let criteria = b;
    if (Object.keys(b).every(isNonBooleanOperator)) {
      criteria = { temp: b };
      format = (x2) => ({ temp: x2 });
    }
    const query = new Query(criteria, options);
    for (let i2 = 0, len = a2.length; i2 < len; i2++) {
      if (query.test(format(a2[i2]))) {
        return true;
      }
    }
  }
  return false;
}
var isNull = (a2) => a2 === null;
var isInt = (a2) => isNumber(a2) && a2 >= MIN_INT && a2 <= MAX_INT && a2.toString().indexOf(".") === -1;
var isLong = (a2) => isNumber(a2) && a2 >= MIN_LONG && a2 <= MAX_LONG && a2.toString().indexOf(".") === -1;
var compareFuncs = {
  array: isArray2,
  bool: isBoolean,
  boolean: isBoolean,
  date: isDate,
  decimal: isNumber,
  double: isNumber,
  int: isInt,
  long: isLong,
  number: isNumber,
  null: isNull,
  object: isObject3,
  regex: isRegExp,
  regexp: isRegExp,
  string: isString,
  // added for completeness
  undefined: isNil,
  // deprecated
  function: (_) => {
    throw new MingoError("unsupported type key `function`.");
  },
  // Mongo identifiers
  1: isNumber,
  //double
  2: isString,
  3: isObject3,
  4: isArray2,
  6: isNil,
  // deprecated
  8: isBoolean,
  9: isDate,
  10: isNull,
  11: isRegExp,
  16: isInt,
  18: isLong,
  19: isNumber
  //decimal
};
function compareType(a2, b, _) {
  const f = compareFuncs[b];
  return f ? f(a2) : false;
}
function $type(a2, b, options) {
  return Array.isArray(b) ? b.findIndex((t) => compareType(a2, t, options)) >= 0 : compareType(a2, b, options);
}
function compare2(a2, b, f) {
  return ensureArray(a2).some((x2) => getType(x2) === getType(b) && f(x2, b));
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/array/nin.js
var $nin2 = createExpressionOperator($nin);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js
var bitwise = (op, compute) => (obj, expr, options) => {
  assert(isArray2(expr), `${op}: expression must be an array.`);
  const nums = computeValue(obj, expr, null, options);
  if (nums.some(isNil))
    return null;
  assert(
    nums.every(isNumber),
    `${op}: expression must evalue to array of numbers.`
  );
  return compute(nums);
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js
var $bitAnd = bitwise(
  "$bitAnd",
  (nums) => nums.reduce((a2, b) => a2 & b, -1)
);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js
var $bitOr = bitwise(
  "$bitOr",
  (nums) => nums.reduce((a2, b) => a2 | b, 0)
);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js
var $bitXor = bitwise(
  "$bitXor",
  (nums) => nums.reduce((a2, b) => a2 ^ b, 0)
);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/eq.js
var $eq2 = createExpressionOperator($eq);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/gt.js
var $gt2 = createExpressionOperator($gt);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/gte.js
var $gte2 = createExpressionOperator($gte);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/lt.js
var $lt2 = createExpressionOperator($lt);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/lte.js
var $lte2 = createExpressionOperator($lte);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/comparison/ne.js
var $ne2 = createExpressionOperator($ne);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js
var buildMap = (letters, sign) => {
  const h2 = {};
  letters.split("").forEach((v, i2) => h2[v] = sign * (i2 + 1));
  return h2;
};
var TZ_LETTER_OFFSETS = {
  ...buildMap("ABCDEFGHIKLM", 1),
  ...buildMap("NOPQRSTUVWXY", -1),
  Z: 0
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js
var FIXED_POINTS = {
  undefined: null,
  null: null,
  NaN: NaN,
  Infinity: new Error(),
  "-Infinity": new Error()
};
function createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {
  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);
  const keySet = new Set(Object.keys(fp));
  return (obj, expr, options) => {
    const n2 = computeValue(obj, expr, null, options);
    if (keySet.has(`${n2}`)) {
      const res = fp[`${n2}`];
      if (res instanceof Error) {
        throw new MingoError(
          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`
        );
      }
      return res;
    }
    return f(n2);
  };
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js
var $acos = createTrignometryOperator(Math.acos, {
  Infinity: Infinity,
  0: new Error()
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js
var $acosh = createTrignometryOperator(Math.acosh, {
  Infinity: Infinity,
  0: new Error()
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js
var $asin = createTrignometryOperator(Math.asin);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js
var $asinh = createTrignometryOperator(Math.asinh, {
  Infinity: Infinity,
  "-Infinity": -Infinity
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js
var $atan = createTrignometryOperator(Math.atan);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js
var $atanh = createTrignometryOperator(Math.atanh, {
  1: Infinity,
  "-1": -Infinity
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js
var $cos = createTrignometryOperator(Math.cos);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js
var $cosh = createTrignometryOperator(Math.cosh, {
  "-Infinity": Infinity,
  Infinity: Infinity
  // [Math.PI]: -1,
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js
var RADIANS_FACTOR = Math.PI / 180;
var $degreesToRadians = createTrignometryOperator(
  (n2) => n2 * RADIANS_FACTOR,
  {
    Infinity: Infinity,
    "-Infinity": Infinity
  }
);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js
var DEGREES_FACTOR = 180 / Math.PI;
var $radiansToDegrees = createTrignometryOperator(
  (n2) => n2 * DEGREES_FACTOR,
  {
    Infinity: Infinity,
    "-Infinity": -Infinity
  }
);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js
var $sin = createTrignometryOperator(Math.sin);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js
var $sinh = createTrignometryOperator(Math.sinh, {
  "-Infinity": -Infinity,
  Infinity: Infinity
});

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js
var $tan = createTrignometryOperator(Math.tan);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/pipeline/project.js
var $project = (collection, expr, options) => {
  if (isEmpty(expr))
    return collection;
  let expressionKeys = Object.keys(expr);
  let idOnlyExcluded = false;
  validateExpression(expr, options);
  const ID_KEY = options.idKey;
  if (inArray(expressionKeys, ID_KEY)) {
    const id = expr[ID_KEY];
    if (id === 0 || id === false) {
      expressionKeys = expressionKeys.filter(
        notInArray.bind(null, [ID_KEY])
      );
      idOnlyExcluded = expressionKeys.length == 0;
    }
  } else {
    expressionKeys.push(ID_KEY);
  }
  const copts = ComputeOptions.init(options);
  return collection.map((obj) => processObject(
    obj,
    expr,
    copts.update(obj),
    expressionKeys,
    idOnlyExcluded
  ));
};
function processObject(obj, expr, options, expressionKeys, idOnlyExcluded) {
  let newObj = {};
  let foundSlice = false;
  let foundExclusion = false;
  const dropKeys = [];
  if (idOnlyExcluded) {
    dropKeys.push(options.idKey);
  }
  for (const key of expressionKeys) {
    let value = void 0;
    const subExpr = expr[key];
    if (key !== options.idKey && inArray([0, false], subExpr)) {
      foundExclusion = true;
    }
    if (key === options.idKey && isEmpty(subExpr)) {
      value = obj[key];
    } else if (isString(subExpr)) {
      value = computeValue(obj, subExpr, key, options);
    } else if (inArray([1, true], subExpr)) {
    } else if (subExpr instanceof Array) {
      value = subExpr.map((v) => {
        const r = computeValue(obj, v, null, options);
        if (isNil(r))
          return null;
        return r;
      });
    } else if (isObject3(subExpr)) {
      const subExprObj = subExpr;
      const subExprKeys = Object.keys(subExpr);
      const operator = subExprKeys.length == 1 ? subExprKeys[0] : "";
      const call = getOperator(
        OperatorType.PROJECTION,
        operator,
        options
      );
      if (call) {
        if (operator === "$slice") {
          if (ensureArray(subExprObj[operator]).every(isNumber)) {
            value = call(obj, subExprObj[operator], key, options);
            foundSlice = true;
          } else {
            value = computeValue(obj, subExprObj, key, options);
          }
        } else {
          value = call(obj, subExprObj[operator], key, options);
        }
      } else if (isOperator(operator)) {
        value = computeValue(obj, subExprObj[operator], operator, options);
      } else if (has(obj, key)) {
        validateExpression(subExprObj, options);
        let target = obj[key];
        if (target instanceof Array) {
          value = target.map(
            (o) => processObject(o, subExprObj, options, subExprKeys, false)
          );
        } else {
          target = isObject3(target) ? target : obj;
          value = processObject(
            target,
            subExprObj,
            options,
            subExprKeys,
            false
          );
        }
      } else {
        value = computeValue(obj, subExpr, null, options);
      }
    } else {
      dropKeys.push(key);
      continue;
    }
    const objPathGraph = resolveGraph(obj, key, {
      preserveMissing: true
    });
    if (objPathGraph !== void 0) {
      merge3(newObj, objPathGraph, {
        flatten: true
      });
    }
    if (notInArray([0, 1, false, true], subExpr)) {
      if (value === void 0) {
        removeValue(newObj, key, { descendArray: true });
      } else {
        setValue(newObj, key, value);
      }
    }
  }
  filterMissing(newObj);
  if (foundSlice || foundExclusion || idOnlyExcluded) {
    newObj = into({}, obj, newObj);
    if (dropKeys.length > 0) {
      for (const k of dropKeys) {
        removeValue(newObj, k, { descendArray: true });
      }
    }
  }
  return newObj;
}
function validateExpression(expr, options) {
  const check = [false, false];
  for (const [k, v] of Object.entries(expr)) {
    if (k === options?.idKey)
      return;
    if (v === 0 || v === false) {
      check[0] = true;
    } else if (v === 1 || v === true) {
      check[1] = true;
    }
    assert(
      !(check[0] && check[1]),
      "Projection cannot have a mix of inclusion and exclusion."
    );
  }
}

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/and.js
var $and = (_, rhs, options) => {
  assert(
    isArray2(rhs),
    "Invalid expression: $and expects value to be an Array."
  );
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.every((q) => q.test(obj));
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/or.js
var $or = (_, rhs, options) => {
  assert(isArray2(rhs), "Invalid expression. $or expects value to be an Array");
  const queries = rhs.map((expr) => new Query(expr, options));
  return (obj) => queries.some((q) => q.test(obj));
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/nor.js
var $nor = (_, rhs, options) => {
  assert(
    isArray2(rhs),
    "Invalid expression. $nor expects value to be an array."
  );
  const f = $or("$or", rhs, options);
  return (obj) => !f(obj);
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/logical/not.js
var $not = (selector, rhs, options) => {
  const criteria = {};
  criteria[selector] = normalize(rhs);
  const query = new Query(criteria, options);
  return (obj) => !query.test(obj);
};

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/eq.js
var $eq3 = createQueryOperator($eq);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/gt.js
var $gt3 = createQueryOperator($gt);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/gte.js
var $gte3 = createQueryOperator($gte);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/in.js
var $in2 = createQueryOperator($in);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/lt.js
var $lt3 = createQueryOperator($lt);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/lte.js
var $lte3 = createQueryOperator($lte);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/ne.js
var $ne3 = createQueryOperator($ne);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/comparison/nin.js
var $nin3 = createQueryOperator($nin);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/mod.js
var $mod2 = createQueryOperator($mod);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/evaluation/regex.js
var $regex2 = createQueryOperator($regex);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/all.js
var $all2 = createQueryOperator($all);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/elemMatch.js
var $elemMatch2 = createQueryOperator($elemMatch);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/array/size.js
var $size2 = createQueryOperator($size);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/element/exists.js
var $exists2 = createQueryOperator($exists);

// node_modules/.pnpm/mingo@6.4.15/node_modules/mingo/dist/esm/operators/query/element/type.js
var $type2 = createQueryOperator($type);

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-query-mingo.js
var mingoInitDone = false;
function getMingoQuery(selector) {
  if (!mingoInitDone) {
    useOperators(OperatorType.PIPELINE, {
      $sort,
      $project
    });
    useOperators(OperatorType.QUERY, {
      $and,
      $eq: $eq3,
      $elemMatch: $elemMatch2,
      $exists: $exists2,
      $gt: $gt3,
      $gte: $gte3,
      $in: $in2,
      $lt: $lt3,
      $lte: $lte3,
      $ne: $ne3,
      $nin: $nin3,
      $mod: $mod2,
      $nor,
      $not,
      $or,
      $regex: $regex2,
      $size: $size2,
      $type: $type2
    });
    mingoInitDone = true;
  }
  return new Query(selector);
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-query-helper.js
function normalizeMangoQuery(schema, mangoQuery) {
  var primaryKey = getPrimaryFieldOfPrimaryKey(schema.primaryKey);
  mangoQuery = flatClone(mangoQuery);
  var normalizedMangoQuery = clone(mangoQuery);
  if (typeof normalizedMangoQuery.skip !== "number") {
    normalizedMangoQuery.skip = 0;
  }
  if (!normalizedMangoQuery.selector) {
    normalizedMangoQuery.selector = {};
  } else {
    normalizedMangoQuery.selector = normalizedMangoQuery.selector;
    Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
      if (typeof matcher !== "object" || matcher === null) {
        normalizedMangoQuery.selector[field] = {
          $eq: matcher
        };
      }
    });
  }
  if (normalizedMangoQuery.index) {
    var indexAr = toArray(normalizedMangoQuery.index);
    if (!indexAr.includes(primaryKey)) {
      indexAr.push(primaryKey);
    }
    normalizedMangoQuery.index = indexAr;
  }
  if (!normalizedMangoQuery.sort) {
    if (normalizedMangoQuery.index) {
      normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field) => {
        return {
          [field]: "asc"
        };
      });
    } else {
      if (schema.indexes) {
        var fieldsWithLogicalOperator = /* @__PURE__ */ new Set();
        Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {
          var hasLogical = false;
          if (typeof matcher === "object" && matcher !== null) {
            hasLogical = !!Object.keys(matcher).find((operator) => LOGICAL_OPERATORS.has(operator));
          } else {
            hasLogical = true;
          }
          if (hasLogical) {
            fieldsWithLogicalOperator.add(field);
          }
        });
        var currentFieldsAmount = -1;
        var currentBestIndexForSort;
        schema.indexes.forEach((index2) => {
          var useIndex = isMaybeReadonlyArray(index2) ? index2 : [index2];
          var firstWrongIndex = useIndex.findIndex((indexField) => !fieldsWithLogicalOperator.has(indexField));
          if (firstWrongIndex > 0 && firstWrongIndex > currentFieldsAmount) {
            currentFieldsAmount = firstWrongIndex;
            currentBestIndexForSort = useIndex;
          }
        });
        if (currentBestIndexForSort) {
          normalizedMangoQuery.sort = currentBestIndexForSort.map((field) => {
            return {
              [field]: "asc"
            };
          });
        }
      }
      if (!normalizedMangoQuery.sort) {
        normalizedMangoQuery.sort = [{
          [primaryKey]: "asc"
        }];
      }
    }
  } else {
    var isPrimaryInSort = normalizedMangoQuery.sort.find((p2) => firstPropertyNameOfObject(p2) === primaryKey);
    if (!isPrimaryInSort) {
      normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);
      normalizedMangoQuery.sort.push({
        [primaryKey]: "asc"
      });
    }
  }
  return normalizedMangoQuery;
}
function getSortComparator(schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var sortParts = [];
  query.sort.forEach((sortBlock) => {
    var key = Object.keys(sortBlock)[0];
    var direction = Object.values(sortBlock)[0];
    sortParts.push({
      key,
      direction,
      getValueFn: objectPathMonad(key)
    });
  });
  var fun = (a2, b) => {
    for (var i2 = 0; i2 < sortParts.length; ++i2) {
      var sortPart = sortParts[i2];
      var valueA = sortPart.getValueFn(a2);
      var valueB = sortPart.getValueFn(b);
      if (valueA !== valueB) {
        var ret = sortPart.direction === "asc" ? compare(valueA, valueB) : compare(valueB, valueA);
        return ret;
      }
    }
  };
  return fun;
}
function getQueryMatcher(_schema, query) {
  if (!query.sort) {
    throw newRxError("SNH", {
      query
    });
  }
  var mingoQuery = getMingoQuery(query.selector);
  var fun = (doc) => {
    return mingoQuery.test(doc);
  };
  return fun;
}
async function runQueryUpdateFunction(rxQuery, fn) {
  var docs = await rxQuery.exec();
  if (!docs) {
    return null;
  }
  if (Array.isArray(docs)) {
    return Promise.all(docs.map((doc) => fn(doc)));
  } else {
    var result = await fn(docs);
    return result;
  }
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/event-reduce.js
function getSortFieldsOfQuery(primaryKey, query) {
  if (!query.sort || query.sort.length === 0) {
    return [primaryKey];
  } else {
    return query.sort.map((part) => Object.keys(part)[0]);
  }
}
var RXQUERY_QUERY_PARAMS_CACHE = /* @__PURE__ */ new WeakMap();
function getQueryParams(rxQuery) {
  return getFromMapOrCreate(RXQUERY_QUERY_PARAMS_CACHE, rxQuery, () => {
    var collection = rxQuery.collection;
    var normalizedMangoQuery = normalizeMangoQuery(collection.storageInstance.schema, clone(rxQuery.mangoQuery));
    var primaryKey = collection.schema.primaryPath;
    var sortComparator = getSortComparator(collection.schema.jsonSchema, normalizedMangoQuery);
    var useSortComparator = (docA, docB) => {
      var sortComparatorData = {
        docA,
        docB,
        rxQuery
      };
      return sortComparator(sortComparatorData.docA, sortComparatorData.docB);
    };
    var queryMatcher = getQueryMatcher(collection.schema.jsonSchema, normalizedMangoQuery);
    var useQueryMatcher = (doc) => {
      var queryMatcherData = {
        doc,
        rxQuery
      };
      return queryMatcher(queryMatcherData.doc);
    };
    var ret = {
      primaryKey: rxQuery.collection.schema.primaryPath,
      skip: normalizedMangoQuery.skip,
      limit: normalizedMangoQuery.limit,
      sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery),
      sortComparator: useSortComparator,
      queryMatcher: useQueryMatcher
    };
    return ret;
  });
}
function calculateNewResults(rxQuery, rxChangeEvents) {
  if (!rxQuery.collection.database.eventReduce) {
    return {
      runFullQueryAgain: true
    };
  }
  var queryParams = getQueryParams(rxQuery);
  var previousResults = ensureNotFalsy(rxQuery._result).docsData.slice(0);
  var previousResultsMap = ensureNotFalsy(rxQuery._result).docsDataMap;
  var changed = false;
  var eventReduceEvents = rxChangeEvents.map((cE) => rxChangeEventToEventReduceChangeEvent(cE)).filter(arrayFilterNotEmpty);
  var foundNonOptimizeable = eventReduceEvents.find((eventReduceEvent) => {
    var stateResolveFunctionInput = {
      queryParams,
      changeEvent: eventReduceEvent,
      previousResults,
      keyDocumentMap: previousResultsMap
    };
    var actionName = calculateActionName(stateResolveFunctionInput);
    if (actionName === "runFullQueryAgain") {
      return true;
    } else if (actionName !== "doNothing") {
      changed = true;
      runAction(actionName, queryParams, eventReduceEvent, previousResults, previousResultsMap);
      return false;
    }
  });
  if (foundNonOptimizeable) {
    return {
      runFullQueryAgain: true
    };
  } else {
    return {
      runFullQueryAgain: false,
      changed,
      newResults: previousResults
    };
  }
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/query-cache.js
var QueryCache = /* @__PURE__ */ function() {
  function QueryCache2() {
    this._map = /* @__PURE__ */ new Map();
  }
  var _proto = QueryCache2.prototype;
  _proto.getByQuery = function getByQuery(rxQuery) {
    var stringRep = rxQuery.toString();
    return getFromMapOrCreate(this._map, stringRep, () => rxQuery);
  };
  return QueryCache2;
}();
function createQueryCache() {
  return new QueryCache();
}
function uncacheRxQuery(queryCache, rxQuery) {
  rxQuery.uncached = true;
  var stringRep = rxQuery.toString();
  queryCache._map.delete(stringRep);
}
function countRxQuerySubscribers(rxQuery) {
  return rxQuery.refCount$.observers.length;
}
var DEFAULT_TRY_TO_KEEP_MAX = 100;
var DEFAULT_UNEXECUTED_LIFETIME = 30 * 1e3;
var defaultCacheReplacementPolicyMonad = (tryToKeepMax, unExecutedLifetime) => (_collection, queryCache) => {
  if (queryCache._map.size < tryToKeepMax) {
    return;
  }
  var minUnExecutedLifetime = now() - unExecutedLifetime;
  var maybeUncache = [];
  var queriesInCache = Array.from(queryCache._map.values());
  for (var rxQuery of queriesInCache) {
    if (countRxQuerySubscribers(rxQuery) > 0) {
      continue;
    }
    if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {
      uncacheRxQuery(queryCache, rxQuery);
      continue;
    }
    maybeUncache.push(rxQuery);
  }
  var mustUncache = maybeUncache.length - tryToKeepMax;
  if (mustUncache <= 0) {
    return;
  }
  var sortedByLastUsage = maybeUncache.sort((a2, b) => a2._lastEnsureEqual - b._lastEnsureEqual);
  var toRemove = sortedByLastUsage.slice(0, mustUncache);
  toRemove.forEach((rxQuery2) => uncacheRxQuery(queryCache, rxQuery2));
};
var defaultCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(DEFAULT_TRY_TO_KEEP_MAX, DEFAULT_UNEXECUTED_LIFETIME);
var COLLECTIONS_WITH_RUNNING_CLEANUP = /* @__PURE__ */ new WeakSet();
function triggerCacheReplacement(rxCollection) {
  if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {
    return;
  }
  COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);
  nextTick().then(() => requestIdlePromise(200)).then(() => {
    if (!rxCollection.destroyed) {
      rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);
    }
    COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);
  });
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/doc-cache.js
var DocumentCache = /* @__PURE__ */ function() {
  function DocumentCache2(primaryPath, changes$, documentCreator) {
    this.cacheItemByDocId = /* @__PURE__ */ new Map();
    this.tasks = /* @__PURE__ */ new Set();
    this.registry = typeof FinalizationRegistry === "function" ? new FinalizationRegistry((docMeta) => {
      var docId = docMeta.docId;
      var cacheItem = this.cacheItemByDocId.get(docId);
      if (cacheItem) {
        cacheItem[0].delete(docMeta.revisionHeight);
        if (cacheItem[0].size === 0) {
          this.cacheItemByDocId.delete(docId);
        }
      }
    }) : void 0;
    this.primaryPath = primaryPath;
    this.changes$ = changes$;
    this.documentCreator = documentCreator;
    changes$.subscribe((events) => {
      this.tasks.add(() => {
        var cacheItemByDocId = this.cacheItemByDocId;
        for (var index2 = 0; index2 < events.length; index2++) {
          var event2 = events[index2];
          var cacheItem = cacheItemByDocId.get(event2.documentId);
          if (cacheItem) {
            var documentData = event2.documentData;
            if (!documentData) {
              documentData = event2.previousDocumentData;
            }
            cacheItem[1] = documentData;
          }
        }
      });
      if (this.tasks.size <= 1) {
        requestIdlePromiseNoQueue().then(() => {
          this.processTasks();
        });
      }
    });
  }
  var _proto = DocumentCache2.prototype;
  _proto.processTasks = function processTasks() {
    if (this.tasks.size === 0) {
      return;
    }
    var tasks = Array.from(this.tasks);
    tasks.forEach((task) => task());
    this.tasks.clear();
  };
  _proto.getLatestDocumentData = function getLatestDocumentData(docId) {
    this.processTasks();
    var cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);
    return cacheItem[1];
  };
  _proto.getLatestDocumentDataIfExists = function getLatestDocumentDataIfExists(docId) {
    this.processTasks();
    var cacheItem = this.cacheItemByDocId.get(docId);
    if (cacheItem) {
      return cacheItem[1];
    }
  };
  return _createClass(DocumentCache2, [{
    key: "getCachedRxDocuments",
    get: function() {
      var fn = getCachedRxDocumentMonad(this);
      return overwriteGetterForCaching(this, "getCachedRxDocuments", fn);
    }
  }, {
    key: "getCachedRxDocument",
    get: function() {
      var fn = getCachedRxDocumentMonad(this);
      return overwriteGetterForCaching(this, "getCachedRxDocument", (doc) => fn([doc])[0]);
    }
  }]);
}();
function getCachedRxDocumentMonad(docCache) {
  var primaryPath = docCache.primaryPath;
  var cacheItemByDocId = docCache.cacheItemByDocId;
  var registry = docCache.registry;
  var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;
  var documentCreator = docCache.documentCreator;
  var fn = (docsData) => {
    var ret = new Array(docsData.length);
    var registryTasks = [];
    for (var index2 = 0; index2 < docsData.length; index2++) {
      var docData = docsData[index2];
      var docId = docData[primaryPath];
      var revisionHeight = getHeightOfRevision(docData._rev);
      var byRev = void 0;
      var cachedRxDocumentWeakRef = void 0;
      var cacheItem = cacheItemByDocId.get(docId);
      if (!cacheItem) {
        byRev = /* @__PURE__ */ new Map();
        cacheItem = [byRev, docData];
        cacheItemByDocId.set(docId, cacheItem);
      } else {
        byRev = cacheItem[0];
        cachedRxDocumentWeakRef = byRev.get(revisionHeight);
      }
      var cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : void 0;
      if (!cachedRxDocument) {
        docData = deepFreezeWhenDevMode(docData);
        cachedRxDocument = documentCreator(docData);
        byRev.set(revisionHeight, createWeakRefWithFallback(cachedRxDocument));
        if (registry) {
          registryTasks.push(cachedRxDocument);
        }
      }
      ret[index2] = cachedRxDocument;
    }
    if (registryTasks.length > 0 && registry) {
      docCache.tasks.add(() => {
        for (var _index = 0; _index < registryTasks.length; _index++) {
          var doc = registryTasks[_index];
          registry.register(doc, {
            docId: doc.primary,
            revisionHeight: getHeightOfRevision(doc.revision)
          });
        }
      });
      if (docCache.tasks.size <= 1) {
        requestIdlePromiseNoQueue().then(() => {
          docCache.processTasks();
        });
      }
    }
    return ret;
  };
  return fn;
}
function mapDocumentsDataToCacheDocs(docCache, docsData) {
  var getCachedRxDocuments = docCache.getCachedRxDocuments;
  return getCachedRxDocuments(docsData);
}
var HAS_WEAK_REF = typeof WeakRef === "function";
var createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;
function createWeakRef(obj) {
  return new WeakRef(obj);
}
function createWeakRefFallback(obj) {
  return {
    deref() {
      return obj;
    }
  };
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-query-single-result.js
var RxQuerySingleResult = /* @__PURE__ */ function() {
  function RxQuerySingleResult2(query, docsDataFromStorageInstance, count) {
    this.time = now();
    this.query = query;
    this.count = count;
    this.documents = mapDocumentsDataToCacheDocs(this.query.collection._docCache, docsDataFromStorageInstance);
  }
  var _proto = RxQuerySingleResult2.prototype;
  _proto.getValue = function getValue2(throwIfMissing) {
    var op = this.query.op;
    if (op === "count") {
      return this.count;
    } else if (op === "findOne") {
      var doc = this.documents.length === 0 ? null : this.documents[0];
      if (!doc && throwIfMissing) {
        throw newRxError("QU10", {
          collection: this.query.collection.name,
          query: this.query.mangoQuery,
          op
        });
      } else {
        return doc;
      }
    } else if (op === "findByIds") {
      return this.docsMap;
    } else {
      return this.documents.slice(0);
    }
  };
  return _createClass(RxQuerySingleResult2, [{
    key: "docsData",
    get: function() {
      return overwriteGetterForCaching(this, "docsData", this.documents.map((d) => d._data));
    }
    // A key->document map, used in the event reduce optimization.
  }, {
    key: "docsDataMap",
    get: function() {
      var map2 = /* @__PURE__ */ new Map();
      this.documents.forEach((d) => {
        map2.set(d.primary, d._data);
      });
      return overwriteGetterForCaching(this, "docsDataMap", map2);
    }
  }, {
    key: "docsMap",
    get: function() {
      var map2 = /* @__PURE__ */ new Map();
      var documents = this.documents;
      for (var i2 = 0; i2 < documents.length; i2++) {
        var doc = documents[i2];
        map2.set(doc.primary, doc);
      }
      return overwriteGetterForCaching(this, "docsMap", map2);
    }
  }]);
}();

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-query.js
var _queryCount = 0;
var newQueryID = function() {
  return ++_queryCount;
};
var RxQueryBase = /* @__PURE__ */ function() {
  function RxQueryBase2(op, mangoQuery, collection, other = {}) {
    this.id = newQueryID();
    this._execOverDatabaseCount = 0;
    this._creationTime = now();
    this._lastEnsureEqual = 0;
    this.uncached = false;
    this.refCount$ = new BehaviorSubject(null);
    this._result = null;
    this._latestChangeEvent = -1;
    this._lastExecStart = 0;
    this._lastExecEnd = 0;
    this._ensureEqualQueue = PROMISE_RESOLVE_FALSE;
    this.op = op;
    this.mangoQuery = mangoQuery;
    this.collection = collection;
    this.other = other;
    if (!mangoQuery) {
      this.mangoQuery = _getDefaultQuery();
    }
    this.isFindOneByIdQuery = isFindOneByIdQuery(this.collection.schema.primaryPath, mangoQuery);
  }
  var _proto = RxQueryBase2.prototype;
  _proto._setResultData = function _setResultData(newResultData) {
    if (typeof newResultData === "undefined") {
      throw newRxError("QU18", {
        database: this.collection.database.name,
        collection: this.collection.name
      });
    }
    if (typeof newResultData === "number") {
      this._result = new RxQuerySingleResult(this, [], newResultData);
      return;
    } else if (newResultData instanceof Map) {
      newResultData = Array.from(newResultData.values());
    }
    var newQueryResult = new RxQuerySingleResult(this, newResultData, newResultData.length);
    this._result = newQueryResult;
  };
  _proto._execOverDatabase = async function _execOverDatabase() {
    this._execOverDatabaseCount = this._execOverDatabaseCount + 1;
    this._lastExecStart = now();
    if (this.op === "count") {
      var preparedQuery = this.getPreparedQuery();
      var result = await this.collection.storageInstance.count(preparedQuery);
      if (result.mode === "slow" && !this.collection.database.allowSlowCount) {
        throw newRxError("QU14", {
          collection: this.collection,
          queryObj: this.mangoQuery
        });
      } else {
        return result.count;
      }
    }
    if (this.op === "findByIds") {
      var ids = ensureNotFalsy(this.mangoQuery.selector)[this.collection.schema.primaryPath].$in;
      var ret = /* @__PURE__ */ new Map();
      var mustBeQueried = [];
      ids.forEach((id) => {
        var docData = this.collection._docCache.getLatestDocumentDataIfExists(id);
        if (docData) {
          if (!docData._deleted) {
            var doc = this.collection._docCache.getCachedRxDocument(docData);
            ret.set(id, doc);
          }
        } else {
          mustBeQueried.push(id);
        }
      });
      if (mustBeQueried.length > 0) {
        var docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);
        docs.forEach((docData) => {
          var doc = this.collection._docCache.getCachedRxDocument(docData);
          ret.set(doc.primary, doc);
        });
      }
      return ret;
    }
    var docsPromise = queryCollection(this);
    return docsPromise.then((docs2) => {
      this._lastExecEnd = now();
      return docs2;
    });
  };
  _proto.exec = async function exec(throwIfMissing) {
    if (throwIfMissing && this.op !== "findOne") {
      throw newRxError("QU9", {
        collection: this.collection.name,
        query: this.mangoQuery,
        op: this.op
      });
    }
    await _ensureEqual(this);
    var useResult = ensureNotFalsy(this._result);
    return useResult.getValue(throwIfMissing);
  };
  _proto.toString = function toString2() {
    var stringObj = sortObject({
      op: this.op,
      query: this.mangoQuery,
      other: this.other
    }, true);
    var value = JSON.stringify(stringObj);
    this.toString = () => value;
    return value;
  };
  _proto.getPreparedQuery = function getPreparedQuery() {
    var hookInput = {
      rxQuery: this,
      // can be mutated by the hooks so we have to deep clone first.
      mangoQuery: normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery)
    };
    hookInput.mangoQuery.selector._deleted = {
      $eq: false
    };
    if (hookInput.mangoQuery.index) {
      hookInput.mangoQuery.index.unshift("_deleted");
    }
    runPluginHooks("prePrepareQuery", hookInput);
    var value = prepareQuery(this.collection.schema.jsonSchema, hookInput.mangoQuery);
    this.getPreparedQuery = () => value;
    return value;
  };
  _proto.doesDocumentDataMatch = function doesDocumentDataMatch(docData) {
    if (docData._deleted) {
      return false;
    }
    return this.queryMatcher(docData);
  };
  _proto.remove = function remove2() {
    return this.exec().then((docs) => {
      if (Array.isArray(docs)) {
        return Promise.all(docs.map((doc) => doc.remove()));
      } else {
        return docs.remove();
      }
    });
  };
  _proto.incrementalRemove = function incrementalRemove() {
    return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.incrementalRemove());
  };
  _proto.update = function update2(_updateObj) {
    throw pluginMissing("update");
  };
  _proto.patch = function patch(_patch) {
    return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.patch(_patch));
  };
  _proto.incrementalPatch = function incrementalPatch(patch) {
    return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.incrementalPatch(patch));
  };
  _proto.modify = function modify(mutationFunction) {
    return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.modify(mutationFunction));
  };
  _proto.incrementalModify = function incrementalModify(mutationFunction) {
    return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.incrementalModify(mutationFunction));
  };
  _proto.where = function where(_queryObj) {
    throw pluginMissing("query-builder");
  };
  _proto.sort = function sort(_params) {
    throw pluginMissing("query-builder");
  };
  _proto.skip = function skip(_amount) {
    throw pluginMissing("query-builder");
  };
  _proto.limit = function limit(_amount) {
    throw pluginMissing("query-builder");
  };
  return _createClass(RxQueryBase2, [{
    key: "$",
    get: function() {
      if (!this._$) {
        var results$ = this.collection.$.pipe(
          /**
           * Performance shortcut.
           * Changes to local documents are not relevant for the query.
           */
          filter((changeEvent) => !changeEvent.isLocal),
          /**
           * Start once to ensure the querying also starts
           * when there where no changes.
           */
          startWith(null),
          // ensure query results are up to date.
          mergeMap(() => _ensureEqual(this)),
          // use the current result set, written by _ensureEqual().
          map(() => this._result),
          // do not run stuff above for each new subscriber, only once.
          shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),
          // do not proceed if result set has not changed.
          distinctUntilChanged((prev, curr) => {
            if (prev && prev.time === ensureNotFalsy(curr).time) {
              return true;
            } else {
              return false;
            }
          }),
          filter((result) => !!result),
          /**
           * Map the result set to a single RxDocument or an array,
           * depending on query type
           */
          map((result) => {
            return ensureNotFalsy(result).getValue();
          })
        );
        this._$ = merge2(
          results$,
          /**
           * Also add the refCount$ to the query observable
           * to allow us to count the amount of subscribers.
           */
          this.refCount$.pipe(filter(() => false))
        );
      }
      return this._$;
    }
  }, {
    key: "$$",
    get: function() {
      var reactivity = this.collection.database.getReactivityFactory();
      return reactivity.fromObservable(this.$, void 0, this.collection.database);
    }
    // stores the changeEvent-number of the last handled change-event
    // time stamps on when the last full exec over the database has run
    // used to properly handle events that happen while the find-query is running
    // TODO do we still need these properties?
    /**
     * ensures that the exec-runs
     * are not run in parallel
     */
  }, {
    key: "queryMatcher",
    get: function() {
      var schema = this.collection.schema.jsonSchema;
      var normalizedQuery = normalizeMangoQuery(this.collection.schema.jsonSchema, this.mangoQuery);
      return overwriteGetterForCaching(this, "queryMatcher", getQueryMatcher(schema, normalizedQuery));
    }
  }, {
    key: "asRxQuery",
    get: function() {
      return this;
    }
  }]);
}();
function _getDefaultQuery() {
  return {
    selector: {}
  };
}
function tunnelQueryCache(rxQuery) {
  return rxQuery.collection._queryCache.getByQuery(rxQuery);
}
function createRxQuery(op, queryObj, collection, other) {
  runPluginHooks("preCreateRxQuery", {
    op,
    queryObj,
    collection,
    other
  });
  var ret = new RxQueryBase(op, queryObj, collection, other);
  ret = tunnelQueryCache(ret);
  triggerCacheReplacement(collection);
  return ret;
}
function _isResultsInSync(rxQuery) {
  var currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();
  if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {
    return true;
  } else {
    return false;
  }
}
async function _ensureEqual(rxQuery) {
  if (rxQuery.collection.awaitBeforeReads.size > 0) {
    await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map((fn) => fn()));
  }
  if (rxQuery.collection.database.destroyed || _isResultsInSync(rxQuery)) {
    return false;
  }
  rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue.then(() => __ensureEqual(rxQuery));
  return rxQuery._ensureEqualQueue;
}
function __ensureEqual(rxQuery) {
  rxQuery._lastEnsureEqual = now();
  if (
    // db is closed
    rxQuery.collection.database.destroyed || // nothing happened since last run
    _isResultsInSync(rxQuery)
  ) {
    return PROMISE_RESOLVE_FALSE;
  }
  var ret = false;
  var mustReExec = false;
  if (rxQuery._latestChangeEvent === -1) {
    mustReExec = true;
  }
  if (!mustReExec) {
    var missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);
    if (missedChangeEvents === null) {
      mustReExec = true;
    } else {
      rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();
      var runChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.reduceByLastOfDoc(missedChangeEvents);
      if (rxQuery.op === "count") {
        var previousCount = ensureNotFalsy(rxQuery._result).count;
        var newCount = previousCount;
        runChangeEvents.forEach((cE) => {
          var didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);
          var doesMatchNow2 = rxQuery.doesDocumentDataMatch(cE.documentData);
          if (!didMatchBefore && doesMatchNow2) {
            newCount++;
          }
          if (didMatchBefore && !doesMatchNow2) {
            newCount--;
          }
        });
        if (newCount !== previousCount) {
          ret = true;
          rxQuery._setResultData(newCount);
        }
      } else {
        var eventReduceResult = calculateNewResults(rxQuery, runChangeEvents);
        if (eventReduceResult.runFullQueryAgain) {
          mustReExec = true;
        } else if (eventReduceResult.changed) {
          ret = true;
          rxQuery._setResultData(eventReduceResult.newResults);
        }
      }
    }
  }
  if (mustReExec) {
    return rxQuery._execOverDatabase().then((newResultData) => {
      rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();
      if (typeof newResultData === "number") {
        if (!rxQuery._result || newResultData !== rxQuery._result.count) {
          ret = true;
          rxQuery._setResultData(newResultData);
        }
        return ret;
      }
      if (!rxQuery._result || !areRxDocumentArraysEqual(rxQuery.collection.schema.primaryPath, newResultData, rxQuery._result.docsData)) {
        ret = true;
        rxQuery._setResultData(newResultData);
      }
      return ret;
    });
  }
  return Promise.resolve(ret);
}
function prepareQuery(schema, mutateableQuery) {
  if (!mutateableQuery.sort) {
    throw newRxError("SNH", {
      query: mutateableQuery
    });
  }
  var queryPlan = getQueryPlan(schema, mutateableQuery);
  return {
    query: mutateableQuery,
    queryPlan
  };
}
async function queryCollection(rxQuery) {
  var docs = [];
  var collection = rxQuery.collection;
  if (rxQuery.isFindOneByIdQuery) {
    if (Array.isArray(rxQuery.isFindOneByIdQuery)) {
      var docIds = rxQuery.isFindOneByIdQuery;
      docIds = docIds.filter((docId2) => {
        var docData2 = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId2);
        if (docData2) {
          if (!docData2._deleted) {
            docs.push(docData2);
          }
          return false;
        } else {
          return true;
        }
      });
      if (docIds.length > 0) {
        var docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);
        appendToArray(docs, docsFromStorage);
      }
    } else {
      var docId = rxQuery.isFindOneByIdQuery;
      var docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);
      if (!docData) {
        var fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);
        if (fromStorageList[0]) {
          docData = fromStorageList[0];
        }
      }
      if (docData && !docData._deleted) {
        docs.push(docData);
      }
    }
  } else {
    var preparedQuery = rxQuery.getPreparedQuery();
    var queryResult = await collection.storageInstance.query(preparedQuery);
    docs = queryResult.documents;
  }
  return docs;
}
function isFindOneByIdQuery(primaryPath, query) {
  if (!query.skip && query.selector && Object.keys(query.selector).length === 1 && query.selector[primaryPath]) {
    var value = query.selector[primaryPath];
    if (typeof value === "string") {
      return value;
    } else if (Object.keys(value).length === 1 && typeof value.$eq === "string") {
      return value.$eq;
    }
    if (Object.keys(value).length === 1 && Array.isArray(value.$eq) && // must only contain strings
    !value.$eq.find((r) => typeof r !== "string")) {
      return value.$eq;
    }
  }
  return false;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-storage-helper.js
var INTERNAL_STORAGE_NAME = "_rxdb_internal";
async function getSingleDocument(storageInstance, documentId) {
  var results = await storageInstance.findDocumentsById([documentId], false);
  var doc = results[0];
  if (doc) {
    return doc;
  } else {
    return void 0;
  }
}
function throwIfIsStorageWriteError(collection, documentId, writeData, error) {
  if (error) {
    if (error.status === 409) {
      throw newRxError("CONFLICT", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else if (error.status === 422) {
      throw newRxError("VD2", {
        collection: collection.name,
        id: documentId,
        writeError: error,
        data: writeData
      });
    } else {
      throw error;
    }
  }
}
function categorizeBulkWriteRows(storageInstance, primaryPath, docsInDb, bulkWriteRows, context2, onInsert, onUpdate) {
  var hasAttachments = !!storageInstance.schema.attachments;
  var bulkInsertDocs = [];
  var bulkUpdateDocs = [];
  var errors = [];
  var eventBulkId = randomCouchString(10);
  var eventBulk = {
    id: eventBulkId,
    events: [],
    checkpoint: null,
    context: context2,
    startTime: now(),
    endTime: 0
  };
  var eventBulkEvents = eventBulk.events;
  var attachmentsAdd = [];
  var attachmentsRemove = [];
  var attachmentsUpdate = [];
  var hasDocsInDb = docsInDb.size > 0;
  var newestRow;
  var rowAmount = bulkWriteRows.length;
  var _loop = function() {
    var writeRow = bulkWriteRows[rowId];
    var document2 = writeRow.document;
    var previous = writeRow.previous;
    var docId = document2[primaryPath];
    var documentDeleted = document2._deleted;
    var previousDeleted = previous && previous._deleted;
    var documentInDb = void 0;
    if (hasDocsInDb) {
      documentInDb = docsInDb.get(docId);
    }
    var attachmentError;
    if (!documentInDb) {
      var insertedIsDeleted = documentDeleted ? true : false;
      if (hasAttachments) {
        Object.entries(document2._attachments).forEach(([attachmentId, attachmentData]) => {
          if (!attachmentData.data) {
            attachmentError = {
              documentId: docId,
              isError: true,
              status: 510,
              writeRow,
              attachmentId
            };
            errors.push(attachmentError);
          } else {
            attachmentsAdd.push({
              documentId: docId,
              attachmentId,
              attachmentData,
              digest: attachmentData.digest
            });
          }
        });
      }
      if (!attachmentError) {
        if (hasAttachments) {
          bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));
          if (onInsert) {
            onInsert(document2);
          }
        } else {
          bulkInsertDocs.push(writeRow);
          if (onInsert) {
            onInsert(document2);
          }
        }
        newestRow = writeRow;
      }
      if (!insertedIsDeleted) {
        var event2 = {
          documentId: docId,
          operation: "INSERT",
          documentData: hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2,
          previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous
        };
        eventBulkEvents.push(event2);
      }
    } else {
      var revInDb = documentInDb._rev;
      if (!previous || !!previous && revInDb !== previous._rev) {
        var err = {
          isError: true,
          status: 409,
          documentId: docId,
          writeRow,
          documentInDb
        };
        errors.push(err);
        return 1;
      }
      var updatedRow = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow;
      if (hasAttachments) {
        if (documentDeleted) {
          if (previous) {
            Object.keys(previous._attachments).forEach((attachmentId) => {
              attachmentsRemove.push({
                documentId: docId,
                attachmentId,
                digest: ensureNotFalsy(previous)._attachments[attachmentId].digest
              });
            });
          }
        } else {
          Object.entries(document2._attachments).find(([attachmentId, attachmentData]) => {
            var previousAttachmentData = previous ? previous._attachments[attachmentId] : void 0;
            if (!previousAttachmentData && !attachmentData.data) {
              attachmentError = {
                documentId: docId,
                documentInDb,
                isError: true,
                status: 510,
                writeRow,
                attachmentId
              };
            }
            return true;
          });
          if (!attachmentError) {
            Object.entries(document2._attachments).forEach(([attachmentId, attachmentData]) => {
              var previousAttachmentData = previous ? previous._attachments[attachmentId] : void 0;
              if (!previousAttachmentData) {
                attachmentsAdd.push({
                  documentId: docId,
                  attachmentId,
                  attachmentData,
                  digest: attachmentData.digest
                });
              } else {
                var newDigest = updatedRow.document._attachments[attachmentId].digest;
                if (attachmentData.data && /**
                 * Performance shortcut,
                 * do not update the attachment data if it did not change.
                 */
                previousAttachmentData.digest !== newDigest) {
                  attachmentsUpdate.push({
                    documentId: docId,
                    attachmentId,
                    attachmentData,
                    digest: attachmentData.digest
                  });
                }
              }
            });
          }
        }
      }
      if (attachmentError) {
        errors.push(attachmentError);
      } else {
        if (hasAttachments) {
          bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));
          if (onUpdate) {
            onUpdate(document2);
          }
        } else {
          bulkUpdateDocs.push(updatedRow);
          if (onUpdate) {
            onUpdate(document2);
          }
        }
        newestRow = updatedRow;
      }
      var eventDocumentData = null;
      var previousEventDocumentData = null;
      var operation = null;
      if (previousDeleted && !documentDeleted) {
        operation = "INSERT";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2;
      } else if (previous && !previousDeleted && !documentDeleted) {
        operation = "UPDATE";
        eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document2) : document2;
        previousEventDocumentData = previous;
      } else if (documentDeleted) {
        operation = "DELETE";
        eventDocumentData = ensureNotFalsy(document2);
        previousEventDocumentData = previous;
      } else {
        throw newRxError("SNH", {
          args: {
            writeRow
          }
        });
      }
      var _event = {
        documentId: docId,
        documentData: eventDocumentData,
        previousDocumentData: previousEventDocumentData,
        operation
      };
      eventBulkEvents.push(_event);
    }
  };
  for (var rowId = 0; rowId < rowAmount; rowId++) {
    if (_loop()) continue;
  }
  return {
    bulkInsertDocs,
    bulkUpdateDocs,
    newestRow,
    errors,
    eventBulk,
    attachmentsAdd,
    attachmentsRemove,
    attachmentsUpdate
  };
}
function stripAttachmentsDataFromRow(writeRow) {
  return {
    previous: writeRow.previous,
    document: stripAttachmentsDataFromDocument(writeRow.document)
  };
}
function getAttachmentSize(attachmentBase64String) {
  return atob(attachmentBase64String).length;
}
function attachmentWriteDataToNormalData(writeData) {
  var data = writeData.data;
  if (!data) {
    return writeData;
  }
  var ret = {
    length: getAttachmentSize(data),
    digest: writeData.digest,
    type: writeData.type
  };
  return ret;
}
function stripAttachmentsDataFromDocument(doc) {
  if (!doc._attachments || Object.keys(doc._attachments).length === 0) {
    return doc;
  }
  var useDoc = flatClone(doc);
  useDoc._attachments = {};
  Object.entries(doc._attachments).forEach(([attachmentId, attachmentData]) => {
    useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);
  });
  return useDoc;
}
function flatCloneDocWithMeta(doc) {
  return Object.assign({}, doc, {
    _meta: flatClone(doc._meta)
  });
}
var BULK_WRITE_SUCCESS_MAP = /* @__PURE__ */ new WeakMap();
function getWrappedStorageInstance(database, storageInstance, rxJsonSchema) {
  overwritable.deepFreezeWhenDevMode(rxJsonSchema);
  var primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);
  var ret = {
    originalStorageInstance: storageInstance,
    schema: storageInstance.schema,
    internals: storageInstance.internals,
    collectionName: storageInstance.collectionName,
    databaseName: storageInstance.databaseName,
    options: storageInstance.options,
    bulkWrite(rows, context2) {
      var databaseToken = database.token;
      var toStorageWriteRows = new Array(rows.length);
      var time = now();
      for (var index2 = 0; index2 < rows.length; index2++) {
        var writeRow = rows[index2];
        var document2 = flatCloneDocWithMeta(writeRow.document);
        document2._meta.lwt = time;
        var previous = writeRow.previous;
        document2._rev = createRevision(databaseToken, previous);
        toStorageWriteRows[index2] = {
          document: document2,
          previous
        };
      }
      runPluginHooks("preStorageWrite", {
        storageInstance: this.originalStorageInstance,
        rows: toStorageWriteRows
      });
      return database.lockedRun(() => storageInstance.bulkWrite(toStorageWriteRows, context2)).then((writeResult) => {
        var useWriteResult = {
          error: []
        };
        var successArray = getWrittenDocumentsFromBulkWriteResponse(primaryPath, toStorageWriteRows, writeResult);
        BULK_WRITE_SUCCESS_MAP.set(useWriteResult, successArray);
        var reInsertErrors = writeResult.error.length === 0 ? [] : writeResult.error.filter((error) => {
          if (error.status === 409 && !error.writeRow.previous && !error.writeRow.document._deleted && ensureNotFalsy(error.documentInDb)._deleted) {
            return true;
          }
          useWriteResult.error.push(error);
          return false;
        });
        if (reInsertErrors.length > 0) {
          var reInserts = reInsertErrors.map((error) => {
            return {
              previous: error.documentInDb,
              document: Object.assign({}, error.writeRow.document, {
                _rev: createRevision(database.token, error.documentInDb)
              })
            };
          });
          return database.lockedRun(() => storageInstance.bulkWrite(reInserts, context2)).then((subResult) => {
            appendToArray(useWriteResult.error, subResult.error);
            var subSuccess = getWrittenDocumentsFromBulkWriteResponse(primaryPath, reInserts, subResult);
            appendToArray(successArray, subSuccess);
            return useWriteResult;
          });
        }
        return useWriteResult;
      });
    },
    query(preparedQuery) {
      return database.lockedRun(() => storageInstance.query(preparedQuery));
    },
    count(preparedQuery) {
      return database.lockedRun(() => storageInstance.count(preparedQuery));
    },
    findDocumentsById(ids, deleted) {
      return database.lockedRun(() => storageInstance.findDocumentsById(ids, deleted));
    },
    getAttachmentData(documentId, attachmentId, digest) {
      return database.lockedRun(() => storageInstance.getAttachmentData(documentId, attachmentId, digest));
    },
    getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? void 0 : (limit, checkpoint) => {
      return database.lockedRun(() => storageInstance.getChangedDocumentsSince(ensureNotFalsy(limit), checkpoint));
    },
    cleanup(minDeletedTime) {
      return database.lockedRun(() => storageInstance.cleanup(minDeletedTime));
    },
    remove() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.remove());
    },
    close() {
      database.storageInstances.delete(ret);
      return database.lockedRun(() => storageInstance.close());
    },
    changeStream() {
      return storageInstance.changeStream();
    },
    conflictResultionTasks() {
      return storageInstance.conflictResultionTasks();
    },
    resolveConflictResultionTask(taskSolution) {
      if (taskSolution.output.isEqual) {
        return storageInstance.resolveConflictResultionTask(taskSolution);
      }
      var doc = Object.assign({}, taskSolution.output.documentData, {
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      });
      var documentData = flatClone(doc);
      delete documentData._meta;
      delete documentData._rev;
      delete documentData._attachments;
      return storageInstance.resolveConflictResultionTask({
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData
        }
      });
    }
  };
  database.storageInstances.add(ret);
  return ret;
}
function ensureRxStorageInstanceParamsAreCorrect(params) {
  if (params.schema.keyCompression) {
    throw newRxError("UT5", {
      args: {
        params
      }
    });
  }
  if (hasEncryption(params.schema)) {
    throw newRxError("UT6", {
      args: {
        params
      }
    });
  }
  if (params.schema.attachments && params.schema.attachments.compression) {
    throw newRxError("UT7", {
      args: {
        params
      }
    });
  }
}
function hasEncryption(jsonSchema) {
  if (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0 || jsonSchema.attachments && jsonSchema.attachments.encrypted) {
    return true;
  } else {
    return false;
  }
}
function getWrittenDocumentsFromBulkWriteResponse(primaryPath, writeRows, response) {
  var fromMap = BULK_WRITE_SUCCESS_MAP.get(response);
  if (fromMap) {
    return fromMap;
  }
  var ret = [];
  if (response.error.length > 0) {
    var errorIds = /* @__PURE__ */ new Set();
    for (var index2 = 0; index2 < response.error.length; index2++) {
      var error = response.error[index2];
      errorIds.add(error.documentId);
    }
    for (var _index = 0; _index < writeRows.length; _index++) {
      var doc = writeRows[_index].document;
      if (!errorIds.has(doc[primaryPath])) {
        ret.push(stripAttachmentsDataFromDocument(doc));
      }
    }
  } else {
    ret.length = writeRows.length - response.error.length;
    for (var _index2 = 0; _index2 < writeRows.length; _index2++) {
      var _doc = writeRows[_index2].document;
      ret[_index2] = stripAttachmentsDataFromDocument(_doc);
    }
  }
  return ret;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/incremental-write.js
var IncrementalWriteQueue = /* @__PURE__ */ function() {
  function IncrementalWriteQueue2(storageInstance, primaryPath, preWrite, postWrite) {
    this.queueByDocId = /* @__PURE__ */ new Map();
    this.isRunning = false;
    this.storageInstance = storageInstance;
    this.primaryPath = primaryPath;
    this.preWrite = preWrite;
    this.postWrite = postWrite;
  }
  var _proto = IncrementalWriteQueue2.prototype;
  _proto.addWrite = function addWrite(lastKnownDocumentState, modifier) {
    var docId = lastKnownDocumentState[this.primaryPath];
    var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
    var ret = new Promise((resolve2, reject) => {
      var item = {
        lastKnownDocumentState,
        modifier,
        resolve: resolve2,
        reject
      };
      ensureNotFalsy(ar).push(item);
      this.triggerRun();
    });
    return ret;
  };
  _proto.triggerRun = async function triggerRun() {
    if (this.isRunning === true || this.queueByDocId.size === 0) {
      return;
    }
    this.isRunning = true;
    var writeRows = [];
    var itemsById = this.queueByDocId;
    this.queueByDocId = /* @__PURE__ */ new Map();
    await Promise.all(Array.from(itemsById.entries()).map(async ([_docId, items]) => {
      var oldData = findNewestOfDocumentStates(items.map((i2) => i2.lastKnownDocumentState));
      var newData = oldData;
      for (var item of items) {
        try {
          newData = await item.modifier(
            /**
             * We have to clone() each time because the modifier
             * might throw while it already changed some properties
             * of the document.
             */
            clone(newData)
          );
        } catch (err) {
          item.reject(err);
          item.reject = () => {
          };
          item.resolve = () => {
          };
        }
      }
      try {
        await this.preWrite(newData, oldData);
      } catch (err) {
        items.forEach((item2) => item2.reject(err));
        return;
      }
      writeRows.push({
        previous: oldData,
        document: newData
      });
    }));
    var writeResult = writeRows.length > 0 ? await this.storageInstance.bulkWrite(writeRows, "incremental-write") : {
      error: []
    };
    await Promise.all(getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map((result) => {
      var docId = result[this.primaryPath];
      this.postWrite(result);
      var items = getFromMapOrThrow(itemsById, docId);
      items.forEach((item) => item.resolve(result));
    }));
    writeResult.error.forEach((error) => {
      var docId = error.documentId;
      var items = getFromMapOrThrow(itemsById, docId);
      var isConflict = isBulkWriteConflictError(error);
      if (isConflict) {
        var ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);
        items.reverse().forEach((item) => {
          item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);
          ensureNotFalsy(ar).unshift(item);
        });
      } else {
        var rxError = rxStorageWriteErrorToRxError(error);
        items.forEach((item) => item.reject(rxError));
      }
    });
    this.isRunning = false;
    return this.triggerRun();
  };
  return IncrementalWriteQueue2;
}();
function modifierFromPublicToInternal(publicModifier) {
  var ret = async (docData) => {
    var withoutMeta = stripMetaDataFromDocument(docData);
    withoutMeta._deleted = docData._deleted;
    var modified = await publicModifier(withoutMeta);
    var reattachedMeta = Object.assign({}, modified, {
      _meta: docData._meta,
      _attachments: docData._attachments,
      _rev: docData._rev,
      _deleted: typeof modified._deleted !== "undefined" ? modified._deleted : docData._deleted
    });
    if (typeof reattachedMeta._deleted === "undefined") {
      reattachedMeta._deleted = false;
    }
    return reattachedMeta;
  };
  return ret;
}
function findNewestOfDocumentStates(docs) {
  var newest = docs[0];
  var newestRevisionHeight = getHeightOfRevision(newest._rev);
  docs.forEach((doc) => {
    var height = getHeightOfRevision(doc._rev);
    if (height > newestRevisionHeight) {
      newest = doc;
      newestRevisionHeight = height;
    }
  });
  return newest;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-document.js
var basePrototype = {
  get primaryPath() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.collection.schema.primaryPath;
  },
  get primary() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data[_this.primaryPath];
  },
  get revision() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._rev;
  },
  get deleted$() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this.$.pipe(map((d) => d._data._deleted));
  },
  get deleted$$() {
    var _this = this;
    var reactivity = _this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(_this.deleted$, _this.getLatest().deleted, _this.collection.database);
  },
  get deleted() {
    var _this = this;
    if (!_this.isInstanceOfRxDocument) {
      return void 0;
    }
    return _this._data._deleted;
  },
  getLatest() {
    var latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);
    return this.collection._docCache.getCachedRxDocument(latestDocData);
  },
  /**
   * returns the observable which emits the plain-data of this document
   */
  get $() {
    var _this = this;
    return _this.collection.$.pipe(filter((changeEvent) => !changeEvent.isLocal), filter((changeEvent) => changeEvent.documentId === this.primary), map((changeEvent) => getDocumentDataOfRxChangeEvent(changeEvent)), startWith(_this.collection._docCache.getLatestDocumentData(this.primary)), distinctUntilChanged((prev, curr) => prev._rev === curr._rev), map((docData) => this.collection._docCache.getCachedRxDocument(docData)), shareReplay(RXJS_SHARE_REPLAY_DEFAULTS));
  },
  get $$() {
    var _this = this;
    var reactivity = _this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(_this.$, _this.getLatest()._data, _this.collection.database);
  },
  /**
   * returns observable of the value of the given path
   */
  get$(path) {
    if (overwritable.isDevMode()) {
      if (path.includes(".item.")) {
        throw newRxError("DOC1", {
          path
        });
      }
      if (path === this.primaryPath) {
        throw newRxError("DOC2");
      }
      if (this.collection.schema.finalFields.includes(path)) {
        throw newRxError("DOC3", {
          path
        });
      }
      var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
      if (!schemaObj) {
        throw newRxError("DOC4", {
          path
        });
      }
    }
    return this.$.pipe(map((data) => getProperty(data, path)), distinctUntilChanged());
  },
  get$$(path) {
    var obs = this.get$(path);
    var reactivity = this.collection.database.getReactivityFactory();
    return reactivity.fromObservable(obs, this.getLatest().get(path), this.collection.database);
  },
  /**
   * populate the given path
   */
  populate(path) {
    var schemaObj = getSchemaByObjectPath(this.collection.schema.jsonSchema, path);
    var value = this.get(path);
    if (!value) {
      return PROMISE_RESOLVE_NULL;
    }
    if (!schemaObj) {
      throw newRxError("DOC5", {
        path
      });
    }
    if (!schemaObj.ref) {
      throw newRxError("DOC6", {
        path,
        schemaObj
      });
    }
    var refCollection = this.collection.database.collections[schemaObj.ref];
    if (!refCollection) {
      throw newRxError("DOC7", {
        ref: schemaObj.ref,
        path,
        schemaObj
      });
    }
    if (schemaObj.type === "array") {
      return refCollection.findByIds(value).exec().then((res) => {
        var valuesIterator = res.values();
        return Array.from(valuesIterator);
      });
    } else {
      return refCollection.findOne(value).exec();
    }
  },
  /**
   * get data by objectPath
   * @hotPath Performance here is really important,
   * run some tests before changing anything.
   */
  get(objPath) {
    return getDocumentProperty(this, objPath);
  },
  toJSON(withMetaFields = false) {
    if (!withMetaFields) {
      var data = flatClone(this._data);
      delete data._rev;
      delete data._attachments;
      delete data._deleted;
      delete data._meta;
      return overwritable.deepFreezeWhenDevMode(data);
    } else {
      return overwritable.deepFreezeWhenDevMode(this._data);
    }
  },
  toMutableJSON(withMetaFields = false) {
    return clone(this.toJSON(withMetaFields));
  },
  /**
   * updates document
   * @overwritten by plugin (optional)
   * @param updateObj mongodb-like syntax
   */
  update(_updateObj) {
    throw pluginMissing("update");
  },
  incrementalUpdate(_updateObj) {
    throw pluginMissing("update");
  },
  updateCRDT(_updateObj) {
    throw pluginMissing("crdt");
  },
  putAttachment() {
    throw pluginMissing("attachments");
  },
  getAttachment() {
    throw pluginMissing("attachments");
  },
  allAttachments() {
    throw pluginMissing("attachments");
  },
  get allAttachments$() {
    throw pluginMissing("attachments");
  },
  async modify(mutationFunction, _context) {
    var oldData = this._data;
    var newData = await modifierFromPublicToInternal(mutationFunction)(oldData);
    return this._saveData(newData, oldData);
  },
  /**
   * runs an incremental update over the document
   * @param function that takes the document-data and returns a new data-object
   */
  incrementalModify(mutationFunction, _context) {
    return this.collection.incrementalWriteQueue.addWrite(this._data, modifierFromPublicToInternal(mutationFunction)).then((result) => this.collection._docCache.getCachedRxDocument(result));
  },
  patch(patch) {
    var oldData = this._data;
    var newData = clone(oldData);
    Object.entries(patch).forEach(([k, v]) => {
      newData[k] = v;
    });
    return this._saveData(newData, oldData);
  },
  /**
   * patches the given properties
   */
  incrementalPatch(patch) {
    return this.incrementalModify((docData) => {
      Object.entries(patch).forEach(([k, v]) => {
        docData[k] = v;
      });
      return docData;
    });
  },
  /**
   * saves the new document-data
   * and handles the events
   */
  async _saveData(newData, oldData) {
    newData = flatClone(newData);
    if (this._data._deleted) {
      throw newRxError("DOC11", {
        id: this.primary,
        document: this
      });
    }
    await beforeDocumentUpdateWrite(this.collection, newData, oldData);
    var writeRows = [{
      previous: oldData,
      document: newData
    }];
    var writeResult = await this.collection.storageInstance.bulkWrite(writeRows, "rx-document-save-data");
    var isError = writeResult.error[0];
    throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);
    await this.collection._runHooks("post", "save", newData, this);
    return this.collection._docCache.getCachedRxDocument(getWrittenDocumentsFromBulkWriteResponse(this.collection.schema.primaryPath, writeRows, writeResult)[0]);
  },
  /**
   * Remove the document.
   * Notice that there is no hard delete,
   * instead deleted documents get flagged with _deleted=true.
   */
  remove() {
    var collection = this.collection;
    if (this.deleted) {
      return Promise.reject(newRxError("DOC13", {
        document: this,
        id: this.primary
      }));
    }
    var deletedData = flatClone(this._data);
    var removedDocData;
    return collection._runHooks("pre", "remove", deletedData, this).then(async () => {
      deletedData._deleted = true;
      var writeRows = [{
        previous: this._data,
        document: deletedData
      }];
      var writeResult = await collection.storageInstance.bulkWrite(writeRows, "rx-document-remove");
      var isError = writeResult.error[0];
      throwIfIsStorageWriteError(collection, this.primary, deletedData, isError);
      return getWrittenDocumentsFromBulkWriteResponse(this.collection.schema.primaryPath, writeRows, writeResult)[0];
    }).then((removed) => {
      removedDocData = removed;
      return this.collection._runHooks("post", "remove", deletedData, this);
    }).then(() => {
      return this.collection._docCache.getCachedRxDocument(removedDocData);
    });
  },
  incrementalRemove() {
    return this.incrementalModify(async (docData) => {
      await this.collection._runHooks("pre", "remove", docData, this);
      docData._deleted = true;
      return docData;
    }).then(async (newDoc) => {
      await this.collection._runHooks("post", "remove", newDoc._data, newDoc);
      return newDoc;
    });
  },
  destroy() {
    throw newRxError("DOC14");
  }
};
function createRxDocumentConstructor(proto = basePrototype) {
  var constructor = function RxDocumentConstructor(collection, docData) {
    this.collection = collection;
    this._data = docData;
    this._propertyCache = /* @__PURE__ */ new Map();
    this.isInstanceOfRxDocument = true;
  };
  constructor.prototype = proto;
  return constructor;
}
function createWithConstructor(constructor, collection, jsonData) {
  var doc = new constructor(collection, jsonData);
  runPluginHooks("createRxDocument", doc);
  return doc;
}
function beforeDocumentUpdateWrite(collection, newData, oldData) {
  newData._meta = Object.assign({}, oldData._meta, newData._meta);
  if (overwritable.isDevMode()) {
    collection.schema.validateChange(oldData, newData);
  }
  return collection._runHooks("pre", "save", newData, oldData);
}
function getDocumentProperty(doc, objPath) {
  return getFromMapOrCreate(doc._propertyCache, objPath, () => {
    var valueObj = getProperty(doc._data, objPath);
    if (typeof valueObj !== "object" || valueObj === null || Array.isArray(valueObj)) {
      return overwritable.deepFreezeWhenDevMode(valueObj);
    }
    var proxy2 = new Proxy(
      /**
       * In dev-mode, the _data is deep-frozen
       * so we have to flat clone here so that
       * the proxy can work.
       */
      flatClone(valueObj),
      {
        /**
         * @performance is really important here
         * because people access nested properties very often
         * and might not be aware that this is internally using a Proxy
         */
        get(target, property) {
          if (typeof property !== "string") {
            return target[property];
          }
          var lastChar = property.charAt(property.length - 1);
          if (lastChar === "$") {
            if (property.endsWith("$$")) {
              var key = property.slice(0, -2);
              return doc.get$$(trimDots(objPath + "." + key));
            } else {
              var _key = property.slice(0, -1);
              return doc.get$(trimDots(objPath + "." + _key));
            }
          } else if (lastChar === "_") {
            var _key2 = property.slice(0, -1);
            return doc.populate(trimDots(objPath + "." + _key2));
          } else {
            var plainValue = target[property];
            if (typeof plainValue === "number" || typeof plainValue === "string" || typeof plainValue === "boolean") {
              return plainValue;
            }
            return getDocumentProperty(doc, trimDots(objPath + "." + property));
          }
        }
      }
    );
    return proxy2;
  });
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-database-internal-store.js
var INTERNAL_CONTEXT_COLLECTION = "collection";
var INTERNAL_CONTEXT_STORAGE_TOKEN = "storage-token";
var INTERNAL_CONTEXT_MIGRATION_STATUS = "rx-migration-status";
var INTERNAL_STORE_SCHEMA_TITLE = "RxInternalDocument";
var INTERNAL_STORE_SCHEMA = fillWithDefaultSettings({
  version: 0,
  title: INTERNAL_STORE_SCHEMA_TITLE,
  primaryKey: {
    key: "id",
    fields: ["context", "key"],
    separator: "|"
  },
  type: "object",
  properties: {
    id: {
      type: "string",
      maxLength: 200
    },
    key: {
      type: "string"
    },
    context: {
      type: "string",
      enum: [INTERNAL_CONTEXT_COLLECTION, INTERNAL_CONTEXT_STORAGE_TOKEN, INTERNAL_CONTEXT_MIGRATION_STATUS, "OTHER"]
    },
    data: {
      type: "object",
      additionalProperties: true
    }
  },
  indexes: [],
  required: ["key", "context", "data"],
  additionalProperties: false,
  /**
   * If the sharding plugin is used,
   * it must not shard on the internal RxStorageInstance
   * because that one anyway has only a small amount of documents
   * and also its creation is in the hot path of the initial page load,
   * so we should spend less time creating multiple RxStorageInstances.
   */
  sharding: {
    shards: 1,
    mode: "collection"
  }
});
function getPrimaryKeyOfInternalDocument(key, context2) {
  return getComposedPrimaryKeyOfDocumentData(INTERNAL_STORE_SCHEMA, {
    key,
    context: context2
  });
}
async function getAllCollectionDocuments(storageInstance) {
  var getAllQueryPrepared = prepareQuery(storageInstance.schema, {
    selector: {
      context: INTERNAL_CONTEXT_COLLECTION,
      _deleted: {
        $eq: false
      }
    },
    sort: [{
      id: "asc"
    }],
    skip: 0
  });
  var queryResult = await storageInstance.query(getAllQueryPrepared);
  var allDocs = queryResult.documents;
  return allDocs;
}
var STORAGE_TOKEN_DOCUMENT_KEY = "storageToken";
var STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(STORAGE_TOKEN_DOCUMENT_KEY, INTERNAL_CONTEXT_STORAGE_TOKEN);
async function ensureStorageTokenDocumentExists(rxDatabase) {
  var storageToken = randomCouchString(10);
  var passwordHash = rxDatabase.password ? await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) : void 0;
  var docData = {
    id: STORAGE_TOKEN_DOCUMENT_ID,
    context: INTERNAL_CONTEXT_STORAGE_TOKEN,
    key: STORAGE_TOKEN_DOCUMENT_KEY,
    data: {
      rxdbVersion: rxDatabase.rxdbVersion,
      token: storageToken,
      /**
       * We add the instance token here
       * to be able to detect if a given RxDatabase instance
       * is the first instance that was ever created
       * or if databases have existed earlier on that storage
       * with the same database name.
       */
      instanceToken: rxDatabase.token,
      passwordHash
    },
    _deleted: false,
    _meta: getDefaultRxDocumentMeta(),
    _rev: getDefaultRevision(),
    _attachments: {}
  };
  var writeRows = [{
    document: docData
  }];
  var writeResult = await rxDatabase.internalStore.bulkWrite(writeRows, "internal-add-storage-token");
  if (!writeResult.error[0]) {
    return getWrittenDocumentsFromBulkWriteResponse("id", writeRows, writeResult)[0];
  }
  var error = ensureNotFalsy(writeResult.error[0]);
  if (error.isError && isBulkWriteConflictError(error)) {
    var conflictError = error;
    if (!isDatabaseStateVersionCompatibleWithDatabaseCode(conflictError.documentInDb.data.rxdbVersion, rxDatabase.rxdbVersion)) {
      throw newRxError("DM5", {
        args: {
          database: rxDatabase.name,
          databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,
          codeVersion: rxDatabase.rxdbVersion
        }
      });
    }
    if (passwordHash && passwordHash !== conflictError.documentInDb.data.passwordHash) {
      throw newRxError("DB1", {
        passwordHash,
        existingPasswordHash: conflictError.documentInDb.data.passwordHash
      });
    }
    var storageTokenDocInDb = conflictError.documentInDb;
    return ensureNotFalsy(storageTokenDocInDb);
  }
  throw error;
}
function isDatabaseStateVersionCompatibleWithDatabaseCode(databaseStateVersion, codeVersion) {
  if (!databaseStateVersion) {
    return false;
  }
  if (codeVersion.includes("beta") && codeVersion !== databaseStateVersion) {
    return false;
  }
  var stateMajor = databaseStateVersion.split(".")[0];
  var codeMajor = codeVersion.split(".")[0];
  if (stateMajor !== codeMajor) {
    return false;
  }
  return true;
}
function _collectionNamePrimary(name, schema) {
  return name + "-" + schema.version;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-collection-helper.js
function fillObjectDataBeforeInsert(schema, data) {
  data = flatClone(data);
  data = fillObjectWithDefaults(schema, data);
  if (typeof schema.jsonSchema.primaryKey !== "string") {
    data = fillPrimaryKey(schema.primaryPath, schema.jsonSchema, data);
  }
  data._meta = getDefaultRxDocumentMeta();
  if (!Object.prototype.hasOwnProperty.call(data, "_deleted")) {
    data._deleted = false;
  }
  if (!Object.prototype.hasOwnProperty.call(data, "_attachments")) {
    data._attachments = {};
  }
  if (!Object.prototype.hasOwnProperty.call(data, "_rev")) {
    data._rev = getDefaultRevision();
  }
  return data;
}
async function createRxCollectionStorageInstance(rxDatabase, storageInstanceCreationParams) {
  storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;
  var storageInstance = await rxDatabase.storage.createStorageInstance(storageInstanceCreationParams);
  return storageInstance;
}
async function removeCollectionStorages(storage, databaseInternalStorage, databaseInstanceToken, databaseName, collectionName, password, hashFunction) {
  var allCollectionMetaDocs = await getAllCollectionDocuments(databaseInternalStorage);
  var relevantCollectionMetaDocs = allCollectionMetaDocs.filter((metaDoc) => metaDoc.data.name === collectionName);
  var removeStorages = [];
  relevantCollectionMetaDocs.forEach((metaDoc) => {
    removeStorages.push({
      collectionName: metaDoc.data.name,
      schema: metaDoc.data.schema,
      isCollection: true
    });
    metaDoc.data.connectedStorages.forEach((row) => removeStorages.push({
      collectionName: row.collectionName,
      isCollection: false,
      schema: row.schema
    }));
  });
  var alreadyAdded = /* @__PURE__ */ new Set();
  removeStorages = removeStorages.filter((row) => {
    var key = row.collectionName + "||" + row.schema.version;
    if (alreadyAdded.has(key)) {
      return false;
    } else {
      alreadyAdded.add(key);
      return true;
    }
  });
  await Promise.all(removeStorages.map(async (row) => {
    var storageInstance = await storage.createStorageInstance({
      collectionName: row.collectionName,
      databaseInstanceToken,
      databaseName,
      multiInstance: false,
      options: {},
      schema: row.schema,
      password,
      devMode: overwritable.isDevMode()
    });
    await storageInstance.remove();
    if (row.isCollection) {
      await runAsyncPluginHooks("postRemoveRxCollection", {
        storage,
        databaseName,
        collectionName
      });
    }
  }));
  if (hashFunction) {
    var writeRows = relevantCollectionMetaDocs.map((doc) => {
      var writeDoc = flatCloneDocWithMeta(doc);
      writeDoc._deleted = true;
      writeDoc._meta.lwt = now();
      writeDoc._rev = createRevision(databaseInstanceToken, doc);
      return {
        previous: doc,
        document: writeDoc
      };
    });
    await databaseInternalStorage.bulkWrite(writeRows, "rx-database-remove-collection-all");
  }
}
function ensureRxCollectionIsNotDestroyed(collection) {
  if (collection.destroyed) {
    throw newRxError("COL21", {
      collection: collection.name,
      version: collection.schema.version
    });
  }
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/change-event-buffer.js
var ChangeEventBuffer = /* @__PURE__ */ function() {
  function ChangeEventBuffer2(collection) {
    this.subs = [];
    this.counter = 0;
    this.eventCounterMap = /* @__PURE__ */ new WeakMap();
    this.buffer = [];
    this.limit = 100;
    this.tasks = /* @__PURE__ */ new Set();
    this.collection = collection;
    this.subs.push(this.collection.database.eventBulks$.pipe(filter((changeEventBulk) => changeEventBulk.collectionName === this.collection.name), filter((bulk) => {
      var first = bulk.events[0];
      return !first.isLocal;
    })).subscribe((eventBulk) => {
      this.tasks.add(() => this._handleChangeEvents(eventBulk.events));
      if (this.tasks.size <= 1) {
        requestIdlePromiseNoQueue().then(() => {
          this.processTasks();
        });
      }
    }));
  }
  var _proto = ChangeEventBuffer2.prototype;
  _proto.processTasks = function processTasks() {
    if (this.tasks.size === 0) {
      return;
    }
    var tasks = Array.from(this.tasks);
    tasks.forEach((task) => task());
    this.tasks.clear();
  };
  _proto._handleChangeEvents = function _handleChangeEvents(events) {
    var counterBefore = this.counter;
    this.counter = this.counter + events.length;
    if (events.length > this.limit) {
      this.buffer = events.slice(events.length * -1);
    } else {
      appendToArray(this.buffer, events);
      this.buffer = this.buffer.slice(this.limit * -1);
    }
    var counterBase = counterBefore + 1;
    var eventCounterMap = this.eventCounterMap;
    for (var index2 = 0; index2 < events.length; index2++) {
      var event2 = events[index2];
      eventCounterMap.set(event2, counterBase + index2);
    }
  };
  _proto.getCounter = function getCounter() {
    this.processTasks();
    return this.counter;
  };
  _proto.getBuffer = function getBuffer() {
    this.processTasks();
    return this.buffer;
  };
  _proto.getArrayIndexByPointer = function getArrayIndexByPointer(pointer) {
    this.processTasks();
    var oldestEvent = this.buffer[0];
    var oldestCounter = this.eventCounterMap.get(oldestEvent);
    if (pointer < oldestCounter) return null;
    var rest = pointer - oldestCounter;
    return rest;
  };
  _proto.getFrom = function getFrom(pointer) {
    this.processTasks();
    var ret = [];
    var currentIndex = this.getArrayIndexByPointer(pointer);
    if (currentIndex === null)
      return null;
    while (true) {
      var nextEvent = this.buffer[currentIndex];
      currentIndex++;
      if (!nextEvent) {
        return ret;
      } else {
        ret.push(nextEvent);
      }
    }
  };
  _proto.runFrom = function runFrom(pointer, fn) {
    this.processTasks();
    var ret = this.getFrom(pointer);
    if (ret === null) {
      throw new Error("out of bounds");
    } else {
      ret.forEach((cE) => fn(cE));
    }
  };
  _proto.reduceByLastOfDoc = function reduceByLastOfDoc(changeEvents) {
    this.processTasks();
    return changeEvents.slice(0);
    var docEventMap = {};
    changeEvents.forEach((changeEvent) => {
      docEventMap[changeEvent.documentId] = changeEvent;
    });
    return Object.values(docEventMap);
  };
  _proto.destroy = function destroy() {
    this.tasks.clear();
    this.subs.forEach((sub) => sub.unsubscribe());
  };
  return ChangeEventBuffer2;
}();
function createChangeEventBuffer(collection) {
  return new ChangeEventBuffer(collection);
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-document-prototype-merge.js
var constructorForCollection = /* @__PURE__ */ new WeakMap();
function getDocumentPrototype(rxCollection) {
  var schemaProto = rxCollection.schema.getDocumentPrototype();
  var ormProto = getDocumentOrmPrototype(rxCollection);
  var baseProto = basePrototype;
  var proto = {};
  [schemaProto, ormProto, baseProto].forEach((obj) => {
    var props = Object.getOwnPropertyNames(obj);
    props.forEach((key) => {
      var desc = Object.getOwnPropertyDescriptor(obj, key);
      var enumerable = true;
      if (key.startsWith("_") || key.endsWith("_") || key.startsWith("$") || key.endsWith("$")) enumerable = false;
      if (typeof desc.value === "function") {
        Object.defineProperty(proto, key, {
          get() {
            return desc.value.bind(this);
          },
          enumerable,
          configurable: false
        });
      } else {
        desc.enumerable = enumerable;
        desc.configurable = false;
        if (desc.writable) desc.writable = false;
        Object.defineProperty(proto, key, desc);
      }
    });
  });
  return proto;
}
function getRxDocumentConstructor(rxCollection) {
  return getFromMapOrCreate(constructorForCollection, rxCollection, () => createRxDocumentConstructor(getDocumentPrototype(rxCollection)));
}
function createNewRxDocument(rxCollection, documentConstructor, docData) {
  var doc = createWithConstructor(documentConstructor, rxCollection, overwritable.deepFreezeWhenDevMode(docData));
  rxCollection._runHooksSync("post", "create", docData, doc);
  runPluginHooks("postCreateRxDocument", doc);
  return doc;
}
function getDocumentOrmPrototype(rxCollection) {
  var proto = {};
  Object.entries(rxCollection.methods).forEach(([k, v]) => {
    proto[k] = v;
  });
  return proto;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/replication-protocol/conflicts.js
var defaultConflictHandler = function(i2, _context) {
  var newDocumentState = stripAttachmentsDataFromDocument(i2.newDocumentState);
  var realMasterState = stripAttachmentsDataFromDocument(i2.realMasterState);
  if (deepEqual(newDocumentState, realMasterState)) {
    return Promise.resolve({
      isEqual: true
    });
  }
  return Promise.resolve({
    isEqual: false,
    documentData: i2.realMasterState
  });
};

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-collection.js
var HOOKS_WHEN = ["pre", "post"];
var HOOKS_KEYS = ["insert", "save", "remove", "create"];
var hooksApplied = false;
var RxCollectionBase = /* @__PURE__ */ function() {
  function RxCollectionBase2(database, name, schema, internalStorageInstance, instanceCreationOptions = {}, migrationStrategies = {}, methods = {}, attachments = {}, options = {}, cacheReplacementPolicy = defaultCacheReplacementPolicy, statics = {}, conflictHandler = defaultConflictHandler) {
    this.storageInstance = {};
    this.timeouts = /* @__PURE__ */ new Set();
    this.incrementalWriteQueue = {};
    this.awaitBeforeReads = /* @__PURE__ */ new Set();
    this._incrementalUpsertQueues = /* @__PURE__ */ new Map();
    this.synced = false;
    this.hooks = {};
    this._subs = [];
    this._docCache = {};
    this._queryCache = createQueryCache();
    this.$ = {};
    this.checkpoint$ = {};
    this._changeEventBuffer = {};
    this.onDestroy = [];
    this.destroyed = false;
    this.onRemove = [];
    this.database = database;
    this.name = name;
    this.schema = schema;
    this.internalStorageInstance = internalStorageInstance;
    this.instanceCreationOptions = instanceCreationOptions;
    this.migrationStrategies = migrationStrategies;
    this.methods = methods;
    this.attachments = attachments;
    this.options = options;
    this.cacheReplacementPolicy = cacheReplacementPolicy;
    this.statics = statics;
    this.conflictHandler = conflictHandler;
    _applyHookFunctions(this.asRxCollection);
  }
  var _proto = RxCollectionBase2.prototype;
  _proto.prepare = async function prepare() {
    this.storageInstance = getWrappedStorageInstance(this.database, this.internalStorageInstance, this.schema.jsonSchema);
    this.incrementalWriteQueue = new IncrementalWriteQueue(this.storageInstance, this.schema.primaryPath, (newData, oldData) => beforeDocumentUpdateWrite(this, newData, oldData), (result) => this._runHooks("post", "save", result));
    var collectionEventBulks$ = this.database.eventBulks$.pipe(filter((changeEventBulk) => changeEventBulk.collectionName === this.name));
    this.$ = collectionEventBulks$.pipe(mergeMap((changeEventBulk) => changeEventBulk.events));
    this.checkpoint$ = collectionEventBulks$.pipe(map((changeEventBulk) => changeEventBulk.checkpoint));
    this._changeEventBuffer = createChangeEventBuffer(this.asRxCollection);
    var documentConstructor;
    this._docCache = new DocumentCache(this.schema.primaryPath, this.database.eventBulks$.pipe(filter((changeEventBulk) => changeEventBulk.collectionName === this.name && !changeEventBulk.events[0].isLocal), map((b) => b.events)), (docData) => {
      if (!documentConstructor) {
        documentConstructor = getRxDocumentConstructor(this.asRxCollection);
      }
      return createNewRxDocument(this.asRxCollection, documentConstructor, docData);
    });
    var listenToRemoveSub = this.database.internalStore.changeStream().pipe(filter((bulk) => {
      var key = this.name + "-" + this.schema.version;
      var found = bulk.events.find((event2) => {
        return event2.documentData.context === "collection" && event2.documentData.key === key && event2.operation === "DELETE";
      });
      return !!found;
    })).subscribe(async () => {
      await this.destroy();
      await Promise.all(this.onRemove.map((fn) => fn()));
    });
    this._subs.push(listenToRemoveSub);
    var databaseStorageToken = await this.database.storageToken;
    var subDocs = this.storageInstance.changeStream().subscribe((eventBulk) => {
      var events = new Array(eventBulk.events.length);
      var rawEvents = eventBulk.events;
      var collectionName = this.name;
      var deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;
      for (var index2 = 0; index2 < rawEvents.length; index2++) {
        var event2 = rawEvents[index2];
        events[index2] = {
          documentId: event2.documentId,
          collectionName,
          isLocal: false,
          operation: event2.operation,
          documentData: deepFreezeWhenDevMode(event2.documentData),
          previousDocumentData: deepFreezeWhenDevMode(event2.previousDocumentData)
        };
      }
      var changeEventBulk = {
        id: eventBulk.id,
        internal: false,
        collectionName: this.name,
        storageToken: databaseStorageToken,
        events,
        databaseToken: this.database.token,
        checkpoint: eventBulk.checkpoint,
        context: eventBulk.context,
        endTime: eventBulk.endTime,
        startTime: eventBulk.startTime
      };
      this.database.$emit(changeEventBulk);
    });
    this._subs.push(subDocs);
    this._subs.push(this.storageInstance.conflictResultionTasks().subscribe((task) => {
      this.conflictHandler(task.input, task.context).then((output) => {
        this.storageInstance.resolveConflictResultionTask({
          id: task.id,
          output
        });
      });
    }));
    return PROMISE_RESOLVE_VOID;
  };
  _proto.cleanup = function cleanup(_minimumDeletedTime) {
    ensureRxCollectionIsNotDestroyed(this);
    throw pluginMissing("cleanup");
  };
  _proto.migrationNeeded = function migrationNeeded() {
    throw pluginMissing("migration-schema");
  };
  _proto.getMigrationState = function getMigrationState() {
    throw pluginMissing("migration-schema");
  };
  _proto.startMigration = function startMigration(batchSize = 10) {
    ensureRxCollectionIsNotDestroyed(this);
    return this.getMigrationState().startMigration(batchSize);
  };
  _proto.migratePromise = function migratePromise(batchSize = 10) {
    return this.getMigrationState().migratePromise(batchSize);
  };
  _proto.insert = async function insert(json) {
    ensureRxCollectionIsNotDestroyed(this);
    var writeResult = await this.bulkInsert([json]);
    var isError = writeResult.error[0];
    throwIfIsStorageWriteError(this, json[this.schema.primaryPath], json, isError);
    var insertResult = ensureNotFalsy(writeResult.success[0]);
    return insertResult;
  };
  _proto.bulkInsert = async function bulkInsert(docsData) {
    ensureRxCollectionIsNotDestroyed(this);
    if (docsData.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var primaryPath = this.schema.primaryPath;
    var insertRows;
    if (this.hasHooks("pre", "insert")) {
      insertRows = await Promise.all(docsData.map((docData2) => {
        var useDocData2 = fillObjectDataBeforeInsert(this.schema, docData2);
        return this._runHooks("pre", "insert", useDocData2).then(() => {
          return {
            document: useDocData2
          };
        });
      }));
    } else {
      insertRows = new Array(docsData.length);
      var _schema = this.schema;
      for (var index2 = 0; index2 < docsData.length; index2++) {
        var docData = docsData[index2];
        var useDocData = fillObjectDataBeforeInsert(_schema, docData);
        insertRows[index2] = {
          document: useDocData
        };
      }
    }
    var results = await this.storageInstance.bulkWrite(insertRows, "rx-collection-bulk-insert");
    var rxDocuments;
    var collection = this;
    var ret = {
      get success() {
        if (!rxDocuments) {
          var success = getWrittenDocumentsFromBulkWriteResponse(collection.schema.primaryPath, insertRows, results);
          rxDocuments = mapDocumentsDataToCacheDocs(collection._docCache, success);
        }
        return rxDocuments;
      },
      error: results.error
    };
    if (this.hasHooks("post", "insert")) {
      var docsMap = /* @__PURE__ */ new Map();
      insertRows.forEach((row) => {
        var doc = row.document;
        docsMap.set(doc[primaryPath], doc);
      });
      await Promise.all(ret.success.map((doc) => {
        return this._runHooks("post", "insert", docsMap.get(doc.primary), doc);
      }));
    }
    return ret;
  };
  _proto.bulkRemove = async function bulkRemove(ids) {
    ensureRxCollectionIsNotDestroyed(this);
    var primaryPath = this.schema.primaryPath;
    if (ids.length === 0) {
      return {
        success: [],
        error: []
      };
    }
    var rxDocumentMap = await this.findByIds(ids).exec();
    var docsData = [];
    var docsMap = /* @__PURE__ */ new Map();
    Array.from(rxDocumentMap.values()).forEach((rxDocument) => {
      var data = rxDocument.toMutableJSON(true);
      docsData.push(data);
      docsMap.set(rxDocument.primary, data);
    });
    await Promise.all(docsData.map((doc) => {
      var primary = doc[this.schema.primaryPath];
      return this._runHooks("pre", "remove", doc, rxDocumentMap.get(primary));
    }));
    var removeDocs = docsData.map((doc) => {
      var writeDoc = flatClone(doc);
      writeDoc._deleted = true;
      return {
        previous: doc,
        document: writeDoc
      };
    });
    var results = await this.storageInstance.bulkWrite(removeDocs, "rx-collection-bulk-remove");
    var success = getWrittenDocumentsFromBulkWriteResponse(this.schema.primaryPath, removeDocs, results);
    var successIds = success.map((d) => d[primaryPath]);
    await Promise.all(successIds.map((id) => {
      return this._runHooks("post", "remove", docsMap.get(id), rxDocumentMap.get(id));
    }));
    var rxDocuments = successIds.map((id) => getFromMapOrThrow(rxDocumentMap, id));
    return {
      success: rxDocuments,
      error: results.error
    };
  };
  _proto.bulkUpsert = async function bulkUpsert(docsData) {
    ensureRxCollectionIsNotDestroyed(this);
    var insertData = [];
    var useJsonByDocId = /* @__PURE__ */ new Map();
    docsData.forEach((docData) => {
      var useJson = fillObjectDataBeforeInsert(this.schema, docData);
      var primary = useJson[this.schema.primaryPath];
      if (!primary) {
        throw newRxError("COL3", {
          primaryPath: this.schema.primaryPath,
          data: useJson,
          schema: this.schema.jsonSchema
        });
      }
      useJsonByDocId.set(primary, useJson);
      insertData.push(useJson);
    });
    var insertResult = await this.bulkInsert(insertData);
    var success = insertResult.success.slice(0);
    var error = [];
    await Promise.all(insertResult.error.map(async (err) => {
      if (err.status !== 409) {
        error.push(err);
      } else {
        var id = err.documentId;
        var writeData = getFromMapOrThrow(useJsonByDocId, id);
        var docDataInDb = ensureNotFalsy(err.documentInDb);
        var doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];
        var newDoc = await doc.incrementalModify(() => writeData);
        success.push(newDoc);
      }
    }));
    return {
      error,
      success
    };
  };
  _proto.upsert = async function upsert(json) {
    ensureRxCollectionIsNotDestroyed(this);
    var bulkResult = await this.bulkUpsert([json]);
    throwIfIsStorageWriteError(this.asRxCollection, json[this.schema.primaryPath], json, bulkResult.error[0]);
    return bulkResult.success[0];
  };
  _proto.incrementalUpsert = function incrementalUpsert(json) {
    ensureRxCollectionIsNotDestroyed(this);
    var useJson = fillObjectDataBeforeInsert(this.schema, json);
    var primary = useJson[this.schema.primaryPath];
    if (!primary) {
      throw newRxError("COL4", {
        data: json
      });
    }
    var queue = this._incrementalUpsertQueues.get(primary);
    if (!queue) {
      queue = PROMISE_RESOLVE_VOID;
    }
    queue = queue.then(() => _incrementalUpsertEnsureRxDocumentExists(this, primary, useJson)).then((wasInserted) => {
      if (!wasInserted.inserted) {
        return _incrementalUpsertUpdate(wasInserted.doc, useJson);
      } else {
        return wasInserted.doc;
      }
    });
    this._incrementalUpsertQueues.set(primary, queue);
    return queue;
  };
  _proto.find = function find(queryObj) {
    ensureRxCollectionIsNotDestroyed(this);
    if (typeof queryObj === "string") {
      throw newRxError("COL5", {
        queryObj
      });
    }
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("find", queryObj, this);
    return query;
  };
  _proto.findOne = function findOne(queryObj) {
    ensureRxCollectionIsNotDestroyed(this);
    if (typeof queryObj === "number" || Array.isArray(queryObj)) {
      throw newRxTypeError("COL6", {
        queryObj
      });
    }
    var query;
    if (typeof queryObj === "string") {
      query = createRxQuery("findOne", {
        selector: {
          [this.schema.primaryPath]: queryObj
        },
        limit: 1
      }, this);
    } else {
      if (!queryObj) {
        queryObj = _getDefaultQuery();
      }
      if (queryObj.limit) {
        throw newRxError("QU6");
      }
      queryObj = flatClone(queryObj);
      queryObj.limit = 1;
      query = createRxQuery("findOne", queryObj, this);
    }
    return query;
  };
  _proto.count = function count(queryObj) {
    ensureRxCollectionIsNotDestroyed(this);
    if (!queryObj) {
      queryObj = _getDefaultQuery();
    }
    var query = createRxQuery("count", queryObj, this);
    return query;
  };
  _proto.findByIds = function findByIds(ids) {
    ensureRxCollectionIsNotDestroyed(this);
    var mangoQuery = {
      selector: {
        [this.schema.primaryPath]: {
          $in: ids.slice(0)
        }
      }
    };
    var query = createRxQuery("findByIds", mangoQuery, this);
    return query;
  };
  _proto.exportJSON = function exportJSON() {
    throw pluginMissing("json-dump");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.insertCRDT = function insertCRDT(_updateObj) {
    throw pluginMissing("crdt");
  };
  _proto.addPipeline = function addPipeline(_options) {
    throw pluginMissing("pipeline");
  };
  _proto.addHook = function addHook(when, key, fun, parallel = false) {
    if (typeof fun !== "function") {
      throw newRxTypeError("COL7", {
        key,
        when
      });
    }
    if (!HOOKS_WHEN.includes(when)) {
      throw newRxTypeError("COL8", {
        key,
        when
      });
    }
    if (!HOOKS_KEYS.includes(key)) {
      throw newRxError("COL9", {
        key
      });
    }
    if (when === "post" && key === "create" && parallel === true) {
      throw newRxError("COL10", {
        when,
        key,
        parallel
      });
    }
    var boundFun = fun.bind(this);
    var runName = parallel ? "parallel" : "series";
    this.hooks[key] = this.hooks[key] || {};
    this.hooks[key][when] = this.hooks[key][when] || {
      series: [],
      parallel: []
    };
    this.hooks[key][when][runName].push(boundFun);
  };
  _proto.getHooks = function getHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return {
        series: [],
        parallel: []
      };
    }
    return this.hooks[key][when];
  };
  _proto.hasHooks = function hasHooks(when, key) {
    if (!this.hooks[key] || !this.hooks[key][when]) {
      return false;
    }
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return false;
    }
    return hooks.series.length > 0 || hooks.parallel.length > 0;
  };
  _proto._runHooks = function _runHooks(when, key, data, instance) {
    var hooks = this.getHooks(when, key);
    if (!hooks) {
      return PROMISE_RESOLVE_VOID;
    }
    var tasks = hooks.series.map((hook) => () => hook(data, instance));
    return promiseSeries(tasks).then(() => Promise.all(hooks.parallel.map((hook) => hook(data, instance))));
  };
  _proto._runHooksSync = function _runHooksSync(when, key, data, instance) {
    if (!this.hasHooks(when, key)) {
      return;
    }
    var hooks = this.getHooks(when, key);
    if (!hooks) return;
    hooks.series.forEach((hook) => hook(data, instance));
  };
  _proto.promiseWait = function promiseWait2(time) {
    var ret = new Promise((res) => {
      var timeout = setTimeout(() => {
        this.timeouts.delete(timeout);
        res();
      }, time);
      this.timeouts.add(timeout);
    });
    return ret;
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    await Promise.all(this.onDestroy.map((fn) => fn()));
    this.destroyed = true;
    Array.from(this.timeouts).forEach((timeout) => clearTimeout(timeout));
    if (this._changeEventBuffer) {
      this._changeEventBuffer.destroy();
    }
    return this.database.requestIdlePromise().then(() => this.storageInstance.close()).then(() => {
      this._subs.forEach((sub) => sub.unsubscribe());
      delete this.database.collections[this.name];
      return runAsyncPluginHooks("postDestroyRxCollection", this).then(() => true);
    });
  };
  _proto.remove = async function remove2() {
    await this.destroy();
    await Promise.all(this.onRemove.map((fn) => fn()));
    await removeCollectionStorages(this.database.storage, this.database.internalStore, this.database.token, this.database.name, this.name, this.database.password, this.database.hashFunction);
  };
  return _createClass(RxCollectionBase2, [{
    key: "insert$",
    get: function() {
      return this.$.pipe(filter((cE) => cE.operation === "INSERT"));
    }
  }, {
    key: "update$",
    get: function() {
      return this.$.pipe(filter((cE) => cE.operation === "UPDATE"));
    }
  }, {
    key: "remove$",
    get: function() {
      return this.$.pipe(filter((cE) => cE.operation === "DELETE"));
    }
    // defaults
    /**
     * When the collection is destroyed,
     * these functions will be called an awaited.
     * Used to automatically clean up stuff that
     * belongs to this collection.
    */
  }, {
    key: "asRxCollection",
    get: function() {
      return this;
    }
  }]);
}();
function _applyHookFunctions(collection) {
  if (hooksApplied) return;
  hooksApplied = true;
  var colProto = Object.getPrototypeOf(collection);
  HOOKS_KEYS.forEach((key) => {
    HOOKS_WHEN.map((when) => {
      var fnName = when + ucfirst(key);
      colProto[fnName] = function(fun, parallel) {
        return this.addHook(when, key, fun, parallel);
      };
    });
  });
}
function _incrementalUpsertUpdate(doc, json) {
  return doc.incrementalModify((_innerDoc) => {
    return json;
  });
}
function _incrementalUpsertEnsureRxDocumentExists(rxCollection, primary, json) {
  var docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);
  if (docDataFromCache) {
    return Promise.resolve({
      doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],
      inserted: false
    });
  }
  return rxCollection.findOne(primary).exec().then((doc) => {
    if (!doc) {
      return rxCollection.insert(json).then((newDoc) => ({
        doc: newDoc,
        inserted: true
      }));
    } else {
      return {
        doc,
        inserted: false
      };
    }
  });
}
function createRxCollection({
  database,
  name,
  schema,
  instanceCreationOptions = {},
  migrationStrategies = {},
  autoMigrate = true,
  statics = {},
  methods = {},
  attachments = {},
  options = {},
  localDocuments = false,
  cacheReplacementPolicy = defaultCacheReplacementPolicy,
  conflictHandler = defaultConflictHandler
}) {
  var storageInstanceCreationParams = {
    databaseInstanceToken: database.token,
    databaseName: database.name,
    collectionName: name,
    schema: schema.jsonSchema,
    options: instanceCreationOptions,
    multiInstance: database.multiInstance,
    password: database.password,
    devMode: overwritable.isDevMode()
  };
  runPluginHooks("preCreateRxStorageInstance", storageInstanceCreationParams);
  return createRxCollectionStorageInstance(database, storageInstanceCreationParams).then((storageInstance) => {
    var collection = new RxCollectionBase(database, name, schema, storageInstance, instanceCreationOptions, migrationStrategies, methods, attachments, options, cacheReplacementPolicy, statics, conflictHandler);
    return collection.prepare().then(() => {
      Object.entries(statics).forEach(([funName, fun]) => {
        Object.defineProperty(collection, funName, {
          get: () => fun.bind(collection)
        });
      });
      var ret = PROMISE_RESOLVE_VOID;
      if (autoMigrate && collection.schema.version !== 0) {
        ret = collection.migratePromise();
      }
      return ret;
    }).then(() => {
      runPluginHooks("createRxCollection", {
        collection,
        creator: {
          name,
          schema,
          storageInstance,
          instanceCreationOptions,
          migrationStrategies,
          methods,
          attachments,
          options,
          cacheReplacementPolicy,
          localDocuments,
          statics
        }
      });
      return collection;
    }).catch((err) => {
      return storageInstance.close().then(() => Promise.reject(err));
    });
  });
}

// node_modules/.pnpm/custom-idle-queue@3.0.1/node_modules/custom-idle-queue/dist/es/index.js
var IdleQueue = function IdleQueue2() {
  var parallels = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
  this._parallels = parallels || 1;
  this._qC = 0;
  this._iC = /* @__PURE__ */ new Set();
  this._lHN = 0;
  this._hPM = /* @__PURE__ */ new Map();
  this._pHM = /* @__PURE__ */ new Map();
};
IdleQueue.prototype = {
  isIdle: function isIdle() {
    return this._qC < this._parallels;
  },
  /**
   * creates a lock in the queue
   * and returns an unlock-function to remove the lock from the queue
   * @return {function} unlock function than must be called afterwards
   */
  lock: function lock() {
    this._qC++;
  },
  unlock: function unlock() {
    this._qC--;
    _tryIdleCall(this);
  },
  /**
   * wraps a function with lock/unlock and runs it
   * @param  {function}  fun
   * @return {Promise<any>}
   */
  wrapCall: function wrapCall(fun) {
    var _this = this;
    this.lock();
    var maybePromise;
    try {
      maybePromise = fun();
    } catch (err) {
      this.unlock();
      throw err;
    }
    if (!maybePromise.then || typeof maybePromise.then !== "function") {
      this.unlock();
      return maybePromise;
    } else {
      return maybePromise.then(function(ret) {
        _this.unlock();
        return ret;
      })["catch"](function(err) {
        _this.unlock();
        throw err;
      });
    }
  },
  /**
   * does the same as requestIdleCallback() but uses promises instead of the callback
   * @param {{timeout?: number}} options like timeout
   * @return {Promise<void>} promise that resolves when the database is in idle-mode
   */
  requestIdlePromise: function requestIdlePromise2(options) {
    var _this2 = this;
    options = options || {};
    var resolve2;
    var prom = new Promise(function(res) {
      return resolve2 = res;
    });
    var resolveFromOutside = function resolveFromOutside2() {
      _removeIdlePromise(_this2, prom);
      resolve2();
    };
    prom._manRes = resolveFromOutside;
    if (options.timeout) {
      var timeoutObj = setTimeout(function() {
        prom._manRes();
      }, options.timeout);
      prom._timeoutObj = timeoutObj;
    }
    this._iC.add(prom);
    _tryIdleCall(this);
    return prom;
  },
  /**
   * remove the promise so it will never be resolved
   * @param  {Promise} promise from requestIdlePromise()
   * @return {void}
   */
  cancelIdlePromise: function cancelIdlePromise(promise) {
    _removeIdlePromise(this, promise);
  },
  /**
   * api equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback
   * @param  {Function} callback
   * @param  {options}   options  [description]
   * @return {number} handle which can be used with cancelIdleCallback()
   */
  requestIdleCallback: function requestIdleCallback2(callback, options) {
    var handle = this._lHN++;
    var promise = this.requestIdlePromise(options);
    this._hPM.set(handle, promise);
    this._pHM.set(promise, handle);
    promise.then(function() {
      return callback();
    });
    return handle;
  },
  /**
   * API equal to
   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback
   * @param  {number} handle returned from requestIdleCallback()
   * @return {void}
   */
  cancelIdleCallback: function cancelIdleCallback(handle) {
    var promise = this._hPM.get(handle);
    this.cancelIdlePromise(promise);
  },
  /**
   * clears and resets everything
   * @return {void}
   */
  clear: function clear() {
    var _this3 = this;
    this._iC.forEach(function(promise) {
      return _removeIdlePromise(_this3, promise);
    });
    this._qC = 0;
    this._iC.clear();
    this._hPM = /* @__PURE__ */ new Map();
    this._pHM = /* @__PURE__ */ new Map();
  }
};
function _resolveOneIdleCall(idleQueue) {
  if (idleQueue._iC.size === 0) return;
  var iterator2 = idleQueue._iC.values();
  var oldestPromise = iterator2.next().value;
  oldestPromise._manRes();
  setTimeout(function() {
    return _tryIdleCall(idleQueue);
  }, 0);
}
function _removeIdlePromise(idleQueue, promise) {
  if (!promise) return;
  if (promise._timeoutObj) clearTimeout(promise._timeoutObj);
  if (idleQueue._pHM.has(promise)) {
    var handle = idleQueue._pHM.get(promise);
    idleQueue._hPM["delete"](handle);
    idleQueue._pHM["delete"](promise);
  }
  idleQueue._iC["delete"](promise);
}
function _tryIdleCall(idleQueue) {
  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;
  idleQueue._tryIR = true;
  setTimeout(function() {
    if (!idleQueue.isIdle()) {
      idleQueue._tryIR = false;
      return;
    }
    setTimeout(function() {
      if (!idleQueue.isIdle()) {
        idleQueue._tryIR = false;
        return;
      }
      _resolveOneIdleCall(idleQueue);
      idleQueue._tryIR = false;
    }, 0);
  }, 0);
}

// node_modules/.pnpm/oblivious-set@1.4.0/node_modules/oblivious-set/dist/esm/src/index.js
var ObliviousSet = class {
  ttl;
  map = /* @__PURE__ */ new Map();
  /**
   * Creating calls to setTimeout() is expensive,
   * so we only do that if there is not timeout already open.
   */
  _to = false;
  constructor(ttl) {
    this.ttl = ttl;
  }
  has(value) {
    return this.map.has(value);
  }
  add(value) {
    this.map.set(value, now2());
    if (!this._to) {
      this._to = true;
      setTimeout(() => {
        this._to = false;
        removeTooOldValues(this);
      }, 0);
    }
  }
  clear() {
    this.map.clear();
  }
};
function removeTooOldValues(obliviousSet) {
  const olderThen = now2() - obliviousSet.ttl;
  const iterator2 = obliviousSet.map[Symbol.iterator]();
  while (true) {
    const next2 = iterator2.next().value;
    if (!next2) {
      return;
    }
    const value = next2[0];
    const time = next2[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now2() {
  return Date.now();
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-database.js
var USED_DATABASE_NAMES = /* @__PURE__ */ new Set();
var DB_COUNT = 0;
var RxDatabaseBase = /* @__PURE__ */ function() {
  function RxDatabaseBase2(name, token, storage, instanceCreationOptions, password, multiInstance, eventReduce = false, options = {}, internalStore, hashFunction, cleanupPolicy, allowSlowCount, reactivity) {
    this.idleQueue = new IdleQueue();
    this.rxdbVersion = RXDB_VERSION;
    this.storageInstances = /* @__PURE__ */ new Set();
    this._subs = [];
    this.startupErrors = [];
    this.onDestroy = [];
    this.destroyed = false;
    this.collections = {};
    this.states = {};
    this.eventBulks$ = new Subject();
    this.observable$ = this.eventBulks$.pipe(mergeMap((changeEventBulk) => changeEventBulk.events));
    this.storageToken = PROMISE_RESOLVE_FALSE;
    this.storageTokenDocument = PROMISE_RESOLVE_FALSE;
    this.emittedEventBulkIds = new ObliviousSet(60 * 1e3);
    this.name = name;
    this.token = token;
    this.storage = storage;
    this.instanceCreationOptions = instanceCreationOptions;
    this.password = password;
    this.multiInstance = multiInstance;
    this.eventReduce = eventReduce;
    this.options = options;
    this.internalStore = internalStore;
    this.hashFunction = hashFunction;
    this.cleanupPolicy = cleanupPolicy;
    this.allowSlowCount = allowSlowCount;
    this.reactivity = reactivity;
    DB_COUNT++;
    if (this.name !== "pseudoInstance") {
      this.internalStore = getWrappedStorageInstance(this.asRxDatabase, internalStore, INTERNAL_STORE_SCHEMA);
      this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase).catch((err) => this.startupErrors.push(err));
      this.storageToken = this.storageTokenDocument.then((doc) => doc.data.token).catch((err) => this.startupErrors.push(err));
    }
  }
  var _proto = RxDatabaseBase2.prototype;
  _proto.getReactivityFactory = function getReactivityFactory() {
    if (!this.reactivity) {
      throw newRxError("DB14", {
        database: this.name
      });
    }
    return this.reactivity;
  };
  _proto.$emit = function $emit(changeEventBulk) {
    if (this.emittedEventBulkIds.has(changeEventBulk.id)) {
      return;
    }
    this.emittedEventBulkIds.add(changeEventBulk.id);
    this.eventBulks$.next(changeEventBulk);
  };
  _proto.removeCollectionDoc = async function removeCollectionDoc(name, schema) {
    var doc = await getSingleDocument(this.internalStore, getPrimaryKeyOfInternalDocument(_collectionNamePrimary(name, schema), INTERNAL_CONTEXT_COLLECTION));
    if (!doc) {
      throw newRxError("SNH", {
        name,
        schema
      });
    }
    var writeDoc = flatCloneDocWithMeta(doc);
    writeDoc._deleted = true;
    await this.internalStore.bulkWrite([{
      document: writeDoc,
      previous: doc
    }], "rx-database-remove-collection");
  };
  _proto.addCollections = async function addCollections(collectionCreators) {
    var jsonSchemas = {};
    var schemas = {};
    var bulkPutDocs = [];
    var useArgsByCollectionName = {};
    await Promise.all(Object.entries(collectionCreators).map(async ([name, args]) => {
      var collectionName = name;
      var rxJsonSchema = args.schema;
      jsonSchemas[collectionName] = rxJsonSchema;
      var schema = createRxSchema(rxJsonSchema, this.hashFunction);
      schemas[collectionName] = schema;
      if (this.collections[name]) {
        throw newRxError("DB3", {
          name
        });
      }
      var collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);
      var collectionDocData = {
        id: getPrimaryKeyOfInternalDocument(collectionNameWithVersion, INTERNAL_CONTEXT_COLLECTION),
        key: collectionNameWithVersion,
        context: INTERNAL_CONTEXT_COLLECTION,
        data: {
          name: collectionName,
          schemaHash: await schema.hash,
          schema: schema.jsonSchema,
          version: schema.version,
          connectedStorages: []
        },
        _deleted: false,
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision(),
        _attachments: {}
      };
      bulkPutDocs.push({
        document: collectionDocData
      });
      var useArgs = Object.assign({}, args, {
        name: collectionName,
        schema,
        database: this
      });
      var hookData = flatClone(args);
      hookData.database = this;
      hookData.name = name;
      runPluginHooks("preCreateRxCollection", hookData);
      useArgs.conflictHandler = hookData.conflictHandler;
      useArgsByCollectionName[collectionName] = useArgs;
    }));
    var putDocsResult = await this.internalStore.bulkWrite(bulkPutDocs, "rx-database-add-collection");
    await ensureNoStartupErrors(this);
    await Promise.all(putDocsResult.error.map(async (error) => {
      if (error.status !== 409) {
        throw newRxError("DB12", {
          database: this.name,
          writeError: error
        });
      }
      var docInDb = ensureNotFalsy(error.documentInDb);
      var collectionName = docInDb.data.name;
      var schema = schemas[collectionName];
      if (docInDb.data.schemaHash !== await schema.hash) {
        throw newRxError("DB6", {
          database: this.name,
          collection: collectionName,
          previousSchemaHash: docInDb.data.schemaHash,
          schemaHash: await schema.hash,
          previousSchema: docInDb.data.schema,
          schema: ensureNotFalsy(jsonSchemas[collectionName])
        });
      }
    }));
    var ret = {};
    await Promise.all(Object.keys(collectionCreators).map(async (collectionName) => {
      var useArgs = useArgsByCollectionName[collectionName];
      var collection = await createRxCollection(useArgs);
      ret[collectionName] = collection;
      this.collections[collectionName] = collection;
      if (!this[collectionName]) {
        Object.defineProperty(this, collectionName, {
          get: () => this.collections[collectionName]
        });
      }
    }));
    return ret;
  };
  _proto.lockedRun = function lockedRun(fn) {
    return this.idleQueue.wrapCall(fn);
  };
  _proto.requestIdlePromise = function requestIdlePromise3() {
    return this.idleQueue.requestIdlePromise();
  };
  _proto.exportJSON = function exportJSON(_collections) {
    throw pluginMissing("json-dump");
  };
  _proto.addState = function addState(_name) {
    throw pluginMissing("state");
  };
  _proto.importJSON = function importJSON(_exportedJSON) {
    throw pluginMissing("json-dump");
  };
  _proto.backup = function backup(_options) {
    throw pluginMissing("backup");
  };
  _proto.leaderElector = function leaderElector() {
    throw pluginMissing("leader-election");
  };
  _proto.isLeader = function isLeader() {
    throw pluginMissing("leader-election");
  };
  _proto.waitForLeadership = function waitForLeadership() {
    throw pluginMissing("leader-election");
  };
  _proto.migrationStates = function migrationStates() {
    throw pluginMissing("migration-schema");
  };
  _proto.destroy = async function destroy() {
    if (this.destroyed) {
      return PROMISE_RESOLVE_FALSE;
    }
    this.destroyed = true;
    await runAsyncPluginHooks("preDestroyRxDatabase", this);
    this.eventBulks$.complete();
    DB_COUNT--;
    this._subs.map((sub) => sub.unsubscribe());
    if (this.name === "pseudoInstance") {
      return PROMISE_RESOLVE_FALSE;
    }
    return this.requestIdlePromise().then(() => Promise.all(this.onDestroy.map((fn) => fn()))).then(() => Promise.all(Object.keys(this.collections).map((key) => this.collections[key]).map((col) => col.destroy()))).then(() => this.internalStore.close()).then(() => USED_DATABASE_NAMES.delete(this.storage.name + "|" + this.name)).then(() => true);
  };
  _proto.remove = function remove2() {
    return this.destroy().then(() => removeRxDatabase(this.name, this.storage, this.password));
  };
  return _createClass(RxDatabaseBase2, [{
    key: "$",
    get: function() {
      return this.observable$;
    }
  }, {
    key: "asRxDatabase",
    get: function() {
      return this;
    }
  }]);
}();
function throwIfDatabaseNameUsed(name, storage) {
  var key = storage.name + "|" + name;
  if (!USED_DATABASE_NAMES.has(key)) {
    return;
  } else {
    throw newRxError("DB8", {
      name,
      storage: storage.name,
      link: "https://rxdb.info/rx-database.html#ignoreduplicate"
    });
  }
}
async function createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, options, multiInstance, password) {
  var internalStore = await storage.createStorageInstance({
    databaseInstanceToken,
    databaseName,
    collectionName: INTERNAL_STORAGE_NAME,
    schema: INTERNAL_STORE_SCHEMA,
    options,
    multiInstance,
    password,
    devMode: overwritable.isDevMode()
  });
  return internalStore;
}
function createRxDatabase({
  storage,
  instanceCreationOptions,
  name,
  password,
  multiInstance = true,
  eventReduce = true,
  ignoreDuplicate = false,
  options = {},
  cleanupPolicy,
  allowSlowCount = false,
  localDocuments = false,
  hashFunction = defaultHashSha256,
  reactivity
}) {
  runPluginHooks("preCreateRxDatabase", {
    storage,
    instanceCreationOptions,
    name,
    password,
    multiInstance,
    eventReduce,
    ignoreDuplicate,
    options,
    localDocuments
  });
  if (!ignoreDuplicate) {
    throwIfDatabaseNameUsed(name, storage);
  }
  USED_DATABASE_NAMES.add(storage.name + "|" + name);
  var databaseInstanceToken = randomCouchString(10);
  return createRxDatabaseStorageInstance(databaseInstanceToken, storage, name, instanceCreationOptions, multiInstance, password).catch((err) => {
    USED_DATABASE_NAMES.delete(storage.name + "|" + name);
    throw err;
  }).then((storageInstance) => {
    var rxDatabase = new RxDatabaseBase(name, databaseInstanceToken, storage, instanceCreationOptions, password, multiInstance, eventReduce, options, storageInstance, hashFunction, cleanupPolicy, allowSlowCount, reactivity);
    return runAsyncPluginHooks("createRxDatabase", {
      database: rxDatabase,
      creator: {
        storage,
        instanceCreationOptions,
        name,
        password,
        multiInstance,
        eventReduce,
        ignoreDuplicate,
        options,
        localDocuments
      }
    }).then(() => rxDatabase);
  });
}
async function removeRxDatabase(databaseName, storage, password) {
  var databaseInstanceToken = randomCouchString(10);
  var dbInternalsStorageInstance = await createRxDatabaseStorageInstance(databaseInstanceToken, storage, databaseName, {}, false, password);
  var collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);
  var collectionNames = /* @__PURE__ */ new Set();
  collectionDocs.forEach((doc) => collectionNames.add(doc.data.name));
  var removedCollectionNames = Array.from(collectionNames);
  await Promise.all(removedCollectionNames.map((collectionName) => removeCollectionStorages(storage, dbInternalsStorageInstance, databaseInstanceToken, databaseName, collectionName, password)));
  await runAsyncPluginHooks("postRemoveRxDatabase", {
    databaseName,
    storage
  });
  await dbInternalsStorageInstance.remove();
  return removedCollectionNames;
}
async function ensureNoStartupErrors(rxDatabase) {
  await rxDatabase.storageToken;
  if (rxDatabase.startupErrors[0]) {
    throw rxDatabase.startupErrors[0];
  }
}

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/util.js
function isPromise2(obj) {
  return obj && typeof obj.then === "function";
}
var PROMISE_RESOLVED_FALSE = Promise.resolve(false);
var PROMISE_RESOLVED_TRUE = Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
  if (!time) time = 0;
  return new Promise(function(res) {
    return setTimeout(function() {
      return res(resolveWith);
    }, time);
  });
}
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
function microSeconds() {
  var ret = Date.now() * 1e3;
  if (ret <= lastMs) {
    ret = lastMs + 1;
  }
  lastMs = ret;
  return ret;
}

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/native.js
var microSeconds2 = microSeconds;
var type = "native";
function create(channelName) {
  var state2 = {
    time: microSeconds(),
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state2.bc.onmessage = function(msgEvent) {
    if (state2.messagesCallback) {
      state2.messagesCallback(msgEvent.data);
    }
  };
  return state2;
}
function close(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  if (typeof globalThis !== "undefined" && globalThis.Deno && globalThis.Deno.args) {
    return true;
  }
  if ((typeof window !== "undefined" || typeof self !== "undefined") && typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else {
    return false;
  }
}
function averageResponseTime() {
  return 150;
}
var NativeMethod = {
  create,
  close,
  onMessage,
  postMessage,
  canBeUsed,
  type,
  averageResponseTime,
  microSeconds: microSeconds2
};

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/options.js
function fillOptionsWithDefaults() {
  var originalOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
  if (!options.idb) options.idb = {};
  if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage) options.localstorage = {};
  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
  if (originalOptions.methods) options.methods = originalOptions.methods;
  if (!options.node) options.node = {};
  if (!options.node.ttl) options.node.ttl = 1e3 * 60 * 2;
  if (!options.node.maxParallelWrites) options.node.maxParallelWrites = 2048;
  if (typeof options.node.useFastPath === "undefined") options.node.useFastPath = true;
  return options;
}

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/indexed-db.js
var microSeconds3 = microSeconds;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
var type2 = "idb";
function getIdb() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  var IndexedDB = getIdb();
  var dbName = DB_PREFIX + channelName;
  var openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = function(ev) {
    var db2 = ev.target.result;
    db2.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  return new Promise(function(res, rej) {
    openRequest.onerror = function(ev) {
      return rej(ev);
    };
    openRequest.onsuccess = function() {
      res(openRequest.result);
    };
  });
}
function writeMessage(db2, readerUuid, messageJson) {
  var time = Date.now();
  var writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  var tx = db2.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise(function(res, rej) {
    tx.oncomplete = function() {
      return res();
    };
    tx.onerror = function(ev) {
      return rej(ev);
    };
    var objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getMessagesHigherThan(db2, lastCursorId) {
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  var keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    var getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise(function(res, rej) {
      getAllRequest.onerror = function(err) {
        return rej(err);
      };
      getAllRequest.onsuccess = function(e) {
        res(e.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e) {
      return objectStore.openCursor();
    }
  }
  return new Promise(function(res, rej) {
    var openCursorRequest = openCursor();
    openCursorRequest.onerror = function(err) {
      return rej(err);
    };
    openCursorRequest.onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor["continue"](lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor["continue"]();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(channelState, ids) {
  if (channelState.closed) {
    return Promise.resolve([]);
  }
  var tx = channelState.db.transaction(OBJECT_STORE_ID, "readwrite", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map(function(id) {
    var deleteRequest = objectStore["delete"](id);
    return new Promise(function(res) {
      deleteRequest.onsuccess = function() {
        return res();
      };
    });
  }));
}
function getOldMessages(db2, ttl) {
  var olderThen = Date.now() - ttl;
  var tx = db2.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  var objectStore = tx.objectStore(OBJECT_STORE_ID);
  var ret = [];
  return new Promise(function(res) {
    objectStore.openCursor().onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        var msgObk = cursor.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor["continue"]();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(channelState) {
  return getOldMessages(channelState.db, channelState.options.idb.ttl).then(function(tooOld) {
    return removeMessagesById(channelState, tooOld.map(function(msg) {
      return msg.id;
    }));
  });
}
function create2(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then(function(db2) {
    var state2 = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db: db2
    };
    db2.onclose = function() {
      state2.closed = true;
      if (options.idb.onclose) options.idb.onclose();
    };
    _readLoop(state2);
    return state2;
  });
}
function _readLoop(state2) {
  if (state2.closed) return;
  readNewMessages(state2).then(function() {
    return sleep(state2.options.idb.fallbackInterval);
  }).then(function() {
    return _readLoop(state2);
  });
}
function _filterMessage(msgObj, state2) {
  if (msgObj.uuid === state2.uuid) return false;
  if (state2.eMIs.has(msgObj.id)) return false;
  if (msgObj.data.time < state2.messagesCallbackTime) return false;
  return true;
}
function readNewMessages(state2) {
  if (state2.closed) return PROMISE_RESOLVED_VOID;
  if (!state2.messagesCallback) return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state2.db, state2.lastCursorId).then(function(newerMessages) {
    var useMessages = newerMessages.filter(function(msgObj) {
      return !!msgObj;
    }).map(function(msgObj) {
      if (msgObj.id > state2.lastCursorId) {
        state2.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter(function(msgObj) {
      return _filterMessage(msgObj, state2);
    }).sort(function(msgObjA, msgObjB) {
      return msgObjA.time - msgObjB.time;
    });
    useMessages.forEach(function(msgObj) {
      if (state2.messagesCallback) {
        state2.eMIs.add(msgObj.id);
        state2.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(function() {
    return writeMessage(channelState.db, channelState.uuid, messageJson);
  }).then(function() {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage2(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed2() {
  return !!getIdb();
}
function averageResponseTime2(options) {
  return options.idb.fallbackInterval * 2;
}
var IndexedDBMethod = {
  create: create2,
  close: close2,
  onMessage: onMessage2,
  postMessage: postMessage2,
  canBeUsed: canBeUsed2,
  type: type2,
  averageResponseTime: averageResponseTime2,
  microSeconds: microSeconds3
};

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/localstorage.js
var microSeconds4 = microSeconds;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type3 = "localstorage";
function getLocalStorage() {
  var localStorage;
  if (typeof window === "undefined") return null;
  try {
    localStorage = window.localStorage;
    localStorage = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e) {
  }
  return localStorage;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage3(channelState, messageJson) {
  return new Promise(function(res) {
    sleep().then(function() {
      var key = storageKey(channelState.channelName);
      var writeObj = {
        token: randomToken(),
        time: Date.now(),
        data: messageJson,
        uuid: channelState.uuid
      };
      var value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      var ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  var key = storageKey(channelName);
  var listener = function listener2(ev) {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create3(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed3()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  var uuid = randomToken();
  var eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  var state2 = {
    channelName,
    uuid,
    eMIs
    // emittedMessagesIds
  };
  state2.listener = addStorageEventListener(channelName, function(msgObj) {
    if (!state2.messagesCallback) return;
    if (msgObj.uuid === uuid) return;
    if (!msgObj.token || eMIs.has(msgObj.token)) return;
    if (msgObj.data.time && msgObj.data.time < state2.messagesCallbackTime) return;
    eMIs.add(msgObj.token);
    state2.messagesCallback(msgObj.data);
  });
  return state2;
}
function close3(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage3(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed3() {
  var ls = getLocalStorage();
  if (!ls) return false;
  try {
    var key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e) {
    return false;
  }
  return true;
}
function averageResponseTime3() {
  var defaultTime = 120;
  var userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}
var LocalstorageMethod = {
  create: create3,
  close: close3,
  onMessage: onMessage3,
  postMessage: postMessage3,
  canBeUsed: canBeUsed3,
  type: type3,
  averageResponseTime: averageResponseTime3,
  microSeconds: microSeconds4
};

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/methods/simulate.js
var microSeconds5 = microSeconds;
var type4 = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
function create4(channelName) {
  var state2 = {
    time: microSeconds5(),
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state2);
  return state2;
}
function close4(channelState) {
  SIMULATE_CHANNELS["delete"](channelState);
}
var SIMULATE_DELAY_TIME = 5;
function postMessage4(channelState, messageJson) {
  return new Promise(function(res) {
    return setTimeout(function() {
      var channelArray = Array.from(SIMULATE_CHANNELS);
      channelArray.forEach(function(channel) {
        if (channel.name === channelState.name && // has same name
        channel !== channelState && // not own channel
        !!channel.messagesCallback && // has subscribers
        channel.time < messageJson.time) {
          channel.messagesCallback(messageJson);
        }
      });
      res();
    }, SIMULATE_DELAY_TIME);
  });
}
function onMessage4(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed4() {
  return true;
}
function averageResponseTime4() {
  return SIMULATE_DELAY_TIME;
}
var SimulateMethod = {
  create: create4,
  close: close4,
  onMessage: onMessage4,
  postMessage: postMessage4,
  canBeUsed: canBeUsed4,
  type: type4,
  averageResponseTime: averageResponseTime4,
  microSeconds: microSeconds5
};

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/method-chooser.js
var METHODS = [
  NativeMethod,
  // fastest
  IndexedDBMethod,
  LocalstorageMethod
];
function chooseMethod(options) {
  var chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return SimulateMethod;
    }
    var ret = chooseMethods.find(function(m) {
      return m.type === options.type;
    });
    if (!ret) throw new Error("method-type " + options.type + " not found");
    else return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter(function(m) {
      return m.type !== "idb";
    });
  }
  var useMethod = chooseMethods.find(function(method) {
    return method.canBeUsed();
  });
  if (!useMethod) {
    throw new Error("No usable method found in " + JSON.stringify(METHODS.map(function(m) {
      return m.type;
    })));
  } else {
    return useMethod;
  }
}

// node_modules/.pnpm/broadcast-channel@7.0.0/node_modules/broadcast-channel/dist/esbrowser/broadcast-channel.js
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel2 = function BroadcastChannel3(name, options) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }
  this.options = fillOptionsWithDefaults(options);
  this.method = chooseMethod(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
BroadcastChannel2._pubkey = true;
var ENFORCED_OPTIONS;
BroadcastChannel2.prototype = {
  postMessage: function postMessage5(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was really hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal: function postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn && typeof fn === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener: function addEventListener2(type5, fn) {
    var time = this.method.microSeconds();
    var listenObj = {
      time,
      fn
    };
    _addListenerObject(this, type5, listenObj);
  },
  removeEventListener: function removeEventListener2(type5, fn) {
    var obj = this._addEL[type5].find(function(obj2) {
      return obj2.fn === fn;
    });
    _removeListenerObject(this, type5, obj);
  },
  close: function close5() {
    var _this = this;
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS["delete"](this);
    this.closed = true;
    var awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(function() {
      return Promise.all(Array.from(_this._uMP));
    }).then(function() {
      return Promise.all(_this._befC.map(function(fn) {
        return fn();
      }));
    }).then(function() {
      return _this.method.close(_this._state);
    });
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel, type5, msg) {
  var time = broadcastChannel.method.microSeconds();
  var msgObj = {
    time,
    type: type5,
    data: msg
  };
  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(function() {
    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise["catch"]().then(function() {
      return broadcastChannel._uMP["delete"](sendPromise);
    });
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  var maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise2(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then(function(s) {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0) return true;
  if (channel._addEL.internal.length > 0) return true;
  return false;
}
function _addListenerObject(channel, type5, obj) {
  channel._addEL[type5].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type5, obj) {
  channel._addEL[type5] = channel._addEL[type5].filter(function(o) {
    return o !== obj;
  });
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    var listenerFn = function listenerFn2(msgObj) {
      channel._addEL[msgObj.type].forEach(function(listenerObject) {
        if (msgObj.time >= listenerObject.time) {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    var time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(function() {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    var time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/rx-storage-multiinstance.js
var BROADCAST_CHANNEL_BY_TOKEN = /* @__PURE__ */ new Map();
function getBroadcastChannelReference(storageName, databaseInstanceToken, databaseName, refObject) {
  var state2 = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state2) {
    state2 = {
      /**
       * We have to use the databaseName instead of the databaseInstanceToken
       * in the BroadcastChannel name because different instances must end with the same
       * channel name to be able to broadcast messages between each other.
       */
      bc: new BroadcastChannel2(["RxDB:", storageName, databaseName].join("|")),
      refs: /* @__PURE__ */ new Set()
    };
    BROADCAST_CHANNEL_BY_TOKEN.set(databaseInstanceToken, state2);
  }
  state2.refs.add(refObject);
  return state2.bc;
}
function removeBroadcastChannelReference(databaseInstanceToken, refObject) {
  var state2 = BROADCAST_CHANNEL_BY_TOKEN.get(databaseInstanceToken);
  if (!state2) {
    return;
  }
  state2.refs.delete(refObject);
  if (state2.refs.size === 0) {
    BROADCAST_CHANNEL_BY_TOKEN.delete(databaseInstanceToken);
    return state2.bc.close();
  }
}
function addRxStorageMultiInstanceSupport(storageName, instanceCreationParams, instance, providedBroadcastChannel) {
  if (!instanceCreationParams.multiInstance) {
    return;
  }
  var broadcastChannel = providedBroadcastChannel ? providedBroadcastChannel : getBroadcastChannelReference(storageName, instanceCreationParams.databaseInstanceToken, instance.databaseName, instance);
  var changesFromOtherInstances$ = new Subject();
  var eventListener = (msg) => {
    if (msg.storageName === storageName && msg.databaseName === instanceCreationParams.databaseName && msg.collectionName === instanceCreationParams.collectionName && msg.version === instanceCreationParams.schema.version) {
      changesFromOtherInstances$.next(msg.eventBulk);
    }
  };
  broadcastChannel.addEventListener("message", eventListener);
  var oldChangestream$ = instance.changeStream();
  var closed = false;
  var sub = oldChangestream$.subscribe((eventBulk) => {
    if (closed) {
      return;
    }
    broadcastChannel.postMessage({
      storageName,
      databaseName: instanceCreationParams.databaseName,
      collectionName: instanceCreationParams.collectionName,
      version: instanceCreationParams.schema.version,
      eventBulk
    });
  });
  instance.changeStream = function() {
    return changesFromOtherInstances$.asObservable().pipe(mergeWith(oldChangestream$));
  };
  var oldClose = instance.close.bind(instance);
  instance.close = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldClose();
  };
  var oldRemove = instance.remove.bind(instance);
  instance.remove = async function() {
    closed = true;
    sub.unsubscribe();
    broadcastChannel.removeEventListener("message", eventListener);
    if (!providedBroadcastChannel) {
      await removeBroadcastChannelReference(instanceCreationParams.databaseInstanceToken, instance);
    }
    return oldRemove();
  };
}

// node_modules/.pnpm/dexie@4.0.8/node_modules/dexie/import-wrapper.mjs
var import_dexie = __toESM(require_dexie(), 1);
var DexieSymbol = Symbol.for("Dexie");
var Dexie = globalThis[DexieSymbol] || (globalThis[DexieSymbol] = import_dexie.default);
if (import_dexie.default.semVer !== Dexie.semVer) {
  throw new Error(`Two different versions of Dexie loaded in the same app: ${import_dexie.default.semVer} and ${Dexie.semVer}`);
}
var {
  liveQuery,
  mergeRanges,
  rangesOverlap,
  RangeSet,
  cmp,
  Entity,
  PropModSymbol,
  PropModification,
  replacePrefix,
  add,
  remove
} = Dexie;

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-helper.js
var DEXIE_DOCS_TABLE_NAME = "docs";
var DEXIE_CHANGES_TABLE_NAME = "changes";
var DEXIE_ATTACHMENTS_TABLE_NAME = "attachments";
var RX_STORAGE_NAME_DEXIE = "dexie";
var DEXIE_STATE_DB_BY_NAME = /* @__PURE__ */ new Map();
var REF_COUNT_PER_DEXIE_DB = /* @__PURE__ */ new Map();
function getDexieDbWithTables(databaseName, collectionName, settings, schema) {
  var dexieDbName = "rxdb-dexie-" + databaseName + "--" + schema.version + "--" + collectionName;
  var state2 = getFromMapOrCreate(DEXIE_STATE_DB_BY_NAME, dexieDbName, () => {
    var value = (async () => {
      var useSettings = flatClone(settings);
      useSettings.autoOpen = false;
      var dexieDb = new Dexie(dexieDbName, useSettings);
      var dexieStoresSettings = {
        [DEXIE_DOCS_TABLE_NAME]: getDexieStoreSchema(schema),
        [DEXIE_CHANGES_TABLE_NAME]: "++sequence, id",
        [DEXIE_ATTACHMENTS_TABLE_NAME]: "id"
      };
      dexieDb.version(1).stores(dexieStoresSettings);
      await dexieDb.open();
      return {
        dexieDb,
        dexieTable: dexieDb[DEXIE_DOCS_TABLE_NAME],
        dexieAttachmentsTable: dexieDb[DEXIE_ATTACHMENTS_TABLE_NAME],
        booleanIndexes: getBooleanIndexes(schema)
      };
    })();
    DEXIE_STATE_DB_BY_NAME.set(dexieDbName, state2);
    REF_COUNT_PER_DEXIE_DB.set(state2, 0);
    return value;
  });
  return state2;
}
async function closeDexieDb(statePromise) {
  var state2 = await statePromise;
  var prevCount = REF_COUNT_PER_DEXIE_DB.get(statePromise);
  var newCount = prevCount - 1;
  if (newCount === 0) {
    state2.dexieDb.close();
    REF_COUNT_PER_DEXIE_DB.delete(statePromise);
  } else {
    REF_COUNT_PER_DEXIE_DB.set(statePromise, newCount);
  }
}
var DEXIE_PIPE_SUBSTITUTE = "__";
function dexieReplaceIfStartsWithPipe(str) {
  var split = str.split(".");
  if (split.length > 1) {
    return split.map((part) => dexieReplaceIfStartsWithPipe(part)).join(".");
  }
  if (str.startsWith("|")) {
    var withoutFirst = str.substring(1);
    return DEXIE_PIPE_SUBSTITUTE + withoutFirst;
  } else {
    return str;
  }
}
function dexieReplaceIfStartsWithPipeRevert(str) {
  var split = str.split(".");
  if (split.length > 1) {
    return split.map((part) => dexieReplaceIfStartsWithPipeRevert(part)).join(".");
  }
  if (str.startsWith(DEXIE_PIPE_SUBSTITUTE)) {
    var withoutFirst = str.substring(DEXIE_PIPE_SUBSTITUTE.length);
    return "|" + withoutFirst;
  } else {
    return str;
  }
}
function fromStorageToDexie(booleanIndexes, inputDoc) {
  if (!inputDoc) {
    return inputDoc;
  }
  var d = flatClone(inputDoc);
  d = fromStorageToDexieField(d);
  booleanIndexes.forEach((idx) => {
    var val = getProperty(inputDoc, idx);
    var newVal = val ? "1" : "0";
    var useIndex = dexieReplaceIfStartsWithPipe(idx);
    setProperty(d, useIndex, newVal);
  });
  return d;
}
function fromDexieToStorage(booleanIndexes, d) {
  if (!d) {
    return d;
  }
  d = flatClone(d);
  d = fromDexieToStorageField(d);
  booleanIndexes.forEach((idx) => {
    var val = getProperty(d, idx);
    var newVal = val === "1" ? true : false;
    setProperty(d, idx, newVal);
  });
  return d;
}
function fromStorageToDexieField(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromStorageToDexieField(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object") {
        value = fromStorageToDexieField(value);
      }
      ret[dexieReplaceIfStartsWithPipe(key)] = value;
    });
    return ret;
  }
}
function fromDexieToStorageField(documentData) {
  if (!documentData || typeof documentData === "string" || typeof documentData === "number" || typeof documentData === "boolean") {
    return documentData;
  } else if (Array.isArray(documentData)) {
    return documentData.map((row) => fromDexieToStorageField(row));
  } else if (typeof documentData === "object") {
    var ret = {};
    Object.entries(documentData).forEach(([key, value]) => {
      if (typeof value === "object" || Array.isArray(documentData)) {
        value = fromDexieToStorageField(value);
      }
      ret[dexieReplaceIfStartsWithPipeRevert(key)] = value;
    });
    return ret;
  }
}
function getDexieStoreSchema(rxJsonSchema) {
  var parts = [];
  var primaryKey = getPrimaryFieldOfPrimaryKey(rxJsonSchema.primaryKey);
  parts.push([primaryKey]);
  parts.push(["_deleted", primaryKey]);
  if (rxJsonSchema.indexes) {
    rxJsonSchema.indexes.forEach((index2) => {
      var arIndex = toArray(index2);
      parts.push(arIndex);
    });
  }
  parts.push(["_meta.lwt", primaryKey]);
  parts.push(["_meta.lwt"]);
  parts = parts.map((part) => {
    return part.map((str) => dexieReplaceIfStartsWithPipe(str));
  });
  var dexieSchemaRows = parts.map((part) => {
    if (part.length === 1) {
      return part[0];
    } else {
      return "[" + part.join("+") + "]";
    }
  });
  dexieSchemaRows = dexieSchemaRows.filter((elem, pos, arr) => arr.indexOf(elem) === pos);
  var dexieSchema = dexieSchemaRows.join(", ");
  return dexieSchema;
}
async function getDocsInDb(internals, docIds) {
  var state2 = await internals;
  var docsInDb = await state2.dexieTable.bulkGet(docIds);
  return docsInDb.map((d) => fromDexieToStorage(state2.booleanIndexes, d));
}
function attachmentObjectId(documentId, attachmentId) {
  return documentId + "||" + attachmentId;
}
function getBooleanIndexes(schema) {
  var checkedFields = /* @__PURE__ */ new Set();
  var ret = [];
  if (!schema.indexes) {
    return ret;
  }
  schema.indexes.forEach((index2) => {
    var fields = toArray(index2);
    fields.forEach((field) => {
      if (checkedFields.has(field)) {
        return;
      }
      checkedFields.add(field);
      var schemaObj = getSchemaByObjectPath(schema, field);
      if (schemaObj.type === "boolean") {
        ret.push(field);
      }
    });
  });
  ret.push("_deleted");
  return uniqueArray(ret);
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/storage-dexie/dexie-query.js
function mapKeyForKeyRange(k) {
  if (k === INDEX_MIN) {
    return -Infinity;
  } else {
    return k;
  }
}
function rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, value) {
  if (booleanIndexes.includes(fieldName)) {
    var newValue = value === INDEX_MAX || value === true ? "1" : "0";
    return newValue;
  } else {
    return value;
  }
}
function getKeyRangeByQueryPlan(booleanIndexes, queryPlan, IDBKeyRange2) {
  if (!IDBKeyRange2) {
    if (typeof window === "undefined") {
      throw new Error("IDBKeyRange missing");
    } else {
      IDBKeyRange2 = window.IDBKeyRange;
    }
  }
  var startKeys = queryPlan.startKeys.map((v, i2) => {
    var fieldName = queryPlan.index[i2];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);
  }).map(mapKeyForKeyRange);
  var endKeys = queryPlan.endKeys.map((v, i2) => {
    var fieldName = queryPlan.index[i2];
    return rangeFieldToBooleanSubstitute(booleanIndexes, fieldName, v);
  }).map(mapKeyForKeyRange);
  var keyRange = IDBKeyRange2.bound(startKeys, endKeys, !queryPlan.inclusiveStart, !queryPlan.inclusiveEnd);
  return keyRange;
}
async function dexieQuery(instance, preparedQuery) {
  var state2 = await instance.internals;
  var query = preparedQuery.query;
  var skip = query.skip ? query.skip : 0;
  var limit = query.limit ? query.limit : Infinity;
  var skipPlusLimit = skip + limit;
  var queryPlan = preparedQuery.queryPlan;
  var queryMatcher = false;
  if (!queryPlan.selectorSatisfiedByIndex) {
    queryMatcher = getQueryMatcher(instance.schema, preparedQuery.query);
  }
  var keyRange = getKeyRangeByQueryPlan(state2.booleanIndexes, queryPlan, state2.dexieDb._options.IDBKeyRange);
  var queryPlanFields = queryPlan.index;
  var rows = [];
  await state2.dexieDb.transaction("r", state2.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index2;
    var indexName;
    indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
    index2 = store.index(indexName);
    var cursorReq = index2.openCursor(keyRange);
    await new Promise((res) => {
      cursorReq.onsuccess = function(e) {
        var cursor = e.target.result;
        if (cursor) {
          var docData = fromDexieToStorage(state2.booleanIndexes, cursor.value);
          if (!queryMatcher || queryMatcher(docData)) {
            rows.push(docData);
          }
          if (queryPlan.sortSatisfiedByIndex && rows.length === skipPlusLimit) {
            res();
          } else {
            cursor.continue();
          }
        } else {
          res();
        }
      };
    });
  });
  if (!queryPlan.sortSatisfiedByIndex) {
    var sortComparator = getSortComparator(instance.schema, preparedQuery.query);
    rows = rows.sort(sortComparator);
  }
  rows = rows.slice(skip, skipPlusLimit);
  return {
    documents: rows
  };
}
async function dexieCount(instance, preparedQuery) {
  var state2 = await instance.internals;
  var queryPlan = preparedQuery.queryPlan;
  var queryPlanFields = queryPlan.index;
  var keyRange = getKeyRangeByQueryPlan(state2.booleanIndexes, queryPlan, state2.dexieDb._options.IDBKeyRange);
  var count = -1;
  await state2.dexieDb.transaction("r", state2.dexieTable, async (dexieTx) => {
    var tx = dexieTx.idbtrans;
    var store = tx.objectStore(DEXIE_DOCS_TABLE_NAME);
    var index2;
    var indexName;
    indexName = "[" + queryPlanFields.map((field) => dexieReplaceIfStartsWithPipe(field)).join("+") + "]";
    index2 = store.index(indexName);
    var request = index2.count(keyRange);
    count = await new Promise((res, rej) => {
      request.onsuccess = function() {
        res(request.result);
      };
      request.onerror = (err) => rej(err);
    });
  });
  return count;
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-instance-dexie.js
var instanceId = now();
var shownNonPremiumLog = false;
var RxStorageInstanceDexie = /* @__PURE__ */ function() {
  function RxStorageInstanceDexie2(storage, databaseName, collectionName, schema, internals, options, settings, devMode) {
    this.changes$ = new Subject();
    this.instanceId = instanceId++;
    this.storage = storage;
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.schema = schema;
    this.internals = internals;
    this.options = options;
    this.settings = settings;
    this.devMode = devMode;
    this.primaryPath = getPrimaryFieldOfPrimaryKey(this.schema.primaryKey);
  }
  var _proto = RxStorageInstanceDexie2.prototype;
  _proto.bulkWrite = async function bulkWrite(documentWrites, context2) {
    ensureNotClosed(this);
    if (!shownNonPremiumLog && (!RXDB_UTILS_GLOBAL.premium || typeof RXDB_UTILS_GLOBAL.premium !== "string" || await defaultHashSha256(RXDB_UTILS_GLOBAL.premium) !== PREMIUM_FLAG_HASH)) {
      console.warn(["-------------- RxDB Open Core RxStorage -------------------------------", "You are using the free Dexie.js based RxStorage implementation from RxDB https://rxdb.info/rx-storage-dexie.html?console=dexie ", "While this is a great option, we want to let you know that there are faster storage solutions available in our premium plugins.", "For professional users and production environments, we highly recommend considering these premium options to enhance performance and reliability.", " https://rxdb.info/premium?console=dexie ", "If you already purchased premium access you can disable this log by calling the setPremiumFlag() function from rxdb-premium/plugins/shared.", "---------------------------------------------------------------------"].join("\n"));
      shownNonPremiumLog = true;
    } else {
      shownNonPremiumLog = true;
    }
    documentWrites.forEach((row) => {
      if (!row.document._rev || row.previous && !row.previous._rev) {
        throw newRxError("SNH", {
          args: {
            row
          }
        });
      }
    });
    var state2 = await this.internals;
    var ret = {
      error: []
    };
    if (this.devMode) {
      documentWrites = documentWrites.map((row) => {
        var doc = flatCloneDocWithMeta(row.document);
        return {
          previous: row.previous,
          document: doc
        };
      });
    }
    var documentKeys = documentWrites.map((writeRow) => writeRow.document[this.primaryPath]);
    var categorized;
    await state2.dexieDb.transaction("rw", state2.dexieTable, state2.dexieAttachmentsTable, async () => {
      var docsInDbMap = /* @__PURE__ */ new Map();
      var docsInDbWithInternals = await getDocsInDb(this.internals, documentKeys);
      docsInDbWithInternals.forEach((docWithDexieInternals) => {
        var doc = docWithDexieInternals;
        if (doc) {
          docsInDbMap.set(doc[this.primaryPath], doc);
        }
        return doc;
      });
      categorized = categorizeBulkWriteRows(this, this.primaryPath, docsInDbMap, documentWrites, context2);
      ret.error = categorized.errors;
      var bulkPutDocs = [];
      categorized.bulkInsertDocs.forEach((row) => {
        bulkPutDocs.push(row.document);
      });
      categorized.bulkUpdateDocs.forEach((row) => {
        bulkPutDocs.push(row.document);
      });
      bulkPutDocs = bulkPutDocs.map((d) => fromStorageToDexie(state2.booleanIndexes, d));
      if (bulkPutDocs.length > 0) {
        await state2.dexieTable.bulkPut(bulkPutDocs);
      }
      var putAttachments = [];
      categorized.attachmentsAdd.forEach((attachment) => {
        putAttachments.push({
          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      categorized.attachmentsUpdate.forEach((attachment) => {
        putAttachments.push({
          id: attachmentObjectId(attachment.documentId, attachment.attachmentId),
          data: attachment.attachmentData.data
        });
      });
      await state2.dexieAttachmentsTable.bulkPut(putAttachments);
      await state2.dexieAttachmentsTable.bulkDelete(categorized.attachmentsRemove.map((attachment) => attachmentObjectId(attachment.documentId, attachment.attachmentId)));
    });
    categorized = ensureNotFalsy(categorized);
    if (categorized.eventBulk.events.length > 0) {
      var lastState = ensureNotFalsy(categorized.newestRow).document;
      categorized.eventBulk.checkpoint = {
        id: lastState[this.primaryPath],
        lwt: lastState._meta.lwt
      };
      categorized.eventBulk.endTime = now();
      this.changes$.next(categorized.eventBulk);
    }
    return ret;
  };
  _proto.findDocumentsById = async function findDocumentsById(ids, deleted) {
    ensureNotClosed(this);
    var state2 = await this.internals;
    var ret = [];
    await state2.dexieDb.transaction("r", state2.dexieTable, async () => {
      var docsInDb = await getDocsInDb(this.internals, ids);
      docsInDb.forEach((documentInDb) => {
        if (documentInDb && (!documentInDb._deleted || deleted)) {
          ret.push(documentInDb);
        }
      });
    });
    return ret;
  };
  _proto.query = function query(preparedQuery) {
    ensureNotClosed(this);
    return dexieQuery(this, preparedQuery);
  };
  _proto.count = async function count(preparedQuery) {
    if (preparedQuery.queryPlan.selectorSatisfiedByIndex) {
      var result = await dexieCount(this, preparedQuery);
      return {
        count: result,
        mode: "fast"
      };
    } else {
      var _result = await dexieQuery(this, preparedQuery);
      return {
        count: _result.documents.length,
        mode: "slow"
      };
    }
  };
  _proto.changeStream = function changeStream() {
    ensureNotClosed(this);
    return this.changes$.asObservable();
  };
  _proto.cleanup = async function cleanup(minimumDeletedTime) {
    ensureNotClosed(this);
    var state2 = await this.internals;
    await state2.dexieDb.transaction("rw", state2.dexieTable, async () => {
      var maxDeletionTime = now() - minimumDeletedTime;
      var toRemove = await state2.dexieTable.where("_meta.lwt").below(maxDeletionTime).toArray();
      var removeIds = [];
      toRemove.forEach((doc) => {
        if (doc._deleted === "1") {
          removeIds.push(doc[this.primaryPath]);
        }
      });
      await state2.dexieTable.bulkDelete(removeIds);
    });
    return true;
  };
  _proto.getAttachmentData = async function getAttachmentData(documentId, attachmentId, _digest) {
    ensureNotClosed(this);
    var state2 = await this.internals;
    var id = attachmentObjectId(documentId, attachmentId);
    return await state2.dexieDb.transaction("r", state2.dexieAttachmentsTable, async () => {
      var attachment = await state2.dexieAttachmentsTable.get(id);
      if (attachment) {
        return attachment.data;
      } else {
        throw new Error("attachment missing documentId: " + documentId + " attachmentId: " + attachmentId);
      }
    });
  };
  _proto.remove = async function remove2() {
    ensureNotClosed(this);
    var state2 = await this.internals;
    await state2.dexieTable.clear();
    return this.close();
  };
  _proto.close = function close6() {
    if (this.closed) {
      return this.closed;
    }
    this.closed = (async () => {
      this.changes$.complete();
      await closeDexieDb(this.internals);
    })();
    return this.closed;
  };
  _proto.conflictResultionTasks = function conflictResultionTasks() {
    return new Subject();
  };
  _proto.resolveConflictResultionTask = async function resolveConflictResultionTask(_taskSolution) {
  };
  return RxStorageInstanceDexie2;
}();
async function createDexieStorageInstance(storage, params, settings) {
  var internals = getDexieDbWithTables(params.databaseName, params.collectionName, settings, params.schema);
  var instance = new RxStorageInstanceDexie(storage, params.databaseName, params.collectionName, params.schema, internals, params.options, settings, params.devMode);
  await addRxStorageMultiInstanceSupport(RX_STORAGE_NAME_DEXIE, params, instance);
  return Promise.resolve(instance);
}
function ensureNotClosed(instance) {
  if (instance.closed) {
    throw new Error("RxStorageInstanceDexie is closed " + instance.databaseName + "-" + instance.collectionName);
  }
}

// node_modules/.pnpm/rxdb@15.34.1_rxjs@7.8.1/node_modules/rxdb/dist/esm/plugins/storage-dexie/rx-storage-dexie.js
var RxStorageDexie = /* @__PURE__ */ function() {
  function RxStorageDexie2(settings) {
    this.name = RX_STORAGE_NAME_DEXIE;
    this.rxdbVersion = RXDB_VERSION;
    this.settings = settings;
  }
  var _proto = RxStorageDexie2.prototype;
  _proto.createStorageInstance = function createStorageInstance(params) {
    ensureRxStorageInstanceParamsAreCorrect(params);
    return createDexieStorageInstance(this, params, this.settings);
  };
  return RxStorageDexie2;
}();
function getRxStorageDexie(settings = {}) {
  var storage = new RxStorageDexie(settings);
  return storage;
}

// ../../node_modules/.pnpm/esm-env@1.2.1/node_modules/esm-env/dev-fallback.js
var node_env = globalThis.process?.env?.NODE_ENV;
if (!node_env) {
  console.warn("If bundling, conditions should include development or production. If not bundling, conditions or NODE_ENV should include development or production. See https://www.npmjs.com/package/esm-env for tips on setting conditions in popular bundlers and runtimes.");
}
var dev_fallback_default = node_env && !node_env.toLowerCase().includes("prod");

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/shared/utils.js
var is_array = Array.isArray;
var array_from = Array.from;
var object_keys = Object.keys;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var noop2 = () => {
};
function run_all(arr) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    arr[i2]();
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var BOUNDARY_EFFECT = 1 << 7;
var UNOWNED = 1 << 8;
var DISCONNECTED = 1 << 9;
var CLEAN = 1 << 10;
var DIRTY = 1 << 11;
var MAYBE_DIRTY = 1 << 12;
var INERT = 1 << 13;
var DESTROYED = 1 << 14;
var EFFECT_RAN = 1 << 15;
var EFFECT_TRANSPARENT = 1 << 16;
var LEGACY_DERIVED_PROP = 1 << 17;
var INSPECT_EFFECT = 1 << 18;
var HEAD_EFFECT = 1 << 19;
var EFFECT_HAS_DERIVED = 1 << 20;
var STATE_SYMBOL = Symbol("$state");
var STATE_SYMBOL_METADATA = Symbol("$state metadata");
var LEGACY_PROPS = Symbol("legacy props");
var LOADING_ATTR_SYMBOL = Symbol("");

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/task.js
var is_micro_task_queued = false;
var is_idle_task_queued = false;
var current_queued_micro_tasks = [];
var current_queued_idle_tasks = [];
function process_micro_tasks() {
  is_micro_task_queued = false;
  const tasks = current_queued_micro_tasks.slice();
  current_queued_micro_tasks = [];
  run_all(tasks);
}
function process_idle_tasks() {
  is_idle_task_queued = false;
  const tasks = current_queued_idle_tasks.slice();
  current_queued_idle_tasks = [];
  run_all(tasks);
}
function flush_tasks() {
  if (is_micro_task_queued) {
    process_micro_tasks();
  }
  if (is_idle_task_queued) {
    process_idle_tasks();
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function hydration_mismatch(location2) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] hydration_mismatch
%c${location2 ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location2}` : "Hydration failed because the initial UI does not match what was rendered on the server"}
https://svelte.dev/e/hydration_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/hydration_mismatch`);
  }
}
function lifecycle_double_unmount() {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted
https://svelte.dev/e/lifecycle_double_unmount`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/lifecycle_double_unmount`);
  }
}
function state_proxy_equality_mismatch(operator) {
  if (dev_fallback_default) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results
https://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
  } else {
    console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/constants.js
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_IS_CONTROLLED = 1 << 2;
var EACH_IS_ANIMATED = 1 << 3;
var EACH_ITEM_IMMUTABLE = 1 << 4;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_BINDABLE = 1 << 3;
var PROPS_IS_LAZY_INITIAL = 1 << 4;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var HYDRATION_START = "[";
var HYDRATION_END = "]";
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var UNINITIALIZED = Symbol();
var FILENAME = Symbol("filename");
var HMR = Symbol("hmr");

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dev/ownership.js
var ADD_OWNER = Symbol("ADD_OWNER");

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a2, b) {
  return a2 != a2 ? b == b : a2 !== b || a2 !== null && typeof a2 === "object" || typeof a2 === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/errors.js
function derived_references_self() {
  if (dev_fallback_default) {
    const error = new Error(`derived_references_self
A derived value cannot reference itself recursively
https://svelte.dev/e/derived_references_self`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/derived_references_self`);
  }
}
function effect_update_depth_exceeded() {
  if (dev_fallback_default) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops
https://svelte.dev/e/effect_update_depth_exceeded`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
  }
}
function hydration_failed() {
  if (dev_fallback_default) {
    const error = new Error(`hydration_failed
Failed to hydrate the application
https://svelte.dev/e/hydration_failed`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/hydration_failed`);
  }
}
function rune_outside_svelte(rune) {
  if (dev_fallback_default) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files
https://svelte.dev/e/rune_outside_svelte`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
  }
}
function state_unsafe_local_read() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_local_read
Reading state that was created inside the same derived is forbidden. Consider using \`untrack\` to read locally created state
https://svelte.dev/e/state_unsafe_local_read`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_local_read`);
  }
}
function state_unsafe_mutation() {
  if (dev_fallback_default) {
    const error = new Error(`state_unsafe_mutation
Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`
https://svelte.dev/e/state_unsafe_mutation`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/flags/index.js
var legacy_mode_flag = false;
var tracing_mode_flag = false;

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dev/tracing.js
var tracing_expressions = null;
function get_stack(label) {
  let error = Error();
  const stack2 = error.stack;
  if (stack2) {
    const lines = stack2.split("\n");
    const new_lines = ["\n"];
    for (let i2 = 0; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (line === "Error") {
        continue;
      }
      if (line.includes("validate_each_keys")) {
        return null;
      }
      if (line.includes("svelte/src/internal")) {
        continue;
      }
      new_lines.push(line);
    }
    if (new_lines.length === 1) {
      return null;
    }
    define_property(error, "stack", {
      value: new_lines.join("\n")
    });
    define_property(error, "name", {
      // 'Error' suffix is required for stack traces to be rendered properly
      value: `${label}Error`
    });
  }
  return error;
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/reactivity/sources.js
var inspect_effects = /* @__PURE__ */ new Set();
function set_inspect_effects(v) {
  inspect_effects = v;
}
function source(v, stack2) {
  var signal = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    version: 0
  };
  if (dev_fallback_default && tracing_mode_flag) {
    signal.created = stack2 ?? get_stack("CreatedAt");
    signal.debug = null;
  }
  return signal;
}
// @__NO_SIDE_EFFECTS__
function mutable_source(initial_value, immutable = false) {
  const s = source(initial_value);
  if (!immutable) {
    s.equals = safe_equals;
  }
  if (legacy_mode_flag && component_context !== null && component_context.l !== null) {
    (component_context.l.s ??= []).push(s);
  }
  return s;
}
function set(source2, value) {
  if (active_reaction !== null && is_runes() && (active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 && // If the source was created locally within the current derived, then
  // we allow the mutation.
  (derived_sources === null || !derived_sources.includes(source2))) {
    state_unsafe_mutation();
  }
  return internal_set(source2, value);
}
function internal_set(source2, value) {
  if (!source2.equals(value)) {
    source2.v = value;
    source2.version = increment_version();
    if (dev_fallback_default && tracing_mode_flag) {
      source2.updated = get_stack("UpdatedAt");
    }
    mark_reactions(source2, DIRTY);
    if (is_runes() && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0) {
      if (new_deps !== null && new_deps.includes(source2)) {
        set_signal_status(active_effect, DIRTY);
        schedule_effect(active_effect);
      } else {
        if (untracked_writes === null) {
          set_untracked_writes([source2]);
        } else {
          untracked_writes.push(source2);
        }
      }
    }
    if (dev_fallback_default && inspect_effects.size > 0) {
      const inspects = Array.from(inspect_effects);
      var previously_flushing_effect = is_flushing_effect;
      set_is_flushing_effect(true);
      try {
        for (const effect2 of inspects) {
          if ((effect2.f & CLEAN) !== 0) {
            set_signal_status(effect2, MAYBE_DIRTY);
          }
          if (check_dirtiness(effect2)) {
            update_effect(effect2);
          }
        }
      } finally {
        set_is_flushing_effect(previously_flushing_effect);
      }
      inspect_effects.clear();
    }
  }
  return value;
}
function mark_reactions(signal, status) {
  var reactions = signal.reactions;
  if (reactions === null) return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i2 = 0; i2 < length; i2++) {
    var reaction = reactions[i2];
    var flags = reaction.f;
    if ((flags & DIRTY) !== 0) continue;
    if (!runes && reaction === active_effect) continue;
    if (dev_fallback_default && (flags & INSPECT_EFFECT) !== 0) {
      inspect_effects.add(reaction);
      continue;
    }
    set_signal_status(reaction, status);
    if ((flags & (CLEAN | UNOWNED)) !== 0) {
      if ((flags & DERIVED) !== 0) {
        mark_reactions(
          /** @type {Derived} */
          reaction,
          MAYBE_DIRTY
        );
      } else {
        schedule_effect(
          /** @type {Effect} */
          reaction
        );
      }
    }
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/reactivity/deriveds.js
function destroy_derived_children(derived3) {
  var children = derived3.children;
  if (children !== null) {
    derived3.children = null;
    for (var i2 = 0; i2 < children.length; i2 += 1) {
      var child2 = children[i2];
      if ((child2.f & DERIVED) !== 0) {
        destroy_derived(
          /** @type {Derived} */
          child2
        );
      } else {
        destroy_effect(
          /** @type {Effect} */
          child2
        );
      }
    }
  }
}
var stack = [];
function get_derived_parent_effect(derived3) {
  var parent = derived3.parent;
  while (parent !== null) {
    if ((parent.f & DERIVED) === 0) {
      return (
        /** @type {Effect} */
        parent
      );
    }
    parent = parent.parent;
  }
  return null;
}
function execute_derived(derived3) {
  var value;
  var prev_active_effect = active_effect;
  set_active_effect(get_derived_parent_effect(derived3));
  if (dev_fallback_default) {
    let prev_inspect_effects = inspect_effects;
    set_inspect_effects(/* @__PURE__ */ new Set());
    try {
      if (stack.includes(derived3)) {
        derived_references_self();
      }
      stack.push(derived3);
      destroy_derived_children(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
      set_inspect_effects(prev_inspect_effects);
      stack.pop();
    }
  } else {
    try {
      destroy_derived_children(derived3);
      value = update_reaction(derived3);
    } finally {
      set_active_effect(prev_active_effect);
    }
  }
  return value;
}
function update_derived(derived3) {
  var value = execute_derived(derived3);
  var status = (skip_reaction || (derived3.f & UNOWNED) !== 0) && derived3.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived3, status);
  if (!derived3.equals(value)) {
    derived3.v = value;
    derived3.version = increment_version();
  }
}
function destroy_derived(derived3) {
  destroy_derived_children(derived3);
  remove_reactions(derived3, 0);
  set_signal_status(derived3, DESTROYED);
  derived3.v = derived3.children = derived3.deps = derived3.ctx = derived3.reactions = null;
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/runtime.js
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var handled_errors = /* @__PURE__ */ new WeakSet();
var is_throwing_error = false;
var scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued2 = false;
var last_scheduled_effect = null;
var is_flushing_effect = false;
var is_destroying_effect = false;
function set_is_flushing_effect(value) {
  is_flushing_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var queued_root_effects = [];
var flush_count = 0;
var dev_effect_stack = [];
var active_reaction = null;
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
var active_effect = null;
function set_active_effect(effect2) {
  active_effect = effect2;
}
var derived_sources = null;
var new_deps = null;
var skipped_deps = 0;
var untracked_writes = null;
function set_untracked_writes(value) {
  untracked_writes = value;
}
var current_version = 1;
var skip_reaction = false;
var captured_signals = null;
var component_context = null;
var dev_current_component_function = null;
function increment_version() {
  return ++current_version;
}
function is_runes() {
  return !legacy_mode_flag || component_context !== null && component_context.l === null;
}
function check_dirtiness(reaction) {
  var flags = reaction.f;
  if ((flags & DIRTY) !== 0) {
    return true;
  }
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    var is_unowned = (flags & UNOWNED) !== 0;
    if (dependencies !== null) {
      var i2;
      if ((flags & DISCONNECTED) !== 0) {
        for (i2 = 0; i2 < dependencies.length; i2++) {
          (dependencies[i2].reactions ??= []).push(reaction);
        }
        reaction.f ^= DISCONNECTED;
      }
      for (i2 = 0; i2 < dependencies.length; i2++) {
        var dependency = dependencies[i2];
        if (check_dirtiness(
          /** @type {Derived} */
          dependency
        )) {
          update_derived(
            /** @type {Derived} */
            dependency
          );
        }
        if (is_unowned && active_effect !== null && !skip_reaction && !dependency?.reactions?.includes(reaction)) {
          (dependency.reactions ??= []).push(reaction);
        }
        if (dependency.version > reaction.version) {
          return true;
        }
      }
    }
    if (!is_unowned || active_effect !== null && !skip_reaction) {
      set_signal_status(reaction, CLEAN);
    }
  }
  return false;
}
function propagate_error(error, effect2) {
  var current = effect2;
  while (current !== null) {
    if ((current.f & BOUNDARY_EFFECT) !== 0) {
      try {
        current.fn(error);
        return;
      } catch {
        current.f ^= BOUNDARY_EFFECT;
      }
    }
    current = current.parent;
  }
  is_throwing_error = false;
  throw error;
}
function should_rethrow_error(effect2) {
  return (effect2.f & DESTROYED) === 0 && (effect2.parent === null || (effect2.parent.f & BOUNDARY_EFFECT) === 0);
}
function handle_error(error, effect2, previous_effect, component_context2) {
  if (is_throwing_error) {
    if (previous_effect === null) {
      is_throwing_error = false;
    }
    if (should_rethrow_error(effect2)) {
      throw error;
    }
    return;
  }
  if (previous_effect !== null) {
    is_throwing_error = true;
  }
  if (!dev_fallback_default || component_context2 === null || !(error instanceof Error) || handled_errors.has(error)) {
    propagate_error(error, effect2);
    return;
  }
  handled_errors.add(error);
  const component_stack = [];
  const effect_name = effect2.fn?.name;
  if (effect_name) {
    component_stack.push(effect_name);
  }
  let current_context = component_context2;
  while (current_context !== null) {
    if (dev_fallback_default) {
      var filename = current_context.function?.[FILENAME];
      if (filename) {
        const file = filename.split("/").pop();
        component_stack.push(file);
      }
    }
    current_context = current_context.p;
  }
  const indent = /Firefox/.test(navigator.userAgent) ? "  " : "	";
  define_property(error, "message", {
    value: error.message + `
${component_stack.map((name) => `
${indent}in ${name}`).join("")}
`
  });
  define_property(error, "component_stack", {
    value: component_stack
  });
  const stack2 = error.stack;
  if (stack2) {
    const lines = stack2.split("\n");
    const new_lines = [];
    for (let i2 = 0; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (line.includes("svelte/src/internal")) {
        continue;
      }
      new_lines.push(line);
    }
    define_property(error, "stack", {
      value: new_lines.join("\n")
    });
  }
  propagate_error(error, effect2);
  if (should_rethrow_error(effect2)) {
    throw error;
  }
}
function update_reaction(reaction) {
  var previous_deps = new_deps;
  var previous_skipped_deps = skipped_deps;
  var previous_untracked_writes = untracked_writes;
  var previous_reaction = active_reaction;
  var previous_skip_reaction = skip_reaction;
  var prev_derived_sources = derived_sources;
  var previous_component_context = component_context;
  var flags = reaction.f;
  new_deps = /** @type {null | Value[]} */
  null;
  skipped_deps = 0;
  untracked_writes = null;
  active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;
  skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;
  derived_sources = null;
  component_context = reaction.ctx;
  try {
    var result = (
      /** @type {Function} */
      (0, reaction.fn)()
    );
    var deps = reaction.deps;
    if (new_deps !== null) {
      var i2;
      remove_reactions(reaction, skipped_deps);
      if (deps !== null && skipped_deps > 0) {
        deps.length = skipped_deps + new_deps.length;
        for (i2 = 0; i2 < new_deps.length; i2++) {
          deps[skipped_deps + i2] = new_deps[i2];
        }
      } else {
        reaction.deps = deps = new_deps;
      }
      if (!skip_reaction) {
        for (i2 = skipped_deps; i2 < deps.length; i2++) {
          (deps[i2].reactions ??= []).push(reaction);
        }
      }
    } else if (deps !== null && skipped_deps < deps.length) {
      remove_reactions(reaction, skipped_deps);
      deps.length = skipped_deps;
    }
    return result;
  } finally {
    new_deps = previous_deps;
    skipped_deps = previous_skipped_deps;
    untracked_writes = previous_untracked_writes;
    active_reaction = previous_reaction;
    skip_reaction = previous_skip_reaction;
    derived_sources = prev_derived_sources;
    component_context = previous_component_context;
  }
}
function remove_reaction(signal, dependency) {
  let reactions = dependency.reactions;
  if (reactions !== null) {
    var index2 = reactions.indexOf(signal);
    if (index2 !== -1) {
      var new_length = reactions.length - 1;
      if (new_length === 0) {
        reactions = dependency.reactions = null;
      } else {
        reactions[index2] = reactions[new_length];
        reactions.pop();
      }
    }
  }
  if (reactions === null && (dependency.f & DERIVED) !== 0 && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (new_deps === null || !new_deps.includes(dependency))) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    remove_reactions(
      /** @type {Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  var dependencies = signal.deps;
  if (dependencies === null) return;
  for (var i2 = start_index; i2 < dependencies.length; i2++) {
    remove_reaction(signal, dependencies[i2]);
  }
}
function update_effect(effect2) {
  var flags = effect2.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var previous_effect = active_effect;
  var previous_component_context = component_context;
  active_effect = effect2;
  if (dev_fallback_default) {
    var previous_component_fn = dev_current_component_function;
    dev_current_component_function = effect2.component_function;
  }
  try {
    if ((flags & BLOCK_EFFECT) !== 0) {
      destroy_block_effect_children(effect2);
    } else {
      destroy_effect_children(effect2);
    }
    destroy_effect_deriveds(effect2);
    execute_effect_teardown(effect2);
    var teardown2 = update_reaction(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
    effect2.version = current_version;
    if (dev_fallback_default) {
      dev_effect_stack.push(effect2);
    }
  } catch (error) {
    handle_error(error, effect2, previous_effect, previous_component_context || effect2.ctx);
  } finally {
    active_effect = previous_effect;
    if (dev_fallback_default) {
      dev_current_component_function = previous_component_fn;
    }
  }
}
function log_effect_stack() {
  console.error(
    "Last ten effects were: ",
    dev_effect_stack.slice(-10).map((d) => d.fn)
  );
  dev_effect_stack = [];
}
function infinite_loop_guard() {
  if (flush_count > 1e3) {
    flush_count = 0;
    try {
      effect_update_depth_exceeded();
    } catch (error) {
      if (dev_fallback_default) {
        define_property(error, "stack", {
          value: ""
        });
      }
      if (last_scheduled_effect !== null) {
        if (dev_fallback_default) {
          try {
            handle_error(error, last_scheduled_effect, null, null);
          } catch (e) {
            log_effect_stack();
            throw e;
          }
        } else {
          handle_error(error, last_scheduled_effect, null, null);
        }
      } else {
        if (dev_fallback_default) {
          log_effect_stack();
        }
        throw error;
      }
    }
  }
  flush_count++;
}
function flush_queued_root_effects(root_effects) {
  var length = root_effects.length;
  if (length === 0) {
    return;
  }
  infinite_loop_guard();
  var previously_flushing_effect = is_flushing_effect;
  is_flushing_effect = true;
  try {
    for (var i2 = 0; i2 < length; i2++) {
      var effect2 = root_effects[i2];
      if ((effect2.f & CLEAN) === 0) {
        effect2.f ^= CLEAN;
      }
      var collected_effects = [];
      process_effects(effect2, collected_effects);
      flush_queued_effects(collected_effects);
    }
  } finally {
    is_flushing_effect = previously_flushing_effect;
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0) return;
  for (var i2 = 0; i2 < length; i2++) {
    var effect2 = effects[i2];
    if ((effect2.f & (DESTROYED | INERT)) === 0) {
      try {
        if (check_dirtiness(effect2)) {
          update_effect(effect2);
          if (effect2.deps === null && effect2.first === null && effect2.nodes_start === null) {
            if (effect2.teardown === null) {
              unlink_effect(effect2);
            } else {
              effect2.fn = null;
            }
          }
        }
      } catch (error) {
        handle_error(error, effect2, null, effect2.ctx);
      }
    }
  }
}
function process_deferred() {
  is_micro_task_queued2 = false;
  if (flush_count > 1001) {
    return;
  }
  const previous_queued_root_effects = queued_root_effects;
  queued_root_effects = [];
  flush_queued_root_effects(previous_queued_root_effects);
  if (!is_micro_task_queued2) {
    flush_count = 0;
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      dev_effect_stack = [];
    }
  }
}
function schedule_effect(signal) {
  if (scheduler_mode === FLUSH_MICROTASK) {
    if (!is_micro_task_queued2) {
      is_micro_task_queued2 = true;
      queueMicrotask(process_deferred);
    }
  }
  last_scheduled_effect = signal;
  var effect2 = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags = effect2.f;
    if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
      if ((flags & CLEAN) === 0) return;
      effect2.f ^= CLEAN;
    }
  }
  queued_root_effects.push(effect2);
}
function process_effects(effect2, collected_effects) {
  var current_effect = effect2.first;
  var effects = [];
  main_loop: while (current_effect !== null) {
    var flags = current_effect.f;
    var is_branch = (flags & BRANCH_EFFECT) !== 0;
    var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;
    var sibling2 = current_effect.next;
    if (!is_skippable_branch && (flags & INERT) === 0) {
      if ((flags & RENDER_EFFECT) !== 0) {
        if (is_branch) {
          current_effect.f ^= CLEAN;
        } else {
          try {
            if (check_dirtiness(current_effect)) {
              update_effect(current_effect);
            }
          } catch (error) {
            handle_error(error, current_effect, null, current_effect.ctx);
          }
        }
        var child2 = current_effect.first;
        if (child2 !== null) {
          current_effect = child2;
          continue;
        }
      } else if ((flags & EFFECT) !== 0) {
        effects.push(current_effect);
      }
    }
    if (sibling2 === null) {
      let parent = current_effect.parent;
      while (parent !== null) {
        if (effect2 === parent) {
          break main_loop;
        }
        var parent_sibling = parent.next;
        if (parent_sibling !== null) {
          current_effect = parent_sibling;
          continue main_loop;
        }
        parent = parent.parent;
      }
    }
    current_effect = sibling2;
  }
  for (var i2 = 0; i2 < effects.length; i2++) {
    child2 = effects[i2];
    collected_effects.push(child2);
    process_effects(child2, collected_effects);
  }
}
function flush_sync(fn) {
  var previous_scheduler_mode = scheduler_mode;
  var previous_queued_root_effects = queued_root_effects;
  try {
    infinite_loop_guard();
    const root_effects = [];
    scheduler_mode = FLUSH_SYNC;
    queued_root_effects = root_effects;
    is_micro_task_queued2 = false;
    flush_queued_root_effects(previous_queued_root_effects);
    var result = fn?.();
    flush_tasks();
    if (queued_root_effects.length > 0 || root_effects.length > 0) {
      flush_sync();
    }
    flush_count = 0;
    last_scheduled_effect = null;
    if (dev_fallback_default) {
      dev_effect_stack = [];
    }
    return result;
  } finally {
    scheduler_mode = previous_scheduler_mode;
    queued_root_effects = previous_queued_root_effects;
  }
}
function get(signal) {
  var flags = signal.f;
  var is_derived = (flags & DERIVED) !== 0;
  if (is_derived && (flags & DESTROYED) !== 0) {
    var value = execute_derived(
      /** @type {Derived} */
      signal
    );
    destroy_derived(
      /** @type {Derived} */
      signal
    );
    return value;
  }
  if (captured_signals !== null) {
    captured_signals.add(signal);
  }
  if (active_reaction !== null) {
    if (derived_sources !== null && derived_sources.includes(signal)) {
      state_unsafe_local_read();
    }
    var deps = active_reaction.deps;
    if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
      skipped_deps++;
    } else if (new_deps === null) {
      new_deps = [signal];
    } else {
      new_deps.push(signal);
    }
    if (untracked_writes !== null && active_effect !== null && (active_effect.f & CLEAN) !== 0 && (active_effect.f & BRANCH_EFFECT) === 0 && untracked_writes.includes(signal)) {
      set_signal_status(active_effect, DIRTY);
      schedule_effect(active_effect);
    }
  } else if (is_derived && /** @type {Derived} */
  signal.deps === null) {
    var derived3 = (
      /** @type {Derived} */
      signal
    );
    var parent = derived3.parent;
    var target = derived3;
    while (parent !== null) {
      if ((parent.f & DERIVED) !== 0) {
        var parent_derived = (
          /** @type {Derived} */
          parent
        );
        target = parent_derived;
        parent = parent_derived.parent;
      } else {
        var parent_effect = (
          /** @type {Effect} */
          parent
        );
        if (!parent_effect.deriveds?.includes(target)) {
          (parent_effect.deriveds ??= []).push(target);
        }
        break;
      }
    }
  }
  if (is_derived) {
    derived3 = /** @type {Derived} */
    signal;
    if (check_dirtiness(derived3)) {
      update_derived(derived3);
    }
  }
  if (dev_fallback_default && tracing_mode_flag && tracing_expressions !== null && active_reaction !== null && tracing_expressions.reaction === active_reaction) {
    if (signal.debug) {
      signal.debug();
    } else if (signal.created) {
      var entry = tracing_expressions.entries.get(signal);
      if (entry === void 0) {
        entry = { read: [] };
        tracing_expressions.entries.set(signal, entry);
      }
      entry.read.push(get_stack("TracedAt"));
    }
  }
  return signal.v;
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function push(props, runes = false, fn) {
  component_context = {
    p: component_context,
    c: null,
    e: null,
    m: false,
    s: props,
    x: null,
    l: null
  };
  if (legacy_mode_flag && !runes) {
    component_context.l = {
      s: null,
      u: null,
      r1: [],
      r2: source(false)
    };
  }
  if (dev_fallback_default) {
    component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  const context_stack_item = component_context;
  if (context_stack_item !== null) {
    if (component2 !== void 0) {
      context_stack_item.x = component2;
    }
    const component_effects = context_stack_item.e;
    if (component_effects !== null) {
      var previous_effect = active_effect;
      var previous_reaction = active_reaction;
      context_stack_item.e = null;
      try {
        for (var i2 = 0; i2 < component_effects.length; i2++) {
          var component_effect = component_effects[i2];
          set_active_effect(component_effect.effect);
          set_active_reaction(component_effect.reaction);
          effect(component_effect.fn);
        }
      } finally {
        set_active_effect(previous_effect);
        set_active_reaction(previous_reaction);
      }
    }
    component_context = context_stack_item.p;
    if (dev_fallback_default) {
      dev_current_component_function = context_stack_item.p?.function ?? null;
    }
    context_stack_item.m = true;
  }
  return component2 || /** @type {T} */
  {};
}
if (dev_fallback_default) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error2 = throw_rune_error;
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}
var throw_rune_error2;

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_node;
function set_hydrate_node(node) {
  if (node === null) {
    hydration_mismatch();
    throw HYDRATION_ERROR;
  }
  return hydrate_node = node;
}
function hydrate_next() {
  return set_hydrate_node(
    /** @type {TemplateNode} */
    get_next_sibling(hydrate_node)
  );
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/proxy.js
function get_proxied_value(value) {
  if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
    return value[STATE_SYMBOL];
  }
  return value;
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      for (let i2 = from_index ?? 0; i2 < this.length; i2 += 1) {
        if (get_proxied_value(this[i2]) === item) {
          state_proxy_equality_mismatch("array.indexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index ?? this.length - 1);
    if (index2 === -1) {
      for (let i2 = 0; i2 <= (from_index ?? this.length - 1); i2 += 1) {
        if (get_proxied_value(this[i2]) === item) {
          state_proxy_equality_mismatch("array.lastIndexOf(...)");
          break;
        }
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has2 = includes.call(this, item, from_index);
    if (!has2) {
      for (let i2 = 0; i2 < this.length; i2 += 1) {
        if (get_proxied_value(this[i2]) === item) {
          state_proxy_equality_mismatch("array.includes(...)");
          break;
        }
      }
    }
    return has2;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
var first_child_getter;
var next_sibling_getter;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  var element_prototype = Element.prototype;
  var node_prototype = Node.prototype;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  element_prototype.__click = void 0;
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__styles = null;
  element_prototype.__e = void 0;
  Text.prototype.__t = void 0;
  if (dev_fallback_default) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function create_text(value = "") {
  return document.createTextNode(value);
}
// @__NO_SIDE_EFFECTS__
function get_first_child(node) {
  return first_child_getter.call(node);
}
// @__NO_SIDE_EFFECTS__
function get_next_sibling(node) {
  return next_sibling_getter.call(node);
}
function clear_text_content(node) {
  node.textContent = "";
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type5, fn, sync, push2 = true) {
  var is_root = (type5 & ROOT_EFFECT) !== 0;
  var parent_effect = active_effect;
  if (dev_fallback_default) {
    while (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {
      parent_effect = parent_effect.parent;
    }
  }
  var effect2 = {
    ctx: component_context,
    deps: null,
    deriveds: null,
    nodes_start: null,
    nodes_end: null,
    f: type5 | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : parent_effect,
    prev: null,
    teardown: null,
    transitions: null,
    version: 0
  };
  if (dev_fallback_default) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    var previously_flushing_effect = is_flushing_effect;
    try {
      set_is_flushing_effect(true);
      update_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } catch (e) {
      destroy_effect(effect2);
      throw e;
    } finally {
      set_is_flushing_effect(previously_flushing_effect);
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var inert = sync && effect2.deps === null && effect2.first === null && effect2.nodes_start === null && effect2.teardown === null && (effect2.f & EFFECT_HAS_DERIVED) === 0;
  if (!inert && !is_root && push2) {
    if (parent_effect !== null) {
      push_effect(effect2, parent_effect);
    }
    if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
      var derived3 = (
        /** @type {Derived} */
        active_reaction
      );
      (derived3.children ??= []).push(effect2);
    }
  }
  return effect2;
}
function effect_root(fn) {
  const effect2 = create_effect(ROOT_EFFECT, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function component_root(fn) {
  const effect2 = create_effect(ROOT_EFFECT, fn, true);
  return (options = {}) => {
    return new Promise((fulfil) => {
      if (options.outro) {
        pause_effect(effect2, () => {
          destroy_effect(effect2);
          fulfil(void 0);
        });
      } else {
        destroy_effect(effect2);
        fulfil(void 0);
      }
    });
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function render_effect(fn) {
  return create_effect(RENDER_EFFECT, fn, true);
}
function branch(fn, push2 = true) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push2);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = active_reaction;
    set_is_destroying_effect(true);
    set_active_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_active_reaction(previous_reaction);
    }
  }
}
function destroy_effect_deriveds(signal) {
  var deriveds = signal.deriveds;
  if (deriveds !== null) {
    signal.deriveds = null;
    for (var i2 = 0; i2 < deriveds.length; i2 += 1) {
      destroy_derived(deriveds[i2]);
    }
  }
}
function destroy_effect_children(signal, remove_dom = false) {
  var effect2 = signal.first;
  signal.first = signal.last = null;
  while (effect2 !== null) {
    var next2 = effect2.next;
    destroy_effect(effect2, remove_dom);
    effect2 = next2;
  }
}
function destroy_block_effect_children(signal) {
  var effect2 = signal.first;
  while (effect2 !== null) {
    var next2 = effect2.next;
    if ((effect2.f & BRANCH_EFFECT) === 0) {
      destroy_effect(effect2);
    }
    effect2 = next2;
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var removed = false;
  if ((remove_dom || (effect2.f & HEAD_EFFECT) !== 0) && effect2.nodes_start !== null) {
    var node = effect2.nodes_start;
    var end = effect2.nodes_end;
    while (node !== null) {
      var next2 = node === end ? null : (
        /** @type {TemplateNode} */
        get_next_sibling(node)
      );
      node.remove();
      node = next2;
    }
    removed = true;
  }
  destroy_effect_children(effect2, remove_dom && !removed);
  destroy_effect_deriveds(effect2);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  var transitions = effect2.transitions;
  if (transitions !== null) {
    for (const transition2 of transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && parent.first !== null) {
    unlink_effect(effect2);
  }
  if (dev_fallback_default) {
    effect2.component_function = null;
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.deps = effect2.fn = effect2.nodes_start = effect2.nodes_end = null;
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next2 = effect2.next;
  if (prev !== null) prev.next = next2;
  if (next2 !== null) next2.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2) parent.first = next2;
    if (parent.last === effect2) parent.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback) callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0) return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/utils.js
var DOM_BOOLEAN_ATTRIBUTES = [
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "disabled",
  "formnovalidate",
  "hidden",
  "indeterminate",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "seamless",
  "selected",
  "webkitdirectory"
];
var DOM_PROPERTIES = [
  ...DOM_BOOLEAN_ATTRIBUTES,
  "formNoValidate",
  "isMap",
  "noModule",
  "playsInline",
  "readOnly",
  "value",
  "inert",
  "volume",
  "defaultValue",
  "defaultChecked",
  "srcObject"
];
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/elements/events.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function handle_event_propagation(event2) {
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = event2.composedPath?.() || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  var path_idx = 0;
  var handled_at = event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_reaction = active_reaction;
  var previous_effect = active_effect;
  set_active_reaction(null);
  set_active_effect(null);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated !== void 0 && !/** @type {any} */
        current_target.disabled) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_reaction(previous_reaction);
    set_active_effect(previous_effect);
  }
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/template.js
function assign_nodes(start, end) {
  var effect2 = (
    /** @type {Effect} */
    active_effect
  );
  if (effect2.nodes_start === null) {
    effect2.nodes_start = start;
    effect2.nodes_end = end;
  }
}
function append(anchor, dom) {
  if (hydrating) {
    active_effect.nodes_end = hydrate_node;
    hydrate_next();
    return;
  }
  if (anchor === null) {
    return;
  }
  anchor.before(
    /** @type {Node} */
    dom
  );
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/render.js
var should_intro = true;
function mount(component2, options) {
  return _mount(component2, options);
}
function hydrate(component2, options) {
  init_operations();
  options.intro = options.intro ?? false;
  const target = options.target;
  const was_hydrating = hydrating;
  const previous_hydrate_node = hydrate_node;
  try {
    var anchor = (
      /** @type {TemplateNode} */
      get_first_child(target)
    );
    while (anchor && (anchor.nodeType !== 8 || /** @type {Comment} */
    anchor.data !== HYDRATION_START)) {
      anchor = /** @type {TemplateNode} */
      get_next_sibling(anchor);
    }
    if (!anchor) {
      throw HYDRATION_ERROR;
    }
    set_hydrating(true);
    set_hydrate_node(
      /** @type {Comment} */
      anchor
    );
    hydrate_next();
    const instance = _mount(component2, { ...options, anchor });
    if (hydrate_node === null || hydrate_node.nodeType !== 8 || /** @type {Comment} */
    hydrate_node.data !== HYDRATION_END) {
      hydration_mismatch();
      throw HYDRATION_ERROR;
    }
    set_hydrating(false);
    return (
      /**  @type {Exports} */
      instance
    );
  } catch (error) {
    if (error === HYDRATION_ERROR) {
      if (options.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component2, options);
    }
    throw error;
  } finally {
    set_hydrating(was_hydrating);
    set_hydrate_node(previous_hydrate_node);
    reset_head_anchor();
  }
}
var document_listeners = /* @__PURE__ */ new Map();
function _mount(Component, { target, anchor, props = {}, events, context: context2, intro = true }) {
  init_operations();
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events2) => {
    for (var i2 = 0; i2 < events2.length; i2++) {
      var event_name = events2[i2];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive2 = is_passive_event(event_name);
      target.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
      var n2 = document_listeners.get(event_name);
      if (n2 === void 0) {
        document.addEventListener(event_name, handle_event_propagation, { passive: passive2 });
        document_listeners.set(event_name, 1);
      } else {
        document_listeners.set(event_name, n2 + 1);
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  var component2 = void 0;
  var unmount2 = component_root(() => {
    var anchor_node = anchor ?? target.appendChild(create_text());
    branch(() => {
      if (context2) {
        push({});
        var ctx = (
          /** @type {ComponentContext} */
          component_context
        );
        ctx.c = context2;
      }
      if (events) {
        props.$$events = events;
      }
      if (hydrating) {
        assign_nodes(
          /** @type {TemplateNode} */
          anchor_node,
          null
        );
      }
      should_intro = intro;
      component2 = Component(anchor_node, props) || {};
      should_intro = true;
      if (hydrating) {
        active_effect.nodes_end = hydrate_node;
      }
      if (context2) {
        pop();
      }
    });
    return () => {
      for (var event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        var n2 = (
          /** @type {number} */
          document_listeners.get(event_name)
        );
        if (--n2 === 0) {
          document.removeEventListener(event_name, handle_event_propagation);
          document_listeners.delete(event_name);
        } else {
          document_listeners.set(event_name, n2);
        }
      }
      root_event_handles.delete(event_handle);
      if (anchor_node !== anchor) {
        anchor_node.parentNode?.removeChild(anchor_node);
      }
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2, options) {
  const fn = mounted_components.get(component2);
  if (fn) {
    mounted_components.delete(component2);
    return fn(options);
  }
  if (dev_fallback_default) {
    lifecycle_double_unmount();
  }
  return Promise.resolve();
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var Svelte4Component = class {
  /** @type {any} */
  #events;
  /** @type {Record<string, any>} */
  #instance;
  /**
   * @param {ComponentConstructorOptions & {
   *  component: any;
   * }} options
   */
  constructor(options) {
    var sources = /* @__PURE__ */ new Map();
    var add_source = (key, value) => {
      var s = mutable_source(value);
      sources.set(key, s);
      return s;
    };
    const props = new Proxy(
      { ...options.props || {}, $$events: {} },
      {
        get(target, prop2) {
          return get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
        },
        has(target, prop2) {
          if (prop2 === LEGACY_PROPS) return true;
          get(sources.get(prop2) ?? add_source(prop2, Reflect.get(target, prop2)));
          return Reflect.has(target, prop2);
        },
        set(target, prop2, value) {
          set(sources.get(prop2) ?? add_source(prop2, value), value);
          return Reflect.set(target, prop2, value);
        }
      }
    );
    this.#instance = (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      anchor: options.anchor,
      props,
      context: options.context,
      intro: options.intro ?? false,
      recover: options.recover
    });
    if (!options?.props?.$$host || options.sync === false) {
      flush_sync();
    }
    this.#events = props.$$events;
    for (const key of Object.keys(this.#instance)) {
      if (key === "$set" || key === "$destroy" || key === "$on") continue;
      define_property(this, key, {
        get() {
          return this.#instance[key];
        },
        /** @param {any} value */
        set(value) {
          this.#instance[key] = value;
        },
        enumerable: true
      });
    }
    this.#instance.$set = /** @param {Record<string, any>} next */
    (next2) => {
      Object.assign(props, next2);
    };
    this.#instance.$destroy = () => {
      unmount(this.#instance);
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    this.#instance.$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    this.#events[event2] = this.#events[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    this.#events[event2].push(cb);
    return () => {
      this.#events[event2] = this.#events[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    this.#instance.$destroy();
  }
};

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /** The Svelte component constructor */
    $$ctor;
    /** Slots */
    $$s;
    /** @type {any} The Svelte component instance */
    $$c;
    /** Whether or not the custom element is connected */
    $$cn = false;
    /** @type {Record<string, any>} Component props data */
    $$d = {};
    /** `true` if currently in the process of reflecting component props back to attributes */
    $$r = false;
    /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
    $$p_d = {};
    /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
    $$l = {};
    /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
    $$l_u = /* @__PURE__ */ new Map();
    /** @type {any} The managed render effect for reflecting attributes */
    $$me;
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type5, listener, options) {
      this.$$l[type5] = this.$$l[type5] || [];
      this.$$l[type5].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type5, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type5, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type5, listener, options) {
      super.removeEventListener(type5, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default") slot2.name = name;
            append(anchor, slot2);
          };
        };
        var create_slot = create_slot2;
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot2(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot2(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = effect_root(() => {
          render_effect(() => {
            this.$$r = true;
            for (const key of object_keys(this.$$c)) {
              if (!this.$$p_d[key]?.reflect) continue;
              this.$$d[key] = this.$$c[key];
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
            this.$$r = false;
          });
        });
        for (const type5 in this.$$l) {
          for (const listener of this.$$l[type5]) {
            const unsub = this.$$c.$on(type5, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr2, _oldValue, newValue) {
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      this.$$c?.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$me();
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  const type5 = props_definition[prop2]?.type;
  value = type5 === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type5) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type5) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}

// ../../node_modules/.pnpm/svelte@5.16.0/node_modules/svelte/src/store/shared/index.js
var subscriber_queue = [];
function writable(value, start = noop2) {
  let stop = null;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(
      /** @type {T} */
      value
    ));
  }
  function subscribe(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update2) || noop2;
    }
    run2(
      /** @type {T} */
      value
    );
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}

// src/lib/entities/extension/model.ts
var initialExtensionContext = {
  account_id: null,
  app_id: null,
  route_path: null,
  route_query: null,
  props: null
};
var extensionContextStore = writable(initialExtensionContext);
var setExtensionContextState = (updater) => {
  extensionContextStore.update((state2) => ({
    ...state2,
    ...updater(state2)
  }));
};

// src/lib/entities/extension/index.ts
var tagName = "akaia-app";
var db = await createRxDatabase({
  name: tagName,
  storage: getRxStorageDexie()
});
var install = async () => {
  const extensionBundle = await h({
    // files: [
    // 	// only one of urls or files can be provided
    // 	{
    // 		name: "App",
    // 		type: "svelte",
    // 		modified: true,
    // 		content: `
    // 			<script>
    // 				import { onMount } from "svelte"
    // 				onMount(() => {
    // 					console.log("test")
    // 				})
    // 				<\/script>
    // 				<p>Example CommLink extension written in Svelte</p>
    // 		`,
    // 	},
    // ],
    urls: [
      "/static/packages/extensions/haptic/routes/+layout.svelte"
      /* "./Nested.svelte" */
    ],
    packagesUrl: "https://ga.jspm.io",
    svelteUrl: "https://ga.jspm.io/npm:svelte@5.1.3",
    injectedJS: "",
    injectedCSS: "",
    onstatus: (val) => {
      console.log("onStatus", val);
    }
  });
  if (customElements.get(tagName) === void 0) {
    customElements.define(
      tagName,
      class AkaiaExtension extends HTMLElement {
        static get observedAttributes() {
          return ["account_id", "app_id", "route_path", "route_query", "props"];
        }
        attributeChangedCallback(name, oldValue, newValue) {
          if (oldValue !== newValue) {
            setExtensionContextState((props) => ({
              ...props,
              [name]: name === "route_query" || name === "props" ? JSON.parse(newValue) : newValue
            }));
          }
        }
        connectedCallback() {
          console.log("connected");
          const Extension = new extensionBundle.render();
          console.log("Extension", Extension);
          console.log("attachShadow result:", this.attachShadow({ mode: "open" }));
          const extensionInstance = new Extension({
            target: this.attachShadow({ mode: "open" })
          });
          console.log("extensionInstance", extensionInstance);
        }
      }
    );
  }
};

// src/index.ts
var init2 = () => {
  install();
};
init2();
export {
  init2 as init
};
/*! Bundled license information:

dexie/dist/dexie.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

svelte-browser-import/dist/svelte-browser-import.es.js:
  (**
   * @license
   * svelte-browser-import v0.0.4
   * Copyright 2022-2023 repalash <palash@shaders.app>
   * MIT License
   *)
*/
